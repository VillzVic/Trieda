// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "TRIEDA-InputXSD.h"

#include <iostream>

// ItemCalendario
// 

const ItemCalendario::id_type& ItemCalendario::
id () const
{
  return this->id_.get ();
}

ItemCalendario::id_type& ItemCalendario::
id ()
{
  return this->id_.get ();
}

void ItemCalendario::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemCalendario::codigo_type& ItemCalendario::
codigo () const
{
  return this->codigo_.get ();
}

ItemCalendario::codigo_type& ItemCalendario::
codigo ()
{
  return this->codigo_.get ();
}

void ItemCalendario::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemCalendario::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemCalendario::tempoAula_type& ItemCalendario::
tempoAula () const
{
  return this->tempoAula_.get ();
}

ItemCalendario::tempoAula_type& ItemCalendario::
tempoAula ()
{
  return this->tempoAula_.get ();
}

void ItemCalendario::
tempoAula (const tempoAula_type& x)
{
  this->tempoAula_.set (x);
}

const ItemCalendario::turnos_type& ItemCalendario::
turnos () const
{
  return this->turnos_.get ();
}

ItemCalendario::turnos_type& ItemCalendario::
turnos ()
{
  return this->turnos_.get ();
}

void ItemCalendario::
turnos (const turnos_type& x)
{
  this->turnos_.set (x);
}

void ItemCalendario::
turnos (::std::auto_ptr< turnos_type > x)
{
  this->turnos_.set (x);
}


// ItemAlunoDemanda
// 

const ItemAlunoDemanda::id_type& ItemAlunoDemanda::
id () const
{
  return this->id_.get ();
}

ItemAlunoDemanda::id_type& ItemAlunoDemanda::
id ()
{
  return this->id_.get ();
}

void ItemAlunoDemanda::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemAlunoDemanda::alunoId_type& ItemAlunoDemanda::
alunoId () const
{
  return this->alunoId_.get ();
}

ItemAlunoDemanda::alunoId_type& ItemAlunoDemanda::
alunoId ()
{
  return this->alunoId_.get ();
}

void ItemAlunoDemanda::
alunoId (const alunoId_type& x)
{
  this->alunoId_.set (x);
}

const ItemAlunoDemanda::nomeAluno_type& ItemAlunoDemanda::
nomeAluno () const
{
  return this->nomeAluno_.get ();
}

ItemAlunoDemanda::nomeAluno_type& ItemAlunoDemanda::
nomeAluno ()
{
  return this->nomeAluno_.get ();
}

void ItemAlunoDemanda::
nomeAluno (const nomeAluno_type& x)
{
  this->nomeAluno_.set (x);
}

void ItemAlunoDemanda::
nomeAluno (::std::auto_ptr< nomeAluno_type > x)
{
  this->nomeAluno_.set (x);
}

const ItemAlunoDemanda::demandaId_type& ItemAlunoDemanda::
demandaId () const
{
  return this->demandaId_.get ();
}

ItemAlunoDemanda::demandaId_type& ItemAlunoDemanda::
demandaId ()
{
  return this->demandaId_.get ();
}

void ItemAlunoDemanda::
demandaId (const demandaId_type& x)
{
  this->demandaId_.set (x);
}


// ItemTurno
// 

const ItemTurno::id_type& ItemTurno::
id () const
{
  return this->id_.get ();
}

ItemTurno::id_type& ItemTurno::
id ()
{
  return this->id_.get ();
}

void ItemTurno::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTurno::nome_type& ItemTurno::
nome () const
{
  return this->nome_.get ();
}

ItemTurno::nome_type& ItemTurno::
nome ()
{
  return this->nome_.get ();
}

void ItemTurno::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTurno::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemTurno::HorariosAula_type& ItemTurno::
HorariosAula () const
{
  return this->HorariosAula_.get ();
}

ItemTurno::HorariosAula_type& ItemTurno::
HorariosAula ()
{
  return this->HorariosAula_.get ();
}

void ItemTurno::
HorariosAula (const HorariosAula_type& x)
{
  this->HorariosAula_.set (x);
}

void ItemTurno::
HorariosAula (::std::auto_ptr< HorariosAula_type > x)
{
  this->HorariosAula_.set (x);
}


// ItemHorarioAula
// 

const ItemHorarioAula::id_type& ItemHorarioAula::
id () const
{
  return this->id_.get ();
}

ItemHorarioAula::id_type& ItemHorarioAula::
id ()
{
  return this->id_.get ();
}

void ItemHorarioAula::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemHorarioAula::inicio_type& ItemHorarioAula::
inicio () const
{
  return this->inicio_.get ();
}

ItemHorarioAula::inicio_type& ItemHorarioAula::
inicio ()
{
  return this->inicio_.get ();
}

void ItemHorarioAula::
inicio (const inicio_type& x)
{
  this->inicio_.set (x);
}

void ItemHorarioAula::
inicio (::std::auto_ptr< inicio_type > x)
{
  this->inicio_.set (x);
}

const ItemHorarioAula::diasSemana_type& ItemHorarioAula::
diasSemana () const
{
  return this->diasSemana_.get ();
}

ItemHorarioAula::diasSemana_type& ItemHorarioAula::
diasSemana ()
{
  return this->diasSemana_.get ();
}

void ItemHorarioAula::
diasSemana (const diasSemana_type& x)
{
  this->diasSemana_.set (x);
}

void ItemHorarioAula::
diasSemana (::std::auto_ptr< diasSemana_type > x)
{
  this->diasSemana_.set (x);
}


// ItemTipoSala
// 

const ItemTipoSala::id_type& ItemTipoSala::
id () const
{
  return this->id_.get ();
}

ItemTipoSala::id_type& ItemTipoSala::
id ()
{
  return this->id_.get ();
}

void ItemTipoSala::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoSala::nome_type& ItemTipoSala::
nome () const
{
  return this->nome_.get ();
}

ItemTipoSala::nome_type& ItemTipoSala::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoSala::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoSala::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemTipoContrato
// 

const ItemTipoContrato::id_type& ItemTipoContrato::
id () const
{
  return this->id_.get ();
}

ItemTipoContrato::id_type& ItemTipoContrato::
id ()
{
  return this->id_.get ();
}

void ItemTipoContrato::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoContrato::nome_type& ItemTipoContrato::
nome () const
{
  return this->nome_.get ();
}

ItemTipoContrato::nome_type& ItemTipoContrato::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoContrato::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoContrato::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemTipoTitulacao
// 

const ItemTipoTitulacao::id_type& ItemTipoTitulacao::
id () const
{
  return this->id_.get ();
}

ItemTipoTitulacao::id_type& ItemTipoTitulacao::
id ()
{
  return this->id_.get ();
}

void ItemTipoTitulacao::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoTitulacao::nome_type& ItemTipoTitulacao::
nome () const
{
  return this->nome_.get ();
}

ItemTipoTitulacao::nome_type& ItemTipoTitulacao::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoTitulacao::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoTitulacao::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemAreaTitulacao
// 

const ItemAreaTitulacao::id_type& ItemAreaTitulacao::
id () const
{
  return this->id_.get ();
}

ItemAreaTitulacao::id_type& ItemAreaTitulacao::
id ()
{
  return this->id_.get ();
}

void ItemAreaTitulacao::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemAreaTitulacao::nome_type& ItemAreaTitulacao::
nome () const
{
  return this->nome_.get ();
}

ItemAreaTitulacao::nome_type& ItemAreaTitulacao::
nome ()
{
  return this->nome_.get ();
}

void ItemAreaTitulacao::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemAreaTitulacao::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemTipoDisciplina
// 

const ItemTipoDisciplina::id_type& ItemTipoDisciplina::
id () const
{
  return this->id_.get ();
}

ItemTipoDisciplina::id_type& ItemTipoDisciplina::
id ()
{
  return this->id_.get ();
}

void ItemTipoDisciplina::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoDisciplina::nome_type& ItemTipoDisciplina::
nome () const
{
  return this->nome_.get ();
}

ItemTipoDisciplina::nome_type& ItemTipoDisciplina::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoDisciplina::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoDisciplina::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemNivelDificuldade
// 

const ItemNivelDificuldade::id_type& ItemNivelDificuldade::
id () const
{
  return this->id_.get ();
}

ItemNivelDificuldade::id_type& ItemNivelDificuldade::
id ()
{
  return this->id_.get ();
}

void ItemNivelDificuldade::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemNivelDificuldade::nome_type& ItemNivelDificuldade::
nome () const
{
  return this->nome_.get ();
}

ItemNivelDificuldade::nome_type& ItemNivelDificuldade::
nome ()
{
  return this->nome_.get ();
}

void ItemNivelDificuldade::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemNivelDificuldade::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemTipoCurso
// 

const ItemTipoCurso::id_type& ItemTipoCurso::
id () const
{
  return this->id_.get ();
}

ItemTipoCurso::id_type& ItemTipoCurso::
id ()
{
  return this->id_.get ();
}

void ItemTipoCurso::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoCurso::nome_type& ItemTipoCurso::
nome () const
{
  return this->nome_.get ();
}

ItemTipoCurso::nome_type& ItemTipoCurso::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoCurso::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoCurso::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemDivisaoCreditos
// 

const ItemDivisaoCreditos::id_type& ItemDivisaoCreditos::
id () const
{
  return this->id_.get ();
}

ItemDivisaoCreditos::id_type& ItemDivisaoCreditos::
id ()
{
  return this->id_.get ();
}

void ItemDivisaoCreditos::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemDivisaoCreditos::creditos_type& ItemDivisaoCreditos::
creditos () const
{
  return this->creditos_.get ();
}

ItemDivisaoCreditos::creditos_type& ItemDivisaoCreditos::
creditos ()
{
  return this->creditos_.get ();
}

void ItemDivisaoCreditos::
creditos (const creditos_type& x)
{
  this->creditos_.set (x);
}

const ItemDivisaoCreditos::dia1_type& ItemDivisaoCreditos::
dia1 () const
{
  return this->dia1_.get ();
}

ItemDivisaoCreditos::dia1_type& ItemDivisaoCreditos::
dia1 ()
{
  return this->dia1_.get ();
}

void ItemDivisaoCreditos::
dia1 (const dia1_type& x)
{
  this->dia1_.set (x);
}

const ItemDivisaoCreditos::dia2_type& ItemDivisaoCreditos::
dia2 () const
{
  return this->dia2_.get ();
}

ItemDivisaoCreditos::dia2_type& ItemDivisaoCreditos::
dia2 ()
{
  return this->dia2_.get ();
}

void ItemDivisaoCreditos::
dia2 (const dia2_type& x)
{
  this->dia2_.set (x);
}

const ItemDivisaoCreditos::dia3_type& ItemDivisaoCreditos::
dia3 () const
{
  return this->dia3_.get ();
}

ItemDivisaoCreditos::dia3_type& ItemDivisaoCreditos::
dia3 ()
{
  return this->dia3_.get ();
}

void ItemDivisaoCreditos::
dia3 (const dia3_type& x)
{
  this->dia3_.set (x);
}

const ItemDivisaoCreditos::dia4_type& ItemDivisaoCreditos::
dia4 () const
{
  return this->dia4_.get ();
}

ItemDivisaoCreditos::dia4_type& ItemDivisaoCreditos::
dia4 ()
{
  return this->dia4_.get ();
}

void ItemDivisaoCreditos::
dia4 (const dia4_type& x)
{
  this->dia4_.set (x);
}

const ItemDivisaoCreditos::dia5_type& ItemDivisaoCreditos::
dia5 () const
{
  return this->dia5_.get ();
}

ItemDivisaoCreditos::dia5_type& ItemDivisaoCreditos::
dia5 ()
{
  return this->dia5_.get ();
}

void ItemDivisaoCreditos::
dia5 (const dia5_type& x)
{
  this->dia5_.set (x);
}

const ItemDivisaoCreditos::dia6_type& ItemDivisaoCreditos::
dia6 () const
{
  return this->dia6_.get ();
}

ItemDivisaoCreditos::dia6_type& ItemDivisaoCreditos::
dia6 ()
{
  return this->dia6_.get ();
}

void ItemDivisaoCreditos::
dia6 (const dia6_type& x)
{
  this->dia6_.set (x);
}

const ItemDivisaoCreditos::dia7_type& ItemDivisaoCreditos::
dia7 () const
{
  return this->dia7_.get ();
}

ItemDivisaoCreditos::dia7_type& ItemDivisaoCreditos::
dia7 ()
{
  return this->dia7_.get ();
}

void ItemDivisaoCreditos::
dia7 (const dia7_type& x)
{
  this->dia7_.set (x);
}


// ItemCampus
// 

const ItemCampus::id_type& ItemCampus::
id () const
{
  return this->id_.get ();
}

ItemCampus::id_type& ItemCampus::
id ()
{
  return this->id_.get ();
}

void ItemCampus::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemCampus::codigo_type& ItemCampus::
codigo () const
{
  return this->codigo_.get ();
}

ItemCampus::codigo_type& ItemCampus::
codigo ()
{
  return this->codigo_.get ();
}

void ItemCampus::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemCampus::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemCampus::nome_type& ItemCampus::
nome () const
{
  return this->nome_.get ();
}

ItemCampus::nome_type& ItemCampus::
nome ()
{
  return this->nome_.get ();
}

void ItemCampus::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemCampus::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemCampus::unidades_type& ItemCampus::
unidades () const
{
  return this->unidades_.get ();
}

ItemCampus::unidades_type& ItemCampus::
unidades ()
{
  return this->unidades_.get ();
}

void ItemCampus::
unidades (const unidades_type& x)
{
  this->unidades_.set (x);
}

void ItemCampus::
unidades (::std::auto_ptr< unidades_type > x)
{
  this->unidades_.set (x);
}

const ItemCampus::professores_type& ItemCampus::
professores () const
{
  return this->professores_.get ();
}

ItemCampus::professores_type& ItemCampus::
professores ()
{
  return this->professores_.get ();
}

void ItemCampus::
professores (const professores_type& x)
{
  this->professores_.set (x);
}

void ItemCampus::
professores (::std::auto_ptr< professores_type > x)
{
  this->professores_.set (x);
}

const ItemCampus::horariosDisponiveis_type& ItemCampus::
horariosDisponiveis () const
{
  return this->horariosDisponiveis_.get ();
}

ItemCampus::horariosDisponiveis_type& ItemCampus::
horariosDisponiveis ()
{
  return this->horariosDisponiveis_.get ();
}

void ItemCampus::
horariosDisponiveis (const horariosDisponiveis_type& x)
{
  this->horariosDisponiveis_.set (x);
}

void ItemCampus::
horariosDisponiveis (::std::auto_ptr< horariosDisponiveis_type > x)
{
  this->horariosDisponiveis_.set (x);
}

const ItemCampus::custo_type& ItemCampus::
custo () const
{
  return this->custo_.get ();
}

ItemCampus::custo_type& ItemCampus::
custo ()
{
  return this->custo_.get ();
}

void ItemCampus::
custo (const custo_type& x)
{
  this->custo_.set (x);
}


// ItemUnidade
// 

const ItemUnidade::id_type& ItemUnidade::
id () const
{
  return this->id_.get ();
}

ItemUnidade::id_type& ItemUnidade::
id ()
{
  return this->id_.get ();
}

void ItemUnidade::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemUnidade::codigo_type& ItemUnidade::
codigo () const
{
  return this->codigo_.get ();
}

ItemUnidade::codigo_type& ItemUnidade::
codigo ()
{
  return this->codigo_.get ();
}

void ItemUnidade::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemUnidade::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemUnidade::nome_type& ItemUnidade::
nome () const
{
  return this->nome_.get ();
}

ItemUnidade::nome_type& ItemUnidade::
nome ()
{
  return this->nome_.get ();
}

void ItemUnidade::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemUnidade::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemUnidade::horariosDisponiveis_type& ItemUnidade::
horariosDisponiveis () const
{
  return this->horariosDisponiveis_.get ();
}

ItemUnidade::horariosDisponiveis_type& ItemUnidade::
horariosDisponiveis ()
{
  return this->horariosDisponiveis_.get ();
}

void ItemUnidade::
horariosDisponiveis (const horariosDisponiveis_type& x)
{
  this->horariosDisponiveis_.set (x);
}

void ItemUnidade::
horariosDisponiveis (::std::auto_ptr< horariosDisponiveis_type > x)
{
  this->horariosDisponiveis_.set (x);
}

const ItemUnidade::salas_type& ItemUnidade::
salas () const
{
  return this->salas_.get ();
}

ItemUnidade::salas_type& ItemUnidade::
salas ()
{
  return this->salas_.get ();
}

void ItemUnidade::
salas (const salas_type& x)
{
  this->salas_.set (x);
}

void ItemUnidade::
salas (::std::auto_ptr< salas_type > x)
{
  this->salas_.set (x);
}


// ItemHorario
// 

const ItemHorario::turnoId_type& ItemHorario::
turnoId () const
{
  return this->turnoId_.get ();
}

ItemHorario::turnoId_type& ItemHorario::
turnoId ()
{
  return this->turnoId_.get ();
}

void ItemHorario::
turnoId (const turnoId_type& x)
{
  this->turnoId_.set (x);
}

const ItemHorario::horarioAulaId_type& ItemHorario::
horarioAulaId () const
{
  return this->horarioAulaId_.get ();
}

ItemHorario::horarioAulaId_type& ItemHorario::
horarioAulaId ()
{
  return this->horarioAulaId_.get ();
}

void ItemHorario::
horarioAulaId (const horarioAulaId_type& x)
{
  this->horarioAulaId_.set (x);
}

const ItemHorario::diasSemana_type& ItemHorario::
diasSemana () const
{
  return this->diasSemana_.get ();
}

ItemHorario::diasSemana_type& ItemHorario::
diasSemana ()
{
  return this->diasSemana_.get ();
}

void ItemHorario::
diasSemana (const diasSemana_type& x)
{
  this->diasSemana_.set (x);
}

void ItemHorario::
diasSemana (::std::auto_ptr< diasSemana_type > x)
{
  this->diasSemana_.set (x);
}


// ItemSala
// 

const ItemSala::id_type& ItemSala::
id () const
{
  return this->id_.get ();
}

ItemSala::id_type& ItemSala::
id ()
{
  return this->id_.get ();
}

void ItemSala::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemSala::codigo_type& ItemSala::
codigo () const
{
  return this->codigo_.get ();
}

ItemSala::codigo_type& ItemSala::
codigo ()
{
  return this->codigo_.get ();
}

void ItemSala::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemSala::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemSala::andar_type& ItemSala::
andar () const
{
  return this->andar_.get ();
}

ItemSala::andar_type& ItemSala::
andar ()
{
  return this->andar_.get ();
}

void ItemSala::
andar (const andar_type& x)
{
  this->andar_.set (x);
}

void ItemSala::
andar (::std::auto_ptr< andar_type > x)
{
  this->andar_.set (x);
}

const ItemSala::numero_type& ItemSala::
numero () const
{
  return this->numero_.get ();
}

ItemSala::numero_type& ItemSala::
numero ()
{
  return this->numero_.get ();
}

void ItemSala::
numero (const numero_type& x)
{
  this->numero_.set (x);
}

void ItemSala::
numero (::std::auto_ptr< numero_type > x)
{
  this->numero_.set (x);
}

const ItemSala::tipoSalaId_type& ItemSala::
tipoSalaId () const
{
  return this->tipoSalaId_.get ();
}

ItemSala::tipoSalaId_type& ItemSala::
tipoSalaId ()
{
  return this->tipoSalaId_.get ();
}

void ItemSala::
tipoSalaId (const tipoSalaId_type& x)
{
  this->tipoSalaId_.set (x);
}

const ItemSala::capacidade_type& ItemSala::
capacidade () const
{
  return this->capacidade_.get ();
}

ItemSala::capacidade_type& ItemSala::
capacidade ()
{
  return this->capacidade_.get ();
}

void ItemSala::
capacidade (const capacidade_type& x)
{
  this->capacidade_.set (x);
}

const ItemSala::horariosDisponiveis_optional& ItemSala::
horariosDisponiveis () const
{
  return this->horariosDisponiveis_;
}

ItemSala::horariosDisponiveis_optional& ItemSala::
horariosDisponiveis ()
{
  return this->horariosDisponiveis_;
}

void ItemSala::
horariosDisponiveis (const horariosDisponiveis_type& x)
{
  this->horariosDisponiveis_.set (x);
}

void ItemSala::
horariosDisponiveis (const horariosDisponiveis_optional& x)
{
  this->horariosDisponiveis_ = x;
}

void ItemSala::
horariosDisponiveis (::std::auto_ptr< horariosDisponiveis_type > x)
{
  this->horariosDisponiveis_.set (x);
}

const ItemSala::creditosDisponiveis_optional& ItemSala::
creditosDisponiveis () const
{
  return this->creditosDisponiveis_;
}

ItemSala::creditosDisponiveis_optional& ItemSala::
creditosDisponiveis ()
{
  return this->creditosDisponiveis_;
}

void ItemSala::
creditosDisponiveis (const creditosDisponiveis_type& x)
{
  this->creditosDisponiveis_.set (x);
}

void ItemSala::
creditosDisponiveis (const creditosDisponiveis_optional& x)
{
  this->creditosDisponiveis_ = x;
}

void ItemSala::
creditosDisponiveis (::std::auto_ptr< creditosDisponiveis_type > x)
{
  this->creditosDisponiveis_.set (x);
}

const ItemSala::disciplinasAssociadas_type& ItemSala::
disciplinasAssociadas () const
{
  return this->disciplinasAssociadas_.get ();
}

ItemSala::disciplinasAssociadas_type& ItemSala::
disciplinasAssociadas ()
{
  return this->disciplinasAssociadas_.get ();
}

void ItemSala::
disciplinasAssociadas (const disciplinasAssociadas_type& x)
{
  this->disciplinasAssociadas_.set (x);
}

void ItemSala::
disciplinasAssociadas (::std::auto_ptr< disciplinasAssociadas_type > x)
{
  this->disciplinasAssociadas_.set (x);
}


// ItemCreditoDisponivel
// 

const ItemCreditoDisponivel::turnoId_type& ItemCreditoDisponivel::
turnoId () const
{
  return this->turnoId_.get ();
}

ItemCreditoDisponivel::turnoId_type& ItemCreditoDisponivel::
turnoId ()
{
  return this->turnoId_.get ();
}

void ItemCreditoDisponivel::
turnoId (const turnoId_type& x)
{
  this->turnoId_.set (x);
}

const ItemCreditoDisponivel::diaSemana_type& ItemCreditoDisponivel::
diaSemana () const
{
  return this->diaSemana_.get ();
}

ItemCreditoDisponivel::diaSemana_type& ItemCreditoDisponivel::
diaSemana ()
{
  return this->diaSemana_.get ();
}

void ItemCreditoDisponivel::
diaSemana (const diaSemana_type& x)
{
  this->diaSemana_.set (x);
}

const ItemCreditoDisponivel::maxCreditos_type& ItemCreditoDisponivel::
maxCreditos () const
{
  return this->maxCreditos_.get ();
}

ItemCreditoDisponivel::maxCreditos_type& ItemCreditoDisponivel::
maxCreditos ()
{
  return this->maxCreditos_.get ();
}

void ItemCreditoDisponivel::
maxCreditos (const maxCreditos_type& x)
{
  this->maxCreditos_.set (x);
}


// ItemProfessor
// 

const ItemProfessor::id_type& ItemProfessor::
id () const
{
  return this->id_.get ();
}

ItemProfessor::id_type& ItemProfessor::
id ()
{
  return this->id_.get ();
}

void ItemProfessor::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemProfessor::cpf_type& ItemProfessor::
cpf () const
{
  return this->cpf_.get ();
}

ItemProfessor::cpf_type& ItemProfessor::
cpf ()
{
  return this->cpf_.get ();
}

void ItemProfessor::
cpf (const cpf_type& x)
{
  this->cpf_.set (x);
}

void ItemProfessor::
cpf (::std::auto_ptr< cpf_type > x)
{
  this->cpf_.set (x);
}

const ItemProfessor::nome_type& ItemProfessor::
nome () const
{
  return this->nome_.get ();
}

ItemProfessor::nome_type& ItemProfessor::
nome ()
{
  return this->nome_.get ();
}

void ItemProfessor::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemProfessor::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemProfessor::tipoContratoId_type& ItemProfessor::
tipoContratoId () const
{
  return this->tipoContratoId_.get ();
}

ItemProfessor::tipoContratoId_type& ItemProfessor::
tipoContratoId ()
{
  return this->tipoContratoId_.get ();
}

void ItemProfessor::
tipoContratoId (const tipoContratoId_type& x)
{
  this->tipoContratoId_.set (x);
}

const ItemProfessor::chMin_type& ItemProfessor::
chMin () const
{
  return this->chMin_.get ();
}

ItemProfessor::chMin_type& ItemProfessor::
chMin ()
{
  return this->chMin_.get ();
}

void ItemProfessor::
chMin (const chMin_type& x)
{
  this->chMin_.set (x);
}

const ItemProfessor::chMax_type& ItemProfessor::
chMax () const
{
  return this->chMax_.get ();
}

ItemProfessor::chMax_type& ItemProfessor::
chMax ()
{
  return this->chMax_.get ();
}

void ItemProfessor::
chMax (const chMax_type& x)
{
  this->chMax_.set (x);
}

const ItemProfessor::titulacaoId_type& ItemProfessor::
titulacaoId () const
{
  return this->titulacaoId_.get ();
}

ItemProfessor::titulacaoId_type& ItemProfessor::
titulacaoId ()
{
  return this->titulacaoId_.get ();
}

void ItemProfessor::
titulacaoId (const titulacaoId_type& x)
{
  this->titulacaoId_.set (x);
}

const ItemProfessor::areaTitulacaoId_optional& ItemProfessor::
areaTitulacaoId () const
{
  return this->areaTitulacaoId_;
}

ItemProfessor::areaTitulacaoId_optional& ItemProfessor::
areaTitulacaoId ()
{
  return this->areaTitulacaoId_;
}

void ItemProfessor::
areaTitulacaoId (const areaTitulacaoId_type& x)
{
  this->areaTitulacaoId_.set (x);
}

void ItemProfessor::
areaTitulacaoId (const areaTitulacaoId_optional& x)
{
  this->areaTitulacaoId_ = x;
}

const ItemProfessor::credAnterior_type& ItemProfessor::
credAnterior () const
{
  return this->credAnterior_.get ();
}

ItemProfessor::credAnterior_type& ItemProfessor::
credAnterior ()
{
  return this->credAnterior_.get ();
}

void ItemProfessor::
credAnterior (const credAnterior_type& x)
{
  this->credAnterior_.set (x);
}

const ItemProfessor::valorCred_type& ItemProfessor::
valorCred () const
{
  return this->valorCred_.get ();
}

ItemProfessor::valorCred_type& ItemProfessor::
valorCred ()
{
  return this->valorCred_.get ();
}

void ItemProfessor::
valorCred (const valorCred_type& x)
{
  this->valorCred_.set (x);
}

const ItemProfessor::horariosDisponiveis_type& ItemProfessor::
horariosDisponiveis () const
{
  return this->horariosDisponiveis_.get ();
}

ItemProfessor::horariosDisponiveis_type& ItemProfessor::
horariosDisponiveis ()
{
  return this->horariosDisponiveis_.get ();
}

void ItemProfessor::
horariosDisponiveis (const horariosDisponiveis_type& x)
{
  this->horariosDisponiveis_.set (x);
}

void ItemProfessor::
horariosDisponiveis (::std::auto_ptr< horariosDisponiveis_type > x)
{
  this->horariosDisponiveis_.set (x);
}

const ItemProfessor::disciplinas_type& ItemProfessor::
disciplinas () const
{
  return this->disciplinas_.get ();
}

ItemProfessor::disciplinas_type& ItemProfessor::
disciplinas ()
{
  return this->disciplinas_.get ();
}

void ItemProfessor::
disciplinas (const disciplinas_type& x)
{
  this->disciplinas_.set (x);
}

void ItemProfessor::
disciplinas (::std::auto_ptr< disciplinas_type > x)
{
  this->disciplinas_.set (x);
}


// ItemProfessorDisciplina
// 

const ItemProfessorDisciplina::nota_type& ItemProfessorDisciplina::
nota () const
{
  return this->nota_.get ();
}

ItemProfessorDisciplina::nota_type& ItemProfessorDisciplina::
nota ()
{
  return this->nota_.get ();
}

void ItemProfessorDisciplina::
nota (const nota_type& x)
{
  this->nota_.set (x);
}

const ItemProfessorDisciplina::preferencia_type& ItemProfessorDisciplina::
preferencia () const
{
  return this->preferencia_.get ();
}

ItemProfessorDisciplina::preferencia_type& ItemProfessorDisciplina::
preferencia ()
{
  return this->preferencia_.get ();
}

void ItemProfessorDisciplina::
preferencia (const preferencia_type& x)
{
  this->preferencia_.set (x);
}

const ItemProfessorDisciplina::disciplinaId_type& ItemProfessorDisciplina::
disciplinaId () const
{
  return this->disciplinaId_.get ();
}

ItemProfessorDisciplina::disciplinaId_type& ItemProfessorDisciplina::
disciplinaId ()
{
  return this->disciplinaId_.get ();
}

void ItemProfessorDisciplina::
disciplinaId (const disciplinaId_type& x)
{
  this->disciplinaId_.set (x);
}


// ItemDeslocamento
// 

const ItemDeslocamento::origemId_type& ItemDeslocamento::
origemId () const
{
  return this->origemId_.get ();
}

ItemDeslocamento::origemId_type& ItemDeslocamento::
origemId ()
{
  return this->origemId_.get ();
}

void ItemDeslocamento::
origemId (const origemId_type& x)
{
  this->origemId_.set (x);
}

const ItemDeslocamento::destinoId_type& ItemDeslocamento::
destinoId () const
{
  return this->destinoId_.get ();
}

ItemDeslocamento::destinoId_type& ItemDeslocamento::
destinoId ()
{
  return this->destinoId_.get ();
}

void ItemDeslocamento::
destinoId (const destinoId_type& x)
{
  this->destinoId_.set (x);
}

const ItemDeslocamento::tempo_type& ItemDeslocamento::
tempo () const
{
  return this->tempo_.get ();
}

ItemDeslocamento::tempo_type& ItemDeslocamento::
tempo ()
{
  return this->tempo_.get ();
}

void ItemDeslocamento::
tempo (const tempo_type& x)
{
  this->tempo_.set (x);
}

const ItemDeslocamento::custo_type& ItemDeslocamento::
custo () const
{
  return this->custo_.get ();
}

ItemDeslocamento::custo_type& ItemDeslocamento::
custo ()
{
  return this->custo_.get ();
}

void ItemDeslocamento::
custo (const custo_type& x)
{
  this->custo_.set (x);
}


// ItemDisciplina
// 

const ItemDisciplina::id_type& ItemDisciplina::
id () const
{
  return this->id_.get ();
}

ItemDisciplina::id_type& ItemDisciplina::
id ()
{
  return this->id_.get ();
}

void ItemDisciplina::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemDisciplina::codigo_type& ItemDisciplina::
codigo () const
{
  return this->codigo_.get ();
}

ItemDisciplina::codigo_type& ItemDisciplina::
codigo ()
{
  return this->codigo_.get ();
}

void ItemDisciplina::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemDisciplina::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemDisciplina::nome_type& ItemDisciplina::
nome () const
{
  return this->nome_.get ();
}

ItemDisciplina::nome_type& ItemDisciplina::
nome ()
{
  return this->nome_.get ();
}

void ItemDisciplina::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemDisciplina::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemDisciplina::credTeoricos_type& ItemDisciplina::
credTeoricos () const
{
  return this->credTeoricos_.get ();
}

ItemDisciplina::credTeoricos_type& ItemDisciplina::
credTeoricos ()
{
  return this->credTeoricos_.get ();
}

void ItemDisciplina::
credTeoricos (const credTeoricos_type& x)
{
  this->credTeoricos_.set (x);
}

const ItemDisciplina::credPraticos_type& ItemDisciplina::
credPraticos () const
{
  return this->credPraticos_.get ();
}

ItemDisciplina::credPraticos_type& ItemDisciplina::
credPraticos ()
{
  return this->credPraticos_.get ();
}

void ItemDisciplina::
credPraticos (const credPraticos_type& x)
{
  this->credPraticos_.set (x);
}

const ItemDisciplina::laboratorio_type& ItemDisciplina::
laboratorio () const
{
  return this->laboratorio_.get ();
}

ItemDisciplina::laboratorio_type& ItemDisciplina::
laboratorio ()
{
  return this->laboratorio_.get ();
}

void ItemDisciplina::
laboratorio (const laboratorio_type& x)
{
  this->laboratorio_.set (x);
}

const ItemDisciplina::maxAlunosTeorico_optional& ItemDisciplina::
maxAlunosTeorico () const
{
  return this->maxAlunosTeorico_;
}

ItemDisciplina::maxAlunosTeorico_optional& ItemDisciplina::
maxAlunosTeorico ()
{
  return this->maxAlunosTeorico_;
}

void ItemDisciplina::
maxAlunosTeorico (const maxAlunosTeorico_type& x)
{
  this->maxAlunosTeorico_.set (x);
}

void ItemDisciplina::
maxAlunosTeorico (const maxAlunosTeorico_optional& x)
{
  this->maxAlunosTeorico_ = x;
}

const ItemDisciplina::maxAlunosPratico_optional& ItemDisciplina::
maxAlunosPratico () const
{
  return this->maxAlunosPratico_;
}

ItemDisciplina::maxAlunosPratico_optional& ItemDisciplina::
maxAlunosPratico ()
{
  return this->maxAlunosPratico_;
}

void ItemDisciplina::
maxAlunosPratico (const maxAlunosPratico_type& x)
{
  this->maxAlunosPratico_.set (x);
}

void ItemDisciplina::
maxAlunosPratico (const maxAlunosPratico_optional& x)
{
  this->maxAlunosPratico_ = x;
}

const ItemDisciplina::tipoDisciplinaId_type& ItemDisciplina::
tipoDisciplinaId () const
{
  return this->tipoDisciplinaId_.get ();
}

ItemDisciplina::tipoDisciplinaId_type& ItemDisciplina::
tipoDisciplinaId ()
{
  return this->tipoDisciplinaId_.get ();
}

void ItemDisciplina::
tipoDisciplinaId (const tipoDisciplinaId_type& x)
{
  this->tipoDisciplinaId_.set (x);
}

const ItemDisciplina::nivelDificuldadeId_type& ItemDisciplina::
nivelDificuldadeId () const
{
  return this->nivelDificuldadeId_.get ();
}

ItemDisciplina::nivelDificuldadeId_type& ItemDisciplina::
nivelDificuldadeId ()
{
  return this->nivelDificuldadeId_.get ();
}

void ItemDisciplina::
nivelDificuldadeId (const nivelDificuldadeId_type& x)
{
  this->nivelDificuldadeId_.set (x);
}

const ItemDisciplina::divisaoDeCreditos_optional& ItemDisciplina::
divisaoDeCreditos () const
{
  return this->divisaoDeCreditos_;
}

ItemDisciplina::divisaoDeCreditos_optional& ItemDisciplina::
divisaoDeCreditos ()
{
  return this->divisaoDeCreditos_;
}

void ItemDisciplina::
divisaoDeCreditos (const divisaoDeCreditos_type& x)
{
  this->divisaoDeCreditos_.set (x);
}

void ItemDisciplina::
divisaoDeCreditos (const divisaoDeCreditos_optional& x)
{
  this->divisaoDeCreditos_ = x;
}

void ItemDisciplina::
divisaoDeCreditos (::std::auto_ptr< divisaoDeCreditos_type > x)
{
  this->divisaoDeCreditos_.set (x);
}

const ItemDisciplina::horariosDisponiveis_type& ItemDisciplina::
horariosDisponiveis () const
{
  return this->horariosDisponiveis_.get ();
}

ItemDisciplina::horariosDisponiveis_type& ItemDisciplina::
horariosDisponiveis ()
{
  return this->horariosDisponiveis_.get ();
}

void ItemDisciplina::
horariosDisponiveis (const horariosDisponiveis_type& x)
{
  this->horariosDisponiveis_.set (x);
}

void ItemDisciplina::
horariosDisponiveis (::std::auto_ptr< horariosDisponiveis_type > x)
{
  this->horariosDisponiveis_.set (x);
}

const ItemDisciplina::disciplinasEquivalentes_type& ItemDisciplina::
disciplinasEquivalentes () const
{
  return this->disciplinasEquivalentes_.get ();
}

ItemDisciplina::disciplinasEquivalentes_type& ItemDisciplina::
disciplinasEquivalentes ()
{
  return this->disciplinasEquivalentes_.get ();
}

void ItemDisciplina::
disciplinasEquivalentes (const disciplinasEquivalentes_type& x)
{
  this->disciplinasEquivalentes_.set (x);
}

void ItemDisciplina::
disciplinasEquivalentes (::std::auto_ptr< disciplinasEquivalentes_type > x)
{
  this->disciplinasEquivalentes_.set (x);
}

const ItemDisciplina::disciplinasIncompativeis_type& ItemDisciplina::
disciplinasIncompativeis () const
{
  return this->disciplinasIncompativeis_.get ();
}

ItemDisciplina::disciplinasIncompativeis_type& ItemDisciplina::
disciplinasIncompativeis ()
{
  return this->disciplinasIncompativeis_.get ();
}

void ItemDisciplina::
disciplinasIncompativeis (const disciplinasIncompativeis_type& x)
{
  this->disciplinasIncompativeis_.set (x);
}

void ItemDisciplina::
disciplinasIncompativeis (::std::auto_ptr< disciplinasIncompativeis_type > x)
{
  this->disciplinasIncompativeis_.set (x);
}


// ItemCurso
// 

const ItemCurso::id_type& ItemCurso::
id () const
{
  return this->id_.get ();
}

ItemCurso::id_type& ItemCurso::
id ()
{
  return this->id_.get ();
}

void ItemCurso::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemCurso::codigo_type& ItemCurso::
codigo () const
{
  return this->codigo_.get ();
}

ItemCurso::codigo_type& ItemCurso::
codigo ()
{
  return this->codigo_.get ();
}

void ItemCurso::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemCurso::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemCurso::tipoId_type& ItemCurso::
tipoId () const
{
  return this->tipoId_.get ();
}

ItemCurso::tipoId_type& ItemCurso::
tipoId ()
{
  return this->tipoId_.get ();
}

void ItemCurso::
tipoId (const tipoId_type& x)
{
  this->tipoId_.set (x);
}

const ItemCurso::regraPercMinMestres_type& ItemCurso::
regraPercMinMestres () const
{
  return this->regraPercMinMestres_.get ();
}

ItemCurso::regraPercMinMestres_type& ItemCurso::
regraPercMinMestres ()
{
  return this->regraPercMinMestres_.get ();
}

void ItemCurso::
regraPercMinMestres (const regraPercMinMestres_type& x)
{
  this->regraPercMinMestres_.set (x);
}

void ItemCurso::
regraPercMinMestres (::std::auto_ptr< regraPercMinMestres_type > x)
{
  this->regraPercMinMestres_.set (x);
}

const ItemCurso::regraPercMinDoutores_type& ItemCurso::
regraPercMinDoutores () const
{
  return this->regraPercMinDoutores_.get ();
}

ItemCurso::regraPercMinDoutores_type& ItemCurso::
regraPercMinDoutores ()
{
  return this->regraPercMinDoutores_.get ();
}

void ItemCurso::
regraPercMinDoutores (const regraPercMinDoutores_type& x)
{
  this->regraPercMinDoutores_.set (x);
}

void ItemCurso::
regraPercMinDoutores (::std::auto_ptr< regraPercMinDoutores_type > x)
{
  this->regraPercMinDoutores_.set (x);
}

const ItemCurso::qtdMaxProfDisc_type& ItemCurso::
qtdMaxProfDisc () const
{
  return this->qtdMaxProfDisc_.get ();
}

ItemCurso::qtdMaxProfDisc_type& ItemCurso::
qtdMaxProfDisc ()
{
  return this->qtdMaxProfDisc_.get ();
}

void ItemCurso::
qtdMaxProfDisc (const qtdMaxProfDisc_type& x)
{
  this->qtdMaxProfDisc_.set (x);
}

const ItemCurso::maisDeUmaDiscPeriodo_type& ItemCurso::
maisDeUmaDiscPeriodo () const
{
  return this->maisDeUmaDiscPeriodo_.get ();
}

ItemCurso::maisDeUmaDiscPeriodo_type& ItemCurso::
maisDeUmaDiscPeriodo ()
{
  return this->maisDeUmaDiscPeriodo_.get ();
}

void ItemCurso::
maisDeUmaDiscPeriodo (const maisDeUmaDiscPeriodo_type& x)
{
  this->maisDeUmaDiscPeriodo_.set (x);
}

const ItemCurso::areasTitulacao_type& ItemCurso::
areasTitulacao () const
{
  return this->areasTitulacao_.get ();
}

ItemCurso::areasTitulacao_type& ItemCurso::
areasTitulacao ()
{
  return this->areasTitulacao_.get ();
}

void ItemCurso::
areasTitulacao (const areasTitulacao_type& x)
{
  this->areasTitulacao_.set (x);
}

void ItemCurso::
areasTitulacao (::std::auto_ptr< areasTitulacao_type > x)
{
  this->areasTitulacao_.set (x);
}

const ItemCurso::curriculos_type& ItemCurso::
curriculos () const
{
  return this->curriculos_.get ();
}

ItemCurso::curriculos_type& ItemCurso::
curriculos ()
{
  return this->curriculos_.get ();
}

void ItemCurso::
curriculos (const curriculos_type& x)
{
  this->curriculos_.set (x);
}

void ItemCurso::
curriculos (::std::auto_ptr< curriculos_type > x)
{
  this->curriculos_.set (x);
}

const ItemCurso::minTempoIntegral_type& ItemCurso::
minTempoIntegral () const
{
  return this->minTempoIntegral_.get ();
}

ItemCurso::minTempoIntegral_type& ItemCurso::
minTempoIntegral ()
{
  return this->minTempoIntegral_.get ();
}

void ItemCurso::
minTempoIntegral (const minTempoIntegral_type& x)
{
  this->minTempoIntegral_.set (x);
}

const ItemCurso::minTempoIntegralParcial_type& ItemCurso::
minTempoIntegralParcial () const
{
  return this->minTempoIntegralParcial_.get ();
}

ItemCurso::minTempoIntegralParcial_type& ItemCurso::
minTempoIntegralParcial ()
{
  return this->minTempoIntegralParcial_.get ();
}

void ItemCurso::
minTempoIntegralParcial (const minTempoIntegralParcial_type& x)
{
  this->minTempoIntegralParcial_.set (x);
}


// ItemPercentualMinimo
// 

const ItemPercentualMinimo::percMinimo_type& ItemPercentualMinimo::
percMinimo () const
{
  return this->percMinimo_.get ();
}

ItemPercentualMinimo::percMinimo_type& ItemPercentualMinimo::
percMinimo ()
{
  return this->percMinimo_.get ();
}

void ItemPercentualMinimo::
percMinimo (const percMinimo_type& x)
{
  this->percMinimo_.set (x);
}

const ItemPercentualMinimo::tipoTitulacaoId_type& ItemPercentualMinimo::
tipoTitulacaoId () const
{
  return this->tipoTitulacaoId_.get ();
}

ItemPercentualMinimo::tipoTitulacaoId_type& ItemPercentualMinimo::
tipoTitulacaoId ()
{
  return this->tipoTitulacaoId_.get ();
}

void ItemPercentualMinimo::
tipoTitulacaoId (const tipoTitulacaoId_type& x)
{
  this->tipoTitulacaoId_.set (x);
}


// ItemCurriculo
// 

const ItemCurriculo::id_type& ItemCurriculo::
id () const
{
  return this->id_.get ();
}

ItemCurriculo::id_type& ItemCurriculo::
id ()
{
  return this->id_.get ();
}

void ItemCurriculo::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemCurriculo::codigo_type& ItemCurriculo::
codigo () const
{
  return this->codigo_.get ();
}

ItemCurriculo::codigo_type& ItemCurriculo::
codigo ()
{
  return this->codigo_.get ();
}

void ItemCurriculo::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemCurriculo::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemCurriculo::disciplinasPeriodo_type& ItemCurriculo::
disciplinasPeriodo () const
{
  return this->disciplinasPeriodo_.get ();
}

ItemCurriculo::disciplinasPeriodo_type& ItemCurriculo::
disciplinasPeriodo ()
{
  return this->disciplinasPeriodo_.get ();
}

void ItemCurriculo::
disciplinasPeriodo (const disciplinasPeriodo_type& x)
{
  this->disciplinasPeriodo_.set (x);
}

void ItemCurriculo::
disciplinasPeriodo (::std::auto_ptr< disciplinasPeriodo_type > x)
{
  this->disciplinasPeriodo_.set (x);
}

const ItemCurriculo::semanaLetivaId_type& ItemCurriculo::
semanaLetivaId () const
{
  return this->semanaLetivaId_.get ();
}

ItemCurriculo::semanaLetivaId_type& ItemCurriculo::
semanaLetivaId ()
{
  return this->semanaLetivaId_.get ();
}

void ItemCurriculo::
semanaLetivaId (const semanaLetivaId_type& x)
{
  this->semanaLetivaId_.set (x);
}


// ItemDisciplinaPeriodo
// 

const ItemDisciplinaPeriodo::periodo_type& ItemDisciplinaPeriodo::
periodo () const
{
  return this->periodo_.get ();
}

ItemDisciplinaPeriodo::periodo_type& ItemDisciplinaPeriodo::
periodo ()
{
  return this->periodo_.get ();
}

void ItemDisciplinaPeriodo::
periodo (const periodo_type& x)
{
  this->periodo_.set (x);
}

const ItemDisciplinaPeriodo::disciplinaId_type& ItemDisciplinaPeriodo::
disciplinaId () const
{
  return this->disciplinaId_.get ();
}

ItemDisciplinaPeriodo::disciplinaId_type& ItemDisciplinaPeriodo::
disciplinaId ()
{
  return this->disciplinaId_.get ();
}

void ItemDisciplinaPeriodo::
disciplinaId (const disciplinaId_type& x)
{
  this->disciplinaId_.set (x);
}


// ItemOfertaCurso
// 

const ItemOfertaCurso::id_type& ItemOfertaCurso::
id () const
{
  return this->id_.get ();
}

ItemOfertaCurso::id_type& ItemOfertaCurso::
id ()
{
  return this->id_.get ();
}

void ItemOfertaCurso::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemOfertaCurso::curriculoId_type& ItemOfertaCurso::
curriculoId () const
{
  return this->curriculoId_.get ();
}

ItemOfertaCurso::curriculoId_type& ItemOfertaCurso::
curriculoId ()
{
  return this->curriculoId_.get ();
}

void ItemOfertaCurso::
curriculoId (const curriculoId_type& x)
{
  this->curriculoId_.set (x);
}

const ItemOfertaCurso::cursoId_type& ItemOfertaCurso::
cursoId () const
{
  return this->cursoId_.get ();
}

ItemOfertaCurso::cursoId_type& ItemOfertaCurso::
cursoId ()
{
  return this->cursoId_.get ();
}

void ItemOfertaCurso::
cursoId (const cursoId_type& x)
{
  this->cursoId_.set (x);
}

const ItemOfertaCurso::turnoId_type& ItemOfertaCurso::
turnoId () const
{
  return this->turnoId_.get ();
}

ItemOfertaCurso::turnoId_type& ItemOfertaCurso::
turnoId ()
{
  return this->turnoId_.get ();
}

void ItemOfertaCurso::
turnoId (const turnoId_type& x)
{
  this->turnoId_.set (x);
}

const ItemOfertaCurso::campusId_type& ItemOfertaCurso::
campusId () const
{
  return this->campusId_.get ();
}

ItemOfertaCurso::campusId_type& ItemOfertaCurso::
campusId ()
{
  return this->campusId_.get ();
}

void ItemOfertaCurso::
campusId (const campusId_type& x)
{
  this->campusId_.set (x);
}

const ItemOfertaCurso::receita_type& ItemOfertaCurso::
receita () const
{
  return this->receita_.get ();
}

ItemOfertaCurso::receita_type& ItemOfertaCurso::
receita ()
{
  return this->receita_.get ();
}

void ItemOfertaCurso::
receita (const receita_type& x)
{
  this->receita_.set (x);
}


// ItemDemanda
// 

const ItemDemanda::id_type& ItemDemanda::
id () const
{
  return this->id_.get ();
}

ItemDemanda::id_type& ItemDemanda::
id ()
{
  return this->id_.get ();
}

void ItemDemanda::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemDemanda::ofertaCursoCampiId_type& ItemDemanda::
ofertaCursoCampiId () const
{
  return this->ofertaCursoCampiId_.get ();
}

ItemDemanda::ofertaCursoCampiId_type& ItemDemanda::
ofertaCursoCampiId ()
{
  return this->ofertaCursoCampiId_.get ();
}

void ItemDemanda::
ofertaCursoCampiId (const ofertaCursoCampiId_type& x)
{
  this->ofertaCursoCampiId_.set (x);
}

const ItemDemanda::disciplinaId_type& ItemDemanda::
disciplinaId () const
{
  return this->disciplinaId_.get ();
}

ItemDemanda::disciplinaId_type& ItemDemanda::
disciplinaId ()
{
  return this->disciplinaId_.get ();
}

void ItemDemanda::
disciplinaId (const disciplinaId_type& x)
{
  this->disciplinaId_.set (x);
}

const ItemDemanda::quantidade_type& ItemDemanda::
quantidade () const
{
  return this->quantidade_.get ();
}

ItemDemanda::quantidade_type& ItemDemanda::
quantidade ()
{
  return this->quantidade_.get ();
}

void ItemDemanda::
quantidade (const quantidade_type& x)
{
  this->quantidade_.set (x);
}


// ItemFixacao
// 

const ItemFixacao::id_type& ItemFixacao::
id () const
{
  return this->id_.get ();
}

ItemFixacao::id_type& ItemFixacao::
id ()
{
  return this->id_.get ();
}

void ItemFixacao::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemFixacao::professorId_optional& ItemFixacao::
professorId () const
{
  return this->professorId_;
}

ItemFixacao::professorId_optional& ItemFixacao::
professorId ()
{
  return this->professorId_;
}

void ItemFixacao::
professorId (const professorId_type& x)
{
  this->professorId_.set (x);
}

void ItemFixacao::
professorId (const professorId_optional& x)
{
  this->professorId_ = x;
}

const ItemFixacao::disciplinaId_optional& ItemFixacao::
disciplinaId () const
{
  return this->disciplinaId_;
}

ItemFixacao::disciplinaId_optional& ItemFixacao::
disciplinaId ()
{
  return this->disciplinaId_;
}

void ItemFixacao::
disciplinaId (const disciplinaId_type& x)
{
  this->disciplinaId_.set (x);
}

void ItemFixacao::
disciplinaId (const disciplinaId_optional& x)
{
  this->disciplinaId_ = x;
}

const ItemFixacao::salaId_optional& ItemFixacao::
salaId () const
{
  return this->salaId_;
}

ItemFixacao::salaId_optional& ItemFixacao::
salaId ()
{
  return this->salaId_;
}

void ItemFixacao::
salaId (const salaId_type& x)
{
  this->salaId_.set (x);
}

void ItemFixacao::
salaId (const salaId_optional& x)
{
  this->salaId_ = x;
}

const ItemFixacao::diaSemana_optional& ItemFixacao::
diaSemana () const
{
  return this->diaSemana_;
}

ItemFixacao::diaSemana_optional& ItemFixacao::
diaSemana ()
{
  return this->diaSemana_;
}

void ItemFixacao::
diaSemana (const diaSemana_type& x)
{
  this->diaSemana_.set (x);
}

void ItemFixacao::
diaSemana (const diaSemana_optional& x)
{
  this->diaSemana_ = x;
}

const ItemFixacao::turnoId_optional& ItemFixacao::
turnoId () const
{
  return this->turnoId_;
}

ItemFixacao::turnoId_optional& ItemFixacao::
turnoId ()
{
  return this->turnoId_;
}

void ItemFixacao::
turnoId (const turnoId_type& x)
{
  this->turnoId_.set (x);
}

void ItemFixacao::
turnoId (const turnoId_optional& x)
{
  this->turnoId_ = x;
}

const ItemFixacao::horarioAulaId_optional& ItemFixacao::
horarioAulaId () const
{
  return this->horarioAulaId_;
}

ItemFixacao::horarioAulaId_optional& ItemFixacao::
horarioAulaId ()
{
  return this->horarioAulaId_;
}

void ItemFixacao::
horarioAulaId (const horarioAulaId_type& x)
{
  this->horarioAulaId_.set (x);
}

void ItemFixacao::
horarioAulaId (const horarioAulaId_optional& x)
{
  this->horarioAulaId_ = x;
}


// ItemParametrosPlanejamento
// 

const ItemParametrosPlanejamento::modoOtimizacao_type& ItemParametrosPlanejamento::
modoOtimizacao () const
{
  return this->modoOtimizacao_.get ();
}

ItemParametrosPlanejamento::modoOtimizacao_type& ItemParametrosPlanejamento::
modoOtimizacao ()
{
  return this->modoOtimizacao_.get ();
}

void ItemParametrosPlanejamento::
modoOtimizacao (const modoOtimizacao_type& x)
{
  this->modoOtimizacao_.set (x);
}

void ItemParametrosPlanejamento::
modoOtimizacao (::std::auto_ptr< modoOtimizacao_type > x)
{
  this->modoOtimizacao_.set (x);
}

const ItemParametrosPlanejamento::cargaHorariaSemanalAluno_type& ItemParametrosPlanejamento::
cargaHorariaSemanalAluno () const
{
  return this->cargaHorariaSemanalAluno_.get ();
}

ItemParametrosPlanejamento::cargaHorariaSemanalAluno_type& ItemParametrosPlanejamento::
cargaHorariaSemanalAluno ()
{
  return this->cargaHorariaSemanalAluno_.get ();
}

void ItemParametrosPlanejamento::
cargaHorariaSemanalAluno (const cargaHorariaSemanalAluno_type& x)
{
  this->cargaHorariaSemanalAluno_.set (x);
}

void ItemParametrosPlanejamento::
cargaHorariaSemanalAluno (::std::auto_ptr< cargaHorariaSemanalAluno_type > x)
{
  this->cargaHorariaSemanalAluno_.set (x);
}

const ItemParametrosPlanejamento::alunosMesmoPeriodoNaMesmaSala_type& ItemParametrosPlanejamento::
alunosMesmoPeriodoNaMesmaSala () const
{
  return this->alunosMesmoPeriodoNaMesmaSala_.get ();
}

ItemParametrosPlanejamento::alunosMesmoPeriodoNaMesmaSala_type& ItemParametrosPlanejamento::
alunosMesmoPeriodoNaMesmaSala ()
{
  return this->alunosMesmoPeriodoNaMesmaSala_.get ();
}

void ItemParametrosPlanejamento::
alunosMesmoPeriodoNaMesmaSala (const alunosMesmoPeriodoNaMesmaSala_type& x)
{
  this->alunosMesmoPeriodoNaMesmaSala_.set (x);
}

const ItemParametrosPlanejamento::permitirAlunosEmVariosCampi_type& ItemParametrosPlanejamento::
permitirAlunosEmVariosCampi () const
{
  return this->permitirAlunosEmVariosCampi_.get ();
}

ItemParametrosPlanejamento::permitirAlunosEmVariosCampi_type& ItemParametrosPlanejamento::
permitirAlunosEmVariosCampi ()
{
  return this->permitirAlunosEmVariosCampi_.get ();
}

void ItemParametrosPlanejamento::
permitirAlunosEmVariosCampi (const permitirAlunosEmVariosCampi_type& x)
{
  this->permitirAlunosEmVariosCampi_.set (x);
}

const ItemParametrosPlanejamento::minimizarDeslocAluno_type& ItemParametrosPlanejamento::
minimizarDeslocAluno () const
{
  return this->minimizarDeslocAluno_.get ();
}

ItemParametrosPlanejamento::minimizarDeslocAluno_type& ItemParametrosPlanejamento::
minimizarDeslocAluno ()
{
  return this->minimizarDeslocAluno_.get ();
}

void ItemParametrosPlanejamento::
minimizarDeslocAluno (const minimizarDeslocAluno_type& x)
{
  this->minimizarDeslocAluno_.set (x);
}

const ItemParametrosPlanejamento::cargaHorariaSemanalProfessor_type& ItemParametrosPlanejamento::
cargaHorariaSemanalProfessor () const
{
  return this->cargaHorariaSemanalProfessor_.get ();
}

ItemParametrosPlanejamento::cargaHorariaSemanalProfessor_type& ItemParametrosPlanejamento::
cargaHorariaSemanalProfessor ()
{
  return this->cargaHorariaSemanalProfessor_.get ();
}

void ItemParametrosPlanejamento::
cargaHorariaSemanalProfessor (const cargaHorariaSemanalProfessor_type& x)
{
  this->cargaHorariaSemanalProfessor_.set (x);
}

void ItemParametrosPlanejamento::
cargaHorariaSemanalProfessor (::std::auto_ptr< cargaHorariaSemanalProfessor_type > x)
{
  this->cargaHorariaSemanalProfessor_.set (x);
}

const ItemParametrosPlanejamento::permitirProfessorEmVariosCampi_type& ItemParametrosPlanejamento::
permitirProfessorEmVariosCampi () const
{
  return this->permitirProfessorEmVariosCampi_.get ();
}

ItemParametrosPlanejamento::permitirProfessorEmVariosCampi_type& ItemParametrosPlanejamento::
permitirProfessorEmVariosCampi ()
{
  return this->permitirProfessorEmVariosCampi_.get ();
}

void ItemParametrosPlanejamento::
permitirProfessorEmVariosCampi (const permitirProfessorEmVariosCampi_type& x)
{
  this->permitirProfessorEmVariosCampi_.set (x);
}

const ItemParametrosPlanejamento::minimizarDeslocProfessor_type& ItemParametrosPlanejamento::
minimizarDeslocProfessor () const
{
  return this->minimizarDeslocProfessor_.get ();
}

ItemParametrosPlanejamento::minimizarDeslocProfessor_type& ItemParametrosPlanejamento::
minimizarDeslocProfessor ()
{
  return this->minimizarDeslocProfessor_.get ();
}

void ItemParametrosPlanejamento::
minimizarDeslocProfessor (const minimizarDeslocProfessor_type& x)
{
  this->minimizarDeslocProfessor_.set (x);
}

const ItemParametrosPlanejamento::maxDeslocProfessor_optional& ItemParametrosPlanejamento::
maxDeslocProfessor () const
{
  return this->maxDeslocProfessor_;
}

ItemParametrosPlanejamento::maxDeslocProfessor_optional& ItemParametrosPlanejamento::
maxDeslocProfessor ()
{
  return this->maxDeslocProfessor_;
}

void ItemParametrosPlanejamento::
maxDeslocProfessor (const maxDeslocProfessor_type& x)
{
  this->maxDeslocProfessor_.set (x);
}

void ItemParametrosPlanejamento::
maxDeslocProfessor (const maxDeslocProfessor_optional& x)
{
  this->maxDeslocProfessor_ = x;
}

const ItemParametrosPlanejamento::minimizarHorariosVaziosProfessor_type& ItemParametrosPlanejamento::
minimizarHorariosVaziosProfessor () const
{
  return this->minimizarHorariosVaziosProfessor_.get ();
}

ItemParametrosPlanejamento::minimizarHorariosVaziosProfessor_type& ItemParametrosPlanejamento::
minimizarHorariosVaziosProfessor ()
{
  return this->minimizarHorariosVaziosProfessor_.get ();
}

void ItemParametrosPlanejamento::
minimizarHorariosVaziosProfessor (const minimizarHorariosVaziosProfessor_type& x)
{
  this->minimizarHorariosVaziosProfessor_.set (x);
}

const ItemParametrosPlanejamento::evitarReducaoCargaHorariaProf_type& ItemParametrosPlanejamento::
evitarReducaoCargaHorariaProf () const
{
  return this->evitarReducaoCargaHorariaProf_.get ();
}

ItemParametrosPlanejamento::evitarReducaoCargaHorariaProf_type& ItemParametrosPlanejamento::
evitarReducaoCargaHorariaProf ()
{
  return this->evitarReducaoCargaHorariaProf_.get ();
}

void ItemParametrosPlanejamento::
evitarReducaoCargaHorariaProf (const evitarReducaoCargaHorariaProf_type& x)
{
  this->evitarReducaoCargaHorariaProf_.set (x);
}

const ItemParametrosPlanejamento::evitarReducaoCargaHorariaProfValor_optional& ItemParametrosPlanejamento::
evitarReducaoCargaHorariaProfValor () const
{
  return this->evitarReducaoCargaHorariaProfValor_;
}

ItemParametrosPlanejamento::evitarReducaoCargaHorariaProfValor_optional& ItemParametrosPlanejamento::
evitarReducaoCargaHorariaProfValor ()
{
  return this->evitarReducaoCargaHorariaProfValor_;
}

void ItemParametrosPlanejamento::
evitarReducaoCargaHorariaProfValor (const evitarReducaoCargaHorariaProfValor_type& x)
{
  this->evitarReducaoCargaHorariaProfValor_.set (x);
}

void ItemParametrosPlanejamento::
evitarReducaoCargaHorariaProfValor (const evitarReducaoCargaHorariaProfValor_optional& x)
{
  this->evitarReducaoCargaHorariaProfValor_ = x;
}

const ItemParametrosPlanejamento::evitarProfUltimoPrimeiroHor_type& ItemParametrosPlanejamento::
evitarProfUltimoPrimeiroHor () const
{
  return this->evitarProfUltimoPrimeiroHor_.get ();
}

ItemParametrosPlanejamento::evitarProfUltimoPrimeiroHor_type& ItemParametrosPlanejamento::
evitarProfUltimoPrimeiroHor ()
{
  return this->evitarProfUltimoPrimeiroHor_.get ();
}

void ItemParametrosPlanejamento::
evitarProfUltimoPrimeiroHor (const evitarProfUltimoPrimeiroHor_type& x)
{
  this->evitarProfUltimoPrimeiroHor_.set (x);
}

const ItemParametrosPlanejamento::preferenciaProfessorDisciplina_type& ItemParametrosPlanejamento::
preferenciaProfessorDisciplina () const
{
  return this->preferenciaProfessorDisciplina_.get ();
}

ItemParametrosPlanejamento::preferenciaProfessorDisciplina_type& ItemParametrosPlanejamento::
preferenciaProfessorDisciplina ()
{
  return this->preferenciaProfessorDisciplina_.get ();
}

void ItemParametrosPlanejamento::
preferenciaProfessorDisciplina (const preferenciaProfessorDisciplina_type& x)
{
  this->preferenciaProfessorDisciplina_.set (x);
}

const ItemParametrosPlanejamento::desempenhoProfDisponibilidade_type& ItemParametrosPlanejamento::
desempenhoProfDisponibilidade () const
{
  return this->desempenhoProfDisponibilidade_.get ();
}

ItemParametrosPlanejamento::desempenhoProfDisponibilidade_type& ItemParametrosPlanejamento::
desempenhoProfDisponibilidade ()
{
  return this->desempenhoProfDisponibilidade_.get ();
}

void ItemParametrosPlanejamento::
desempenhoProfDisponibilidade (const desempenhoProfDisponibilidade_type& x)
{
  this->desempenhoProfDisponibilidade_.set (x);
}

const ItemParametrosPlanejamento::funcaoObjetivo_type& ItemParametrosPlanejamento::
funcaoObjetivo () const
{
  return this->funcaoObjetivo_.get ();
}

ItemParametrosPlanejamento::funcaoObjetivo_type& ItemParametrosPlanejamento::
funcaoObjetivo ()
{
  return this->funcaoObjetivo_.get ();
}

void ItemParametrosPlanejamento::
funcaoObjetivo (const funcaoObjetivo_type& x)
{
  this->funcaoObjetivo_.set (x);
}

const ItemParametrosPlanejamento::considerarEquivalencia_type& ItemParametrosPlanejamento::
considerarEquivalencia () const
{
  return this->considerarEquivalencia_.get ();
}

ItemParametrosPlanejamento::considerarEquivalencia_type& ItemParametrosPlanejamento::
considerarEquivalencia ()
{
  return this->considerarEquivalencia_.get ();
}

void ItemParametrosPlanejamento::
considerarEquivalencia (const considerarEquivalencia_type& x)
{
  this->considerarEquivalencia_.set (x);
}

const ItemParametrosPlanejamento::minAlunosAberturaTurmas_type& ItemParametrosPlanejamento::
minAlunosAberturaTurmas () const
{
  return this->minAlunosAberturaTurmas_.get ();
}

ItemParametrosPlanejamento::minAlunosAberturaTurmas_type& ItemParametrosPlanejamento::
minAlunosAberturaTurmas ()
{
  return this->minAlunosAberturaTurmas_.get ();
}

void ItemParametrosPlanejamento::
minAlunosAberturaTurmas (const minAlunosAberturaTurmas_type& x)
{
  this->minAlunosAberturaTurmas_.set (x);
}

const ItemParametrosPlanejamento::minAlunosAberturaTurmasValor_optional& ItemParametrosPlanejamento::
minAlunosAberturaTurmasValor () const
{
  return this->minAlunosAberturaTurmasValor_;
}

ItemParametrosPlanejamento::minAlunosAberturaTurmasValor_optional& ItemParametrosPlanejamento::
minAlunosAberturaTurmasValor ()
{
  return this->minAlunosAberturaTurmasValor_;
}

void ItemParametrosPlanejamento::
minAlunosAberturaTurmasValor (const minAlunosAberturaTurmasValor_type& x)
{
  this->minAlunosAberturaTurmasValor_.set (x);
}

void ItemParametrosPlanejamento::
minAlunosAberturaTurmasValor (const minAlunosAberturaTurmasValor_optional& x)
{
  this->minAlunosAberturaTurmasValor_ = x;
}

const ItemParametrosPlanejamento::niveisDificuldadeHorario_type& ItemParametrosPlanejamento::
niveisDificuldadeHorario () const
{
  return this->niveisDificuldadeHorario_.get ();
}

ItemParametrosPlanejamento::niveisDificuldadeHorario_type& ItemParametrosPlanejamento::
niveisDificuldadeHorario ()
{
  return this->niveisDificuldadeHorario_.get ();
}

void ItemParametrosPlanejamento::
niveisDificuldadeHorario (const niveisDificuldadeHorario_type& x)
{
  this->niveisDificuldadeHorario_.set (x);
}

void ItemParametrosPlanejamento::
niveisDificuldadeHorario (::std::auto_ptr< niveisDificuldadeHorario_type > x)
{
  this->niveisDificuldadeHorario_.set (x);
}

const ItemParametrosPlanejamento::equilibrarDiversidadeDiscDia_type& ItemParametrosPlanejamento::
equilibrarDiversidadeDiscDia () const
{
  return this->equilibrarDiversidadeDiscDia_.get ();
}

ItemParametrosPlanejamento::equilibrarDiversidadeDiscDia_type& ItemParametrosPlanejamento::
equilibrarDiversidadeDiscDia ()
{
  return this->equilibrarDiversidadeDiscDia_.get ();
}

void ItemParametrosPlanejamento::
equilibrarDiversidadeDiscDia (const equilibrarDiversidadeDiscDia_type& x)
{
  this->equilibrarDiversidadeDiscDia_.set (x);
}

const ItemParametrosPlanejamento::regrasGenericasDivisaoCredito_type& ItemParametrosPlanejamento::
regrasGenericasDivisaoCredito () const
{
  return this->regrasGenericasDivisaoCredito_.get ();
}

ItemParametrosPlanejamento::regrasGenericasDivisaoCredito_type& ItemParametrosPlanejamento::
regrasGenericasDivisaoCredito ()
{
  return this->regrasGenericasDivisaoCredito_.get ();
}

void ItemParametrosPlanejamento::
regrasGenericasDivisaoCredito (const regrasGenericasDivisaoCredito_type& x)
{
  this->regrasGenericasDivisaoCredito_.set (x);
}

const ItemParametrosPlanejamento::regrasEspecificasDivisaoCredito_type& ItemParametrosPlanejamento::
regrasEspecificasDivisaoCredito () const
{
  return this->regrasEspecificasDivisaoCredito_.get ();
}

ItemParametrosPlanejamento::regrasEspecificasDivisaoCredito_type& ItemParametrosPlanejamento::
regrasEspecificasDivisaoCredito ()
{
  return this->regrasEspecificasDivisaoCredito_.get ();
}

void ItemParametrosPlanejamento::
regrasEspecificasDivisaoCredito (const regrasEspecificasDivisaoCredito_type& x)
{
  this->regrasEspecificasDivisaoCredito_.set (x);
}

const ItemParametrosPlanejamento::maximizarAvaliacaoCursosSel_type& ItemParametrosPlanejamento::
maximizarAvaliacaoCursosSel () const
{
  return this->maximizarAvaliacaoCursosSel_.get ();
}

ItemParametrosPlanejamento::maximizarAvaliacaoCursosSel_type& ItemParametrosPlanejamento::
maximizarAvaliacaoCursosSel ()
{
  return this->maximizarAvaliacaoCursosSel_.get ();
}

void ItemParametrosPlanejamento::
maximizarAvaliacaoCursosSel (const maximizarAvaliacaoCursosSel_type& x)
{
  this->maximizarAvaliacaoCursosSel_.set (x);
}

const ItemParametrosPlanejamento::maximizarAvaliacaoCursos_optional& ItemParametrosPlanejamento::
maximizarAvaliacaoCursos () const
{
  return this->maximizarAvaliacaoCursos_;
}

ItemParametrosPlanejamento::maximizarAvaliacaoCursos_optional& ItemParametrosPlanejamento::
maximizarAvaliacaoCursos ()
{
  return this->maximizarAvaliacaoCursos_;
}

void ItemParametrosPlanejamento::
maximizarAvaliacaoCursos (const maximizarAvaliacaoCursos_type& x)
{
  this->maximizarAvaliacaoCursos_.set (x);
}

void ItemParametrosPlanejamento::
maximizarAvaliacaoCursos (const maximizarAvaliacaoCursos_optional& x)
{
  this->maximizarAvaliacaoCursos_ = x;
}

void ItemParametrosPlanejamento::
maximizarAvaliacaoCursos (::std::auto_ptr< maximizarAvaliacaoCursos_type > x)
{
  this->maximizarAvaliacaoCursos_.set (x);
}

const ItemParametrosPlanejamento::minimizarCustoDocenteCursosSel_type& ItemParametrosPlanejamento::
minimizarCustoDocenteCursosSel () const
{
  return this->minimizarCustoDocenteCursosSel_.get ();
}

ItemParametrosPlanejamento::minimizarCustoDocenteCursosSel_type& ItemParametrosPlanejamento::
minimizarCustoDocenteCursosSel ()
{
  return this->minimizarCustoDocenteCursosSel_.get ();
}

void ItemParametrosPlanejamento::
minimizarCustoDocenteCursosSel (const minimizarCustoDocenteCursosSel_type& x)
{
  this->minimizarCustoDocenteCursosSel_.set (x);
}

const ItemParametrosPlanejamento::minimizarCustoDocenteCursos_optional& ItemParametrosPlanejamento::
minimizarCustoDocenteCursos () const
{
  return this->minimizarCustoDocenteCursos_;
}

ItemParametrosPlanejamento::minimizarCustoDocenteCursos_optional& ItemParametrosPlanejamento::
minimizarCustoDocenteCursos ()
{
  return this->minimizarCustoDocenteCursos_;
}

void ItemParametrosPlanejamento::
minimizarCustoDocenteCursos (const minimizarCustoDocenteCursos_type& x)
{
  this->minimizarCustoDocenteCursos_.set (x);
}

void ItemParametrosPlanejamento::
minimizarCustoDocenteCursos (const minimizarCustoDocenteCursos_optional& x)
{
  this->minimizarCustoDocenteCursos_ = x;
}

void ItemParametrosPlanejamento::
minimizarCustoDocenteCursos (::std::auto_ptr< minimizarCustoDocenteCursos_type > x)
{
  this->minimizarCustoDocenteCursos_.set (x);
}

const ItemParametrosPlanejamento::permiteCompartilhamentoTurmaSel_type& ItemParametrosPlanejamento::
permiteCompartilhamentoTurmaSel () const
{
  return this->permiteCompartilhamentoTurmaSel_.get ();
}

ItemParametrosPlanejamento::permiteCompartilhamentoTurmaSel_type& ItemParametrosPlanejamento::
permiteCompartilhamentoTurmaSel ()
{
  return this->permiteCompartilhamentoTurmaSel_.get ();
}

void ItemParametrosPlanejamento::
permiteCompartilhamentoTurmaSel (const permiteCompartilhamentoTurmaSel_type& x)
{
  this->permiteCompartilhamentoTurmaSel_.set (x);
}

const ItemParametrosPlanejamento::permiteCompartilhamentoTurma_optional& ItemParametrosPlanejamento::
permiteCompartilhamentoTurma () const
{
  return this->permiteCompartilhamentoTurma_;
}

ItemParametrosPlanejamento::permiteCompartilhamentoTurma_optional& ItemParametrosPlanejamento::
permiteCompartilhamentoTurma ()
{
  return this->permiteCompartilhamentoTurma_;
}

void ItemParametrosPlanejamento::
permiteCompartilhamentoTurma (const permiteCompartilhamentoTurma_type& x)
{
  this->permiteCompartilhamentoTurma_.set (x);
}

void ItemParametrosPlanejamento::
permiteCompartilhamentoTurma (const permiteCompartilhamentoTurma_optional& x)
{
  this->permiteCompartilhamentoTurma_ = x;
}

void ItemParametrosPlanejamento::
permiteCompartilhamentoTurma (::std::auto_ptr< permiteCompartilhamentoTurma_type > x)
{
  this->permiteCompartilhamentoTurma_.set (x);
}

const ItemParametrosPlanejamento::percentuaisMinimoMestres_type& ItemParametrosPlanejamento::
percentuaisMinimoMestres () const
{
  return this->percentuaisMinimoMestres_.get ();
}

ItemParametrosPlanejamento::percentuaisMinimoMestres_type& ItemParametrosPlanejamento::
percentuaisMinimoMestres ()
{
  return this->percentuaisMinimoMestres_.get ();
}

void ItemParametrosPlanejamento::
percentuaisMinimoMestres (const percentuaisMinimoMestres_type& x)
{
  this->percentuaisMinimoMestres_.set (x);
}

const ItemParametrosPlanejamento::percentuaisMinimoDoutores_type& ItemParametrosPlanejamento::
percentuaisMinimoDoutores () const
{
  return this->percentuaisMinimoDoutores_.get ();
}

ItemParametrosPlanejamento::percentuaisMinimoDoutores_type& ItemParametrosPlanejamento::
percentuaisMinimoDoutores ()
{
  return this->percentuaisMinimoDoutores_.get ();
}

void ItemParametrosPlanejamento::
percentuaisMinimoDoutores (const percentuaisMinimoDoutores_type& x)
{
  this->percentuaisMinimoDoutores_.set (x);
}

const ItemParametrosPlanejamento::areaTitulacaoProfessorCurso_type& ItemParametrosPlanejamento::
areaTitulacaoProfessorCurso () const
{
  return this->areaTitulacaoProfessorCurso_.get ();
}

ItemParametrosPlanejamento::areaTitulacaoProfessorCurso_type& ItemParametrosPlanejamento::
areaTitulacaoProfessorCurso ()
{
  return this->areaTitulacaoProfessorCurso_.get ();
}

void ItemParametrosPlanejamento::
areaTitulacaoProfessorCurso (const areaTitulacaoProfessorCurso_type& x)
{
  this->areaTitulacaoProfessorCurso_.set (x);
}

const ItemParametrosPlanejamento::maximoDisciplinasDeUmProfessorPorCurso_type& ItemParametrosPlanejamento::
maximoDisciplinasDeUmProfessorPorCurso () const
{
  return this->maximoDisciplinasDeUmProfessorPorCurso_.get ();
}

ItemParametrosPlanejamento::maximoDisciplinasDeUmProfessorPorCurso_type& ItemParametrosPlanejamento::
maximoDisciplinasDeUmProfessorPorCurso ()
{
  return this->maximoDisciplinasDeUmProfessorPorCurso_.get ();
}

void ItemParametrosPlanejamento::
maximoDisciplinasDeUmProfessorPorCurso (const maximoDisciplinasDeUmProfessorPorCurso_type& x)
{
  this->maximoDisciplinasDeUmProfessorPorCurso_.set (x);
}

const ItemParametrosPlanejamento::custoProfDisponibilidade_type& ItemParametrosPlanejamento::
custoProfDisponibilidade () const
{
  return this->custoProfDisponibilidade_.get ();
}

ItemParametrosPlanejamento::custoProfDisponibilidade_type& ItemParametrosPlanejamento::
custoProfDisponibilidade ()
{
  return this->custoProfDisponibilidade_.get ();
}

void ItemParametrosPlanejamento::
custoProfDisponibilidade (const custoProfDisponibilidade_type& x)
{
  this->custoProfDisponibilidade_.set (x);
}


// ItemNivelDificuldadeHorario
// 

const ItemNivelDificuldadeHorario::nivelDificuldadeId_type& ItemNivelDificuldadeHorario::
nivelDificuldadeId () const
{
  return this->nivelDificuldadeId_.get ();
}

ItemNivelDificuldadeHorario::nivelDificuldadeId_type& ItemNivelDificuldadeHorario::
nivelDificuldadeId ()
{
  return this->nivelDificuldadeId_.get ();
}

void ItemNivelDificuldadeHorario::
nivelDificuldadeId (const nivelDificuldadeId_type& x)
{
  this->nivelDificuldadeId_.set (x);
}

const ItemNivelDificuldadeHorario::horariosAula_type& ItemNivelDificuldadeHorario::
horariosAula () const
{
  return this->horariosAula_.get ();
}

ItemNivelDificuldadeHorario::horariosAula_type& ItemNivelDificuldadeHorario::
horariosAula ()
{
  return this->horariosAula_.get ();
}

void ItemNivelDificuldadeHorario::
horariosAula (const horariosAula_type& x)
{
  this->horariosAula_.set (x);
}

void ItemNivelDificuldadeHorario::
horariosAula (::std::auto_ptr< horariosAula_type > x)
{
  this->horariosAula_.set (x);
}


// GrupoCalendario
// 

const GrupoCalendario::Calendario_sequence& GrupoCalendario::
Calendario () const
{
  return this->Calendario_;
}

GrupoCalendario::Calendario_sequence& GrupoCalendario::
Calendario ()
{
  return this->Calendario_;
}

void GrupoCalendario::
Calendario (const Calendario_sequence& s)
{
  this->Calendario_ = s;
}


// GrupoAlunoDemanda
// 

const GrupoAlunoDemanda::AlunoDemanda_sequence& GrupoAlunoDemanda::
AlunoDemanda () const
{
  return this->AlunoDemanda_;
}

GrupoAlunoDemanda::AlunoDemanda_sequence& GrupoAlunoDemanda::
AlunoDemanda ()
{
  return this->AlunoDemanda_;
}

void GrupoAlunoDemanda::
AlunoDemanda (const AlunoDemanda_sequence& s)
{
  this->AlunoDemanda_ = s;
}


// GrupoTurno
// 

const GrupoTurno::Turno_sequence& GrupoTurno::
Turno () const
{
  return this->Turno_;
}

GrupoTurno::Turno_sequence& GrupoTurno::
Turno ()
{
  return this->Turno_;
}

void GrupoTurno::
Turno (const Turno_sequence& s)
{
  this->Turno_ = s;
}


// GrupoHorarioAula
// 

const GrupoHorarioAula::HorarioAula_sequence& GrupoHorarioAula::
HorarioAula () const
{
  return this->HorarioAula_;
}

GrupoHorarioAula::HorarioAula_sequence& GrupoHorarioAula::
HorarioAula ()
{
  return this->HorarioAula_;
}

void GrupoHorarioAula::
HorarioAula (const HorarioAula_sequence& s)
{
  this->HorarioAula_ = s;
}


// GrupoDiaSemana
// 

const GrupoDiaSemana::diaSemana_sequence& GrupoDiaSemana::
diaSemana () const
{
  return this->diaSemana_;
}

GrupoDiaSemana::diaSemana_sequence& GrupoDiaSemana::
diaSemana ()
{
  return this->diaSemana_;
}

void GrupoDiaSemana::
diaSemana (const diaSemana_sequence& s)
{
  this->diaSemana_ = s;
}


// GrupoTipoSala
// 

const GrupoTipoSala::TipoSala_sequence& GrupoTipoSala::
TipoSala () const
{
  return this->TipoSala_;
}

GrupoTipoSala::TipoSala_sequence& GrupoTipoSala::
TipoSala ()
{
  return this->TipoSala_;
}

void GrupoTipoSala::
TipoSala (const TipoSala_sequence& s)
{
  this->TipoSala_ = s;
}


// GrupoTipoContrato
// 

const GrupoTipoContrato::TipoContrato_sequence& GrupoTipoContrato::
TipoContrato () const
{
  return this->TipoContrato_;
}

GrupoTipoContrato::TipoContrato_sequence& GrupoTipoContrato::
TipoContrato ()
{
  return this->TipoContrato_;
}

void GrupoTipoContrato::
TipoContrato (const TipoContrato_sequence& s)
{
  this->TipoContrato_ = s;
}


// GrupoTipoTitulacao
// 

const GrupoTipoTitulacao::TipoTitulacao_sequence& GrupoTipoTitulacao::
TipoTitulacao () const
{
  return this->TipoTitulacao_;
}

GrupoTipoTitulacao::TipoTitulacao_sequence& GrupoTipoTitulacao::
TipoTitulacao ()
{
  return this->TipoTitulacao_;
}

void GrupoTipoTitulacao::
TipoTitulacao (const TipoTitulacao_sequence& s)
{
  this->TipoTitulacao_ = s;
}


// GrupoAreaTitulacao
// 

const GrupoAreaTitulacao::AreaTitulacao_sequence& GrupoAreaTitulacao::
AreaTitulacao () const
{
  return this->AreaTitulacao_;
}

GrupoAreaTitulacao::AreaTitulacao_sequence& GrupoAreaTitulacao::
AreaTitulacao ()
{
  return this->AreaTitulacao_;
}

void GrupoAreaTitulacao::
AreaTitulacao (const AreaTitulacao_sequence& s)
{
  this->AreaTitulacao_ = s;
}


// GrupoTipoDisciplina
// 

const GrupoTipoDisciplina::TipoDisciplina_sequence& GrupoTipoDisciplina::
TipoDisciplina () const
{
  return this->TipoDisciplina_;
}

GrupoTipoDisciplina::TipoDisciplina_sequence& GrupoTipoDisciplina::
TipoDisciplina ()
{
  return this->TipoDisciplina_;
}

void GrupoTipoDisciplina::
TipoDisciplina (const TipoDisciplina_sequence& s)
{
  this->TipoDisciplina_ = s;
}


// GrupoNivelDificuldade
// 

const GrupoNivelDificuldade::NivelDificuldade_sequence& GrupoNivelDificuldade::
NivelDificuldade () const
{
  return this->NivelDificuldade_;
}

GrupoNivelDificuldade::NivelDificuldade_sequence& GrupoNivelDificuldade::
NivelDificuldade ()
{
  return this->NivelDificuldade_;
}

void GrupoNivelDificuldade::
NivelDificuldade (const NivelDificuldade_sequence& s)
{
  this->NivelDificuldade_ = s;
}


// GrupoTipoCurso
// 

const GrupoTipoCurso::TipoCurso_sequence& GrupoTipoCurso::
TipoCurso () const
{
  return this->TipoCurso_;
}

GrupoTipoCurso::TipoCurso_sequence& GrupoTipoCurso::
TipoCurso ()
{
  return this->TipoCurso_;
}

void GrupoTipoCurso::
TipoCurso (const TipoCurso_sequence& s)
{
  this->TipoCurso_ = s;
}


// GrupoDivisaoCreditos
// 

const GrupoDivisaoCreditos::DivisaoCreditos_sequence& GrupoDivisaoCreditos::
DivisaoCreditos () const
{
  return this->DivisaoCreditos_;
}

GrupoDivisaoCreditos::DivisaoCreditos_sequence& GrupoDivisaoCreditos::
DivisaoCreditos ()
{
  return this->DivisaoCreditos_;
}

void GrupoDivisaoCreditos::
DivisaoCreditos (const DivisaoCreditos_sequence& s)
{
  this->DivisaoCreditos_ = s;
}


// GrupoCampus
// 

const GrupoCampus::Campus_sequence& GrupoCampus::
Campus () const
{
  return this->Campus_;
}

GrupoCampus::Campus_sequence& GrupoCampus::
Campus ()
{
  return this->Campus_;
}

void GrupoCampus::
Campus (const Campus_sequence& s)
{
  this->Campus_ = s;
}


// GrupoUnidade
// 

const GrupoUnidade::Unidade_sequence& GrupoUnidade::
Unidade () const
{
  return this->Unidade_;
}

GrupoUnidade::Unidade_sequence& GrupoUnidade::
Unidade ()
{
  return this->Unidade_;
}

void GrupoUnidade::
Unidade (const Unidade_sequence& s)
{
  this->Unidade_ = s;
}


// GrupoHorario
// 

const GrupoHorario::Horario_sequence& GrupoHorario::
Horario () const
{
  return this->Horario_;
}

GrupoHorario::Horario_sequence& GrupoHorario::
Horario ()
{
  return this->Horario_;
}

void GrupoHorario::
Horario (const Horario_sequence& s)
{
  this->Horario_ = s;
}


// GrupoSala
// 

const GrupoSala::Sala_sequence& GrupoSala::
Sala () const
{
  return this->Sala_;
}

GrupoSala::Sala_sequence& GrupoSala::
Sala ()
{
  return this->Sala_;
}

void GrupoSala::
Sala (const Sala_sequence& s)
{
  this->Sala_ = s;
}


// GrupoCreditoDisponivel
// 

const GrupoCreditoDisponivel::CreditoDisponivel_sequence& GrupoCreditoDisponivel::
CreditoDisponivel () const
{
  return this->CreditoDisponivel_;
}

GrupoCreditoDisponivel::CreditoDisponivel_sequence& GrupoCreditoDisponivel::
CreditoDisponivel ()
{
  return this->CreditoDisponivel_;
}

void GrupoCreditoDisponivel::
CreditoDisponivel (const CreditoDisponivel_sequence& s)
{
  this->CreditoDisponivel_ = s;
}


// GrupoProfessor
// 

const GrupoProfessor::Professor_sequence& GrupoProfessor::
Professor () const
{
  return this->Professor_;
}

GrupoProfessor::Professor_sequence& GrupoProfessor::
Professor ()
{
  return this->Professor_;
}

void GrupoProfessor::
Professor (const Professor_sequence& s)
{
  this->Professor_ = s;
}


// GrupoProfessorDisciplina
// 

const GrupoProfessorDisciplina::ProfessorDisciplina_sequence& GrupoProfessorDisciplina::
ProfessorDisciplina () const
{
  return this->ProfessorDisciplina_;
}

GrupoProfessorDisciplina::ProfessorDisciplina_sequence& GrupoProfessorDisciplina::
ProfessorDisciplina ()
{
  return this->ProfessorDisciplina_;
}

void GrupoProfessorDisciplina::
ProfessorDisciplina (const ProfessorDisciplina_sequence& s)
{
  this->ProfessorDisciplina_ = s;
}


// GrupoDeslocamento
// 

const GrupoDeslocamento::Deslocamento_sequence& GrupoDeslocamento::
Deslocamento () const
{
  return this->Deslocamento_;
}

GrupoDeslocamento::Deslocamento_sequence& GrupoDeslocamento::
Deslocamento ()
{
  return this->Deslocamento_;
}

void GrupoDeslocamento::
Deslocamento (const Deslocamento_sequence& s)
{
  this->Deslocamento_ = s;
}


// GrupoDisciplina
// 

const GrupoDisciplina::Disciplina_sequence& GrupoDisciplina::
Disciplina () const
{
  return this->Disciplina_;
}

GrupoDisciplina::Disciplina_sequence& GrupoDisciplina::
Disciplina ()
{
  return this->Disciplina_;
}

void GrupoDisciplina::
Disciplina (const Disciplina_sequence& s)
{
  this->Disciplina_ = s;
}


// GrupoCurso
// 

const GrupoCurso::Curso_sequence& GrupoCurso::
Curso () const
{
  return this->Curso_;
}

GrupoCurso::Curso_sequence& GrupoCurso::
Curso ()
{
  return this->Curso_;
}

void GrupoCurso::
Curso (const Curso_sequence& s)
{
  this->Curso_ = s;
}


// GrupoCurriculo
// 

const GrupoCurriculo::Curriculo_sequence& GrupoCurriculo::
Curriculo () const
{
  return this->Curriculo_;
}

GrupoCurriculo::Curriculo_sequence& GrupoCurriculo::
Curriculo ()
{
  return this->Curriculo_;
}

void GrupoCurriculo::
Curriculo (const Curriculo_sequence& s)
{
  this->Curriculo_ = s;
}


// GrupoDisciplinaPeriodo
// 

const GrupoDisciplinaPeriodo::DisciplinaPeriodo_sequence& GrupoDisciplinaPeriodo::
DisciplinaPeriodo () const
{
  return this->DisciplinaPeriodo_;
}

GrupoDisciplinaPeriodo::DisciplinaPeriodo_sequence& GrupoDisciplinaPeriodo::
DisciplinaPeriodo ()
{
  return this->DisciplinaPeriodo_;
}

void GrupoDisciplinaPeriodo::
DisciplinaPeriodo (const DisciplinaPeriodo_sequence& s)
{
  this->DisciplinaPeriodo_ = s;
}


// GrupoOfertaCurso
// 

const GrupoOfertaCurso::OfertaCurso_sequence& GrupoOfertaCurso::
OfertaCurso () const
{
  return this->OfertaCurso_;
}

GrupoOfertaCurso::OfertaCurso_sequence& GrupoOfertaCurso::
OfertaCurso ()
{
  return this->OfertaCurso_;
}

void GrupoOfertaCurso::
OfertaCurso (const OfertaCurso_sequence& s)
{
  this->OfertaCurso_ = s;
}


// GrupoDemanda
// 

const GrupoDemanda::Demanda_sequence& GrupoDemanda::
Demanda () const
{
  return this->Demanda_;
}

GrupoDemanda::Demanda_sequence& GrupoDemanda::
Demanda ()
{
  return this->Demanda_;
}

void GrupoDemanda::
Demanda (const Demanda_sequence& s)
{
  this->Demanda_ = s;
}


// GrupoFixacao
// 

const GrupoFixacao::Fixacao_sequence& GrupoFixacao::
Fixacao () const
{
  return this->Fixacao_;
}

GrupoFixacao::Fixacao_sequence& GrupoFixacao::
Fixacao ()
{
  return this->Fixacao_;
}

void GrupoFixacao::
Fixacao (const Fixacao_sequence& s)
{
  this->Fixacao_ = s;
}


// GrupoNivelDificuldadeHorario
// 

const GrupoNivelDificuldadeHorario::NivelDificuldadeHorario_sequence& GrupoNivelDificuldadeHorario::
NivelDificuldadeHorario () const
{
  return this->NivelDificuldadeHorario_;
}

GrupoNivelDificuldadeHorario::NivelDificuldadeHorario_sequence& GrupoNivelDificuldadeHorario::
NivelDificuldadeHorario ()
{
  return this->NivelDificuldadeHorario_;
}

void GrupoNivelDificuldadeHorario::
NivelDificuldadeHorario (const NivelDificuldadeHorario_sequence& s)
{
  this->NivelDificuldadeHorario_ = s;
}


// GrupoIdentificador
// 

const GrupoIdentificador::id_sequence& GrupoIdentificador::
id () const
{
  return this->id_;
}

GrupoIdentificador::id_sequence& GrupoIdentificador::
id ()
{
  return this->id_;
}

void GrupoIdentificador::
id (const id_sequence& s)
{
  this->id_ = s;
}


// GrupoGrupo
// 

const GrupoGrupo::GrupoIdentificador_sequence& GrupoGrupo::
GrupoIdentificador () const
{
  return this->GrupoIdentificador_;
}

GrupoGrupo::GrupoIdentificador_sequence& GrupoGrupo::
GrupoIdentificador ()
{
  return this->GrupoIdentificador_;
}

void GrupoGrupo::
GrupoIdentificador (const GrupoIdentificador_sequence& s)
{
  this->GrupoIdentificador_ = s;
}


// ItemAtendimentoCampusSolucao
// 

const ItemAtendimentoCampusSolucao::campusId_type& ItemAtendimentoCampusSolucao::
campusId () const
{
  return this->campusId_.get ();
}

ItemAtendimentoCampusSolucao::campusId_type& ItemAtendimentoCampusSolucao::
campusId ()
{
  return this->campusId_.get ();
}

void ItemAtendimentoCampusSolucao::
campusId (const campusId_type& x)
{
  this->campusId_.set (x);
}

const ItemAtendimentoCampusSolucao::campusCodigo_type& ItemAtendimentoCampusSolucao::
campusCodigo () const
{
  return this->campusCodigo_.get ();
}

ItemAtendimentoCampusSolucao::campusCodigo_type& ItemAtendimentoCampusSolucao::
campusCodigo ()
{
  return this->campusCodigo_.get ();
}

void ItemAtendimentoCampusSolucao::
campusCodigo (const campusCodigo_type& x)
{
  this->campusCodigo_.set (x);
}

void ItemAtendimentoCampusSolucao::
campusCodigo (::std::auto_ptr< campusCodigo_type > x)
{
  this->campusCodigo_.set (x);
}

const ItemAtendimentoCampusSolucao::atendimentosUnidades_type& ItemAtendimentoCampusSolucao::
atendimentosUnidades () const
{
  return this->atendimentosUnidades_.get ();
}

ItemAtendimentoCampusSolucao::atendimentosUnidades_type& ItemAtendimentoCampusSolucao::
atendimentosUnidades ()
{
  return this->atendimentosUnidades_.get ();
}

void ItemAtendimentoCampusSolucao::
atendimentosUnidades (const atendimentosUnidades_type& x)
{
  this->atendimentosUnidades_.set (x);
}

void ItemAtendimentoCampusSolucao::
atendimentosUnidades (::std::auto_ptr< atendimentosUnidades_type > x)
{
  this->atendimentosUnidades_.set (x);
}


// ItemAtendimentoUnidadeSolucao
// 

const ItemAtendimentoUnidadeSolucao::unidadeId_type& ItemAtendimentoUnidadeSolucao::
unidadeId () const
{
  return this->unidadeId_.get ();
}

ItemAtendimentoUnidadeSolucao::unidadeId_type& ItemAtendimentoUnidadeSolucao::
unidadeId ()
{
  return this->unidadeId_.get ();
}

void ItemAtendimentoUnidadeSolucao::
unidadeId (const unidadeId_type& x)
{
  this->unidadeId_.set (x);
}

const ItemAtendimentoUnidadeSolucao::unidadeCodigo_type& ItemAtendimentoUnidadeSolucao::
unidadeCodigo () const
{
  return this->unidadeCodigo_.get ();
}

ItemAtendimentoUnidadeSolucao::unidadeCodigo_type& ItemAtendimentoUnidadeSolucao::
unidadeCodigo ()
{
  return this->unidadeCodigo_.get ();
}

void ItemAtendimentoUnidadeSolucao::
unidadeCodigo (const unidadeCodigo_type& x)
{
  this->unidadeCodigo_.set (x);
}

void ItemAtendimentoUnidadeSolucao::
unidadeCodigo (::std::auto_ptr< unidadeCodigo_type > x)
{
  this->unidadeCodigo_.set (x);
}

const ItemAtendimentoUnidadeSolucao::atendimentosSalas_type& ItemAtendimentoUnidadeSolucao::
atendimentosSalas () const
{
  return this->atendimentosSalas_.get ();
}

ItemAtendimentoUnidadeSolucao::atendimentosSalas_type& ItemAtendimentoUnidadeSolucao::
atendimentosSalas ()
{
  return this->atendimentosSalas_.get ();
}

void ItemAtendimentoUnidadeSolucao::
atendimentosSalas (const atendimentosSalas_type& x)
{
  this->atendimentosSalas_.set (x);
}

void ItemAtendimentoUnidadeSolucao::
atendimentosSalas (::std::auto_ptr< atendimentosSalas_type > x)
{
  this->atendimentosSalas_.set (x);
}


// ItemAtendimentoSalaSolucao
// 

const ItemAtendimentoSalaSolucao::salaId_type& ItemAtendimentoSalaSolucao::
salaId () const
{
  return this->salaId_.get ();
}

ItemAtendimentoSalaSolucao::salaId_type& ItemAtendimentoSalaSolucao::
salaId ()
{
  return this->salaId_.get ();
}

void ItemAtendimentoSalaSolucao::
salaId (const salaId_type& x)
{
  this->salaId_.set (x);
}

const ItemAtendimentoSalaSolucao::salaNome_type& ItemAtendimentoSalaSolucao::
salaNome () const
{
  return this->salaNome_.get ();
}

ItemAtendimentoSalaSolucao::salaNome_type& ItemAtendimentoSalaSolucao::
salaNome ()
{
  return this->salaNome_.get ();
}

void ItemAtendimentoSalaSolucao::
salaNome (const salaNome_type& x)
{
  this->salaNome_.set (x);
}

void ItemAtendimentoSalaSolucao::
salaNome (::std::auto_ptr< salaNome_type > x)
{
  this->salaNome_.set (x);
}

const ItemAtendimentoSalaSolucao::atendimentosDiasSemana_type& ItemAtendimentoSalaSolucao::
atendimentosDiasSemana () const
{
  return this->atendimentosDiasSemana_.get ();
}

ItemAtendimentoSalaSolucao::atendimentosDiasSemana_type& ItemAtendimentoSalaSolucao::
atendimentosDiasSemana ()
{
  return this->atendimentosDiasSemana_.get ();
}

void ItemAtendimentoSalaSolucao::
atendimentosDiasSemana (const atendimentosDiasSemana_type& x)
{
  this->atendimentosDiasSemana_.set (x);
}

void ItemAtendimentoSalaSolucao::
atendimentosDiasSemana (::std::auto_ptr< atendimentosDiasSemana_type > x)
{
  this->atendimentosDiasSemana_.set (x);
}


// ItemAtendimentoDiaSemanaSolucao
// 

const ItemAtendimentoDiaSemanaSolucao::diaSemana_type& ItemAtendimentoDiaSemanaSolucao::
diaSemana () const
{
  return this->diaSemana_.get ();
}

ItemAtendimentoDiaSemanaSolucao::diaSemana_type& ItemAtendimentoDiaSemanaSolucao::
diaSemana ()
{
  return this->diaSemana_.get ();
}

void ItemAtendimentoDiaSemanaSolucao::
diaSemana (const diaSemana_type& x)
{
  this->diaSemana_.set (x);
}

const ItemAtendimentoDiaSemanaSolucao::atendimentosTatico_type& ItemAtendimentoDiaSemanaSolucao::
atendimentosTatico () const
{
  return this->atendimentosTatico_.get ();
}

ItemAtendimentoDiaSemanaSolucao::atendimentosTatico_type& ItemAtendimentoDiaSemanaSolucao::
atendimentosTatico ()
{
  return this->atendimentosTatico_.get ();
}

void ItemAtendimentoDiaSemanaSolucao::
atendimentosTatico (const atendimentosTatico_type& x)
{
  this->atendimentosTatico_.set (x);
}

void ItemAtendimentoDiaSemanaSolucao::
atendimentosTatico (::std::auto_ptr< atendimentosTatico_type > x)
{
  this->atendimentosTatico_.set (x);
}


// ItemAtendimentoOfertaSolucao
// 

const ItemAtendimentoOfertaSolucao::ofertaCursoCampiId_type& ItemAtendimentoOfertaSolucao::
ofertaCursoCampiId () const
{
  return this->ofertaCursoCampiId_.get ();
}

ItemAtendimentoOfertaSolucao::ofertaCursoCampiId_type& ItemAtendimentoOfertaSolucao::
ofertaCursoCampiId ()
{
  return this->ofertaCursoCampiId_.get ();
}

void ItemAtendimentoOfertaSolucao::
ofertaCursoCampiId (const ofertaCursoCampiId_type& x)
{
  this->ofertaCursoCampiId_.set (x);
}

const ItemAtendimentoOfertaSolucao::disciplinaId_type& ItemAtendimentoOfertaSolucao::
disciplinaId () const
{
  return this->disciplinaId_.get ();
}

ItemAtendimentoOfertaSolucao::disciplinaId_type& ItemAtendimentoOfertaSolucao::
disciplinaId ()
{
  return this->disciplinaId_.get ();
}

void ItemAtendimentoOfertaSolucao::
disciplinaId (const disciplinaId_type& x)
{
  this->disciplinaId_.set (x);
}

const ItemAtendimentoOfertaSolucao::disciplinaId_type& ItemAtendimentoOfertaSolucao::
disciplinaSubstitutaId () const
{
  return this->disciplinaSubstitutaId_.get ();
}

ItemAtendimentoOfertaSolucao::disciplinaId_type& ItemAtendimentoOfertaSolucao::
disciplinaSubstitutaId ()
{
  return this->disciplinaSubstitutaId_.get ();
}

void ItemAtendimentoOfertaSolucao::
disciplinaSubstitutaId (const disciplinaId_type& x)
{
  this->disciplinaSubstitutaId_.set (x);
}

const ItemAtendimentoOfertaSolucao::quantidade_type& ItemAtendimentoOfertaSolucao::
quantidade () const
{
  return this->quantidade_.get ();
}

ItemAtendimentoOfertaSolucao::quantidade_type& ItemAtendimentoOfertaSolucao::
quantidade ()
{
  return this->quantidade_.get ();
}

void ItemAtendimentoOfertaSolucao::
quantidade (const quantidade_type& x)
{
  this->quantidade_.set (x);
}

const ItemAtendimentoOfertaSolucao::turma_type& ItemAtendimentoOfertaSolucao::
turma () const
{
  return this->turma_.get ();
}

ItemAtendimentoOfertaSolucao::turma_type& ItemAtendimentoOfertaSolucao::
turma ()
{
  return this->turma_.get ();
}

void ItemAtendimentoOfertaSolucao::
turma (const turma_type& x)
{
  this->turma_.set (x);
}

void ItemAtendimentoOfertaSolucao::
turma (::std::auto_ptr< turma_type > x)
{
  this->turma_.set (x);
}


// ItemAtendimentoTaticoSolucao
// 

const ItemAtendimentoTaticoSolucao::atendimentoOferta_type& ItemAtendimentoTaticoSolucao::
atendimentoOferta () const
{
  return this->atendimentoOferta_.get ();
}

ItemAtendimentoTaticoSolucao::atendimentoOferta_type& ItemAtendimentoTaticoSolucao::
atendimentoOferta ()
{
  return this->atendimentoOferta_.get ();
}

void ItemAtendimentoTaticoSolucao::
atendimentoOferta (const atendimentoOferta_type& x)
{
  this->atendimentoOferta_.set (x);
}

void ItemAtendimentoTaticoSolucao::
atendimentoOferta (::std::auto_ptr< atendimentoOferta_type > x)
{
  this->atendimentoOferta_.set (x);
}

const ItemAtendimentoTaticoSolucao::qtdeCreditosTeoricos_type& ItemAtendimentoTaticoSolucao::
qtdeCreditosTeoricos () const
{
  return this->qtdeCreditosTeoricos_.get ();
}

ItemAtendimentoTaticoSolucao::qtdeCreditosTeoricos_type& ItemAtendimentoTaticoSolucao::
qtdeCreditosTeoricos ()
{
  return this->qtdeCreditosTeoricos_.get ();
}

void ItemAtendimentoTaticoSolucao::
qtdeCreditosTeoricos (const qtdeCreditosTeoricos_type& x)
{
  this->qtdeCreditosTeoricos_.set (x);
}

const ItemAtendimentoTaticoSolucao::qtdeCreditosPraticos_type& ItemAtendimentoTaticoSolucao::
qtdeCreditosPraticos () const
{
  return this->qtdeCreditosPraticos_.get ();
}

ItemAtendimentoTaticoSolucao::qtdeCreditosPraticos_type& ItemAtendimentoTaticoSolucao::
qtdeCreditosPraticos ()
{
  return this->qtdeCreditosPraticos_.get ();
}

void ItemAtendimentoTaticoSolucao::
qtdeCreditosPraticos (const qtdeCreditosPraticos_type& x)
{
  this->qtdeCreditosPraticos_.set (x);
}


// GrupoAtendimentoCampusSolucao
// 

const GrupoAtendimentoCampusSolucao::AtendimentoCampus_sequence& GrupoAtendimentoCampusSolucao::
AtendimentoCampus () const
{
  return this->AtendimentoCampus_;
}

GrupoAtendimentoCampusSolucao::AtendimentoCampus_sequence& GrupoAtendimentoCampusSolucao::
AtendimentoCampus ()
{
  return this->AtendimentoCampus_;
}

void GrupoAtendimentoCampusSolucao::
AtendimentoCampus (const AtendimentoCampus_sequence& s)
{
  this->AtendimentoCampus_ = s;
}


// GrupoAtendimentoUnidadeSolucao
// 

const GrupoAtendimentoUnidadeSolucao::AtendimentoUnidade_sequence& GrupoAtendimentoUnidadeSolucao::
AtendimentoUnidade () const
{
  return this->AtendimentoUnidade_;
}

GrupoAtendimentoUnidadeSolucao::AtendimentoUnidade_sequence& GrupoAtendimentoUnidadeSolucao::
AtendimentoUnidade ()
{
  return this->AtendimentoUnidade_;
}

void GrupoAtendimentoUnidadeSolucao::
AtendimentoUnidade (const AtendimentoUnidade_sequence& s)
{
  this->AtendimentoUnidade_ = s;
}


// GrupoAtendimentoSalaSolucao
// 

const GrupoAtendimentoSalaSolucao::AtendimentoSala_sequence& GrupoAtendimentoSalaSolucao::
AtendimentoSala () const
{
  return this->AtendimentoSala_;
}

GrupoAtendimentoSalaSolucao::AtendimentoSala_sequence& GrupoAtendimentoSalaSolucao::
AtendimentoSala ()
{
  return this->AtendimentoSala_;
}

void GrupoAtendimentoSalaSolucao::
AtendimentoSala (const AtendimentoSala_sequence& s)
{
  this->AtendimentoSala_ = s;
}


// GrupoAtendimentoDiaSemanaSolucao
// 

const GrupoAtendimentoDiaSemanaSolucao::AtendimentoDiaSemana_sequence& GrupoAtendimentoDiaSemanaSolucao::
AtendimentoDiaSemana () const
{
  return this->AtendimentoDiaSemana_;
}

GrupoAtendimentoDiaSemanaSolucao::AtendimentoDiaSemana_sequence& GrupoAtendimentoDiaSemanaSolucao::
AtendimentoDiaSemana ()
{
  return this->AtendimentoDiaSemana_;
}

void GrupoAtendimentoDiaSemanaSolucao::
AtendimentoDiaSemana (const AtendimentoDiaSemana_sequence& s)
{
  this->AtendimentoDiaSemana_ = s;
}


// GrupoAtendimentoTaticoSolucao
// 

const GrupoAtendimentoTaticoSolucao::AtendimentoTatico_sequence& GrupoAtendimentoTaticoSolucao::
AtendimentoTatico () const
{
  return this->AtendimentoTatico_;
}

GrupoAtendimentoTaticoSolucao::AtendimentoTatico_sequence& GrupoAtendimentoTaticoSolucao::
AtendimentoTatico ()
{
  return this->AtendimentoTatico_;
}

void GrupoAtendimentoTaticoSolucao::
AtendimentoTatico (const AtendimentoTatico_sequence& s)
{
  this->AtendimentoTatico_ = s;
}


// TriedaInput
// 

const TriedaInput::calendarios_type& TriedaInput::
calendarios () const
{
  return this->calendarios_.get ();
}

TriedaInput::calendarios_type& TriedaInput::
calendarios ()
{
  return this->calendarios_.get ();
}

void TriedaInput::
calendarios (const calendarios_type& x)
{
  this->calendarios_.set (x);
}

void TriedaInput::
calendarios (::std::auto_ptr< calendarios_type > x)
{
  this->calendarios_.set (x);
}

const TriedaInput::tiposSala_type& TriedaInput::
tiposSala () const
{
  return this->tiposSala_.get ();
}

TriedaInput::tiposSala_type& TriedaInput::
tiposSala ()
{
  return this->tiposSala_.get ();
}

void TriedaInput::
tiposSala (const tiposSala_type& x)
{
  this->tiposSala_.set (x);
}

void TriedaInput::
tiposSala (::std::auto_ptr< tiposSala_type > x)
{
  this->tiposSala_.set (x);
}

const TriedaInput::tiposContrato_type& TriedaInput::
tiposContrato () const
{
  return this->tiposContrato_.get ();
}

TriedaInput::tiposContrato_type& TriedaInput::
tiposContrato ()
{
  return this->tiposContrato_.get ();
}

void TriedaInput::
tiposContrato (const tiposContrato_type& x)
{
  this->tiposContrato_.set (x);
}

void TriedaInput::
tiposContrato (::std::auto_ptr< tiposContrato_type > x)
{
  this->tiposContrato_.set (x);
}

const TriedaInput::tiposTitulacao_type& TriedaInput::
tiposTitulacao () const
{
  return this->tiposTitulacao_.get ();
}

TriedaInput::tiposTitulacao_type& TriedaInput::
tiposTitulacao ()
{
  return this->tiposTitulacao_.get ();
}

void TriedaInput::
tiposTitulacao (const tiposTitulacao_type& x)
{
  this->tiposTitulacao_.set (x);
}

void TriedaInput::
tiposTitulacao (::std::auto_ptr< tiposTitulacao_type > x)
{
  this->tiposTitulacao_.set (x);
}

const TriedaInput::areasTitulacao_type& TriedaInput::
areasTitulacao () const
{
  return this->areasTitulacao_.get ();
}

TriedaInput::areasTitulacao_type& TriedaInput::
areasTitulacao ()
{
  return this->areasTitulacao_.get ();
}

void TriedaInput::
areasTitulacao (const areasTitulacao_type& x)
{
  this->areasTitulacao_.set (x);
}

void TriedaInput::
areasTitulacao (::std::auto_ptr< areasTitulacao_type > x)
{
  this->areasTitulacao_.set (x);
}

const TriedaInput::tiposDisciplina_type& TriedaInput::
tiposDisciplina () const
{
  return this->tiposDisciplina_.get ();
}

TriedaInput::tiposDisciplina_type& TriedaInput::
tiposDisciplina ()
{
  return this->tiposDisciplina_.get ();
}

void TriedaInput::
tiposDisciplina (const tiposDisciplina_type& x)
{
  this->tiposDisciplina_.set (x);
}

void TriedaInput::
tiposDisciplina (::std::auto_ptr< tiposDisciplina_type > x)
{
  this->tiposDisciplina_.set (x);
}

const TriedaInput::niveisDificuldade_type& TriedaInput::
niveisDificuldade () const
{
  return this->niveisDificuldade_.get ();
}

TriedaInput::niveisDificuldade_type& TriedaInput::
niveisDificuldade ()
{
  return this->niveisDificuldade_.get ();
}

void TriedaInput::
niveisDificuldade (const niveisDificuldade_type& x)
{
  this->niveisDificuldade_.set (x);
}

void TriedaInput::
niveisDificuldade (::std::auto_ptr< niveisDificuldade_type > x)
{
  this->niveisDificuldade_.set (x);
}

const TriedaInput::tiposCurso_type& TriedaInput::
tiposCurso () const
{
  return this->tiposCurso_.get ();
}

TriedaInput::tiposCurso_type& TriedaInput::
tiposCurso ()
{
  return this->tiposCurso_.get ();
}

void TriedaInput::
tiposCurso (const tiposCurso_type& x)
{
  this->tiposCurso_.set (x);
}

void TriedaInput::
tiposCurso (::std::auto_ptr< tiposCurso_type > x)
{
  this->tiposCurso_.set (x);
}

const TriedaInput::regrasDivisaoCredito_type& TriedaInput::
regrasDivisaoCredito () const
{
  return this->regrasDivisaoCredito_.get ();
}

TriedaInput::regrasDivisaoCredito_type& TriedaInput::
regrasDivisaoCredito ()
{
  return this->regrasDivisaoCredito_.get ();
}

void TriedaInput::
regrasDivisaoCredito (const regrasDivisaoCredito_type& x)
{
  this->regrasDivisaoCredito_.set (x);
}

void TriedaInput::
regrasDivisaoCredito (::std::auto_ptr< regrasDivisaoCredito_type > x)
{
  this->regrasDivisaoCredito_.set (x);
}

const TriedaInput::campi_type& TriedaInput::
campi () const
{
  return this->campi_.get ();
}

TriedaInput::campi_type& TriedaInput::
campi ()
{
  return this->campi_.get ();
}

void TriedaInput::
campi (const campi_type& x)
{
  this->campi_.set (x);
}

void TriedaInput::
campi (::std::auto_ptr< campi_type > x)
{
  this->campi_.set (x);
}

const TriedaInput::temposDeslocamentosCampi_type& TriedaInput::
temposDeslocamentosCampi () const
{
  return this->temposDeslocamentosCampi_.get ();
}

TriedaInput::temposDeslocamentosCampi_type& TriedaInput::
temposDeslocamentosCampi ()
{
  return this->temposDeslocamentosCampi_.get ();
}

void TriedaInput::
temposDeslocamentosCampi (const temposDeslocamentosCampi_type& x)
{
  this->temposDeslocamentosCampi_.set (x);
}

void TriedaInput::
temposDeslocamentosCampi (::std::auto_ptr< temposDeslocamentosCampi_type > x)
{
  this->temposDeslocamentosCampi_.set (x);
}

const TriedaInput::temposDeslocamentosUnidades_type& TriedaInput::
temposDeslocamentosUnidades () const
{
  return this->temposDeslocamentosUnidades_.get ();
}

TriedaInput::temposDeslocamentosUnidades_type& TriedaInput::
temposDeslocamentosUnidades ()
{
  return this->temposDeslocamentosUnidades_.get ();
}

void TriedaInput::
temposDeslocamentosUnidades (const temposDeslocamentosUnidades_type& x)
{
  this->temposDeslocamentosUnidades_.set (x);
}

void TriedaInput::
temposDeslocamentosUnidades (::std::auto_ptr< temposDeslocamentosUnidades_type > x)
{
  this->temposDeslocamentosUnidades_.set (x);
}

const TriedaInput::disciplinas_type& TriedaInput::
disciplinas () const
{
  return this->disciplinas_.get ();
}

TriedaInput::disciplinas_type& TriedaInput::
disciplinas ()
{
  return this->disciplinas_.get ();
}

void TriedaInput::
disciplinas (const disciplinas_type& x)
{
  this->disciplinas_.set (x);
}

void TriedaInput::
disciplinas (::std::auto_ptr< disciplinas_type > x)
{
  this->disciplinas_.set (x);
}

const TriedaInput::cursos_type& TriedaInput::
cursos () const
{
  return this->cursos_.get ();
}

TriedaInput::cursos_type& TriedaInput::
cursos ()
{
  return this->cursos_.get ();
}

void TriedaInput::
cursos (const cursos_type& x)
{
  this->cursos_.set (x);
}

void TriedaInput::
cursos (::std::auto_ptr< cursos_type > x)
{
  this->cursos_.set (x);
}

const TriedaInput::ofertaCursosCampi_type& TriedaInput::
ofertaCursosCampi () const
{
  return this->ofertaCursosCampi_.get ();
}

TriedaInput::ofertaCursosCampi_type& TriedaInput::
ofertaCursosCampi ()
{
  return this->ofertaCursosCampi_.get ();
}

void TriedaInput::
ofertaCursosCampi (const ofertaCursosCampi_type& x)
{
  this->ofertaCursosCampi_.set (x);
}

void TriedaInput::
ofertaCursosCampi (::std::auto_ptr< ofertaCursosCampi_type > x)
{
  this->ofertaCursosCampi_.set (x);
}

const TriedaInput::demandas_type& TriedaInput::
demandas () const
{
  return this->demandas_.get ();
}

TriedaInput::demandas_type& TriedaInput::
demandas ()
{
  return this->demandas_.get ();
}

void TriedaInput::
demandas (const demandas_type& x)
{
  this->demandas_.set (x);
}

void TriedaInput::
demandas (::std::auto_ptr< demandas_type > x)
{
  this->demandas_.set (x);
}

const TriedaInput::alunosDemanda_type& TriedaInput::
alunosDemanda () const
{
  return this->alunosDemanda_.get ();
}

TriedaInput::alunosDemanda_type& TriedaInput::
alunosDemanda ()
{
  return this->alunosDemanda_.get ();
}

void TriedaInput::
alunosDemanda (const alunosDemanda_type& x)
{
  this->alunosDemanda_.set (x);
}

void TriedaInput::
alunosDemanda (::std::auto_ptr< alunosDemanda_type > x)
{
  this->alunosDemanda_.set (x);
}

const TriedaInput::parametrosPlanejamento_type& TriedaInput::
parametrosPlanejamento () const
{
  return this->parametrosPlanejamento_.get ();
}

TriedaInput::parametrosPlanejamento_type& TriedaInput::
parametrosPlanejamento ()
{
  return this->parametrosPlanejamento_.get ();
}

void TriedaInput::
parametrosPlanejamento (const parametrosPlanejamento_type& x)
{
  this->parametrosPlanejamento_.set (x);
}

void TriedaInput::
parametrosPlanejamento (::std::auto_ptr< parametrosPlanejamento_type > x)
{
  this->parametrosPlanejamento_.set (x);
}

const TriedaInput::fixacoes_type& TriedaInput::
fixacoes () const
{
  return this->fixacoes_.get ();
}

TriedaInput::fixacoes_type& TriedaInput::
fixacoes ()
{
  return this->fixacoes_.get ();
}

void TriedaInput::
fixacoes (const fixacoes_type& x)
{
  this->fixacoes_.set (x);
}

void TriedaInput::
fixacoes (::std::auto_ptr< fixacoes_type > x)
{
  this->fixacoes_.set (x);
}

const TriedaInput::atendimentosTatico_optional& TriedaInput::
atendimentosTatico () const
{
  return this->atendimentosTatico_;
}

TriedaInput::atendimentosTatico_optional& TriedaInput::
atendimentosTatico ()
{
  return this->atendimentosTatico_;
}

void TriedaInput::
atendimentosTatico (const atendimentosTatico_type& x)
{
  this->atendimentosTatico_.set (x);
}

void TriedaInput::
atendimentosTatico (const atendimentosTatico_optional& x)
{
  this->atendimentosTatico_ = x;
}

void TriedaInput::
atendimentosTatico (::std::auto_ptr< atendimentosTatico_type > x)
{
  this->atendimentosTatico_.set (x);
}


// cargaHorariaSemanalAluno
// 

const cargaHorariaSemanalAluno::equilibrar_optional& cargaHorariaSemanalAluno::
equilibrar () const
{
  return this->equilibrar_;
}

cargaHorariaSemanalAluno::equilibrar_optional& cargaHorariaSemanalAluno::
equilibrar ()
{
  return this->equilibrar_;
}

void cargaHorariaSemanalAluno::
equilibrar (const equilibrar_type& x)
{
  this->equilibrar_.set (x);
}

void cargaHorariaSemanalAluno::
equilibrar (const equilibrar_optional& x)
{
  this->equilibrar_ = x;
}

void cargaHorariaSemanalAluno::
equilibrar (::std::auto_ptr< equilibrar_type > x)
{
  this->equilibrar_.set (x);
}

const cargaHorariaSemanalAluno::minimizarDias_optional& cargaHorariaSemanalAluno::
minimizarDias () const
{
  return this->minimizarDias_;
}

cargaHorariaSemanalAluno::minimizarDias_optional& cargaHorariaSemanalAluno::
minimizarDias ()
{
  return this->minimizarDias_;
}

void cargaHorariaSemanalAluno::
minimizarDias (const minimizarDias_type& x)
{
  this->minimizarDias_.set (x);
}

void cargaHorariaSemanalAluno::
minimizarDias (const minimizarDias_optional& x)
{
  this->minimizarDias_ = x;
}

void cargaHorariaSemanalAluno::
minimizarDias (::std::auto_ptr< minimizarDias_type > x)
{
  this->minimizarDias_.set (x);
}

const cargaHorariaSemanalAluno::indiferente_optional& cargaHorariaSemanalAluno::
indiferente () const
{
  return this->indiferente_;
}

cargaHorariaSemanalAluno::indiferente_optional& cargaHorariaSemanalAluno::
indiferente ()
{
  return this->indiferente_;
}

void cargaHorariaSemanalAluno::
indiferente (const indiferente_type& x)
{
  this->indiferente_.set (x);
}

void cargaHorariaSemanalAluno::
indiferente (const indiferente_optional& x)
{
  this->indiferente_ = x;
}

void cargaHorariaSemanalAluno::
indiferente (::std::auto_ptr< indiferente_type > x)
{
  this->indiferente_.set (x);
}


// cargaHorariaSemanalProfessor
// 

const cargaHorariaSemanalProfessor::equilibrar_optional& cargaHorariaSemanalProfessor::
equilibrar () const
{
  return this->equilibrar_;
}

cargaHorariaSemanalProfessor::equilibrar_optional& cargaHorariaSemanalProfessor::
equilibrar ()
{
  return this->equilibrar_;
}

void cargaHorariaSemanalProfessor::
equilibrar (const equilibrar_type& x)
{
  this->equilibrar_.set (x);
}

void cargaHorariaSemanalProfessor::
equilibrar (const equilibrar_optional& x)
{
  this->equilibrar_ = x;
}

void cargaHorariaSemanalProfessor::
equilibrar (::std::auto_ptr< equilibrar_type > x)
{
  this->equilibrar_.set (x);
}

const cargaHorariaSemanalProfessor::minimizarDias_optional& cargaHorariaSemanalProfessor::
minimizarDias () const
{
  return this->minimizarDias_;
}

cargaHorariaSemanalProfessor::minimizarDias_optional& cargaHorariaSemanalProfessor::
minimizarDias ()
{
  return this->minimizarDias_;
}

void cargaHorariaSemanalProfessor::
minimizarDias (const minimizarDias_type& x)
{
  this->minimizarDias_.set (x);
}

void cargaHorariaSemanalProfessor::
minimizarDias (const minimizarDias_optional& x)
{
  this->minimizarDias_ = x;
}

void cargaHorariaSemanalProfessor::
minimizarDias (::std::auto_ptr< minimizarDias_type > x)
{
  this->minimizarDias_.set (x);
}

const cargaHorariaSemanalProfessor::indiferente_optional& cargaHorariaSemanalProfessor::
indiferente () const
{
  return this->indiferente_;
}

cargaHorariaSemanalProfessor::indiferente_optional& cargaHorariaSemanalProfessor::
indiferente ()
{
  return this->indiferente_;
}

void cargaHorariaSemanalProfessor::
indiferente (const indiferente_type& x)
{
  this->indiferente_.set (x);
}

void cargaHorariaSemanalProfessor::
indiferente (const indiferente_optional& x)
{
  this->indiferente_ = x;
}

void cargaHorariaSemanalProfessor::
indiferente (::std::auto_ptr< indiferente_type > x)
{
  this->indiferente_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// ItemCalendario
//

ItemCalendario::
ItemCalendario (const id_type& id,
                const codigo_type& codigo,
                const tempoAula_type& tempoAula,
                const turnos_type& turnos)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  tempoAula_ (tempoAula, ::xml_schema::flags (), this),
  turnos_ (turnos, ::xml_schema::flags (), this)
{
}

ItemCalendario::
ItemCalendario (const id_type& id,
                const codigo_type& codigo,
                const tempoAula_type& tempoAula,
                ::std::auto_ptr< turnos_type >& turnos)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  tempoAula_ (tempoAula, ::xml_schema::flags (), this),
  turnos_ (turnos, ::xml_schema::flags (), this)
{
}

ItemCalendario::
ItemCalendario (const ItemCalendario& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  tempoAula_ (x.tempoAula_, f, this),
  turnos_ (x.turnos_, f, this)
{
}

ItemCalendario::
ItemCalendario (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  tempoAula_ (f, this),
  turnos_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemCalendario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // tempoAula
    //
    if (n.name () == "tempoAula" && n.namespace_ ().empty ())
    {
      if (!tempoAula_.present ())
      {
        this->tempoAula_.set (tempoAula_traits::create (i, f, this));
        continue;
      }
    }

    // turnos
    //
    if (n.name () == "turnos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< turnos_type > r (
        turnos_traits::create (i, f, this));

      if (!turnos_.present ())
      {
        this->turnos_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!tempoAula_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tempoAula",
      "");
  }

  if (!turnos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turnos",
      "");
  }
}

ItemCalendario* ItemCalendario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemCalendario (*this, f, c);
}

ItemCalendario::
~ItemCalendario ()
{
}

// ItemAlunoDemanda
//

ItemAlunoDemanda::
ItemAlunoDemanda (const id_type& id,
                  const alunoId_type& alunoId,
                  const nomeAluno_type& nomeAluno,
                  const demandaId_type& demandaId)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  alunoId_ (alunoId, ::xml_schema::flags (), this),
  nomeAluno_ (nomeAluno, ::xml_schema::flags (), this),
  demandaId_ (demandaId, ::xml_schema::flags (), this)
{
}

ItemAlunoDemanda::
ItemAlunoDemanda (const ItemAlunoDemanda& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  alunoId_ (x.alunoId_, f, this),
  nomeAluno_ (x.nomeAluno_, f, this),
  demandaId_ (x.demandaId_, f, this)
{
}

ItemAlunoDemanda::
ItemAlunoDemanda (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  alunoId_ (f, this),
  nomeAluno_ (f, this),
  demandaId_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAlunoDemanda::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // alunoId
    //
    if (n.name () == "alunoId" && n.namespace_ ().empty ())
    {
      if (!alunoId_.present ())
      {
        this->alunoId_.set (alunoId_traits::create (i, f, this));
        continue;
      }
    }

    // nomeAluno
    //
    if (n.name () == "nomeAluno" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nomeAluno_type > r (
        nomeAluno_traits::create (i, f, this));

      if (!nomeAluno_.present ())
      {
        this->nomeAluno_.set (r);
        continue;
      }
    }

    // demandaId
    //
    if (n.name () == "demandaId" && n.namespace_ ().empty ())
    {
      if (!demandaId_.present ())
      {
        this->demandaId_.set (demandaId_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!alunoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "alunoId",
      "");
  }

  if (!nomeAluno_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nomeAluno",
      "");
  }

  if (!demandaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "demandaId",
      "");
  }
}

ItemAlunoDemanda* ItemAlunoDemanda::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAlunoDemanda (*this, f, c);
}

ItemAlunoDemanda::
~ItemAlunoDemanda ()
{
}

// ItemTurno
//

ItemTurno::
ItemTurno (const id_type& id,
           const nome_type& nome,
           const HorariosAula_type& HorariosAula)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  HorariosAula_ (HorariosAula, ::xml_schema::flags (), this)
{
}

ItemTurno::
ItemTurno (const id_type& id,
           const nome_type& nome,
           ::std::auto_ptr< HorariosAula_type >& HorariosAula)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  HorariosAula_ (HorariosAula, ::xml_schema::flags (), this)
{
}

ItemTurno::
ItemTurno (const ItemTurno& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this),
  HorariosAula_ (x.HorariosAula_, f, this)
{
}

ItemTurno::
ItemTurno (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this),
  HorariosAula_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTurno::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // HorariosAula
    //
    if (n.name () == "HorariosAula" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HorariosAula_type > r (
        HorariosAula_traits::create (i, f, this));

      if (!HorariosAula_.present ())
      {
        this->HorariosAula_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!HorariosAula_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "HorariosAula",
      "");
  }
}

ItemTurno* ItemTurno::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTurno (*this, f, c);
}

ItemTurno::
~ItemTurno ()
{
}

// ItemHorarioAula
//

ItemHorarioAula::
ItemHorarioAula (const id_type& id,
                 const inicio_type& inicio,
                 const diasSemana_type& diasSemana)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  inicio_ (inicio, ::xml_schema::flags (), this),
  diasSemana_ (diasSemana, ::xml_schema::flags (), this)
{
}

ItemHorarioAula::
ItemHorarioAula (const id_type& id,
                 const inicio_type& inicio,
                 ::std::auto_ptr< diasSemana_type >& diasSemana)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  inicio_ (inicio, ::xml_schema::flags (), this),
  diasSemana_ (diasSemana, ::xml_schema::flags (), this)
{
}

ItemHorarioAula::
ItemHorarioAula (const ItemHorarioAula& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  inicio_ (x.inicio_, f, this),
  diasSemana_ (x.diasSemana_, f, this)
{
}

ItemHorarioAula::
ItemHorarioAula (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  inicio_ (f, this),
  diasSemana_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemHorarioAula::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // inicio
    //
    if (n.name () == "inicio" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inicio_type > r (
        inicio_traits::create (i, f, this));

      if (!inicio_.present ())
      {
        this->inicio_.set (r);
        continue;
      }
    }

    // diasSemana
    //
    if (n.name () == "diasSemana" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< diasSemana_type > r (
        diasSemana_traits::create (i, f, this));

      if (!diasSemana_.present ())
      {
        this->diasSemana_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!inicio_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inicio",
      "");
  }

  if (!diasSemana_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "diasSemana",
      "");
  }
}

ItemHorarioAula* ItemHorarioAula::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemHorarioAula (*this, f, c);
}

ItemHorarioAula::
~ItemHorarioAula ()
{
}

// ItemTipoSala
//

ItemTipoSala::
ItemTipoSala (const id_type& id,
              const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoSala::
ItemTipoSala (const ItemTipoSala& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoSala::
ItemTipoSala (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoSala::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoSala* ItemTipoSala::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoSala (*this, f, c);
}

ItemTipoSala::
~ItemTipoSala ()
{
}

// ItemTipoContrato
//

ItemTipoContrato::
ItemTipoContrato (const id_type& id,
                  const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoContrato::
ItemTipoContrato (const ItemTipoContrato& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoContrato::
ItemTipoContrato (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoContrato::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoContrato* ItemTipoContrato::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoContrato (*this, f, c);
}

ItemTipoContrato::
~ItemTipoContrato ()
{
}

// ItemTipoTitulacao
//

ItemTipoTitulacao::
ItemTipoTitulacao (const id_type& id,
                   const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoTitulacao::
ItemTipoTitulacao (const ItemTipoTitulacao& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoTitulacao::
ItemTipoTitulacao (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoTitulacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoTitulacao* ItemTipoTitulacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoTitulacao (*this, f, c);
}

ItemTipoTitulacao::
~ItemTipoTitulacao ()
{
}

// ItemAreaTitulacao
//

ItemAreaTitulacao::
ItemAreaTitulacao (const id_type& id,
                   const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemAreaTitulacao::
ItemAreaTitulacao (const ItemAreaTitulacao& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemAreaTitulacao::
ItemAreaTitulacao (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAreaTitulacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemAreaTitulacao* ItemAreaTitulacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAreaTitulacao (*this, f, c);
}

ItemAreaTitulacao::
~ItemAreaTitulacao ()
{
}

// ItemTipoDisciplina
//

ItemTipoDisciplina::
ItemTipoDisciplina (const id_type& id,
                    const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoDisciplina::
ItemTipoDisciplina (const ItemTipoDisciplina& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoDisciplina::
ItemTipoDisciplina (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoDisciplina* ItemTipoDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoDisciplina (*this, f, c);
}

ItemTipoDisciplina::
~ItemTipoDisciplina ()
{
}

// ItemNivelDificuldade
//

ItemNivelDificuldade::
ItemNivelDificuldade (const id_type& id,
                      const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemNivelDificuldade::
ItemNivelDificuldade (const ItemNivelDificuldade& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemNivelDificuldade::
ItemNivelDificuldade (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemNivelDificuldade::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemNivelDificuldade* ItemNivelDificuldade::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemNivelDificuldade (*this, f, c);
}

ItemNivelDificuldade::
~ItemNivelDificuldade ()
{
}

// ItemTipoCurso
//

ItemTipoCurso::
ItemTipoCurso (const id_type& id,
               const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoCurso::
ItemTipoCurso (const ItemTipoCurso& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoCurso::
ItemTipoCurso (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoCurso* ItemTipoCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoCurso (*this, f, c);
}

ItemTipoCurso::
~ItemTipoCurso ()
{
}

// ItemDivisaoCreditos
//

ItemDivisaoCreditos::
ItemDivisaoCreditos (const id_type& id,
                     const creditos_type& creditos,
                     const dia1_type& dia1,
                     const dia2_type& dia2,
                     const dia3_type& dia3,
                     const dia4_type& dia4,
                     const dia5_type& dia5,
                     const dia6_type& dia6,
                     const dia7_type& dia7)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  creditos_ (creditos, ::xml_schema::flags (), this),
  dia1_ (dia1, ::xml_schema::flags (), this),
  dia2_ (dia2, ::xml_schema::flags (), this),
  dia3_ (dia3, ::xml_schema::flags (), this),
  dia4_ (dia4, ::xml_schema::flags (), this),
  dia5_ (dia5, ::xml_schema::flags (), this),
  dia6_ (dia6, ::xml_schema::flags (), this),
  dia7_ (dia7, ::xml_schema::flags (), this)
{
}

ItemDivisaoCreditos::
ItemDivisaoCreditos (const ItemDivisaoCreditos& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  creditos_ (x.creditos_, f, this),
  dia1_ (x.dia1_, f, this),
  dia2_ (x.dia2_, f, this),
  dia3_ (x.dia3_, f, this),
  dia4_ (x.dia4_, f, this),
  dia5_ (x.dia5_, f, this),
  dia6_ (x.dia6_, f, this),
  dia7_ (x.dia7_, f, this)
{
}

ItemDivisaoCreditos::
ItemDivisaoCreditos (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  creditos_ (f, this),
  dia1_ (f, this),
  dia2_ (f, this),
  dia3_ (f, this),
  dia4_ (f, this),
  dia5_ (f, this),
  dia6_ (f, this),
  dia7_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDivisaoCreditos::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // creditos
    //
    if (n.name () == "creditos" && n.namespace_ ().empty ())
    {
      if (!creditos_.present ())
      {
        this->creditos_.set (creditos_traits::create (i, f, this));
        continue;
      }
    }

    // dia1
    //
    if (n.name () == "dia1" && n.namespace_ ().empty ())
    {
      if (!dia1_.present ())
      {
        this->dia1_.set (dia1_traits::create (i, f, this));
        continue;
      }
    }

    // dia2
    //
    if (n.name () == "dia2" && n.namespace_ ().empty ())
    {
      if (!dia2_.present ())
      {
        this->dia2_.set (dia2_traits::create (i, f, this));
        continue;
      }
    }

    // dia3
    //
    if (n.name () == "dia3" && n.namespace_ ().empty ())
    {
      if (!dia3_.present ())
      {
        this->dia3_.set (dia3_traits::create (i, f, this));
        continue;
      }
    }

    // dia4
    //
    if (n.name () == "dia4" && n.namespace_ ().empty ())
    {
      if (!dia4_.present ())
      {
        this->dia4_.set (dia4_traits::create (i, f, this));
        continue;
      }
    }

    // dia5
    //
    if (n.name () == "dia5" && n.namespace_ ().empty ())
    {
      if (!dia5_.present ())
      {
        this->dia5_.set (dia5_traits::create (i, f, this));
        continue;
      }
    }

    // dia6
    //
    if (n.name () == "dia6" && n.namespace_ ().empty ())
    {
      if (!dia6_.present ())
      {
        this->dia6_.set (dia6_traits::create (i, f, this));
        continue;
      }
    }

    // dia7
    //
    if (n.name () == "dia7" && n.namespace_ ().empty ())
    {
      if (!dia7_.present ())
      {
        this->dia7_.set (dia7_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!creditos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "creditos",
      "");
  }

  if (!dia1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia1",
      "");
  }

  if (!dia2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia2",
      "");
  }

  if (!dia3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia3",
      "");
  }

  if (!dia4_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia4",
      "");
  }

  if (!dia5_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia5",
      "");
  }

  if (!dia6_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia6",
      "");
  }

  if (!dia7_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia7",
      "");
  }
}

ItemDivisaoCreditos* ItemDivisaoCreditos::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDivisaoCreditos (*this, f, c);
}

ItemDivisaoCreditos::
~ItemDivisaoCreditos ()
{
}

// ItemCampus
//

ItemCampus::
ItemCampus (const id_type& id,
            const codigo_type& codigo,
            const nome_type& nome,
            const unidades_type& unidades,
            const professores_type& professores,
            const horariosDisponiveis_type& horariosDisponiveis,
            const custo_type& custo)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  unidades_ (unidades, ::xml_schema::flags (), this),
  professores_ (professores, ::xml_schema::flags (), this),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  custo_ (custo, ::xml_schema::flags (), this)
{
}

ItemCampus::
ItemCampus (const id_type& id,
            const codigo_type& codigo,
            const nome_type& nome,
            ::std::auto_ptr< unidades_type >& unidades,
            ::std::auto_ptr< professores_type >& professores,
            ::std::auto_ptr< horariosDisponiveis_type >& horariosDisponiveis,
            const custo_type& custo)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  unidades_ (unidades, ::xml_schema::flags (), this),
  professores_ (professores, ::xml_schema::flags (), this),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  custo_ (custo, ::xml_schema::flags (), this)
{
}

ItemCampus::
ItemCampus (const ItemCampus& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  nome_ (x.nome_, f, this),
  unidades_ (x.unidades_, f, this),
  professores_ (x.professores_, f, this),
  horariosDisponiveis_ (x.horariosDisponiveis_, f, this),
  custo_ (x.custo_, f, this)
{
}

ItemCampus::
ItemCampus (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  nome_ (f, this),
  unidades_ (f, this),
  professores_ (f, this),
  horariosDisponiveis_ (f, this),
  custo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemCampus::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // unidades
    //
    if (n.name () == "unidades" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< unidades_type > r (
        unidades_traits::create (i, f, this));

      if (!unidades_.present ())
      {
        this->unidades_.set (r);
        continue;
      }
    }

    // professores
    //
    if (n.name () == "professores" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< professores_type > r (
        professores_traits::create (i, f, this));

      if (!professores_.present ())
      {
        this->professores_.set (r);
        continue;
      }
    }

    // horariosDisponiveis
    //
    if (n.name () == "horariosDisponiveis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horariosDisponiveis_type > r (
        horariosDisponiveis_traits::create (i, f, this));

      if (!horariosDisponiveis_.present ())
      {
        this->horariosDisponiveis_.set (r);
        continue;
      }
    }

    // custo
    //
    if (n.name () == "custo" && n.namespace_ ().empty ())
    {
      if (!custo_.present ())
      {
        this->custo_.set (custo_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!unidades_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "unidades",
      "");
  }

  if (!professores_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "professores",
      "");
  }

  if (!horariosDisponiveis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horariosDisponiveis",
      "");
  }

  if (!custo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "custo",
      "");
  }
}

ItemCampus* ItemCampus::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemCampus (*this, f, c);
}

ItemCampus::
~ItemCampus ()
{
}

// ItemUnidade
//

ItemUnidade::
ItemUnidade (const id_type& id,
             const codigo_type& codigo,
             const nome_type& nome,
             const horariosDisponiveis_type& horariosDisponiveis,
             const salas_type& salas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  salas_ (salas, ::xml_schema::flags (), this)
{
}

ItemUnidade::
ItemUnidade (const id_type& id,
             const codigo_type& codigo,
             const nome_type& nome,
             ::std::auto_ptr< horariosDisponiveis_type >& horariosDisponiveis,
             ::std::auto_ptr< salas_type >& salas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  salas_ (salas, ::xml_schema::flags (), this)
{
}

ItemUnidade::
ItemUnidade (const ItemUnidade& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  nome_ (x.nome_, f, this),
  horariosDisponiveis_ (x.horariosDisponiveis_, f, this),
  salas_ (x.salas_, f, this)
{
}

ItemUnidade::
ItemUnidade (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  nome_ (f, this),
  horariosDisponiveis_ (f, this),
  salas_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemUnidade::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // horariosDisponiveis
    //
    if (n.name () == "horariosDisponiveis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horariosDisponiveis_type > r (
        horariosDisponiveis_traits::create (i, f, this));

      if (!horariosDisponiveis_.present ())
      {
        this->horariosDisponiveis_.set (r);
        continue;
      }
    }

    // salas
    //
    if (n.name () == "salas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< salas_type > r (
        salas_traits::create (i, f, this));

      if (!salas_.present ())
      {
        this->salas_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!horariosDisponiveis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horariosDisponiveis",
      "");
  }

  if (!salas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "salas",
      "");
  }
}

ItemUnidade* ItemUnidade::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemUnidade (*this, f, c);
}

ItemUnidade::
~ItemUnidade ()
{
}

// ItemHorario
//

ItemHorario::
ItemHorario (const turnoId_type& turnoId,
             const horarioAulaId_type& horarioAulaId,
             const diasSemana_type& diasSemana)
: ::xml_schema::type (),
  turnoId_ (turnoId, ::xml_schema::flags (), this),
  horarioAulaId_ (horarioAulaId, ::xml_schema::flags (), this),
  diasSemana_ (diasSemana, ::xml_schema::flags (), this)
{
}

ItemHorario::
ItemHorario (const turnoId_type& turnoId,
             const horarioAulaId_type& horarioAulaId,
             ::std::auto_ptr< diasSemana_type >& diasSemana)
: ::xml_schema::type (),
  turnoId_ (turnoId, ::xml_schema::flags (), this),
  horarioAulaId_ (horarioAulaId, ::xml_schema::flags (), this),
  diasSemana_ (diasSemana, ::xml_schema::flags (), this)
{
}

ItemHorario::
ItemHorario (const ItemHorario& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  turnoId_ (x.turnoId_, f, this),
  horarioAulaId_ (x.horarioAulaId_, f, this),
  diasSemana_ (x.diasSemana_, f, this)
{
}

ItemHorario::
ItemHorario (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  turnoId_ (f, this),
  horarioAulaId_ (f, this),
  diasSemana_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemHorario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // turnoId
    //
    if (n.name () == "turnoId" && n.namespace_ ().empty ())
    {
      if (!turnoId_.present ())
      {
        this->turnoId_.set (turnoId_traits::create (i, f, this));
        continue;
      }
    }

    // horarioAulaId
    //
    if (n.name () == "horarioAulaId" && n.namespace_ ().empty ())
    {
      if (!horarioAulaId_.present ())
      {
        this->horarioAulaId_.set (horarioAulaId_traits::create (i, f, this));
        continue;
      }
    }

    // diasSemana
    //
    if (n.name () == "diasSemana" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< diasSemana_type > r (
        diasSemana_traits::create (i, f, this));

      if (!diasSemana_.present ())
      {
        this->diasSemana_.set (r);
        continue;
      }
    }

    break;
  }

  if (!turnoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turnoId",
      "");
  }

  if (!horarioAulaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horarioAulaId",
      "");
  }

  if (!diasSemana_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "diasSemana",
      "");
  }
}

ItemHorario* ItemHorario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemHorario (*this, f, c);
}

ItemHorario::
~ItemHorario ()
{
}

// ItemSala
//

ItemSala::
ItemSala (const id_type& id,
          const codigo_type& codigo,
          const andar_type& andar,
          const numero_type& numero,
          const tipoSalaId_type& tipoSalaId,
          const capacidade_type& capacidade,
          const disciplinasAssociadas_type& disciplinasAssociadas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  andar_ (andar, ::xml_schema::flags (), this),
  numero_ (numero, ::xml_schema::flags (), this),
  tipoSalaId_ (tipoSalaId, ::xml_schema::flags (), this),
  capacidade_ (capacidade, ::xml_schema::flags (), this),
  horariosDisponiveis_ (::xml_schema::flags (), this),
  creditosDisponiveis_ (::xml_schema::flags (), this),
  disciplinasAssociadas_ (disciplinasAssociadas, ::xml_schema::flags (), this)
{
}

ItemSala::
ItemSala (const id_type& id,
          const codigo_type& codigo,
          const andar_type& andar,
          const numero_type& numero,
          const tipoSalaId_type& tipoSalaId,
          const capacidade_type& capacidade,
          ::std::auto_ptr< disciplinasAssociadas_type >& disciplinasAssociadas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  andar_ (andar, ::xml_schema::flags (), this),
  numero_ (numero, ::xml_schema::flags (), this),
  tipoSalaId_ (tipoSalaId, ::xml_schema::flags (), this),
  capacidade_ (capacidade, ::xml_schema::flags (), this),
  horariosDisponiveis_ (::xml_schema::flags (), this),
  creditosDisponiveis_ (::xml_schema::flags (), this),
  disciplinasAssociadas_ (disciplinasAssociadas, ::xml_schema::flags (), this)
{
}

ItemSala::
ItemSala (const ItemSala& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  andar_ (x.andar_, f, this),
  numero_ (x.numero_, f, this),
  tipoSalaId_ (x.tipoSalaId_, f, this),
  capacidade_ (x.capacidade_, f, this),
  horariosDisponiveis_ (x.horariosDisponiveis_, f, this),
  creditosDisponiveis_ (x.creditosDisponiveis_, f, this),
  disciplinasAssociadas_ (x.disciplinasAssociadas_, f, this)
{
}

ItemSala::
ItemSala (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  andar_ (f, this),
  numero_ (f, this),
  tipoSalaId_ (f, this),
  capacidade_ (f, this),
  horariosDisponiveis_ (f, this),
  creditosDisponiveis_ (f, this),
  disciplinasAssociadas_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemSala::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // andar
    //
    if (n.name () == "andar" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< andar_type > r (
        andar_traits::create (i, f, this));

      if (!andar_.present ())
      {
        this->andar_.set (r);
        continue;
      }
    }

    // numero
    //
    if (n.name () == "numero" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< numero_type > r (
        numero_traits::create (i, f, this));

      if (!numero_.present ())
      {
        this->numero_.set (r);
        continue;
      }
    }

    // tipoSalaId
    //
    if (n.name () == "tipoSalaId" && n.namespace_ ().empty ())
    {
      if (!tipoSalaId_.present ())
      {
        this->tipoSalaId_.set (tipoSalaId_traits::create (i, f, this));
        continue;
      }
    }

    // capacidade
    //
    if (n.name () == "capacidade" && n.namespace_ ().empty ())
    {
      if (!capacidade_.present ())
      {
        this->capacidade_.set (capacidade_traits::create (i, f, this));
        continue;
      }
    }

    // horariosDisponiveis
    //
    if (n.name () == "horariosDisponiveis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horariosDisponiveis_type > r (
        horariosDisponiveis_traits::create (i, f, this));

      if (!this->horariosDisponiveis_)
      {
        this->horariosDisponiveis_.set (r);
        continue;
      }
    }

    // creditosDisponiveis
    //
    if (n.name () == "creditosDisponiveis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< creditosDisponiveis_type > r (
        creditosDisponiveis_traits::create (i, f, this));

      if (!this->creditosDisponiveis_)
      {
        this->creditosDisponiveis_.set (r);
        continue;
      }
    }

    // disciplinasAssociadas
    //
    if (n.name () == "disciplinasAssociadas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplinasAssociadas_type > r (
        disciplinasAssociadas_traits::create (i, f, this));

      if (!disciplinasAssociadas_.present ())
      {
        this->disciplinasAssociadas_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!andar_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "andar",
      "");
  }

  if (!numero_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numero",
      "");
  }

  if (!tipoSalaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tipoSalaId",
      "");
  }

  if (!capacidade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "capacidade",
      "");
  }

  if (!disciplinasAssociadas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinasAssociadas",
      "");
  }
}

ItemSala* ItemSala::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemSala (*this, f, c);
}

ItemSala::
~ItemSala ()
{
}

// ItemCreditoDisponivel
//

ItemCreditoDisponivel::
ItemCreditoDisponivel (const turnoId_type& turnoId,
                       const diaSemana_type& diaSemana,
                       const maxCreditos_type& maxCreditos)
: ::xml_schema::type (),
  turnoId_ (turnoId, ::xml_schema::flags (), this),
  diaSemana_ (diaSemana, ::xml_schema::flags (), this),
  maxCreditos_ (maxCreditos, ::xml_schema::flags (), this)
{
}

ItemCreditoDisponivel::
ItemCreditoDisponivel (const ItemCreditoDisponivel& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  turnoId_ (x.turnoId_, f, this),
  diaSemana_ (x.diaSemana_, f, this),
  maxCreditos_ (x.maxCreditos_, f, this)
{
}

ItemCreditoDisponivel::
ItemCreditoDisponivel (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  turnoId_ (f, this),
  diaSemana_ (f, this),
  maxCreditos_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemCreditoDisponivel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // turnoId
    //
    if (n.name () == "turnoId" && n.namespace_ ().empty ())
    {
      if (!turnoId_.present ())
      {
        this->turnoId_.set (turnoId_traits::create (i, f, this));
        continue;
      }
    }

    // diaSemana
    //
    if (n.name () == "diaSemana" && n.namespace_ ().empty ())
    {
      if (!diaSemana_.present ())
      {
        this->diaSemana_.set (diaSemana_traits::create (i, f, this));
        continue;
      }
    }

    // maxCreditos
    //
    if (n.name () == "maxCreditos" && n.namespace_ ().empty ())
    {
      if (!maxCreditos_.present ())
      {
        this->maxCreditos_.set (maxCreditos_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!turnoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turnoId",
      "");
  }

  if (!diaSemana_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "diaSemana",
      "");
  }

  if (!maxCreditos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maxCreditos",
      "");
  }
}

ItemCreditoDisponivel* ItemCreditoDisponivel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemCreditoDisponivel (*this, f, c);
}

ItemCreditoDisponivel::
~ItemCreditoDisponivel ()
{
}

// ItemProfessor
//

ItemProfessor::
ItemProfessor (const id_type& id,
               const cpf_type& cpf,
               const nome_type& nome,
               const tipoContratoId_type& tipoContratoId,
               const chMin_type& chMin,
               const chMax_type& chMax,
               const titulacaoId_type& titulacaoId,
               const credAnterior_type& credAnterior,
               const valorCred_type& valorCred,
               const horariosDisponiveis_type& horariosDisponiveis,
               const disciplinas_type& disciplinas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  cpf_ (cpf, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  tipoContratoId_ (tipoContratoId, ::xml_schema::flags (), this),
  chMin_ (chMin, ::xml_schema::flags (), this),
  chMax_ (chMax, ::xml_schema::flags (), this),
  titulacaoId_ (titulacaoId, ::xml_schema::flags (), this),
  areaTitulacaoId_ (::xml_schema::flags (), this),
  credAnterior_ (credAnterior, ::xml_schema::flags (), this),
  valorCred_ (valorCred, ::xml_schema::flags (), this),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  disciplinas_ (disciplinas, ::xml_schema::flags (), this)
{
}

ItemProfessor::
ItemProfessor (const id_type& id,
               const cpf_type& cpf,
               const nome_type& nome,
               const tipoContratoId_type& tipoContratoId,
               const chMin_type& chMin,
               const chMax_type& chMax,
               const titulacaoId_type& titulacaoId,
               const credAnterior_type& credAnterior,
               const valorCred_type& valorCred,
               ::std::auto_ptr< horariosDisponiveis_type >& horariosDisponiveis,
               ::std::auto_ptr< disciplinas_type >& disciplinas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  cpf_ (cpf, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  tipoContratoId_ (tipoContratoId, ::xml_schema::flags (), this),
  chMin_ (chMin, ::xml_schema::flags (), this),
  chMax_ (chMax, ::xml_schema::flags (), this),
  titulacaoId_ (titulacaoId, ::xml_schema::flags (), this),
  areaTitulacaoId_ (::xml_schema::flags (), this),
  credAnterior_ (credAnterior, ::xml_schema::flags (), this),
  valorCred_ (valorCred, ::xml_schema::flags (), this),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  disciplinas_ (disciplinas, ::xml_schema::flags (), this)
{
}

ItemProfessor::
ItemProfessor (const ItemProfessor& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  cpf_ (x.cpf_, f, this),
  nome_ (x.nome_, f, this),
  tipoContratoId_ (x.tipoContratoId_, f, this),
  chMin_ (x.chMin_, f, this),
  chMax_ (x.chMax_, f, this),
  titulacaoId_ (x.titulacaoId_, f, this),
  areaTitulacaoId_ (x.areaTitulacaoId_, f, this),
  credAnterior_ (x.credAnterior_, f, this),
  valorCred_ (x.valorCred_, f, this),
  horariosDisponiveis_ (x.horariosDisponiveis_, f, this),
  disciplinas_ (x.disciplinas_, f, this)
{
}

ItemProfessor::
ItemProfessor (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  cpf_ (f, this),
  nome_ (f, this),
  tipoContratoId_ (f, this),
  chMin_ (f, this),
  chMax_ (f, this),
  titulacaoId_ (f, this),
  areaTitulacaoId_ (f, this),
  credAnterior_ (f, this),
  valorCred_ (f, this),
  horariosDisponiveis_ (f, this),
  disciplinas_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemProfessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // cpf
    //
    if (n.name () == "cpf" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cpf_type > r (
        cpf_traits::create (i, f, this));

      if (!cpf_.present ())
      {
        this->cpf_.set (r);
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // tipoContratoId
    //
    if (n.name () == "tipoContratoId" && n.namespace_ ().empty ())
    {
      if (!tipoContratoId_.present ())
      {
        this->tipoContratoId_.set (tipoContratoId_traits::create (i, f, this));
        continue;
      }
    }

    // chMin
    //
    if (n.name () == "chMin" && n.namespace_ ().empty ())
    {
      if (!chMin_.present ())
      {
        this->chMin_.set (chMin_traits::create (i, f, this));
        continue;
      }
    }

    // chMax
    //
    if (n.name () == "chMax" && n.namespace_ ().empty ())
    {
      if (!chMax_.present ())
      {
        this->chMax_.set (chMax_traits::create (i, f, this));
        continue;
      }
    }

    // titulacaoId
    //
    if (n.name () == "titulacaoId" && n.namespace_ ().empty ())
    {
      if (!titulacaoId_.present ())
      {
        this->titulacaoId_.set (titulacaoId_traits::create (i, f, this));
        continue;
      }
    }

    // areaTitulacaoId
    //
    if (n.name () == "areaTitulacaoId" && n.namespace_ ().empty ())
    {
      if (!this->areaTitulacaoId_)
      {
        this->areaTitulacaoId_.set (areaTitulacaoId_traits::create (i, f, this));
        continue;
      }
    }

    // credAnterior
    //
    if (n.name () == "credAnterior" && n.namespace_ ().empty ())
    {
      if (!credAnterior_.present ())
      {
        this->credAnterior_.set (credAnterior_traits::create (i, f, this));
        continue;
      }
    }

    // valorCred
    //
    if (n.name () == "valorCred" && n.namespace_ ().empty ())
    {
      if (!valorCred_.present ())
      {
        this->valorCred_.set (valorCred_traits::create (i, f, this));
        continue;
      }
    }

    // horariosDisponiveis
    //
    if (n.name () == "horariosDisponiveis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horariosDisponiveis_type > r (
        horariosDisponiveis_traits::create (i, f, this));

      if (!horariosDisponiveis_.present ())
      {
        this->horariosDisponiveis_.set (r);
        continue;
      }
    }

    // disciplinas
    //
    if (n.name () == "disciplinas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplinas_type > r (
        disciplinas_traits::create (i, f, this));

      if (!disciplinas_.present ())
      {
        this->disciplinas_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!cpf_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cpf",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!tipoContratoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tipoContratoId",
      "");
  }

  if (!chMin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "chMin",
      "");
  }

  if (!chMax_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "chMax",
      "");
  }

  if (!titulacaoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "titulacaoId",
      "");
  }

  if (!credAnterior_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "credAnterior",
      "");
  }

  if (!valorCred_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "valorCred",
      "");
  }

  if (!horariosDisponiveis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horariosDisponiveis",
      "");
  }

  if (!disciplinas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinas",
      "");
  }
}

ItemProfessor* ItemProfessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemProfessor (*this, f, c);
}

ItemProfessor::
~ItemProfessor ()
{
}

// ItemProfessorDisciplina
//

ItemProfessorDisciplina::
ItemProfessorDisciplina (const nota_type& nota,
                         const preferencia_type& preferencia,
                         const disciplinaId_type& disciplinaId)
: ::xml_schema::type (),
  nota_ (nota, ::xml_schema::flags (), this),
  preferencia_ (preferencia, ::xml_schema::flags (), this),
  disciplinaId_ (disciplinaId, ::xml_schema::flags (), this)
{
}

ItemProfessorDisciplina::
ItemProfessorDisciplina (const ItemProfessorDisciplina& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  nota_ (x.nota_, f, this),
  preferencia_ (x.preferencia_, f, this),
  disciplinaId_ (x.disciplinaId_, f, this)
{
}

ItemProfessorDisciplina::
ItemProfessorDisciplina (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  nota_ (f, this),
  preferencia_ (f, this),
  disciplinaId_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemProfessorDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // nota
    //
    if (n.name () == "nota" && n.namespace_ ().empty ())
    {
      if (!nota_.present ())
      {
        this->nota_.set (nota_traits::create (i, f, this));
        continue;
      }
    }

    // preferencia
    //
    if (n.name () == "preferencia" && n.namespace_ ().empty ())
    {
      if (!preferencia_.present ())
      {
        this->preferencia_.set (preferencia_traits::create (i, f, this));
        continue;
      }
    }

    // disciplinaId
    //
    if (n.name () == "disciplinaId" && n.namespace_ ().empty ())
    {
      if (!disciplinaId_.present ())
      {
        this->disciplinaId_.set (disciplinaId_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!nota_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nota",
      "");
  }

  if (!preferencia_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "preferencia",
      "");
  }

  if (!disciplinaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinaId",
      "");
  }
}

ItemProfessorDisciplina* ItemProfessorDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemProfessorDisciplina (*this, f, c);
}

ItemProfessorDisciplina::
~ItemProfessorDisciplina ()
{
}

// ItemDeslocamento
//

ItemDeslocamento::
ItemDeslocamento (const origemId_type& origemId,
                  const destinoId_type& destinoId,
                  const tempo_type& tempo,
                  const custo_type& custo)
: ::xml_schema::type (),
  origemId_ (origemId, ::xml_schema::flags (), this),
  destinoId_ (destinoId, ::xml_schema::flags (), this),
  tempo_ (tempo, ::xml_schema::flags (), this),
  custo_ (custo, ::xml_schema::flags (), this)
{
}

ItemDeslocamento::
ItemDeslocamento (const ItemDeslocamento& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origemId_ (x.origemId_, f, this),
  destinoId_ (x.destinoId_, f, this),
  tempo_ (x.tempo_, f, this),
  custo_ (x.custo_, f, this)
{
}

ItemDeslocamento::
ItemDeslocamento (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origemId_ (f, this),
  destinoId_ (f, this),
  tempo_ (f, this),
  custo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDeslocamento::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origemId
    //
    if (n.name () == "origemId" && n.namespace_ ().empty ())
    {
      if (!origemId_.present ())
      {
        this->origemId_.set (origemId_traits::create (i, f, this));
        continue;
      }
    }

    // destinoId
    //
    if (n.name () == "destinoId" && n.namespace_ ().empty ())
    {
      if (!destinoId_.present ())
      {
        this->destinoId_.set (destinoId_traits::create (i, f, this));
        continue;
      }
    }

    // tempo
    //
    if (n.name () == "tempo" && n.namespace_ ().empty ())
    {
      if (!tempo_.present ())
      {
        this->tempo_.set (tempo_traits::create (i, f, this));
        continue;
      }
    }

    // custo
    //
    if (n.name () == "custo" && n.namespace_ ().empty ())
    {
      if (!custo_.present ())
      {
        this->custo_.set (custo_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!origemId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "origemId",
      "");
  }

  if (!destinoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "destinoId",
      "");
  }

  if (!tempo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tempo",
      "");
  }

  if (!custo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "custo",
      "");
  }
}

ItemDeslocamento* ItemDeslocamento::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDeslocamento (*this, f, c);
}

ItemDeslocamento::
~ItemDeslocamento ()
{
}

// ItemDisciplina
//

ItemDisciplina::
ItemDisciplina (const id_type& id,
                const codigo_type& codigo,
                const nome_type& nome,
                const credTeoricos_type& credTeoricos,
                const credPraticos_type& credPraticos,
                const laboratorio_type& laboratorio,
                const tipoDisciplinaId_type& tipoDisciplinaId,
                const nivelDificuldadeId_type& nivelDificuldadeId,
                const horariosDisponiveis_type& horariosDisponiveis,
                const disciplinasEquivalentes_type& disciplinasEquivalentes,
                const disciplinasIncompativeis_type& disciplinasIncompativeis)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  credTeoricos_ (credTeoricos, ::xml_schema::flags (), this),
  credPraticos_ (credPraticos, ::xml_schema::flags (), this),
  laboratorio_ (laboratorio, ::xml_schema::flags (), this),
  maxAlunosTeorico_ (::xml_schema::flags (), this),
  maxAlunosPratico_ (::xml_schema::flags (), this),
  tipoDisciplinaId_ (tipoDisciplinaId, ::xml_schema::flags (), this),
  nivelDificuldadeId_ (nivelDificuldadeId, ::xml_schema::flags (), this),
  divisaoDeCreditos_ (::xml_schema::flags (), this),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  disciplinasEquivalentes_ (disciplinasEquivalentes, ::xml_schema::flags (), this),
  disciplinasIncompativeis_ (disciplinasIncompativeis, ::xml_schema::flags (), this)
{
}

ItemDisciplina::
ItemDisciplina (const id_type& id,
                const codigo_type& codigo,
                const nome_type& nome,
                const credTeoricos_type& credTeoricos,
                const credPraticos_type& credPraticos,
                const laboratorio_type& laboratorio,
                const tipoDisciplinaId_type& tipoDisciplinaId,
                const nivelDificuldadeId_type& nivelDificuldadeId,
                ::std::auto_ptr< horariosDisponiveis_type >& horariosDisponiveis,
                ::std::auto_ptr< disciplinasEquivalentes_type >& disciplinasEquivalentes,
                ::std::auto_ptr< disciplinasIncompativeis_type >& disciplinasIncompativeis)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  credTeoricos_ (credTeoricos, ::xml_schema::flags (), this),
  credPraticos_ (credPraticos, ::xml_schema::flags (), this),
  laboratorio_ (laboratorio, ::xml_schema::flags (), this),
  maxAlunosTeorico_ (::xml_schema::flags (), this),
  maxAlunosPratico_ (::xml_schema::flags (), this),
  tipoDisciplinaId_ (tipoDisciplinaId, ::xml_schema::flags (), this),
  nivelDificuldadeId_ (nivelDificuldadeId, ::xml_schema::flags (), this),
  divisaoDeCreditos_ (::xml_schema::flags (), this),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  disciplinasEquivalentes_ (disciplinasEquivalentes, ::xml_schema::flags (), this),
  disciplinasIncompativeis_ (disciplinasIncompativeis, ::xml_schema::flags (), this)
{
}

ItemDisciplina::
ItemDisciplina (const ItemDisciplina& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  nome_ (x.nome_, f, this),
  credTeoricos_ (x.credTeoricos_, f, this),
  credPraticos_ (x.credPraticos_, f, this),
  laboratorio_ (x.laboratorio_, f, this),
  maxAlunosTeorico_ (x.maxAlunosTeorico_, f, this),
  maxAlunosPratico_ (x.maxAlunosPratico_, f, this),
  tipoDisciplinaId_ (x.tipoDisciplinaId_, f, this),
  nivelDificuldadeId_ (x.nivelDificuldadeId_, f, this),
  divisaoDeCreditos_ (x.divisaoDeCreditos_, f, this),
  horariosDisponiveis_ (x.horariosDisponiveis_, f, this),
  disciplinasEquivalentes_ (x.disciplinasEquivalentes_, f, this),
  disciplinasIncompativeis_ (x.disciplinasIncompativeis_, f, this)
{
}

ItemDisciplina::
ItemDisciplina (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  nome_ (f, this),
  credTeoricos_ (f, this),
  credPraticos_ (f, this),
  laboratorio_ (f, this),
  maxAlunosTeorico_ (f, this),
  maxAlunosPratico_ (f, this),
  tipoDisciplinaId_ (f, this),
  nivelDificuldadeId_ (f, this),
  divisaoDeCreditos_ (f, this),
  horariosDisponiveis_ (f, this),
  disciplinasEquivalentes_ (f, this),
  disciplinasIncompativeis_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // credTeoricos
    //
    if (n.name () == "credTeoricos" && n.namespace_ ().empty ())
    {
      if (!credTeoricos_.present ())
      {
        this->credTeoricos_.set (credTeoricos_traits::create (i, f, this));
        continue;
      }
    }

    // credPraticos
    //
    if (n.name () == "credPraticos" && n.namespace_ ().empty ())
    {
      if (!credPraticos_.present ())
      {
        this->credPraticos_.set (credPraticos_traits::create (i, f, this));
        continue;
      }
    }

    // laboratorio
    //
    if (n.name () == "laboratorio" && n.namespace_ ().empty ())
    {
      if (!laboratorio_.present ())
      {
        this->laboratorio_.set (laboratorio_traits::create (i, f, this));
        continue;
      }
    }

    // maxAlunosTeorico
    //
    if (n.name () == "maxAlunosTeorico" && n.namespace_ ().empty ())
    {
      if (!this->maxAlunosTeorico_)
      {
        this->maxAlunosTeorico_.set (maxAlunosTeorico_traits::create (i, f, this));
        continue;
      }
    }

    // maxAlunosPratico
    //
    if (n.name () == "maxAlunosPratico" && n.namespace_ ().empty ())
    {
      if (!this->maxAlunosPratico_)
      {
        this->maxAlunosPratico_.set (maxAlunosPratico_traits::create (i, f, this));
        continue;
      }
    }

    // tipoDisciplinaId
    //
    if (n.name () == "tipoDisciplinaId" && n.namespace_ ().empty ())
    {
      if (!tipoDisciplinaId_.present ())
      {
        this->tipoDisciplinaId_.set (tipoDisciplinaId_traits::create (i, f, this));
        continue;
      }
    }

    // nivelDificuldadeId
    //
    if (n.name () == "nivelDificuldadeId" && n.namespace_ ().empty ())
    {
      if (!nivelDificuldadeId_.present ())
      {
        this->nivelDificuldadeId_.set (nivelDificuldadeId_traits::create (i, f, this));
        continue;
      }
    }

    // divisaoDeCreditos
    //
    if (n.name () == "divisaoDeCreditos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< divisaoDeCreditos_type > r (
        divisaoDeCreditos_traits::create (i, f, this));

      if (!this->divisaoDeCreditos_)
      {
        this->divisaoDeCreditos_.set (r);
        continue;
      }
    }

    // horariosDisponiveis
    //
    if (n.name () == "horariosDisponiveis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horariosDisponiveis_type > r (
        horariosDisponiveis_traits::create (i, f, this));

      if (!horariosDisponiveis_.present ())
      {
        this->horariosDisponiveis_.set (r);
        continue;
      }
    }

    // disciplinasEquivalentes
    //
    if (n.name () == "disciplinasEquivalentes" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplinasEquivalentes_type > r (
        disciplinasEquivalentes_traits::create (i, f, this));

      if (!disciplinasEquivalentes_.present ())
      {
        this->disciplinasEquivalentes_.set (r);
        continue;
      }
    }

    // disciplinasIncompativeis
    //
    if (n.name () == "disciplinasIncompativeis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplinasIncompativeis_type > r (
        disciplinasIncompativeis_traits::create (i, f, this));

      if (!disciplinasIncompativeis_.present ())
      {
        this->disciplinasIncompativeis_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!credTeoricos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "credTeoricos",
      "");
  }

  if (!credPraticos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "credPraticos",
      "");
  }

  if (!laboratorio_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "laboratorio",
      "");
  }

  if (!tipoDisciplinaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tipoDisciplinaId",
      "");
  }

  if (!nivelDificuldadeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nivelDificuldadeId",
      "");
  }

  if (!horariosDisponiveis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horariosDisponiveis",
      "");
  }

  if (!disciplinasEquivalentes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinasEquivalentes",
      "");
  }

  if (!disciplinasIncompativeis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinasIncompativeis",
      "");
  }
}

ItemDisciplina* ItemDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDisciplina (*this, f, c);
}

ItemDisciplina::
~ItemDisciplina ()
{
}

// ItemCurso
//

ItemCurso::
ItemCurso (const id_type& id,
           const codigo_type& codigo,
           const tipoId_type& tipoId,
           const regraPercMinMestres_type& regraPercMinMestres,
           const regraPercMinDoutores_type& regraPercMinDoutores,
           const qtdMaxProfDisc_type& qtdMaxProfDisc,
           const maisDeUmaDiscPeriodo_type& maisDeUmaDiscPeriodo,
           const areasTitulacao_type& areasTitulacao,
           const curriculos_type& curriculos,
           const minTempoIntegral_type& minTempoIntegral,
           const minTempoIntegralParcial_type& minTempoIntegralParcial)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  tipoId_ (tipoId, ::xml_schema::flags (), this),
  regraPercMinMestres_ (regraPercMinMestres, ::xml_schema::flags (), this),
  regraPercMinDoutores_ (regraPercMinDoutores, ::xml_schema::flags (), this),
  qtdMaxProfDisc_ (qtdMaxProfDisc, ::xml_schema::flags (), this),
  maisDeUmaDiscPeriodo_ (maisDeUmaDiscPeriodo, ::xml_schema::flags (), this),
  areasTitulacao_ (areasTitulacao, ::xml_schema::flags (), this),
  curriculos_ (curriculos, ::xml_schema::flags (), this),
  minTempoIntegral_ (minTempoIntegral, ::xml_schema::flags (), this),
  minTempoIntegralParcial_ (minTempoIntegralParcial, ::xml_schema::flags (), this)
{
}

ItemCurso::
ItemCurso (const id_type& id,
           const codigo_type& codigo,
           const tipoId_type& tipoId,
           ::std::auto_ptr< regraPercMinMestres_type >& regraPercMinMestres,
           ::std::auto_ptr< regraPercMinDoutores_type >& regraPercMinDoutores,
           const qtdMaxProfDisc_type& qtdMaxProfDisc,
           const maisDeUmaDiscPeriodo_type& maisDeUmaDiscPeriodo,
           ::std::auto_ptr< areasTitulacao_type >& areasTitulacao,
           ::std::auto_ptr< curriculos_type >& curriculos,
           const minTempoIntegral_type& minTempoIntegral,
           const minTempoIntegralParcial_type& minTempoIntegralParcial)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  tipoId_ (tipoId, ::xml_schema::flags (), this),
  regraPercMinMestres_ (regraPercMinMestres, ::xml_schema::flags (), this),
  regraPercMinDoutores_ (regraPercMinDoutores, ::xml_schema::flags (), this),
  qtdMaxProfDisc_ (qtdMaxProfDisc, ::xml_schema::flags (), this),
  maisDeUmaDiscPeriodo_ (maisDeUmaDiscPeriodo, ::xml_schema::flags (), this),
  areasTitulacao_ (areasTitulacao, ::xml_schema::flags (), this),
  curriculos_ (curriculos, ::xml_schema::flags (), this),
  minTempoIntegral_ (minTempoIntegral, ::xml_schema::flags (), this),
  minTempoIntegralParcial_ (minTempoIntegralParcial, ::xml_schema::flags (), this)
{
}

ItemCurso::
ItemCurso (const ItemCurso& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  tipoId_ (x.tipoId_, f, this),
  regraPercMinMestres_ (x.regraPercMinMestres_, f, this),
  regraPercMinDoutores_ (x.regraPercMinDoutores_, f, this),
  qtdMaxProfDisc_ (x.qtdMaxProfDisc_, f, this),
  maisDeUmaDiscPeriodo_ (x.maisDeUmaDiscPeriodo_, f, this),
  areasTitulacao_ (x.areasTitulacao_, f, this),
  curriculos_ (x.curriculos_, f, this),
  minTempoIntegral_ (x.minTempoIntegral_, f, this),
  minTempoIntegralParcial_ (x.minTempoIntegralParcial_, f, this)
{
}

ItemCurso::
ItemCurso (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  tipoId_ (f, this),
  regraPercMinMestres_ (f, this),
  regraPercMinDoutores_ (f, this),
  qtdMaxProfDisc_ (f, this),
  maisDeUmaDiscPeriodo_ (f, this),
  areasTitulacao_ (f, this),
  curriculos_ (f, this),
  minTempoIntegral_ (f, this),
  minTempoIntegralParcial_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // tipoId
    //
    if (n.name () == "tipoId" && n.namespace_ ().empty ())
    {
      if (!tipoId_.present ())
      {
        this->tipoId_.set (tipoId_traits::create (i, f, this));
        continue;
      }
    }

    // regraPercMinMestres
    //
    if (n.name () == "regraPercMinMestres" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< regraPercMinMestres_type > r (
        regraPercMinMestres_traits::create (i, f, this));

      if (!regraPercMinMestres_.present ())
      {
        this->regraPercMinMestres_.set (r);
        continue;
      }
    }

    // regraPercMinDoutores
    //
    if (n.name () == "regraPercMinDoutores" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< regraPercMinDoutores_type > r (
        regraPercMinDoutores_traits::create (i, f, this));

      if (!regraPercMinDoutores_.present ())
      {
        this->regraPercMinDoutores_.set (r);
        continue;
      }
    }

    // qtdMaxProfDisc
    //
    if (n.name () == "qtdMaxProfDisc" && n.namespace_ ().empty ())
    {
      if (!qtdMaxProfDisc_.present ())
      {
        this->qtdMaxProfDisc_.set (qtdMaxProfDisc_traits::create (i, f, this));
        continue;
      }
    }

    // maisDeUmaDiscPeriodo
    //
    if (n.name () == "maisDeUmaDiscPeriodo" && n.namespace_ ().empty ())
    {
      if (!maisDeUmaDiscPeriodo_.present ())
      {
        this->maisDeUmaDiscPeriodo_.set (maisDeUmaDiscPeriodo_traits::create (i, f, this));
        continue;
      }
    }

    // areasTitulacao
    //
    if (n.name () == "areasTitulacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< areasTitulacao_type > r (
        areasTitulacao_traits::create (i, f, this));

      if (!areasTitulacao_.present ())
      {
        this->areasTitulacao_.set (r);
        continue;
      }
    }

    // curriculos
    //
    if (n.name () == "curriculos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< curriculos_type > r (
        curriculos_traits::create (i, f, this));

      if (!curriculos_.present ())
      {
        this->curriculos_.set (r);
        continue;
      }
    }

    // minTempoIntegral
    //
    if (n.name () == "minTempoIntegral" && n.namespace_ ().empty ())
    {
      if (!minTempoIntegral_.present ())
      {
        this->minTempoIntegral_.set (minTempoIntegral_traits::create (i, f, this));
        continue;
      }
    }

    // minTempoIntegralParcial
    //
    if (n.name () == "minTempoIntegralParcial" && n.namespace_ ().empty ())
    {
      if (!minTempoIntegralParcial_.present ())
      {
        this->minTempoIntegralParcial_.set (minTempoIntegralParcial_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!tipoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tipoId",
      "");
  }

  if (!regraPercMinMestres_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "regraPercMinMestres",
      "");
  }

  if (!regraPercMinDoutores_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "regraPercMinDoutores",
      "");
  }

  if (!qtdMaxProfDisc_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qtdMaxProfDisc",
      "");
  }

  if (!maisDeUmaDiscPeriodo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maisDeUmaDiscPeriodo",
      "");
  }

  if (!areasTitulacao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "areasTitulacao",
      "");
  }

  if (!curriculos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "curriculos",
      "");
  }

  if (!minTempoIntegral_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minTempoIntegral",
      "");
  }

  if (!minTempoIntegralParcial_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minTempoIntegralParcial",
      "");
  }
}

ItemCurso* ItemCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemCurso (*this, f, c);
}

ItemCurso::
~ItemCurso ()
{
}

// ItemPercentualMinimo
//

ItemPercentualMinimo::
ItemPercentualMinimo (const percMinimo_type& percMinimo,
                      const tipoTitulacaoId_type& tipoTitulacaoId)
: ::xml_schema::type (),
  percMinimo_ (percMinimo, ::xml_schema::flags (), this),
  tipoTitulacaoId_ (tipoTitulacaoId, ::xml_schema::flags (), this)
{
}

ItemPercentualMinimo::
ItemPercentualMinimo (const ItemPercentualMinimo& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  percMinimo_ (x.percMinimo_, f, this),
  tipoTitulacaoId_ (x.tipoTitulacaoId_, f, this)
{
}

ItemPercentualMinimo::
ItemPercentualMinimo (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  percMinimo_ (f, this),
  tipoTitulacaoId_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemPercentualMinimo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // percMinimo
    //
    if (n.name () == "percMinimo" && n.namespace_ ().empty ())
    {
      if (!percMinimo_.present ())
      {
        this->percMinimo_.set (percMinimo_traits::create (i, f, this));
        continue;
      }
    }

    // tipoTitulacaoId
    //
    if (n.name () == "tipoTitulacaoId" && n.namespace_ ().empty ())
    {
      if (!tipoTitulacaoId_.present ())
      {
        this->tipoTitulacaoId_.set (tipoTitulacaoId_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!percMinimo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "percMinimo",
      "");
  }

  if (!tipoTitulacaoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tipoTitulacaoId",
      "");
  }
}

ItemPercentualMinimo* ItemPercentualMinimo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemPercentualMinimo (*this, f, c);
}

ItemPercentualMinimo::
~ItemPercentualMinimo ()
{
}

// ItemCurriculo
//

ItemCurriculo::
ItemCurriculo (const id_type& id,
               const codigo_type& codigo,
               const disciplinasPeriodo_type& disciplinasPeriodo,
               const semanaLetivaId_type& semanaLetivaId)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  disciplinasPeriodo_ (disciplinasPeriodo, ::xml_schema::flags (), this),
  semanaLetivaId_ (semanaLetivaId, ::xml_schema::flags (), this)
{
}

ItemCurriculo::
ItemCurriculo (const id_type& id,
               const codigo_type& codigo,
               ::std::auto_ptr< disciplinasPeriodo_type >& disciplinasPeriodo,
               const semanaLetivaId_type& semanaLetivaId)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  disciplinasPeriodo_ (disciplinasPeriodo, ::xml_schema::flags (), this),
  semanaLetivaId_ (semanaLetivaId, ::xml_schema::flags (), this)
{
}

ItemCurriculo::
ItemCurriculo (const ItemCurriculo& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  disciplinasPeriodo_ (x.disciplinasPeriodo_, f, this),
  semanaLetivaId_ (x.semanaLetivaId_, f, this)
{
}

ItemCurriculo::
ItemCurriculo (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  disciplinasPeriodo_ (f, this),
  semanaLetivaId_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemCurriculo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // disciplinasPeriodo
    //
    if (n.name () == "disciplinasPeriodo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplinasPeriodo_type > r (
        disciplinasPeriodo_traits::create (i, f, this));

      if (!disciplinasPeriodo_.present ())
      {
        this->disciplinasPeriodo_.set (r);
        continue;
      }
    }

    // semanaLetivaId
    //
    if (n.name () == "semanaLetivaId" && n.namespace_ ().empty ())
    {
      if (!semanaLetivaId_.present ())
      {
        this->semanaLetivaId_.set (semanaLetivaId_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!disciplinasPeriodo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinasPeriodo",
      "");
  }

  if (!semanaLetivaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "semanaLetivaId",
      "");
  }
}

ItemCurriculo* ItemCurriculo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemCurriculo (*this, f, c);
}

ItemCurriculo::
~ItemCurriculo ()
{
}

// ItemDisciplinaPeriodo
//

ItemDisciplinaPeriodo::
ItemDisciplinaPeriodo (const periodo_type& periodo,
                       const disciplinaId_type& disciplinaId)
: ::xml_schema::type (),
  periodo_ (periodo, ::xml_schema::flags (), this),
  disciplinaId_ (disciplinaId, ::xml_schema::flags (), this)
{
}

ItemDisciplinaPeriodo::
ItemDisciplinaPeriodo (const ItemDisciplinaPeriodo& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  periodo_ (x.periodo_, f, this),
  disciplinaId_ (x.disciplinaId_, f, this)
{
}

ItemDisciplinaPeriodo::
ItemDisciplinaPeriodo (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  periodo_ (f, this),
  disciplinaId_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDisciplinaPeriodo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // periodo
    //
    if (n.name () == "periodo" && n.namespace_ ().empty ())
    {
      if (!periodo_.present ())
      {
        this->periodo_.set (periodo_traits::create (i, f, this));
        continue;
      }
    }

    // disciplinaId
    //
    if (n.name () == "disciplinaId" && n.namespace_ ().empty ())
    {
      if (!disciplinaId_.present ())
      {
        this->disciplinaId_.set (disciplinaId_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!periodo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "periodo",
      "");
  }

  if (!disciplinaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinaId",
      "");
  }
}

ItemDisciplinaPeriodo* ItemDisciplinaPeriodo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDisciplinaPeriodo (*this, f, c);
}

ItemDisciplinaPeriodo::
~ItemDisciplinaPeriodo ()
{
}

// ItemOfertaCurso
//

ItemOfertaCurso::
ItemOfertaCurso (const id_type& id,
                 const curriculoId_type& curriculoId,
                 const cursoId_type& cursoId,
                 const turnoId_type& turnoId,
                 const campusId_type& campusId,
                 const receita_type& receita)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  curriculoId_ (curriculoId, ::xml_schema::flags (), this),
  cursoId_ (cursoId, ::xml_schema::flags (), this),
  turnoId_ (turnoId, ::xml_schema::flags (), this),
  campusId_ (campusId, ::xml_schema::flags (), this),
  receita_ (receita, ::xml_schema::flags (), this)
{
}

ItemOfertaCurso::
ItemOfertaCurso (const ItemOfertaCurso& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  curriculoId_ (x.curriculoId_, f, this),
  cursoId_ (x.cursoId_, f, this),
  turnoId_ (x.turnoId_, f, this),
  campusId_ (x.campusId_, f, this),
  receita_ (x.receita_, f, this)
{
}

ItemOfertaCurso::
ItemOfertaCurso (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  curriculoId_ (f, this),
  cursoId_ (f, this),
  turnoId_ (f, this),
  campusId_ (f, this),
  receita_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemOfertaCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // curriculoId
    //
    if (n.name () == "curriculoId" && n.namespace_ ().empty ())
    {
      if (!curriculoId_.present ())
      {
        this->curriculoId_.set (curriculoId_traits::create (i, f, this));
        continue;
      }
    }

    // cursoId
    //
    if (n.name () == "cursoId" && n.namespace_ ().empty ())
    {
      if (!cursoId_.present ())
      {
        this->cursoId_.set (cursoId_traits::create (i, f, this));
        continue;
      }
    }

    // turnoId
    //
    if (n.name () == "turnoId" && n.namespace_ ().empty ())
    {
      if (!turnoId_.present ())
      {
        this->turnoId_.set (turnoId_traits::create (i, f, this));
        continue;
      }
    }

    // campusId
    //
    if (n.name () == "campusId" && n.namespace_ ().empty ())
    {
      if (!campusId_.present ())
      {
        this->campusId_.set (campusId_traits::create (i, f, this));
        continue;
      }
    }

    // receita
    //
    if (n.name () == "receita" && n.namespace_ ().empty ())
    {
      if (!receita_.present ())
      {
        this->receita_.set (receita_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!curriculoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "curriculoId",
      "");
  }

  if (!cursoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cursoId",
      "");
  }

  if (!turnoId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turnoId",
      "");
  }

  if (!campusId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "campusId",
      "");
  }

  if (!receita_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "receita",
      "");
  }
}

ItemOfertaCurso* ItemOfertaCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemOfertaCurso (*this, f, c);
}

ItemOfertaCurso::
~ItemOfertaCurso ()
{
}

// ItemDemanda
//

ItemDemanda::
ItemDemanda (const id_type& id,
             const ofertaCursoCampiId_type& ofertaCursoCampiId,
             const disciplinaId_type& disciplinaId,
             const quantidade_type& quantidade)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  ofertaCursoCampiId_ (ofertaCursoCampiId, ::xml_schema::flags (), this),
  disciplinaId_ (disciplinaId, ::xml_schema::flags (), this),
  quantidade_ (quantidade, ::xml_schema::flags (), this)
{
}

ItemDemanda::
ItemDemanda (const ItemDemanda& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  ofertaCursoCampiId_ (x.ofertaCursoCampiId_, f, this),
  disciplinaId_ (x.disciplinaId_, f, this),
  quantidade_ (x.quantidade_, f, this)
{
}

ItemDemanda::
ItemDemanda (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  ofertaCursoCampiId_ (f, this),
  disciplinaId_ (f, this),
  quantidade_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDemanda::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // ofertaCursoCampiId
    //
    if (n.name () == "ofertaCursoCampiId" && n.namespace_ ().empty ())
    {
      if (!ofertaCursoCampiId_.present ())
      {
        this->ofertaCursoCampiId_.set (ofertaCursoCampiId_traits::create (i, f, this));
        continue;
      }
    }

    // disciplinaId
    //
    if (n.name () == "disciplinaId" && n.namespace_ ().empty ())
    {
      if (!disciplinaId_.present ())
      {
        this->disciplinaId_.set (disciplinaId_traits::create (i, f, this));
        continue;
      }
    }

    // quantidade
    //
    if (n.name () == "quantidade" && n.namespace_ ().empty ())
    {
      if (!quantidade_.present ())
      {
        this->quantidade_.set (quantidade_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!ofertaCursoCampiId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ofertaCursoCampiId",
      "");
  }

  if (!disciplinaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinaId",
      "");
  }

  if (!quantidade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "quantidade",
      "");
  }
}

ItemDemanda* ItemDemanda::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDemanda (*this, f, c);
}

ItemDemanda::
~ItemDemanda ()
{
}

// ItemFixacao
//

ItemFixacao::
ItemFixacao (const id_type& id)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  professorId_ (::xml_schema::flags (), this),
  disciplinaId_ (::xml_schema::flags (), this),
  salaId_ (::xml_schema::flags (), this),
  diaSemana_ (::xml_schema::flags (), this),
  turnoId_ (::xml_schema::flags (), this),
  horarioAulaId_ (::xml_schema::flags (), this)
{
}

ItemFixacao::
ItemFixacao (const ItemFixacao& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  professorId_ (x.professorId_, f, this),
  disciplinaId_ (x.disciplinaId_, f, this),
  salaId_ (x.salaId_, f, this),
  diaSemana_ (x.diaSemana_, f, this),
  turnoId_ (x.turnoId_, f, this),
  horarioAulaId_ (x.horarioAulaId_, f, this)
{
}

ItemFixacao::
ItemFixacao (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  professorId_ (f, this),
  disciplinaId_ (f, this),
  salaId_ (f, this),
  diaSemana_ (f, this),
  turnoId_ (f, this),
  horarioAulaId_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemFixacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // professorId
    //
    if (n.name () == "professorId" && n.namespace_ ().empty ())
    {
      if (!this->professorId_)
      {
        this->professorId_.set (professorId_traits::create (i, f, this));
        continue;
      }
    }

    // disciplinaId
    //
    if (n.name () == "disciplinaId" && n.namespace_ ().empty ())
    {
      if (!this->disciplinaId_)
      {
        this->disciplinaId_.set (disciplinaId_traits::create (i, f, this));
        continue;
      }
    }

    // salaId
    //
    if (n.name () == "salaId" && n.namespace_ ().empty ())
    {
      if (!this->salaId_)
      {
        this->salaId_.set (salaId_traits::create (i, f, this));
        continue;
      }
    }

    // diaSemana
    //
    if (n.name () == "diaSemana" && n.namespace_ ().empty ())
    {
      if (!this->diaSemana_)
      {
        this->diaSemana_.set (diaSemana_traits::create (i, f, this));
        continue;
      }
    }

    // turnoId
    //
    if (n.name () == "turnoId" && n.namespace_ ().empty ())
    {
      if (!this->turnoId_)
      {
        this->turnoId_.set (turnoId_traits::create (i, f, this));
        continue;
      }
    }

    // horarioAulaId
    //
    if (n.name () == "horarioAulaId" && n.namespace_ ().empty ())
    {
      if (!this->horarioAulaId_)
      {
        this->horarioAulaId_.set (horarioAulaId_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }
}

ItemFixacao* ItemFixacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemFixacao (*this, f, c);
}

ItemFixacao::
~ItemFixacao ()
{
}

// ItemParametrosPlanejamento
//

ItemParametrosPlanejamento::
ItemParametrosPlanejamento (const modoOtimizacao_type& modoOtimizacao,
                            const cargaHorariaSemanalAluno_type& cargaHorariaSemanalAluno,
                            const alunosMesmoPeriodoNaMesmaSala_type& alunosMesmoPeriodoNaMesmaSala,
                            const permitirAlunosEmVariosCampi_type& permitirAlunosEmVariosCampi,
                            const minimizarDeslocAluno_type& minimizarDeslocAluno,
                            const cargaHorariaSemanalProfessor_type& cargaHorariaSemanalProfessor,
                            const permitirProfessorEmVariosCampi_type& permitirProfessorEmVariosCampi,
                            const minimizarDeslocProfessor_type& minimizarDeslocProfessor,
                            const minimizarHorariosVaziosProfessor_type& minimizarHorariosVaziosProfessor,
                            const evitarReducaoCargaHorariaProf_type& evitarReducaoCargaHorariaProf,
                            const evitarProfUltimoPrimeiroHor_type& evitarProfUltimoPrimeiroHor,
                            const preferenciaProfessorDisciplina_type& preferenciaProfessorDisciplina,
                            const desempenhoProfDisponibilidade_type& desempenhoProfDisponibilidade,
                            const funcaoObjetivo_type& funcaoObjetivo,
                            const considerarEquivalencia_type& considerarEquivalencia,
                            const minAlunosAberturaTurmas_type& minAlunosAberturaTurmas,
                            const niveisDificuldadeHorario_type& niveisDificuldadeHorario,
                            const equilibrarDiversidadeDiscDia_type& equilibrarDiversidadeDiscDia,
                            const regrasGenericasDivisaoCredito_type& regrasGenericasDivisaoCredito,
                            const regrasEspecificasDivisaoCredito_type& regrasEspecificasDivisaoCredito,
                            const maximizarAvaliacaoCursosSel_type& maximizarAvaliacaoCursosSel,
                            const minimizarCustoDocenteCursosSel_type& minimizarCustoDocenteCursosSel,
                            const permiteCompartilhamentoTurmaSel_type& permiteCompartilhamentoTurmaSel,
                            const percentuaisMinimoMestres_type& percentuaisMinimoMestres,
                            const percentuaisMinimoDoutores_type& percentuaisMinimoDoutores,
                            const areaTitulacaoProfessorCurso_type& areaTitulacaoProfessorCurso,
                            const maximoDisciplinasDeUmProfessorPorCurso_type& maximoDisciplinasDeUmProfessorPorCurso,
                            const custoProfDisponibilidade_type& custoProfDisponibilidade)
: ::xml_schema::type (),
  modoOtimizacao_ (modoOtimizacao, ::xml_schema::flags (), this),
  cargaHorariaSemanalAluno_ (cargaHorariaSemanalAluno, ::xml_schema::flags (), this),
  alunosMesmoPeriodoNaMesmaSala_ (alunosMesmoPeriodoNaMesmaSala, ::xml_schema::flags (), this),
  permitirAlunosEmVariosCampi_ (permitirAlunosEmVariosCampi, ::xml_schema::flags (), this),
  minimizarDeslocAluno_ (minimizarDeslocAluno, ::xml_schema::flags (), this),
  cargaHorariaSemanalProfessor_ (cargaHorariaSemanalProfessor, ::xml_schema::flags (), this),
  permitirProfessorEmVariosCampi_ (permitirProfessorEmVariosCampi, ::xml_schema::flags (), this),
  minimizarDeslocProfessor_ (minimizarDeslocProfessor, ::xml_schema::flags (), this),
  maxDeslocProfessor_ (::xml_schema::flags (), this),
  minimizarHorariosVaziosProfessor_ (minimizarHorariosVaziosProfessor, ::xml_schema::flags (), this),
  evitarReducaoCargaHorariaProf_ (evitarReducaoCargaHorariaProf, ::xml_schema::flags (), this),
  evitarReducaoCargaHorariaProfValor_ (::xml_schema::flags (), this),
  evitarProfUltimoPrimeiroHor_ (evitarProfUltimoPrimeiroHor, ::xml_schema::flags (), this),
  preferenciaProfessorDisciplina_ (preferenciaProfessorDisciplina, ::xml_schema::flags (), this),
  desempenhoProfDisponibilidade_ (desempenhoProfDisponibilidade, ::xml_schema::flags (), this),
  funcaoObjetivo_ (funcaoObjetivo, ::xml_schema::flags (), this),
  considerarEquivalencia_ (considerarEquivalencia, ::xml_schema::flags (), this),
  minAlunosAberturaTurmas_ (minAlunosAberturaTurmas, ::xml_schema::flags (), this),
  minAlunosAberturaTurmasValor_ (::xml_schema::flags (), this),
  niveisDificuldadeHorario_ (niveisDificuldadeHorario, ::xml_schema::flags (), this),
  equilibrarDiversidadeDiscDia_ (equilibrarDiversidadeDiscDia, ::xml_schema::flags (), this),
  regrasGenericasDivisaoCredito_ (regrasGenericasDivisaoCredito, ::xml_schema::flags (), this),
  regrasEspecificasDivisaoCredito_ (regrasEspecificasDivisaoCredito, ::xml_schema::flags (), this),
  maximizarAvaliacaoCursosSel_ (maximizarAvaliacaoCursosSel, ::xml_schema::flags (), this),
  maximizarAvaliacaoCursos_ (::xml_schema::flags (), this),
  minimizarCustoDocenteCursosSel_ (minimizarCustoDocenteCursosSel, ::xml_schema::flags (), this),
  minimizarCustoDocenteCursos_ (::xml_schema::flags (), this),
  permiteCompartilhamentoTurmaSel_ (permiteCompartilhamentoTurmaSel, ::xml_schema::flags (), this),
  permiteCompartilhamentoTurma_ (::xml_schema::flags (), this),
  percentuaisMinimoMestres_ (percentuaisMinimoMestres, ::xml_schema::flags (), this),
  percentuaisMinimoDoutores_ (percentuaisMinimoDoutores, ::xml_schema::flags (), this),
  areaTitulacaoProfessorCurso_ (areaTitulacaoProfessorCurso, ::xml_schema::flags (), this),
  maximoDisciplinasDeUmProfessorPorCurso_ (maximoDisciplinasDeUmProfessorPorCurso, ::xml_schema::flags (), this),
  custoProfDisponibilidade_ (custoProfDisponibilidade, ::xml_schema::flags (), this)
{
}

ItemParametrosPlanejamento::
ItemParametrosPlanejamento (const modoOtimizacao_type& modoOtimizacao,
                            ::std::auto_ptr< cargaHorariaSemanalAluno_type >& cargaHorariaSemanalAluno,
                            const alunosMesmoPeriodoNaMesmaSala_type& alunosMesmoPeriodoNaMesmaSala,
                            const permitirAlunosEmVariosCampi_type& permitirAlunosEmVariosCampi,
                            const minimizarDeslocAluno_type& minimizarDeslocAluno,
                            ::std::auto_ptr< cargaHorariaSemanalProfessor_type >& cargaHorariaSemanalProfessor,
                            const permitirProfessorEmVariosCampi_type& permitirProfessorEmVariosCampi,
                            const minimizarDeslocProfessor_type& minimizarDeslocProfessor,
                            const minimizarHorariosVaziosProfessor_type& minimizarHorariosVaziosProfessor,
                            const evitarReducaoCargaHorariaProf_type& evitarReducaoCargaHorariaProf,
                            const evitarProfUltimoPrimeiroHor_type& evitarProfUltimoPrimeiroHor,
                            const preferenciaProfessorDisciplina_type& preferenciaProfessorDisciplina,
                            const desempenhoProfDisponibilidade_type& desempenhoProfDisponibilidade,
                            const funcaoObjetivo_type& funcaoObjetivo,
                            const considerarEquivalencia_type& considerarEquivalencia,
                            const minAlunosAberturaTurmas_type& minAlunosAberturaTurmas,
                            ::std::auto_ptr< niveisDificuldadeHorario_type >& niveisDificuldadeHorario,
                            const equilibrarDiversidadeDiscDia_type& equilibrarDiversidadeDiscDia,
                            const regrasGenericasDivisaoCredito_type& regrasGenericasDivisaoCredito,
                            const regrasEspecificasDivisaoCredito_type& regrasEspecificasDivisaoCredito,
                            const maximizarAvaliacaoCursosSel_type& maximizarAvaliacaoCursosSel,
                            const minimizarCustoDocenteCursosSel_type& minimizarCustoDocenteCursosSel,
                            const permiteCompartilhamentoTurmaSel_type& permiteCompartilhamentoTurmaSel,
                            const percentuaisMinimoMestres_type& percentuaisMinimoMestres,
                            const percentuaisMinimoDoutores_type& percentuaisMinimoDoutores,
                            const areaTitulacaoProfessorCurso_type& areaTitulacaoProfessorCurso,
                            const maximoDisciplinasDeUmProfessorPorCurso_type& maximoDisciplinasDeUmProfessorPorCurso,
                            const custoProfDisponibilidade_type& custoProfDisponibilidade)
: ::xml_schema::type (),
  modoOtimizacao_ (modoOtimizacao, ::xml_schema::flags (), this),
  cargaHorariaSemanalAluno_ (cargaHorariaSemanalAluno, ::xml_schema::flags (), this),
  alunosMesmoPeriodoNaMesmaSala_ (alunosMesmoPeriodoNaMesmaSala, ::xml_schema::flags (), this),
  permitirAlunosEmVariosCampi_ (permitirAlunosEmVariosCampi, ::xml_schema::flags (), this),
  minimizarDeslocAluno_ (minimizarDeslocAluno, ::xml_schema::flags (), this),
  cargaHorariaSemanalProfessor_ (cargaHorariaSemanalProfessor, ::xml_schema::flags (), this),
  permitirProfessorEmVariosCampi_ (permitirProfessorEmVariosCampi, ::xml_schema::flags (), this),
  minimizarDeslocProfessor_ (minimizarDeslocProfessor, ::xml_schema::flags (), this),
  maxDeslocProfessor_ (::xml_schema::flags (), this),
  minimizarHorariosVaziosProfessor_ (minimizarHorariosVaziosProfessor, ::xml_schema::flags (), this),
  evitarReducaoCargaHorariaProf_ (evitarReducaoCargaHorariaProf, ::xml_schema::flags (), this),
  evitarReducaoCargaHorariaProfValor_ (::xml_schema::flags (), this),
  evitarProfUltimoPrimeiroHor_ (evitarProfUltimoPrimeiroHor, ::xml_schema::flags (), this),
  preferenciaProfessorDisciplina_ (preferenciaProfessorDisciplina, ::xml_schema::flags (), this),
  desempenhoProfDisponibilidade_ (desempenhoProfDisponibilidade, ::xml_schema::flags (), this),
  funcaoObjetivo_ (funcaoObjetivo, ::xml_schema::flags (), this),
  considerarEquivalencia_ (considerarEquivalencia, ::xml_schema::flags (), this),
  minAlunosAberturaTurmas_ (minAlunosAberturaTurmas, ::xml_schema::flags (), this),
  minAlunosAberturaTurmasValor_ (::xml_schema::flags (), this),
  niveisDificuldadeHorario_ (niveisDificuldadeHorario, ::xml_schema::flags (), this),
  equilibrarDiversidadeDiscDia_ (equilibrarDiversidadeDiscDia, ::xml_schema::flags (), this),
  regrasGenericasDivisaoCredito_ (regrasGenericasDivisaoCredito, ::xml_schema::flags (), this),
  regrasEspecificasDivisaoCredito_ (regrasEspecificasDivisaoCredito, ::xml_schema::flags (), this),
  maximizarAvaliacaoCursosSel_ (maximizarAvaliacaoCursosSel, ::xml_schema::flags (), this),
  maximizarAvaliacaoCursos_ (::xml_schema::flags (), this),
  minimizarCustoDocenteCursosSel_ (minimizarCustoDocenteCursosSel, ::xml_schema::flags (), this),
  minimizarCustoDocenteCursos_ (::xml_schema::flags (), this),
  permiteCompartilhamentoTurmaSel_ (permiteCompartilhamentoTurmaSel, ::xml_schema::flags (), this),
  permiteCompartilhamentoTurma_ (::xml_schema::flags (), this),
  percentuaisMinimoMestres_ (percentuaisMinimoMestres, ::xml_schema::flags (), this),
  percentuaisMinimoDoutores_ (percentuaisMinimoDoutores, ::xml_schema::flags (), this),
  areaTitulacaoProfessorCurso_ (areaTitulacaoProfessorCurso, ::xml_schema::flags (), this),
  maximoDisciplinasDeUmProfessorPorCurso_ (maximoDisciplinasDeUmProfessorPorCurso, ::xml_schema::flags (), this),
  custoProfDisponibilidade_ (custoProfDisponibilidade, ::xml_schema::flags (), this)
{
}

ItemParametrosPlanejamento::
ItemParametrosPlanejamento (const ItemParametrosPlanejamento& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  modoOtimizacao_ (x.modoOtimizacao_, f, this),
  cargaHorariaSemanalAluno_ (x.cargaHorariaSemanalAluno_, f, this),
  alunosMesmoPeriodoNaMesmaSala_ (x.alunosMesmoPeriodoNaMesmaSala_, f, this),
  permitirAlunosEmVariosCampi_ (x.permitirAlunosEmVariosCampi_, f, this),
  minimizarDeslocAluno_ (x.minimizarDeslocAluno_, f, this),
  cargaHorariaSemanalProfessor_ (x.cargaHorariaSemanalProfessor_, f, this),
  permitirProfessorEmVariosCampi_ (x.permitirProfessorEmVariosCampi_, f, this),
  minimizarDeslocProfessor_ (x.minimizarDeslocProfessor_, f, this),
  maxDeslocProfessor_ (x.maxDeslocProfessor_, f, this),
  minimizarHorariosVaziosProfessor_ (x.minimizarHorariosVaziosProfessor_, f, this),
  evitarReducaoCargaHorariaProf_ (x.evitarReducaoCargaHorariaProf_, f, this),
  evitarReducaoCargaHorariaProfValor_ (x.evitarReducaoCargaHorariaProfValor_, f, this),
  evitarProfUltimoPrimeiroHor_ (x.evitarProfUltimoPrimeiroHor_, f, this),
  preferenciaProfessorDisciplina_ (x.preferenciaProfessorDisciplina_, f, this),
  desempenhoProfDisponibilidade_ (x.desempenhoProfDisponibilidade_, f, this),
  funcaoObjetivo_ (x.funcaoObjetivo_, f, this),
  considerarEquivalencia_ (x.considerarEquivalencia_, f, this),
  minAlunosAberturaTurmas_ (x.minAlunosAberturaTurmas_, f, this),
  minAlunosAberturaTurmasValor_ (x.minAlunosAberturaTurmasValor_, f, this),
  niveisDificuldadeHorario_ (x.niveisDificuldadeHorario_, f, this),
  equilibrarDiversidadeDiscDia_ (x.equilibrarDiversidadeDiscDia_, f, this),
  regrasGenericasDivisaoCredito_ (x.regrasGenericasDivisaoCredito_, f, this),
  regrasEspecificasDivisaoCredito_ (x.regrasEspecificasDivisaoCredito_, f, this),
  maximizarAvaliacaoCursosSel_ (x.maximizarAvaliacaoCursosSel_, f, this),
  maximizarAvaliacaoCursos_ (x.maximizarAvaliacaoCursos_, f, this),
  minimizarCustoDocenteCursosSel_ (x.minimizarCustoDocenteCursosSel_, f, this),
  minimizarCustoDocenteCursos_ (x.minimizarCustoDocenteCursos_, f, this),
  permiteCompartilhamentoTurmaSel_ (x.permiteCompartilhamentoTurmaSel_, f, this),
  permiteCompartilhamentoTurma_ (x.permiteCompartilhamentoTurma_, f, this),
  percentuaisMinimoMestres_ (x.percentuaisMinimoMestres_, f, this),
  percentuaisMinimoDoutores_ (x.percentuaisMinimoDoutores_, f, this),
  areaTitulacaoProfessorCurso_ (x.areaTitulacaoProfessorCurso_, f, this),
  maximoDisciplinasDeUmProfessorPorCurso_ (x.maximoDisciplinasDeUmProfessorPorCurso_, f, this),
  custoProfDisponibilidade_ (x.custoProfDisponibilidade_, f, this)
{
}

ItemParametrosPlanejamento::
ItemParametrosPlanejamento (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  modoOtimizacao_ (f, this),
  cargaHorariaSemanalAluno_ (f, this),
  alunosMesmoPeriodoNaMesmaSala_ (f, this),
  permitirAlunosEmVariosCampi_ (f, this),
  minimizarDeslocAluno_ (f, this),
  cargaHorariaSemanalProfessor_ (f, this),
  permitirProfessorEmVariosCampi_ (f, this),
  minimizarDeslocProfessor_ (f, this),
  maxDeslocProfessor_ (f, this),
  minimizarHorariosVaziosProfessor_ (f, this),
  evitarReducaoCargaHorariaProf_ (f, this),
  evitarReducaoCargaHorariaProfValor_ (f, this),
  evitarProfUltimoPrimeiroHor_ (f, this),
  preferenciaProfessorDisciplina_ (f, this),
  desempenhoProfDisponibilidade_ (f, this),
  funcaoObjetivo_ (f, this),
  considerarEquivalencia_ (f, this),
  minAlunosAberturaTurmas_ (f, this),
  minAlunosAberturaTurmasValor_ (f, this),
  niveisDificuldadeHorario_ (f, this),
  equilibrarDiversidadeDiscDia_ (f, this),
  regrasGenericasDivisaoCredito_ (f, this),
  regrasEspecificasDivisaoCredito_ (f, this),
  maximizarAvaliacaoCursosSel_ (f, this),
  maximizarAvaliacaoCursos_ (f, this),
  minimizarCustoDocenteCursosSel_ (f, this),
  minimizarCustoDocenteCursos_ (f, this),
  permiteCompartilhamentoTurmaSel_ (f, this),
  permiteCompartilhamentoTurma_ (f, this),
  percentuaisMinimoMestres_ (f, this),
  percentuaisMinimoDoutores_ (f, this),
  areaTitulacaoProfessorCurso_ (f, this),
  maximoDisciplinasDeUmProfessorPorCurso_ (f, this),
  custoProfDisponibilidade_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemParametrosPlanejamento::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // modoOtimizacao
    //
    if (n.name () == "modoOtimizacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< modoOtimizacao_type > r (
        modoOtimizacao_traits::create (i, f, this));

      if (!modoOtimizacao_.present ())
      {
        this->modoOtimizacao_.set (r);
        continue;
      }
    }

    // cargaHorariaSemanalAluno
    //
    if (n.name () == "cargaHorariaSemanalAluno" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cargaHorariaSemanalAluno_type > r (
        cargaHorariaSemanalAluno_traits::create (i, f, this));

      if (!cargaHorariaSemanalAluno_.present ())
      {
        this->cargaHorariaSemanalAluno_.set (r);
        continue;
      }
    }

    // alunosMesmoPeriodoNaMesmaSala
    //
    if (n.name () == "alunosMesmoPeriodoNaMesmaSala" && n.namespace_ ().empty ())
    {
      if (!alunosMesmoPeriodoNaMesmaSala_.present ())
      {
        this->alunosMesmoPeriodoNaMesmaSala_.set (alunosMesmoPeriodoNaMesmaSala_traits::create (i, f, this));
        continue;
      }
    }

    // permitirAlunosEmVariosCampi
    //
    if (n.name () == "permitirAlunosEmVariosCampi" && n.namespace_ ().empty ())
    {
      if (!permitirAlunosEmVariosCampi_.present ())
      {
        this->permitirAlunosEmVariosCampi_.set (permitirAlunosEmVariosCampi_traits::create (i, f, this));
        continue;
      }
    }

    // minimizarDeslocAluno
    //
    if (n.name () == "minimizarDeslocAluno" && n.namespace_ ().empty ())
    {
      if (!minimizarDeslocAluno_.present ())
      {
        this->minimizarDeslocAluno_.set (minimizarDeslocAluno_traits::create (i, f, this));
        continue;
      }
    }

    // cargaHorariaSemanalProfessor
    //
    if (n.name () == "cargaHorariaSemanalProfessor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cargaHorariaSemanalProfessor_type > r (
        cargaHorariaSemanalProfessor_traits::create (i, f, this));

      if (!cargaHorariaSemanalProfessor_.present ())
      {
        this->cargaHorariaSemanalProfessor_.set (r);
        continue;
      }
    }

    // permitirProfessorEmVariosCampi
    //
    if (n.name () == "permitirProfessorEmVariosCampi" && n.namespace_ ().empty ())
    {
      if (!permitirProfessorEmVariosCampi_.present ())
      {
        this->permitirProfessorEmVariosCampi_.set (permitirProfessorEmVariosCampi_traits::create (i, f, this));
        continue;
      }
    }

    // minimizarDeslocProfessor
    //
    if (n.name () == "minimizarDeslocProfessor" && n.namespace_ ().empty ())
    {
      if (!minimizarDeslocProfessor_.present ())
      {
        this->minimizarDeslocProfessor_.set (minimizarDeslocProfessor_traits::create (i, f, this));
        continue;
      }
    }

    // maxDeslocProfessor
    //
    if (n.name () == "maxDeslocProfessor" && n.namespace_ ().empty ())
    {
      if (!this->maxDeslocProfessor_)
      {
        this->maxDeslocProfessor_.set (maxDeslocProfessor_traits::create (i, f, this));
        continue;
      }
    }

    // minimizarHorariosVaziosProfessor
    //
    if (n.name () == "minimizarHorariosVaziosProfessor" && n.namespace_ ().empty ())
    {
      if (!minimizarHorariosVaziosProfessor_.present ())
      {
        this->minimizarHorariosVaziosProfessor_.set (minimizarHorariosVaziosProfessor_traits::create (i, f, this));
        continue;
      }
    }

    // evitarReducaoCargaHorariaProf
    //
    if (n.name () == "evitarReducaoCargaHorariaProf" && n.namespace_ ().empty ())
    {
      if (!evitarReducaoCargaHorariaProf_.present ())
      {
        this->evitarReducaoCargaHorariaProf_.set (evitarReducaoCargaHorariaProf_traits::create (i, f, this));
        continue;
      }
    }

    // evitarReducaoCargaHorariaProfValor
    //
    if (n.name () == "evitarReducaoCargaHorariaProfValor" && n.namespace_ ().empty ())
    {
      if (!this->evitarReducaoCargaHorariaProfValor_)
      {
        this->evitarReducaoCargaHorariaProfValor_.set (evitarReducaoCargaHorariaProfValor_traits::create (i, f, this));
        continue;
      }
    }

    // evitarProfUltimoPrimeiroHor
    //
    if (n.name () == "evitarProfUltimoPrimeiroHor" && n.namespace_ ().empty ())
    {
      if (!evitarProfUltimoPrimeiroHor_.present ())
      {
        this->evitarProfUltimoPrimeiroHor_.set (evitarProfUltimoPrimeiroHor_traits::create (i, f, this));
        continue;
      }
    }

    // preferenciaProfessorDisciplina
    //
    if (n.name () == "preferenciaProfessorDisciplina" && n.namespace_ ().empty ())
    {
      if (!preferenciaProfessorDisciplina_.present ())
      {
        this->preferenciaProfessorDisciplina_.set (preferenciaProfessorDisciplina_traits::create (i, f, this));
        continue;
      }
    }

    // desempenhoProfDisponibilidade
    //
    if (n.name () == "desempenhoProfDisponibilidade" && n.namespace_ ().empty ())
    {
      if (!desempenhoProfDisponibilidade_.present ())
      {
        this->desempenhoProfDisponibilidade_.set (desempenhoProfDisponibilidade_traits::create (i, f, this));
        continue;
      }
    }

    // funcaoObjetivo
    //
    if (n.name () == "funcaoObjetivo" && n.namespace_ ().empty ())
    {
      if (!funcaoObjetivo_.present ())
      {
        this->funcaoObjetivo_.set (funcaoObjetivo_traits::create (i, f, this));
        continue;
      }
    }

    // considerarEquivalencia
    //
    if (n.name () == "considerarEquivalencia" && n.namespace_ ().empty ())
    {
      if (!considerarEquivalencia_.present ())
      {
        this->considerarEquivalencia_.set (considerarEquivalencia_traits::create (i, f, this));
        continue;
      }
    }

    // minAlunosAberturaTurmas
    //
    if (n.name () == "minAlunosAberturaTurmas" && n.namespace_ ().empty ())
    {
      if (!minAlunosAberturaTurmas_.present ())
      {
        this->minAlunosAberturaTurmas_.set (minAlunosAberturaTurmas_traits::create (i, f, this));
        continue;
      }
    }

    // minAlunosAberturaTurmasValor
    //
    if (n.name () == "minAlunosAberturaTurmasValor" && n.namespace_ ().empty ())
    {
      if (!this->minAlunosAberturaTurmasValor_)
      {
        this->minAlunosAberturaTurmasValor_.set (minAlunosAberturaTurmasValor_traits::create (i, f, this));
        continue;
      }
    }

    // niveisDificuldadeHorario
    //
    if (n.name () == "niveisDificuldadeHorario" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< niveisDificuldadeHorario_type > r (
        niveisDificuldadeHorario_traits::create (i, f, this));

      if (!niveisDificuldadeHorario_.present ())
      {
        this->niveisDificuldadeHorario_.set (r);
        continue;
      }
    }

    // equilibrarDiversidadeDiscDia
    //
    if (n.name () == "equilibrarDiversidadeDiscDia" && n.namespace_ ().empty ())
    {
      if (!equilibrarDiversidadeDiscDia_.present ())
      {
        this->equilibrarDiversidadeDiscDia_.set (equilibrarDiversidadeDiscDia_traits::create (i, f, this));
        continue;
      }
    }

    // regrasGenericasDivisaoCredito
    //
    if (n.name () == "regrasGenericasDivisaoCredito" && n.namespace_ ().empty ())
    {
      if (!regrasGenericasDivisaoCredito_.present ())
      {
        this->regrasGenericasDivisaoCredito_.set (regrasGenericasDivisaoCredito_traits::create (i, f, this));
        continue;
      }
    }

    // regrasEspecificasDivisaoCredito
    //
    if (n.name () == "regrasEspecificasDivisaoCredito" && n.namespace_ ().empty ())
    {
      if (!regrasEspecificasDivisaoCredito_.present ())
      {
        this->regrasEspecificasDivisaoCredito_.set (regrasEspecificasDivisaoCredito_traits::create (i, f, this));
        continue;
      }
    }

    // maximizarAvaliacaoCursosSel
    //
    if (n.name () == "maximizarAvaliacaoCursosSel" && n.namespace_ ().empty ())
    {
      if (!maximizarAvaliacaoCursosSel_.present ())
      {
        this->maximizarAvaliacaoCursosSel_.set (maximizarAvaliacaoCursosSel_traits::create (i, f, this));
        continue;
      }
    }

    // maximizarAvaliacaoCursos
    //
    if (n.name () == "maximizarAvaliacaoCursos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< maximizarAvaliacaoCursos_type > r (
        maximizarAvaliacaoCursos_traits::create (i, f, this));

      if (!this->maximizarAvaliacaoCursos_)
      {
        this->maximizarAvaliacaoCursos_.set (r);
        continue;
      }
    }

    // minimizarCustoDocenteCursosSel
    //
    if (n.name () == "minimizarCustoDocenteCursosSel" && n.namespace_ ().empty ())
    {
      if (!minimizarCustoDocenteCursosSel_.present ())
      {
        this->minimizarCustoDocenteCursosSel_.set (minimizarCustoDocenteCursosSel_traits::create (i, f, this));
        continue;
      }
    }

    // minimizarCustoDocenteCursos
    //
    if (n.name () == "minimizarCustoDocenteCursos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< minimizarCustoDocenteCursos_type > r (
        minimizarCustoDocenteCursos_traits::create (i, f, this));

      if (!this->minimizarCustoDocenteCursos_)
      {
        this->minimizarCustoDocenteCursos_.set (r);
        continue;
      }
    }

    // permiteCompartilhamentoTurmaSel
    //
    if (n.name () == "permiteCompartilhamentoTurmaSel" && n.namespace_ ().empty ())
    {
      if (!permiteCompartilhamentoTurmaSel_.present ())
      {
        this->permiteCompartilhamentoTurmaSel_.set (permiteCompartilhamentoTurmaSel_traits::create (i, f, this));
        continue;
      }
    }

    // permiteCompartilhamentoTurma
    //
    if (n.name () == "permiteCompartilhamentoTurma" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< permiteCompartilhamentoTurma_type > r (
        permiteCompartilhamentoTurma_traits::create (i, f, this));

      if (!this->permiteCompartilhamentoTurma_)
      {
        this->permiteCompartilhamentoTurma_.set (r);
        continue;
      }
    }

    // percentuaisMinimoMestres
    //
    if (n.name () == "percentuaisMinimoMestres" && n.namespace_ ().empty ())
    {
      if (!percentuaisMinimoMestres_.present ())
      {
        this->percentuaisMinimoMestres_.set (percentuaisMinimoMestres_traits::create (i, f, this));
        continue;
      }
    }

    // percentuaisMinimoDoutores
    //
    if (n.name () == "percentuaisMinimoDoutores" && n.namespace_ ().empty ())
    {
      if (!percentuaisMinimoDoutores_.present ())
      {
        this->percentuaisMinimoDoutores_.set (percentuaisMinimoDoutores_traits::create (i, f, this));
        continue;
      }
    }

    // areaTitulacaoProfessorCurso
    //
    if (n.name () == "areaTitulacaoProfessorCurso" && n.namespace_ ().empty ())
    {
      if (!areaTitulacaoProfessorCurso_.present ())
      {
        this->areaTitulacaoProfessorCurso_.set (areaTitulacaoProfessorCurso_traits::create (i, f, this));
        continue;
      }
    }

    // maximoDisciplinasDeUmProfessorPorCurso
    //
    if (n.name () == "maximoDisciplinasDeUmProfessorPorCurso" && n.namespace_ ().empty ())
    {
      if (!maximoDisciplinasDeUmProfessorPorCurso_.present ())
      {
        this->maximoDisciplinasDeUmProfessorPorCurso_.set (maximoDisciplinasDeUmProfessorPorCurso_traits::create (i, f, this));
        continue;
      }
    }

    // custoProfDisponibilidade
    //
    if (n.name () == "custoProfDisponibilidade" && n.namespace_ ().empty ())
    {
      if (!custoProfDisponibilidade_.present ())
      {
        this->custoProfDisponibilidade_.set (custoProfDisponibilidade_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!modoOtimizacao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "modoOtimizacao",
      "");
  }

  if (!cargaHorariaSemanalAluno_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cargaHorariaSemanalAluno",
      "");
  }

  if (!alunosMesmoPeriodoNaMesmaSala_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "alunosMesmoPeriodoNaMesmaSala",
      "");
  }

  if (!permitirAlunosEmVariosCampi_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "permitirAlunosEmVariosCampi",
      "");
  }

  if (!minimizarDeslocAluno_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minimizarDeslocAluno",
      "");
  }

  if (!cargaHorariaSemanalProfessor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cargaHorariaSemanalProfessor",
      "");
  }

  if (!permitirProfessorEmVariosCampi_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "permitirProfessorEmVariosCampi",
      "");
  }

  if (!minimizarDeslocProfessor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minimizarDeslocProfessor",
      "");
  }

  if (!minimizarHorariosVaziosProfessor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minimizarHorariosVaziosProfessor",
      "");
  }

  if (!evitarReducaoCargaHorariaProf_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "evitarReducaoCargaHorariaProf",
      "");
  }

  if (!evitarProfUltimoPrimeiroHor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "evitarProfUltimoPrimeiroHor",
      "");
  }

  if (!preferenciaProfessorDisciplina_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "preferenciaProfessorDisciplina",
      "");
  }

  if (!desempenhoProfDisponibilidade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "desempenhoProfDisponibilidade",
      "");
  }

  if (!funcaoObjetivo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "funcaoObjetivo",
      "");
  }

  if (!considerarEquivalencia_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "considerarEquivalencia",
      "");
  }

  if (!minAlunosAberturaTurmas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minAlunosAberturaTurmas",
      "");
  }

  if (!niveisDificuldadeHorario_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "niveisDificuldadeHorario",
      "");
  }

  if (!equilibrarDiversidadeDiscDia_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "equilibrarDiversidadeDiscDia",
      "");
  }

  if (!regrasGenericasDivisaoCredito_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "regrasGenericasDivisaoCredito",
      "");
  }

  if (!regrasEspecificasDivisaoCredito_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "regrasEspecificasDivisaoCredito",
      "");
  }

  if (!maximizarAvaliacaoCursosSel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maximizarAvaliacaoCursosSel",
      "");
  }

  if (!minimizarCustoDocenteCursosSel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minimizarCustoDocenteCursosSel",
      "");
  }

  if (!permiteCompartilhamentoTurmaSel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "permiteCompartilhamentoTurmaSel",
      "");
  }

  if (!percentuaisMinimoMestres_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "percentuaisMinimoMestres",
      "");
  }

  if (!percentuaisMinimoDoutores_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "percentuaisMinimoDoutores",
      "");
  }

  if (!areaTitulacaoProfessorCurso_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "areaTitulacaoProfessorCurso",
      "");
  }

  if (!maximoDisciplinasDeUmProfessorPorCurso_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maximoDisciplinasDeUmProfessorPorCurso",
      "");
  }

  if (!custoProfDisponibilidade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "custoProfDisponibilidade",
      "");
  }
}

ItemParametrosPlanejamento* ItemParametrosPlanejamento::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemParametrosPlanejamento (*this, f, c);
}

ItemParametrosPlanejamento::
~ItemParametrosPlanejamento ()
{
}

// ItemNivelDificuldadeHorario
//

ItemNivelDificuldadeHorario::
ItemNivelDificuldadeHorario (const nivelDificuldadeId_type& nivelDificuldadeId,
                             const horariosAula_type& horariosAula)
: ::xml_schema::type (),
  nivelDificuldadeId_ (nivelDificuldadeId, ::xml_schema::flags (), this),
  horariosAula_ (horariosAula, ::xml_schema::flags (), this)
{
}

ItemNivelDificuldadeHorario::
ItemNivelDificuldadeHorario (const nivelDificuldadeId_type& nivelDificuldadeId,
                             ::std::auto_ptr< horariosAula_type >& horariosAula)
: ::xml_schema::type (),
  nivelDificuldadeId_ (nivelDificuldadeId, ::xml_schema::flags (), this),
  horariosAula_ (horariosAula, ::xml_schema::flags (), this)
{
}

ItemNivelDificuldadeHorario::
ItemNivelDificuldadeHorario (const ItemNivelDificuldadeHorario& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  nivelDificuldadeId_ (x.nivelDificuldadeId_, f, this),
  horariosAula_ (x.horariosAula_, f, this)
{
}

ItemNivelDificuldadeHorario::
ItemNivelDificuldadeHorario (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  nivelDificuldadeId_ (f, this),
  horariosAula_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemNivelDificuldadeHorario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // nivelDificuldadeId
    //
    if (n.name () == "nivelDificuldadeId" && n.namespace_ ().empty ())
    {
      if (!nivelDificuldadeId_.present ())
      {
        this->nivelDificuldadeId_.set (nivelDificuldadeId_traits::create (i, f, this));
        continue;
      }
    }

    // horariosAula
    //
    if (n.name () == "horariosAula" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horariosAula_type > r (
        horariosAula_traits::create (i, f, this));

      if (!horariosAula_.present ())
      {
        this->horariosAula_.set (r);
        continue;
      }
    }

    break;
  }

  if (!nivelDificuldadeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nivelDificuldadeId",
      "");
  }

  if (!horariosAula_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horariosAula",
      "");
  }
}

ItemNivelDificuldadeHorario* ItemNivelDificuldadeHorario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemNivelDificuldadeHorario (*this, f, c);
}

ItemNivelDificuldadeHorario::
~ItemNivelDificuldadeHorario ()
{
}

// GrupoCalendario
//

GrupoCalendario::
GrupoCalendario ()
: ::xml_schema::type (),
  Calendario_ (::xml_schema::flags (), this)
{
}

GrupoCalendario::
GrupoCalendario (const GrupoCalendario& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Calendario_ (x.Calendario_, f, this)
{
}

GrupoCalendario::
GrupoCalendario (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Calendario_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoCalendario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Calendario
    //
    if (n.name () == "Calendario" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Calendario_type > r (
        Calendario_traits::create (i, f, this));

      this->Calendario_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoCalendario* GrupoCalendario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoCalendario (*this, f, c);
}

GrupoCalendario::
~GrupoCalendario ()
{
}

// GrupoAlunoDemanda
//

GrupoAlunoDemanda::
GrupoAlunoDemanda ()
: ::xml_schema::type (),
  AlunoDemanda_ (::xml_schema::flags (), this)
{
}

GrupoAlunoDemanda::
GrupoAlunoDemanda (const GrupoAlunoDemanda& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AlunoDemanda_ (x.AlunoDemanda_, f, this)
{
}

GrupoAlunoDemanda::
GrupoAlunoDemanda (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AlunoDemanda_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoAlunoDemanda::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AlunoDemanda
    //
    if (n.name () == "AlunoDemanda" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AlunoDemanda_type > r (
        AlunoDemanda_traits::create (i, f, this));

      this->AlunoDemanda_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoAlunoDemanda* GrupoAlunoDemanda::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoAlunoDemanda (*this, f, c);
}

GrupoAlunoDemanda::
~GrupoAlunoDemanda ()
{
}

// GrupoTurno
//

GrupoTurno::
GrupoTurno ()
: ::xml_schema::type (),
  Turno_ (::xml_schema::flags (), this)
{
}

GrupoTurno::
GrupoTurno (const GrupoTurno& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Turno_ (x.Turno_, f, this)
{
}

GrupoTurno::
GrupoTurno (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Turno_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoTurno::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Turno
    //
    if (n.name () == "Turno" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Turno_type > r (
        Turno_traits::create (i, f, this));

      this->Turno_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoTurno* GrupoTurno::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoTurno (*this, f, c);
}

GrupoTurno::
~GrupoTurno ()
{
}

// GrupoHorarioAula
//

GrupoHorarioAula::
GrupoHorarioAula ()
: ::xml_schema::type (),
  HorarioAula_ (::xml_schema::flags (), this)
{
}

GrupoHorarioAula::
GrupoHorarioAula (const GrupoHorarioAula& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  HorarioAula_ (x.HorarioAula_, f, this)
{
}

GrupoHorarioAula::
GrupoHorarioAula (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  HorarioAula_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoHorarioAula::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // HorarioAula
    //
    if (n.name () == "HorarioAula" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HorarioAula_type > r (
        HorarioAula_traits::create (i, f, this));

      this->HorarioAula_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoHorarioAula* GrupoHorarioAula::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoHorarioAula (*this, f, c);
}

GrupoHorarioAula::
~GrupoHorarioAula ()
{
}

// GrupoDiaSemana
//

GrupoDiaSemana::
GrupoDiaSemana ()
: ::xml_schema::type (),
  diaSemana_ (::xml_schema::flags (), this)
{
}

GrupoDiaSemana::
GrupoDiaSemana (const GrupoDiaSemana& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  diaSemana_ (x.diaSemana_, f, this)
{
}

GrupoDiaSemana::
GrupoDiaSemana (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  diaSemana_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDiaSemana::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // diaSemana
    //
    if (n.name () == "diaSemana" && n.namespace_ ().empty ())
    {
      this->diaSemana_.push_back (diaSemana_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

GrupoDiaSemana* GrupoDiaSemana::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDiaSemana (*this, f, c);
}

GrupoDiaSemana::
~GrupoDiaSemana ()
{
}

// GrupoTipoSala
//

GrupoTipoSala::
GrupoTipoSala ()
: ::xml_schema::type (),
  TipoSala_ (::xml_schema::flags (), this)
{
}

GrupoTipoSala::
GrupoTipoSala (const GrupoTipoSala& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TipoSala_ (x.TipoSala_, f, this)
{
}

GrupoTipoSala::
GrupoTipoSala (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TipoSala_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoTipoSala::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TipoSala
    //
    if (n.name () == "TipoSala" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TipoSala_type > r (
        TipoSala_traits::create (i, f, this));

      this->TipoSala_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoTipoSala* GrupoTipoSala::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoTipoSala (*this, f, c);
}

GrupoTipoSala::
~GrupoTipoSala ()
{
}

// GrupoTipoContrato
//

GrupoTipoContrato::
GrupoTipoContrato ()
: ::xml_schema::type (),
  TipoContrato_ (::xml_schema::flags (), this)
{
}

GrupoTipoContrato::
GrupoTipoContrato (const GrupoTipoContrato& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TipoContrato_ (x.TipoContrato_, f, this)
{
}

GrupoTipoContrato::
GrupoTipoContrato (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TipoContrato_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoTipoContrato::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TipoContrato
    //
    if (n.name () == "TipoContrato" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TipoContrato_type > r (
        TipoContrato_traits::create (i, f, this));

      this->TipoContrato_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoTipoContrato* GrupoTipoContrato::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoTipoContrato (*this, f, c);
}

GrupoTipoContrato::
~GrupoTipoContrato ()
{
}

// GrupoTipoTitulacao
//

GrupoTipoTitulacao::
GrupoTipoTitulacao ()
: ::xml_schema::type (),
  TipoTitulacao_ (::xml_schema::flags (), this)
{
}

GrupoTipoTitulacao::
GrupoTipoTitulacao (const GrupoTipoTitulacao& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TipoTitulacao_ (x.TipoTitulacao_, f, this)
{
}

GrupoTipoTitulacao::
GrupoTipoTitulacao (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TipoTitulacao_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoTipoTitulacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TipoTitulacao
    //
    if (n.name () == "TipoTitulacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TipoTitulacao_type > r (
        TipoTitulacao_traits::create (i, f, this));

      this->TipoTitulacao_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoTipoTitulacao* GrupoTipoTitulacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoTipoTitulacao (*this, f, c);
}

GrupoTipoTitulacao::
~GrupoTipoTitulacao ()
{
}

// GrupoAreaTitulacao
//

GrupoAreaTitulacao::
GrupoAreaTitulacao ()
: ::xml_schema::type (),
  AreaTitulacao_ (::xml_schema::flags (), this)
{
}

GrupoAreaTitulacao::
GrupoAreaTitulacao (const GrupoAreaTitulacao& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AreaTitulacao_ (x.AreaTitulacao_, f, this)
{
}

GrupoAreaTitulacao::
GrupoAreaTitulacao (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AreaTitulacao_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoAreaTitulacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AreaTitulacao
    //
    if (n.name () == "AreaTitulacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AreaTitulacao_type > r (
        AreaTitulacao_traits::create (i, f, this));

      this->AreaTitulacao_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoAreaTitulacao* GrupoAreaTitulacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoAreaTitulacao (*this, f, c);
}

GrupoAreaTitulacao::
~GrupoAreaTitulacao ()
{
}

// GrupoTipoDisciplina
//

GrupoTipoDisciplina::
GrupoTipoDisciplina ()
: ::xml_schema::type (),
  TipoDisciplina_ (::xml_schema::flags (), this)
{
}

GrupoTipoDisciplina::
GrupoTipoDisciplina (const GrupoTipoDisciplina& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TipoDisciplina_ (x.TipoDisciplina_, f, this)
{
}

GrupoTipoDisciplina::
GrupoTipoDisciplina (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TipoDisciplina_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoTipoDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TipoDisciplina
    //
    if (n.name () == "TipoDisciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TipoDisciplina_type > r (
        TipoDisciplina_traits::create (i, f, this));

      this->TipoDisciplina_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoTipoDisciplina* GrupoTipoDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoTipoDisciplina (*this, f, c);
}

GrupoTipoDisciplina::
~GrupoTipoDisciplina ()
{
}

// GrupoNivelDificuldade
//

GrupoNivelDificuldade::
GrupoNivelDificuldade ()
: ::xml_schema::type (),
  NivelDificuldade_ (::xml_schema::flags (), this)
{
}

GrupoNivelDificuldade::
GrupoNivelDificuldade (const GrupoNivelDificuldade& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NivelDificuldade_ (x.NivelDificuldade_, f, this)
{
}

GrupoNivelDificuldade::
GrupoNivelDificuldade (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NivelDificuldade_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoNivelDificuldade::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NivelDificuldade
    //
    if (n.name () == "NivelDificuldade" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NivelDificuldade_type > r (
        NivelDificuldade_traits::create (i, f, this));

      this->NivelDificuldade_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoNivelDificuldade* GrupoNivelDificuldade::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoNivelDificuldade (*this, f, c);
}

GrupoNivelDificuldade::
~GrupoNivelDificuldade ()
{
}

// GrupoTipoCurso
//

GrupoTipoCurso::
GrupoTipoCurso ()
: ::xml_schema::type (),
  TipoCurso_ (::xml_schema::flags (), this)
{
}

GrupoTipoCurso::
GrupoTipoCurso (const GrupoTipoCurso& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TipoCurso_ (x.TipoCurso_, f, this)
{
}

GrupoTipoCurso::
GrupoTipoCurso (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TipoCurso_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoTipoCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TipoCurso
    //
    if (n.name () == "TipoCurso" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TipoCurso_type > r (
        TipoCurso_traits::create (i, f, this));

      this->TipoCurso_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoTipoCurso* GrupoTipoCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoTipoCurso (*this, f, c);
}

GrupoTipoCurso::
~GrupoTipoCurso ()
{
}

// GrupoDivisaoCreditos
//

GrupoDivisaoCreditos::
GrupoDivisaoCreditos ()
: ::xml_schema::type (),
  DivisaoCreditos_ (::xml_schema::flags (), this)
{
}

GrupoDivisaoCreditos::
GrupoDivisaoCreditos (const GrupoDivisaoCreditos& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DivisaoCreditos_ (x.DivisaoCreditos_, f, this)
{
}

GrupoDivisaoCreditos::
GrupoDivisaoCreditos (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DivisaoCreditos_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDivisaoCreditos::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DivisaoCreditos
    //
    if (n.name () == "DivisaoCreditos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DivisaoCreditos_type > r (
        DivisaoCreditos_traits::create (i, f, this));

      this->DivisaoCreditos_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDivisaoCreditos* GrupoDivisaoCreditos::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDivisaoCreditos (*this, f, c);
}

GrupoDivisaoCreditos::
~GrupoDivisaoCreditos ()
{
}

// GrupoCampus
//

GrupoCampus::
GrupoCampus ()
: ::xml_schema::type (),
  Campus_ (::xml_schema::flags (), this)
{
}

GrupoCampus::
GrupoCampus (const GrupoCampus& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Campus_ (x.Campus_, f, this)
{
}

GrupoCampus::
GrupoCampus (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Campus_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoCampus::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Campus
    //
    if (n.name () == "Campus" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Campus_type > r (
        Campus_traits::create (i, f, this));

      this->Campus_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoCampus* GrupoCampus::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoCampus (*this, f, c);
}

GrupoCampus::
~GrupoCampus ()
{
}

// GrupoUnidade
//

GrupoUnidade::
GrupoUnidade ()
: ::xml_schema::type (),
  Unidade_ (::xml_schema::flags (), this)
{
}

GrupoUnidade::
GrupoUnidade (const GrupoUnidade& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Unidade_ (x.Unidade_, f, this)
{
}

GrupoUnidade::
GrupoUnidade (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Unidade_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoUnidade::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Unidade
    //
    if (n.name () == "Unidade" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Unidade_type > r (
        Unidade_traits::create (i, f, this));

      this->Unidade_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoUnidade* GrupoUnidade::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoUnidade (*this, f, c);
}

GrupoUnidade::
~GrupoUnidade ()
{
}

// GrupoHorario
//

GrupoHorario::
GrupoHorario ()
: ::xml_schema::type (),
  Horario_ (::xml_schema::flags (), this)
{
}

GrupoHorario::
GrupoHorario (const GrupoHorario& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Horario_ (x.Horario_, f, this)
{
}

GrupoHorario::
GrupoHorario (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Horario_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoHorario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Horario
    //
    if (n.name () == "Horario" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Horario_type > r (
        Horario_traits::create (i, f, this));

      this->Horario_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoHorario* GrupoHorario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoHorario (*this, f, c);
}

GrupoHorario::
~GrupoHorario ()
{
}

// GrupoSala
//

GrupoSala::
GrupoSala ()
: ::xml_schema::type (),
  Sala_ (::xml_schema::flags (), this)
{
}

GrupoSala::
GrupoSala (const GrupoSala& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Sala_ (x.Sala_, f, this)
{
}

GrupoSala::
GrupoSala (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Sala_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoSala::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Sala
    //
    if (n.name () == "Sala" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sala_type > r (
        Sala_traits::create (i, f, this));

      this->Sala_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoSala* GrupoSala::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoSala (*this, f, c);
}

GrupoSala::
~GrupoSala ()
{
}

// GrupoCreditoDisponivel
//

GrupoCreditoDisponivel::
GrupoCreditoDisponivel ()
: ::xml_schema::type (),
  CreditoDisponivel_ (::xml_schema::flags (), this)
{
}

GrupoCreditoDisponivel::
GrupoCreditoDisponivel (const GrupoCreditoDisponivel& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  CreditoDisponivel_ (x.CreditoDisponivel_, f, this)
{
}

GrupoCreditoDisponivel::
GrupoCreditoDisponivel (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  CreditoDisponivel_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoCreditoDisponivel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CreditoDisponivel
    //
    if (n.name () == "CreditoDisponivel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< CreditoDisponivel_type > r (
        CreditoDisponivel_traits::create (i, f, this));

      this->CreditoDisponivel_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoCreditoDisponivel* GrupoCreditoDisponivel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoCreditoDisponivel (*this, f, c);
}

GrupoCreditoDisponivel::
~GrupoCreditoDisponivel ()
{
}

// GrupoProfessor
//

GrupoProfessor::
GrupoProfessor ()
: ::xml_schema::type (),
  Professor_ (::xml_schema::flags (), this)
{
}

GrupoProfessor::
GrupoProfessor (const GrupoProfessor& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Professor_ (x.Professor_, f, this)
{
}

GrupoProfessor::
GrupoProfessor (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Professor_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoProfessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Professor
    //
    if (n.name () == "Professor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Professor_type > r (
        Professor_traits::create (i, f, this));

      this->Professor_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoProfessor* GrupoProfessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoProfessor (*this, f, c);
}

GrupoProfessor::
~GrupoProfessor ()
{
}

// GrupoProfessorDisciplina
//

GrupoProfessorDisciplina::
GrupoProfessorDisciplina ()
: ::xml_schema::type (),
  ProfessorDisciplina_ (::xml_schema::flags (), this)
{
}

GrupoProfessorDisciplina::
GrupoProfessorDisciplina (const GrupoProfessorDisciplina& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ProfessorDisciplina_ (x.ProfessorDisciplina_, f, this)
{
}

GrupoProfessorDisciplina::
GrupoProfessorDisciplina (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ProfessorDisciplina_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoProfessorDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ProfessorDisciplina
    //
    if (n.name () == "ProfessorDisciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ProfessorDisciplina_type > r (
        ProfessorDisciplina_traits::create (i, f, this));

      this->ProfessorDisciplina_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoProfessorDisciplina* GrupoProfessorDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoProfessorDisciplina (*this, f, c);
}

GrupoProfessorDisciplina::
~GrupoProfessorDisciplina ()
{
}

// GrupoDeslocamento
//

GrupoDeslocamento::
GrupoDeslocamento ()
: ::xml_schema::type (),
  Deslocamento_ (::xml_schema::flags (), this)
{
}

GrupoDeslocamento::
GrupoDeslocamento (const GrupoDeslocamento& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Deslocamento_ (x.Deslocamento_, f, this)
{
}

GrupoDeslocamento::
GrupoDeslocamento (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Deslocamento_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDeslocamento::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Deslocamento
    //
    if (n.name () == "Deslocamento" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Deslocamento_type > r (
        Deslocamento_traits::create (i, f, this));

      this->Deslocamento_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDeslocamento* GrupoDeslocamento::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDeslocamento (*this, f, c);
}

GrupoDeslocamento::
~GrupoDeslocamento ()
{
}

// GrupoDisciplina
//

GrupoDisciplina::
GrupoDisciplina ()
: ::xml_schema::type (),
  Disciplina_ (::xml_schema::flags (), this)
{
}

GrupoDisciplina::
GrupoDisciplina (const GrupoDisciplina& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Disciplina_ (x.Disciplina_, f, this)
{
}

GrupoDisciplina::
GrupoDisciplina (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Disciplina_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Disciplina
    //
    if (n.name () == "Disciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Disciplina_type > r (
        Disciplina_traits::create (i, f, this));

      this->Disciplina_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDisciplina* GrupoDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDisciplina (*this, f, c);
}

GrupoDisciplina::
~GrupoDisciplina ()
{
}

// GrupoCurso
//

GrupoCurso::
GrupoCurso ()
: ::xml_schema::type (),
  Curso_ (::xml_schema::flags (), this)
{
}

GrupoCurso::
GrupoCurso (const GrupoCurso& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Curso_ (x.Curso_, f, this)
{
}

GrupoCurso::
GrupoCurso (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Curso_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Curso
    //
    if (n.name () == "Curso" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Curso_type > r (
        Curso_traits::create (i, f, this));

      this->Curso_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoCurso* GrupoCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoCurso (*this, f, c);
}

GrupoCurso::
~GrupoCurso ()
{
}

// GrupoCurriculo
//

GrupoCurriculo::
GrupoCurriculo ()
: ::xml_schema::type (),
  Curriculo_ (::xml_schema::flags (), this)
{
}

GrupoCurriculo::
GrupoCurriculo (const GrupoCurriculo& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Curriculo_ (x.Curriculo_, f, this)
{
}

GrupoCurriculo::
GrupoCurriculo (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Curriculo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoCurriculo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Curriculo
    //
    if (n.name () == "Curriculo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Curriculo_type > r (
        Curriculo_traits::create (i, f, this));

      this->Curriculo_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoCurriculo* GrupoCurriculo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoCurriculo (*this, f, c);
}

GrupoCurriculo::
~GrupoCurriculo ()
{
}

// GrupoDisciplinaPeriodo
//

GrupoDisciplinaPeriodo::
GrupoDisciplinaPeriodo ()
: ::xml_schema::type (),
  DisciplinaPeriodo_ (::xml_schema::flags (), this)
{
}

GrupoDisciplinaPeriodo::
GrupoDisciplinaPeriodo (const GrupoDisciplinaPeriodo& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DisciplinaPeriodo_ (x.DisciplinaPeriodo_, f, this)
{
}

GrupoDisciplinaPeriodo::
GrupoDisciplinaPeriodo (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DisciplinaPeriodo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDisciplinaPeriodo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DisciplinaPeriodo
    //
    if (n.name () == "DisciplinaPeriodo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DisciplinaPeriodo_type > r (
        DisciplinaPeriodo_traits::create (i, f, this));

      this->DisciplinaPeriodo_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDisciplinaPeriodo* GrupoDisciplinaPeriodo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDisciplinaPeriodo (*this, f, c);
}

GrupoDisciplinaPeriodo::
~GrupoDisciplinaPeriodo ()
{
}

// GrupoOfertaCurso
//

GrupoOfertaCurso::
GrupoOfertaCurso ()
: ::xml_schema::type (),
  OfertaCurso_ (::xml_schema::flags (), this)
{
}

GrupoOfertaCurso::
GrupoOfertaCurso (const GrupoOfertaCurso& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  OfertaCurso_ (x.OfertaCurso_, f, this)
{
}

GrupoOfertaCurso::
GrupoOfertaCurso (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  OfertaCurso_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoOfertaCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // OfertaCurso
    //
    if (n.name () == "OfertaCurso" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OfertaCurso_type > r (
        OfertaCurso_traits::create (i, f, this));

      this->OfertaCurso_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoOfertaCurso* GrupoOfertaCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoOfertaCurso (*this, f, c);
}

GrupoOfertaCurso::
~GrupoOfertaCurso ()
{
}

// GrupoDemanda
//

GrupoDemanda::
GrupoDemanda ()
: ::xml_schema::type (),
  Demanda_ (::xml_schema::flags (), this)
{
}

GrupoDemanda::
GrupoDemanda (const GrupoDemanda& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Demanda_ (x.Demanda_, f, this)
{
}

GrupoDemanda::
GrupoDemanda (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Demanda_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDemanda::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Demanda
    //
    if (n.name () == "Demanda" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Demanda_type > r (
        Demanda_traits::create (i, f, this));

      this->Demanda_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDemanda* GrupoDemanda::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDemanda (*this, f, c);
}

GrupoDemanda::
~GrupoDemanda ()
{
}

// GrupoFixacao
//

GrupoFixacao::
GrupoFixacao ()
: ::xml_schema::type (),
  Fixacao_ (::xml_schema::flags (), this)
{
}

GrupoFixacao::
GrupoFixacao (const GrupoFixacao& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Fixacao_ (x.Fixacao_, f, this)
{
}

GrupoFixacao::
GrupoFixacao (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Fixacao_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoFixacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fixacao
    //
    if (n.name () == "Fixacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Fixacao_type > r (
        Fixacao_traits::create (i, f, this));

      this->Fixacao_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoFixacao* GrupoFixacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoFixacao (*this, f, c);
}

GrupoFixacao::
~GrupoFixacao ()
{
}

// GrupoNivelDificuldadeHorario
//

GrupoNivelDificuldadeHorario::
GrupoNivelDificuldadeHorario ()
: ::xml_schema::type (),
  NivelDificuldadeHorario_ (::xml_schema::flags (), this)
{
}

GrupoNivelDificuldadeHorario::
GrupoNivelDificuldadeHorario (const GrupoNivelDificuldadeHorario& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NivelDificuldadeHorario_ (x.NivelDificuldadeHorario_, f, this)
{
}

GrupoNivelDificuldadeHorario::
GrupoNivelDificuldadeHorario (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NivelDificuldadeHorario_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoNivelDificuldadeHorario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NivelDificuldadeHorario
    //
    if (n.name () == "NivelDificuldadeHorario" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NivelDificuldadeHorario_type > r (
        NivelDificuldadeHorario_traits::create (i, f, this));

      this->NivelDificuldadeHorario_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoNivelDificuldadeHorario* GrupoNivelDificuldadeHorario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoNivelDificuldadeHorario (*this, f, c);
}

GrupoNivelDificuldadeHorario::
~GrupoNivelDificuldadeHorario ()
{
}

// GrupoIdentificador
//

GrupoIdentificador::
GrupoIdentificador ()
: ::xml_schema::type (),
  id_ (::xml_schema::flags (), this)
{
}

GrupoIdentificador::
GrupoIdentificador (const GrupoIdentificador& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this)
{
}

GrupoIdentificador::
GrupoIdentificador (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoIdentificador::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.push_back (id_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

GrupoIdentificador* GrupoIdentificador::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoIdentificador (*this, f, c);
}

GrupoIdentificador::
~GrupoIdentificador ()
{
}

// GrupoGrupo
//

GrupoGrupo::
GrupoGrupo ()
: ::xml_schema::type (),
  GrupoIdentificador_ (::xml_schema::flags (), this)
{
}

GrupoGrupo::
GrupoGrupo (const GrupoGrupo& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  GrupoIdentificador_ (x.GrupoIdentificador_, f, this)
{
}

GrupoGrupo::
GrupoGrupo (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  GrupoIdentificador_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoGrupo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GrupoIdentificador
    //
    if (n.name () == "GrupoIdentificador" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< GrupoIdentificador_type > r (
        GrupoIdentificador_traits::create (i, f, this));

      this->GrupoIdentificador_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoGrupo* GrupoGrupo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoGrupo (*this, f, c);
}

GrupoGrupo::
~GrupoGrupo ()
{
}

// ItemAtendimentoCampusSolucao
//

ItemAtendimentoCampusSolucao::
ItemAtendimentoCampusSolucao (const campusId_type& campusId,
                              const campusCodigo_type& campusCodigo,
                              const atendimentosUnidades_type& atendimentosUnidades)
: ::xml_schema::type (),
  campusId_ (campusId, ::xml_schema::flags (), this),
  campusCodigo_ (campusCodigo, ::xml_schema::flags (), this),
  atendimentosUnidades_ (atendimentosUnidades, ::xml_schema::flags (), this)
{
}

ItemAtendimentoCampusSolucao::
ItemAtendimentoCampusSolucao (const campusId_type& campusId,
                              const campusCodigo_type& campusCodigo,
                              ::std::auto_ptr< atendimentosUnidades_type >& atendimentosUnidades)
: ::xml_schema::type (),
  campusId_ (campusId, ::xml_schema::flags (), this),
  campusCodigo_ (campusCodigo, ::xml_schema::flags (), this),
  atendimentosUnidades_ (atendimentosUnidades, ::xml_schema::flags (), this)
{
}

ItemAtendimentoCampusSolucao::
ItemAtendimentoCampusSolucao (const ItemAtendimentoCampusSolucao& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  campusId_ (x.campusId_, f, this),
  campusCodigo_ (x.campusCodigo_, f, this),
  atendimentosUnidades_ (x.atendimentosUnidades_, f, this)
{
}

ItemAtendimentoCampusSolucao::
ItemAtendimentoCampusSolucao (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  campusId_ (f, this),
  campusCodigo_ (f, this),
  atendimentosUnidades_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAtendimentoCampusSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // campusId
    //
    if (n.name () == "campusId" && n.namespace_ ().empty ())
    {
      if (!campusId_.present ())
      {
        this->campusId_.set (campusId_traits::create (i, f, this));
        continue;
      }
    }

    // campusCodigo
    //
    if (n.name () == "campusCodigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< campusCodigo_type > r (
        campusCodigo_traits::create (i, f, this));

      if (!campusCodigo_.present ())
      {
        this->campusCodigo_.set (r);
        continue;
      }
    }

    // atendimentosUnidades
    //
    if (n.name () == "atendimentosUnidades" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< atendimentosUnidades_type > r (
        atendimentosUnidades_traits::create (i, f, this));

      if (!atendimentosUnidades_.present ())
      {
        this->atendimentosUnidades_.set (r);
        continue;
      }
    }

    break;
  }

  if (!campusId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "campusId",
      "");
  }

  if (!campusCodigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "campusCodigo",
      "");
  }

  if (!atendimentosUnidades_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "atendimentosUnidades",
      "");
  }
}

ItemAtendimentoCampusSolucao* ItemAtendimentoCampusSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAtendimentoCampusSolucao (*this, f, c);
}

ItemAtendimentoCampusSolucao::
~ItemAtendimentoCampusSolucao ()
{
}

// ItemAtendimentoUnidadeSolucao
//

ItemAtendimentoUnidadeSolucao::
ItemAtendimentoUnidadeSolucao (const unidadeId_type& unidadeId,
                               const unidadeCodigo_type& unidadeCodigo,
                               const atendimentosSalas_type& atendimentosSalas)
: ::xml_schema::type (),
  unidadeId_ (unidadeId, ::xml_schema::flags (), this),
  unidadeCodigo_ (unidadeCodigo, ::xml_schema::flags (), this),
  atendimentosSalas_ (atendimentosSalas, ::xml_schema::flags (), this)
{
}

ItemAtendimentoUnidadeSolucao::
ItemAtendimentoUnidadeSolucao (const unidadeId_type& unidadeId,
                               const unidadeCodigo_type& unidadeCodigo,
                               ::std::auto_ptr< atendimentosSalas_type >& atendimentosSalas)
: ::xml_schema::type (),
  unidadeId_ (unidadeId, ::xml_schema::flags (), this),
  unidadeCodigo_ (unidadeCodigo, ::xml_schema::flags (), this),
  atendimentosSalas_ (atendimentosSalas, ::xml_schema::flags (), this)
{
}

ItemAtendimentoUnidadeSolucao::
ItemAtendimentoUnidadeSolucao (const ItemAtendimentoUnidadeSolucao& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  unidadeId_ (x.unidadeId_, f, this),
  unidadeCodigo_ (x.unidadeCodigo_, f, this),
  atendimentosSalas_ (x.atendimentosSalas_, f, this)
{
}

ItemAtendimentoUnidadeSolucao::
ItemAtendimentoUnidadeSolucao (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  unidadeId_ (f, this),
  unidadeCodigo_ (f, this),
  atendimentosSalas_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAtendimentoUnidadeSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // unidadeId
    //
    if (n.name () == "unidadeId" && n.namespace_ ().empty ())
    {
      if (!unidadeId_.present ())
      {
        this->unidadeId_.set (unidadeId_traits::create (i, f, this));
        continue;
      }
    }

    // unidadeCodigo
    //
    if (n.name () == "unidadeCodigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< unidadeCodigo_type > r (
        unidadeCodigo_traits::create (i, f, this));

      if (!unidadeCodigo_.present ())
      {
        this->unidadeCodigo_.set (r);
        continue;
      }
    }

    // atendimentosSalas
    //
    if (n.name () == "atendimentosSalas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< atendimentosSalas_type > r (
        atendimentosSalas_traits::create (i, f, this));

      if (!atendimentosSalas_.present ())
      {
        this->atendimentosSalas_.set (r);
        continue;
      }
    }

    break;
  }

  if (!unidadeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "unidadeId",
      "");
  }

  if (!unidadeCodigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "unidadeCodigo",
      "");
  }

  if (!atendimentosSalas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "atendimentosSalas",
      "");
  }
}

ItemAtendimentoUnidadeSolucao* ItemAtendimentoUnidadeSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAtendimentoUnidadeSolucao (*this, f, c);
}

ItemAtendimentoUnidadeSolucao::
~ItemAtendimentoUnidadeSolucao ()
{
}

// ItemAtendimentoSalaSolucao
//

ItemAtendimentoSalaSolucao::
ItemAtendimentoSalaSolucao (const salaId_type& salaId,
                            const salaNome_type& salaNome,
                            const atendimentosDiasSemana_type& atendimentosDiasSemana)
: ::xml_schema::type (),
  salaId_ (salaId, ::xml_schema::flags (), this),
  salaNome_ (salaNome, ::xml_schema::flags (), this),
  atendimentosDiasSemana_ (atendimentosDiasSemana, ::xml_schema::flags (), this)
{
}

ItemAtendimentoSalaSolucao::
ItemAtendimentoSalaSolucao (const salaId_type& salaId,
                            const salaNome_type& salaNome,
                            ::std::auto_ptr< atendimentosDiasSemana_type >& atendimentosDiasSemana)
: ::xml_schema::type (),
  salaId_ (salaId, ::xml_schema::flags (), this),
  salaNome_ (salaNome, ::xml_schema::flags (), this),
  atendimentosDiasSemana_ (atendimentosDiasSemana, ::xml_schema::flags (), this)
{
}

ItemAtendimentoSalaSolucao::
ItemAtendimentoSalaSolucao (const ItemAtendimentoSalaSolucao& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  salaId_ (x.salaId_, f, this),
  salaNome_ (x.salaNome_, f, this),
  atendimentosDiasSemana_ (x.atendimentosDiasSemana_, f, this)
{
}

ItemAtendimentoSalaSolucao::
ItemAtendimentoSalaSolucao (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  salaId_ (f, this),
  salaNome_ (f, this),
  atendimentosDiasSemana_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAtendimentoSalaSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // salaId
    //
    if (n.name () == "salaId" && n.namespace_ ().empty ())
    {
      if (!salaId_.present ())
      {
        this->salaId_.set (salaId_traits::create (i, f, this));
        continue;
      }
    }

    // salaNome
    //
    if (n.name () == "salaNome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< salaNome_type > r (
        salaNome_traits::create (i, f, this));

      if (!salaNome_.present ())
      {
        this->salaNome_.set (r);
        continue;
      }
    }

    // atendimentosDiasSemana
    //
    if (n.name () == "atendimentosDiasSemana" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< atendimentosDiasSemana_type > r (
        atendimentosDiasSemana_traits::create (i, f, this));

      if (!atendimentosDiasSemana_.present ())
      {
        this->atendimentosDiasSemana_.set (r);
        continue;
      }
    }

    break;
  }

  if (!salaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "salaId",
      "");
  }

  if (!salaNome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "salaNome",
      "");
  }

  if (!atendimentosDiasSemana_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "atendimentosDiasSemana",
      "");
  }
}

ItemAtendimentoSalaSolucao* ItemAtendimentoSalaSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAtendimentoSalaSolucao (*this, f, c);
}

ItemAtendimentoSalaSolucao::
~ItemAtendimentoSalaSolucao ()
{
}

// ItemAtendimentoDiaSemanaSolucao
//

ItemAtendimentoDiaSemanaSolucao::
ItemAtendimentoDiaSemanaSolucao (const diaSemana_type& diaSemana,
                                 const atendimentosTatico_type& atendimentosTatico)
: ::xml_schema::type (),
  diaSemana_ (diaSemana, ::xml_schema::flags (), this),
  atendimentosTatico_ (atendimentosTatico, ::xml_schema::flags (), this)
{
}

ItemAtendimentoDiaSemanaSolucao::
ItemAtendimentoDiaSemanaSolucao (const diaSemana_type& diaSemana,
                                 ::std::auto_ptr< atendimentosTatico_type >& atendimentosTatico)
: ::xml_schema::type (),
  diaSemana_ (diaSemana, ::xml_schema::flags (), this),
  atendimentosTatico_ (atendimentosTatico, ::xml_schema::flags (), this)
{
}

ItemAtendimentoDiaSemanaSolucao::
ItemAtendimentoDiaSemanaSolucao (const ItemAtendimentoDiaSemanaSolucao& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  diaSemana_ (x.diaSemana_, f, this),
  atendimentosTatico_ (x.atendimentosTatico_, f, this)
{
}

ItemAtendimentoDiaSemanaSolucao::
ItemAtendimentoDiaSemanaSolucao (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  diaSemana_ (f, this),
  atendimentosTatico_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAtendimentoDiaSemanaSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // diaSemana
    //
    if (n.name () == "diaSemana" && n.namespace_ ().empty ())
    {
      if (!diaSemana_.present ())
      {
        this->diaSemana_.set (diaSemana_traits::create (i, f, this));
        continue;
      }
    }

    // atendimentosTatico
    //
    if (n.name () == "atendimentosTatico" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< atendimentosTatico_type > r (
        atendimentosTatico_traits::create (i, f, this));

      if (!atendimentosTatico_.present ())
      {
        this->atendimentosTatico_.set (r);
        continue;
      }
    }

    break;
  }

  if (!diaSemana_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "diaSemana",
      "");
  }

  if (!atendimentosTatico_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "atendimentosTatico",
      "");
  }
}

ItemAtendimentoDiaSemanaSolucao* ItemAtendimentoDiaSemanaSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAtendimentoDiaSemanaSolucao (*this, f, c);
}

ItemAtendimentoDiaSemanaSolucao::
~ItemAtendimentoDiaSemanaSolucao ()
{
}

// ItemAtendimentoOfertaSolucao
//

ItemAtendimentoOfertaSolucao::
ItemAtendimentoOfertaSolucao (const ofertaCursoCampiId_type& ofertaCursoCampiId,
                              const disciplinaId_type& disciplinaId,
							  const disciplinaSubstitutaId_type& disciplinaSubstitutaId,
                              const quantidade_type& quantidade,
                              const turma_type& turma)
: ::xml_schema::type (),
  ofertaCursoCampiId_ (ofertaCursoCampiId, ::xml_schema::flags (), this),
  disciplinaId_ (disciplinaId, ::xml_schema::flags (), this),
  disciplinaSubstitutaId_ (disciplinaSubstitutaId, ::xml_schema::flags (), this),
  quantidade_ (quantidade, ::xml_schema::flags (), this),
  turma_ (turma, ::xml_schema::flags (), this)
{
}

ItemAtendimentoOfertaSolucao::
ItemAtendimentoOfertaSolucao (const ItemAtendimentoOfertaSolucao& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ofertaCursoCampiId_ (x.ofertaCursoCampiId_, f, this),
  disciplinaId_ (x.disciplinaId_, f, this),
  disciplinaSubstitutaId_ (x.disciplinaSubstitutaId_, f, this),
  quantidade_ (x.quantidade_, f, this),
  turma_ (x.turma_, f, this)
{
}

ItemAtendimentoOfertaSolucao::
ItemAtendimentoOfertaSolucao (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ofertaCursoCampiId_ (f, this),
  disciplinaId_ (f, this),
  disciplinaSubstitutaId_ (f, this),
  quantidade_ (f, this),
  turma_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAtendimentoOfertaSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ofertaCursoCampiId
    //
    if (n.name () == "ofertaCursoCampiId" && n.namespace_ ().empty ())
    {
      if (!ofertaCursoCampiId_.present ())
      {
        this->ofertaCursoCampiId_.set (ofertaCursoCampiId_traits::create (i, f, this));
        continue;
      }
    }

    // disciplinaId
    //
    if (n.name () == "disciplinaId" && n.namespace_ ().empty ())
    {
      if (!disciplinaId_.present ())
      {
        this->disciplinaId_.set (disciplinaId_traits::create (i, f, this));
        continue;
      }
    }

    // disciplinaSubstitutaId
    //
    if (n.name () == "disciplinaSubstitutaId" && n.namespace_ ().empty ())
    {
      if (!disciplinaSubstitutaId_.present ())
      {
        this->disciplinaSubstitutaId_.set (disciplinaSubstitutaId_traits::create (i, f, this));
        continue;
      }
    }

    // quantidade
    //
    if (n.name () == "quantidade" && n.namespace_ ().empty ())
    {
      if (!quantidade_.present ())
      {
        this->quantidade_.set (quantidade_traits::create (i, f, this));
        continue;
      }
    }

    // turma
    //
    if (n.name () == "turma" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< turma_type > r (
        turma_traits::create (i, f, this));

      if (!turma_.present ())
      {
        this->turma_.set (r);
        continue;
      }
    }

    break;
  }

  if (!ofertaCursoCampiId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ofertaCursoCampiId",
      "");
  }

  if (!disciplinaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinaId",
      "");
  }
  
  if (!disciplinaSubstitutaId_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinaSubstitutaId",
      "");
  }

  if (!quantidade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "quantidade",
      "");
  }

  if (!turma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turma",
      "");
  }
}

ItemAtendimentoOfertaSolucao* ItemAtendimentoOfertaSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAtendimentoOfertaSolucao (*this, f, c);
}

ItemAtendimentoOfertaSolucao::
~ItemAtendimentoOfertaSolucao ()
{
}

// ItemAtendimentoTaticoSolucao
//

ItemAtendimentoTaticoSolucao::
ItemAtendimentoTaticoSolucao (const atendimentoOferta_type& atendimentoOferta,
                              const qtdeCreditosTeoricos_type& qtdeCreditosTeoricos,
                              const qtdeCreditosPraticos_type& qtdeCreditosPraticos)
: ::xml_schema::type (),
  atendimentoOferta_ (atendimentoOferta, ::xml_schema::flags (), this),
  qtdeCreditosTeoricos_ (qtdeCreditosTeoricos, ::xml_schema::flags (), this),
  qtdeCreditosPraticos_ (qtdeCreditosPraticos, ::xml_schema::flags (), this)
{
}

ItemAtendimentoTaticoSolucao::
ItemAtendimentoTaticoSolucao (::std::auto_ptr< atendimentoOferta_type >& atendimentoOferta,
                              const qtdeCreditosTeoricos_type& qtdeCreditosTeoricos,
                              const qtdeCreditosPraticos_type& qtdeCreditosPraticos)
: ::xml_schema::type (),
  atendimentoOferta_ (atendimentoOferta, ::xml_schema::flags (), this),
  qtdeCreditosTeoricos_ (qtdeCreditosTeoricos, ::xml_schema::flags (), this),
  qtdeCreditosPraticos_ (qtdeCreditosPraticos, ::xml_schema::flags (), this)
{
}

ItemAtendimentoTaticoSolucao::
ItemAtendimentoTaticoSolucao (const ItemAtendimentoTaticoSolucao& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  atendimentoOferta_ (x.atendimentoOferta_, f, this),
  qtdeCreditosTeoricos_ (x.qtdeCreditosTeoricos_, f, this),
  qtdeCreditosPraticos_ (x.qtdeCreditosPraticos_, f, this)
{
}

ItemAtendimentoTaticoSolucao::
ItemAtendimentoTaticoSolucao (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  atendimentoOferta_ (f, this),
  qtdeCreditosTeoricos_ (f, this),
  qtdeCreditosPraticos_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAtendimentoTaticoSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // atendimentoOferta
    //
    if (n.name () == "atendimentoOferta" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< atendimentoOferta_type > r (
        atendimentoOferta_traits::create (i, f, this));

      if (!atendimentoOferta_.present ())
      {
        this->atendimentoOferta_.set (r);
        continue;
      }
    }

    // qtdeCreditosTeoricos
    //
    if (n.name () == "qtdeCreditosTeoricos" && n.namespace_ ().empty ())
    {
      if (!qtdeCreditosTeoricos_.present ())
      {
        this->qtdeCreditosTeoricos_.set (qtdeCreditosTeoricos_traits::create (i, f, this));
        continue;
      }
    }

    // qtdeCreditosPraticos
    //
    if (n.name () == "qtdeCreditosPraticos" && n.namespace_ ().empty ())
    {
      if (!qtdeCreditosPraticos_.present ())
      {
        this->qtdeCreditosPraticos_.set (qtdeCreditosPraticos_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!atendimentoOferta_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "atendimentoOferta",
      "");
  }

  if (!qtdeCreditosTeoricos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qtdeCreditosTeoricos",
      "");
  }

  if (!qtdeCreditosPraticos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qtdeCreditosPraticos",
      "");
  }
}

ItemAtendimentoTaticoSolucao* ItemAtendimentoTaticoSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAtendimentoTaticoSolucao (*this, f, c);
}

ItemAtendimentoTaticoSolucao::
~ItemAtendimentoTaticoSolucao ()
{
}

// GrupoAtendimentoCampusSolucao
//

GrupoAtendimentoCampusSolucao::
GrupoAtendimentoCampusSolucao ()
: ::xml_schema::type (),
  AtendimentoCampus_ (::xml_schema::flags (), this)
{
}

GrupoAtendimentoCampusSolucao::
GrupoAtendimentoCampusSolucao (const GrupoAtendimentoCampusSolucao& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AtendimentoCampus_ (x.AtendimentoCampus_, f, this)
{
}

GrupoAtendimentoCampusSolucao::
GrupoAtendimentoCampusSolucao (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AtendimentoCampus_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoAtendimentoCampusSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AtendimentoCampus
    //
    if (n.name () == "AtendimentoCampus" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AtendimentoCampus_type > r (
        AtendimentoCampus_traits::create (i, f, this));

      this->AtendimentoCampus_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoAtendimentoCampusSolucao* GrupoAtendimentoCampusSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoAtendimentoCampusSolucao (*this, f, c);
}

GrupoAtendimentoCampusSolucao::
~GrupoAtendimentoCampusSolucao ()
{
}

// GrupoAtendimentoUnidadeSolucao
//

GrupoAtendimentoUnidadeSolucao::
GrupoAtendimentoUnidadeSolucao ()
: ::xml_schema::type (),
  AtendimentoUnidade_ (::xml_schema::flags (), this)
{
}

GrupoAtendimentoUnidadeSolucao::
GrupoAtendimentoUnidadeSolucao (const GrupoAtendimentoUnidadeSolucao& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AtendimentoUnidade_ (x.AtendimentoUnidade_, f, this)
{
}

GrupoAtendimentoUnidadeSolucao::
GrupoAtendimentoUnidadeSolucao (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AtendimentoUnidade_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoAtendimentoUnidadeSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AtendimentoUnidade
    //
    if (n.name () == "AtendimentoUnidade" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AtendimentoUnidade_type > r (
        AtendimentoUnidade_traits::create (i, f, this));

      this->AtendimentoUnidade_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoAtendimentoUnidadeSolucao* GrupoAtendimentoUnidadeSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoAtendimentoUnidadeSolucao (*this, f, c);
}

GrupoAtendimentoUnidadeSolucao::
~GrupoAtendimentoUnidadeSolucao ()
{
}

// GrupoAtendimentoSalaSolucao
//

GrupoAtendimentoSalaSolucao::
GrupoAtendimentoSalaSolucao ()
: ::xml_schema::type (),
  AtendimentoSala_ (::xml_schema::flags (), this)
{
}

GrupoAtendimentoSalaSolucao::
GrupoAtendimentoSalaSolucao (const GrupoAtendimentoSalaSolucao& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AtendimentoSala_ (x.AtendimentoSala_, f, this)
{
}

GrupoAtendimentoSalaSolucao::
GrupoAtendimentoSalaSolucao (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AtendimentoSala_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoAtendimentoSalaSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AtendimentoSala
    //
    if (n.name () == "AtendimentoSala" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AtendimentoSala_type > r (
        AtendimentoSala_traits::create (i, f, this));

      this->AtendimentoSala_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoAtendimentoSalaSolucao* GrupoAtendimentoSalaSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoAtendimentoSalaSolucao (*this, f, c);
}

GrupoAtendimentoSalaSolucao::
~GrupoAtendimentoSalaSolucao ()
{
}

// GrupoAtendimentoDiaSemanaSolucao
//

GrupoAtendimentoDiaSemanaSolucao::
GrupoAtendimentoDiaSemanaSolucao ()
: ::xml_schema::type (),
  AtendimentoDiaSemana_ (::xml_schema::flags (), this)
{
}

GrupoAtendimentoDiaSemanaSolucao::
GrupoAtendimentoDiaSemanaSolucao (const GrupoAtendimentoDiaSemanaSolucao& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AtendimentoDiaSemana_ (x.AtendimentoDiaSemana_, f, this)
{
}

GrupoAtendimentoDiaSemanaSolucao::
GrupoAtendimentoDiaSemanaSolucao (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AtendimentoDiaSemana_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoAtendimentoDiaSemanaSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AtendimentoDiaSemana
    //
    if (n.name () == "AtendimentoDiaSemana" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AtendimentoDiaSemana_type > r (
        AtendimentoDiaSemana_traits::create (i, f, this));

      this->AtendimentoDiaSemana_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoAtendimentoDiaSemanaSolucao* GrupoAtendimentoDiaSemanaSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoAtendimentoDiaSemanaSolucao (*this, f, c);
}

GrupoAtendimentoDiaSemanaSolucao::
~GrupoAtendimentoDiaSemanaSolucao ()
{
}

// GrupoAtendimentoTaticoSolucao
//

GrupoAtendimentoTaticoSolucao::
GrupoAtendimentoTaticoSolucao ()
: ::xml_schema::type (),
  AtendimentoTatico_ (::xml_schema::flags (), this)
{
}

GrupoAtendimentoTaticoSolucao::
GrupoAtendimentoTaticoSolucao (const GrupoAtendimentoTaticoSolucao& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  AtendimentoTatico_ (x.AtendimentoTatico_, f, this)
{
}

GrupoAtendimentoTaticoSolucao::
GrupoAtendimentoTaticoSolucao (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  AtendimentoTatico_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoAtendimentoTaticoSolucao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AtendimentoTatico
    //
    if (n.name () == "AtendimentoTatico" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AtendimentoTatico_type > r (
        AtendimentoTatico_traits::create (i, f, this));

      this->AtendimentoTatico_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoAtendimentoTaticoSolucao* GrupoAtendimentoTaticoSolucao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoAtendimentoTaticoSolucao (*this, f, c);
}

GrupoAtendimentoTaticoSolucao::
~GrupoAtendimentoTaticoSolucao ()
{
}

// TriedaInput
//

TriedaInput::
TriedaInput (const calendarios_type& calendarios,
             const tiposSala_type& tiposSala,
             const tiposContrato_type& tiposContrato,
             const tiposTitulacao_type& tiposTitulacao,
             const areasTitulacao_type& areasTitulacao,
             const tiposDisciplina_type& tiposDisciplina,
             const niveisDificuldade_type& niveisDificuldade,
             const tiposCurso_type& tiposCurso,
             const regrasDivisaoCredito_type& regrasDivisaoCredito,
             const campi_type& campi,
             const temposDeslocamentosCampi_type& temposDeslocamentosCampi,
             const temposDeslocamentosUnidades_type& temposDeslocamentosUnidades,
             const disciplinas_type& disciplinas,
             const cursos_type& cursos,
             const ofertaCursosCampi_type& ofertaCursosCampi,
             const demandas_type& demandas,
             const alunosDemanda_type& alunosDemanda,
             const parametrosPlanejamento_type& parametrosPlanejamento,
             const fixacoes_type& fixacoes)
: ::xml_schema::type (),
  calendarios_ (calendarios, ::xml_schema::flags (), this),
  tiposSala_ (tiposSala, ::xml_schema::flags (), this),
  tiposContrato_ (tiposContrato, ::xml_schema::flags (), this),
  tiposTitulacao_ (tiposTitulacao, ::xml_schema::flags (), this),
  areasTitulacao_ (areasTitulacao, ::xml_schema::flags (), this),
  tiposDisciplina_ (tiposDisciplina, ::xml_schema::flags (), this),
  niveisDificuldade_ (niveisDificuldade, ::xml_schema::flags (), this),
  tiposCurso_ (tiposCurso, ::xml_schema::flags (), this),
  regrasDivisaoCredito_ (regrasDivisaoCredito, ::xml_schema::flags (), this),
  campi_ (campi, ::xml_schema::flags (), this),
  temposDeslocamentosCampi_ (temposDeslocamentosCampi, ::xml_schema::flags (), this),
  temposDeslocamentosUnidades_ (temposDeslocamentosUnidades, ::xml_schema::flags (), this),
  disciplinas_ (disciplinas, ::xml_schema::flags (), this),
  cursos_ (cursos, ::xml_schema::flags (), this),
  ofertaCursosCampi_ (ofertaCursosCampi, ::xml_schema::flags (), this),
  demandas_ (demandas, ::xml_schema::flags (), this),
  alunosDemanda_ (alunosDemanda, ::xml_schema::flags (), this),
  parametrosPlanejamento_ (parametrosPlanejamento, ::xml_schema::flags (), this),
  fixacoes_ (fixacoes, ::xml_schema::flags (), this),
  atendimentosTatico_ (::xml_schema::flags (), this)
{
}

TriedaInput::
TriedaInput (::std::auto_ptr< calendarios_type >& calendarios,
             ::std::auto_ptr< tiposSala_type >& tiposSala,
             ::std::auto_ptr< tiposContrato_type >& tiposContrato,
             ::std::auto_ptr< tiposTitulacao_type >& tiposTitulacao,
             ::std::auto_ptr< areasTitulacao_type >& areasTitulacao,
             ::std::auto_ptr< tiposDisciplina_type >& tiposDisciplina,
             ::std::auto_ptr< niveisDificuldade_type >& niveisDificuldade,
             ::std::auto_ptr< tiposCurso_type >& tiposCurso,
             ::std::auto_ptr< regrasDivisaoCredito_type >& regrasDivisaoCredito,
             ::std::auto_ptr< campi_type >& campi,
             ::std::auto_ptr< temposDeslocamentosCampi_type >& temposDeslocamentosCampi,
             ::std::auto_ptr< temposDeslocamentosUnidades_type >& temposDeslocamentosUnidades,
             ::std::auto_ptr< disciplinas_type >& disciplinas,
             ::std::auto_ptr< cursos_type >& cursos,
             ::std::auto_ptr< ofertaCursosCampi_type >& ofertaCursosCampi,
             ::std::auto_ptr< demandas_type >& demandas,
             ::std::auto_ptr< alunosDemanda_type >& alunosDemanda,
             ::std::auto_ptr< parametrosPlanejamento_type >& parametrosPlanejamento,
             ::std::auto_ptr< fixacoes_type >& fixacoes)
: ::xml_schema::type (),
  calendarios_ (calendarios, ::xml_schema::flags (), this),
  tiposSala_ (tiposSala, ::xml_schema::flags (), this),
  tiposContrato_ (tiposContrato, ::xml_schema::flags (), this),
  tiposTitulacao_ (tiposTitulacao, ::xml_schema::flags (), this),
  areasTitulacao_ (areasTitulacao, ::xml_schema::flags (), this),
  tiposDisciplina_ (tiposDisciplina, ::xml_schema::flags (), this),
  niveisDificuldade_ (niveisDificuldade, ::xml_schema::flags (), this),
  tiposCurso_ (tiposCurso, ::xml_schema::flags (), this),
  regrasDivisaoCredito_ (regrasDivisaoCredito, ::xml_schema::flags (), this),
  campi_ (campi, ::xml_schema::flags (), this),
  temposDeslocamentosCampi_ (temposDeslocamentosCampi, ::xml_schema::flags (), this),
  temposDeslocamentosUnidades_ (temposDeslocamentosUnidades, ::xml_schema::flags (), this),
  disciplinas_ (disciplinas, ::xml_schema::flags (), this),
  cursos_ (cursos, ::xml_schema::flags (), this),
  ofertaCursosCampi_ (ofertaCursosCampi, ::xml_schema::flags (), this),
  demandas_ (demandas, ::xml_schema::flags (), this),
  alunosDemanda_ (alunosDemanda, ::xml_schema::flags (), this),
  parametrosPlanejamento_ (parametrosPlanejamento, ::xml_schema::flags (), this),
  fixacoes_ (fixacoes, ::xml_schema::flags (), this),
  atendimentosTatico_ (::xml_schema::flags (), this)
{
}

TriedaInput::
TriedaInput (const TriedaInput& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  calendarios_ (x.calendarios_, f, this),
  tiposSala_ (x.tiposSala_, f, this),
  tiposContrato_ (x.tiposContrato_, f, this),
  tiposTitulacao_ (x.tiposTitulacao_, f, this),
  areasTitulacao_ (x.areasTitulacao_, f, this),
  tiposDisciplina_ (x.tiposDisciplina_, f, this),
  niveisDificuldade_ (x.niveisDificuldade_, f, this),
  tiposCurso_ (x.tiposCurso_, f, this),
  regrasDivisaoCredito_ (x.regrasDivisaoCredito_, f, this),
  campi_ (x.campi_, f, this),
  temposDeslocamentosCampi_ (x.temposDeslocamentosCampi_, f, this),
  temposDeslocamentosUnidades_ (x.temposDeslocamentosUnidades_, f, this),
  disciplinas_ (x.disciplinas_, f, this),
  cursos_ (x.cursos_, f, this),
  ofertaCursosCampi_ (x.ofertaCursosCampi_, f, this),
  demandas_ (x.demandas_, f, this),
  alunosDemanda_ (x.alunosDemanda_, f, this),
  parametrosPlanejamento_ (x.parametrosPlanejamento_, f, this),
  fixacoes_ (x.fixacoes_, f, this),
  atendimentosTatico_ (x.atendimentosTatico_, f, this)
{
}

TriedaInput::
TriedaInput (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  calendarios_ (f, this),
  tiposSala_ (f, this),
  tiposContrato_ (f, this),
  tiposTitulacao_ (f, this),
  areasTitulacao_ (f, this),
  tiposDisciplina_ (f, this),
  niveisDificuldade_ (f, this),
  tiposCurso_ (f, this),
  regrasDivisaoCredito_ (f, this),
  campi_ (f, this),
  temposDeslocamentosCampi_ (f, this),
  temposDeslocamentosUnidades_ (f, this),
  disciplinas_ (f, this),
  cursos_ (f, this),
  ofertaCursosCampi_ (f, this),
  demandas_ (f, this),
  alunosDemanda_ (f, this),
  parametrosPlanejamento_ (f, this),
  fixacoes_ (f, this),
  atendimentosTatico_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void TriedaInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // calendarios
    //
    if (n.name () == "calendarios" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< calendarios_type > r (
        calendarios_traits::create (i, f, this));

      if (!calendarios_.present ())
      {
        this->calendarios_.set (r);
        continue;
      }
    }

    // tiposSala
    //
    if (n.name () == "tiposSala" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tiposSala_type > r (
        tiposSala_traits::create (i, f, this));

      if (!tiposSala_.present ())
      {
        this->tiposSala_.set (r);
        continue;
      }
    }

    // tiposContrato
    //
    if (n.name () == "tiposContrato" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tiposContrato_type > r (
        tiposContrato_traits::create (i, f, this));

      if (!tiposContrato_.present ())
      {
        this->tiposContrato_.set (r);
        continue;
      }
    }

    // tiposTitulacao
    //
    if (n.name () == "tiposTitulacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tiposTitulacao_type > r (
        tiposTitulacao_traits::create (i, f, this));

      if (!tiposTitulacao_.present ())
      {
        this->tiposTitulacao_.set (r);
        continue;
      }
    }

    // areasTitulacao
    //
    if (n.name () == "areasTitulacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< areasTitulacao_type > r (
        areasTitulacao_traits::create (i, f, this));

      if (!areasTitulacao_.present ())
      {
        this->areasTitulacao_.set (r);
        continue;
      }
    }

    // tiposDisciplina
    //
    if (n.name () == "tiposDisciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tiposDisciplina_type > r (
        tiposDisciplina_traits::create (i, f, this));

      if (!tiposDisciplina_.present ())
      {
        this->tiposDisciplina_.set (r);
        continue;
      }
    }

    // niveisDificuldade
    //
    if (n.name () == "niveisDificuldade" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< niveisDificuldade_type > r (
        niveisDificuldade_traits::create (i, f, this));

      if (!niveisDificuldade_.present ())
      {
        this->niveisDificuldade_.set (r);
        continue;
      }
    }

    // tiposCurso
    //
    if (n.name () == "tiposCurso" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tiposCurso_type > r (
        tiposCurso_traits::create (i, f, this));

      if (!tiposCurso_.present ())
      {
        this->tiposCurso_.set (r);
        continue;
      }
    }

    // regrasDivisaoCredito
    //
    if (n.name () == "regrasDivisaoCredito" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< regrasDivisaoCredito_type > r (
        regrasDivisaoCredito_traits::create (i, f, this));

      if (!regrasDivisaoCredito_.present ())
      {
        this->regrasDivisaoCredito_.set (r);
        continue;
      }
    }

    // campi
    //
    if (n.name () == "campi" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< campi_type > r (
        campi_traits::create (i, f, this));

      if (!campi_.present ())
      {
        this->campi_.set (r);
        continue;
      }
    }

    // temposDeslocamentosCampi
    //
    if (n.name () == "temposDeslocamentosCampi" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< temposDeslocamentosCampi_type > r (
        temposDeslocamentosCampi_traits::create (i, f, this));

      if (!temposDeslocamentosCampi_.present ())
      {
        this->temposDeslocamentosCampi_.set (r);
        continue;
      }
    }

    // temposDeslocamentosUnidades
    //
    if (n.name () == "temposDeslocamentosUnidades" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< temposDeslocamentosUnidades_type > r (
        temposDeslocamentosUnidades_traits::create (i, f, this));

      if (!temposDeslocamentosUnidades_.present ())
      {
        this->temposDeslocamentosUnidades_.set (r);
        continue;
      }
    }

    // disciplinas
    //
    if (n.name () == "disciplinas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplinas_type > r (
        disciplinas_traits::create (i, f, this));

      if (!disciplinas_.present ())
      {
        this->disciplinas_.set (r);
        continue;
      }
    }

    // cursos
    //
    if (n.name () == "cursos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cursos_type > r (
        cursos_traits::create (i, f, this));

      if (!cursos_.present ())
      {
        this->cursos_.set (r);
        continue;
      }
    }

    // ofertaCursosCampi
    //
    if (n.name () == "ofertaCursosCampi" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ofertaCursosCampi_type > r (
        ofertaCursosCampi_traits::create (i, f, this));

      if (!ofertaCursosCampi_.present ())
      {
        this->ofertaCursosCampi_.set (r);
        continue;
      }
    }

    // demandas
    //
    if (n.name () == "demandas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< demandas_type > r (
        demandas_traits::create (i, f, this));

      if (!demandas_.present ())
      {
        this->demandas_.set (r);
        continue;
      }
    }

    // alunosDemanda
    //
    if (n.name () == "alunosDemanda" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< alunosDemanda_type > r (
        alunosDemanda_traits::create (i, f, this));

      if (!alunosDemanda_.present ())
      {
        this->alunosDemanda_.set (r);
        continue;
      }
    }

    // parametrosPlanejamento
    //
    if (n.name () == "parametrosPlanejamento" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parametrosPlanejamento_type > r (
        parametrosPlanejamento_traits::create (i, f, this));

      if (!parametrosPlanejamento_.present ())
      {
        this->parametrosPlanejamento_.set (r);
        continue;
      }
    }

    // fixacoes
    //
    if (n.name () == "fixacoes" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fixacoes_type > r (
        fixacoes_traits::create (i, f, this));

      if (!fixacoes_.present ())
      {
        this->fixacoes_.set (r);
        continue;
      }
    }

    // atendimentosTatico
    //
    if (n.name () == "atendimentosTatico" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< atendimentosTatico_type > r (
        atendimentosTatico_traits::create (i, f, this));

      if (!this->atendimentosTatico_)
      {
        this->atendimentosTatico_.set (r);
        continue;
      }
    }

    break;
  }

  if (!calendarios_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "calendarios",
      "");
  }

  if (!tiposSala_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tiposSala",
      "");
  }

  if (!tiposContrato_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tiposContrato",
      "");
  }

  if (!tiposTitulacao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tiposTitulacao",
      "");
  }

  if (!areasTitulacao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "areasTitulacao",
      "");
  }

  if (!tiposDisciplina_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tiposDisciplina",
      "");
  }

  if (!niveisDificuldade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "niveisDificuldade",
      "");
  }

  if (!tiposCurso_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tiposCurso",
      "");
  }

  if (!regrasDivisaoCredito_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "regrasDivisaoCredito",
      "");
  }

  if (!campi_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "campi",
      "");
  }

  if (!temposDeslocamentosCampi_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "temposDeslocamentosCampi",
      "");
  }

  if (!temposDeslocamentosUnidades_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "temposDeslocamentosUnidades",
      "");
  }

  if (!disciplinas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinas",
      "");
  }

  if (!cursos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cursos",
      "");
  }

  if (!ofertaCursosCampi_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ofertaCursosCampi",
      "");
  }

  if (!demandas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "demandas",
      "");
  }

  if (!alunosDemanda_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "alunosDemanda",
      "");
  }

  if (!parametrosPlanejamento_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parametrosPlanejamento",
      "");
  }

  if (!fixacoes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "fixacoes",
      "");
  }
}

TriedaInput* TriedaInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TriedaInput (*this, f, c);
}

TriedaInput::
~TriedaInput ()
{
}

// cargaHorariaSemanalAluno
//

cargaHorariaSemanalAluno::
cargaHorariaSemanalAluno ()
: ::xml_schema::type (),
  equilibrar_ (::xml_schema::flags (), this),
  minimizarDias_ (::xml_schema::flags (), this),
  indiferente_ (::xml_schema::flags (), this)
{
}

cargaHorariaSemanalAluno::
cargaHorariaSemanalAluno (const cargaHorariaSemanalAluno& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  equilibrar_ (x.equilibrar_, f, this),
  minimizarDias_ (x.minimizarDias_, f, this),
  indiferente_ (x.indiferente_, f, this)
{
}

cargaHorariaSemanalAluno::
cargaHorariaSemanalAluno (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  equilibrar_ (f, this),
  minimizarDias_ (f, this),
  indiferente_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void cargaHorariaSemanalAluno::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // equilibrar
    //
    if (n.name () == "equilibrar" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< equilibrar_type > r (
        equilibrar_traits::create (i, f, this));

      if (!this->equilibrar_)
      {
        this->equilibrar_.set (r);
        continue;
      }
    }

    // minimizarDias
    //
    if (n.name () == "minimizarDias" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< minimizarDias_type > r (
        minimizarDias_traits::create (i, f, this));

      if (!this->minimizarDias_)
      {
        this->minimizarDias_.set (r);
        continue;
      }
    }

    // indiferente
    //
    if (n.name () == "indiferente" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< indiferente_type > r (
        indiferente_traits::create (i, f, this));

      if (!this->indiferente_)
      {
        this->indiferente_.set (r);
        continue;
      }
    }

    break;
  }
}

cargaHorariaSemanalAluno* cargaHorariaSemanalAluno::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cargaHorariaSemanalAluno (*this, f, c);
}

cargaHorariaSemanalAluno::
~cargaHorariaSemanalAluno ()
{
}

// cargaHorariaSemanalProfessor
//

cargaHorariaSemanalProfessor::
cargaHorariaSemanalProfessor ()
: ::xml_schema::type (),
  equilibrar_ (::xml_schema::flags (), this),
  minimizarDias_ (::xml_schema::flags (), this),
  indiferente_ (::xml_schema::flags (), this)
{
}

cargaHorariaSemanalProfessor::
cargaHorariaSemanalProfessor (const cargaHorariaSemanalProfessor& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  equilibrar_ (x.equilibrar_, f, this),
  minimizarDias_ (x.minimizarDias_, f, this),
  indiferente_ (x.indiferente_, f, this)
{
}

cargaHorariaSemanalProfessor::
cargaHorariaSemanalProfessor (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  equilibrar_ (f, this),
  minimizarDias_ (f, this),
  indiferente_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void cargaHorariaSemanalProfessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // equilibrar
    //
    if (n.name () == "equilibrar" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< equilibrar_type > r (
        equilibrar_traits::create (i, f, this));

      if (!this->equilibrar_)
      {
        this->equilibrar_.set (r);
        continue;
      }
    }

    // minimizarDias
    //
    if (n.name () == "minimizarDias" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< minimizarDias_type > r (
        minimizarDias_traits::create (i, f, this));

      if (!this->minimizarDias_)
      {
        this->minimizarDias_.set (r);
        continue;
      }
    }

    // indiferente
    //
    if (n.name () == "indiferente" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< indiferente_type > r (
        indiferente_traits::create (i, f, this));

      if (!this->indiferente_)
      {
        this->indiferente_.set (r);
        continue;
      }
    }

    break;
  }
}

cargaHorariaSemanalProfessor* cargaHorariaSemanalProfessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cargaHorariaSemanalProfessor (*this, f, c);
}

cargaHorariaSemanalProfessor::
~cargaHorariaSemanalProfessor ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;
  	
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::TriedaInput > r (
    ::TriedaInput_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::TriedaInput > r (
    ::TriedaInput_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::TriedaInput > r (
    ::TriedaInput_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TriedaInput_ (isrc, f, p);
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TriedaInput_ (isrc, h, f, p);
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TriedaInput_ (isrc, h, f, p);
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TriedaInput_ (isrc, f, p);
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TriedaInput_ (isrc, h, f, p);
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TriedaInput_ (isrc, h, f, p);
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::TriedaInput > r (
    ::TriedaInput_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::TriedaInput > r (
    ::TriedaInput_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::TriedaInput > r (
    ::TriedaInput_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::TriedaInput > r (
      ::TriedaInput_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "TriedaInput" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::TriedaInput > r (
      ::xsd::cxx::tree::traits< ::TriedaInput, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "TriedaInput",
    "");
}

::std::auto_ptr< ::TriedaInput >
TriedaInput_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "TriedaInput" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::TriedaInput > r (
      ::xsd::cxx::tree::traits< ::TriedaInput, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "TriedaInput",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

