// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "TRIEDA-InputXSD.h"

// ItemProfessorDisciplina
// 

const ItemProfessorDisciplina::nota_optional& ItemProfessorDisciplina::
nota () const
{
  return this->nota_;
}

ItemProfessorDisciplina::nota_optional& ItemProfessorDisciplina::
nota ()
{
  return this->nota_;
}

void ItemProfessorDisciplina::
nota (const nota_type& x)
{
  this->nota_.set (x);
}

void ItemProfessorDisciplina::
nota (const nota_optional& x)
{
  this->nota_ = x;
}

const ItemProfessorDisciplina::ranking_optional& ItemProfessorDisciplina::
ranking () const
{
  return this->ranking_;
}

ItemProfessorDisciplina::ranking_optional& ItemProfessorDisciplina::
ranking ()
{
  return this->ranking_;
}

void ItemProfessorDisciplina::
ranking (const ranking_type& x)
{
  this->ranking_.set (x);
}

void ItemProfessorDisciplina::
ranking (const ranking_optional& x)
{
  this->ranking_ = x;
}

const ItemProfessorDisciplina::disciplina_optional& ItemProfessorDisciplina::
disciplina () const
{
  return this->disciplina_;
}

ItemProfessorDisciplina::disciplina_optional& ItemProfessorDisciplina::
disciplina ()
{
  return this->disciplina_;
}

void ItemProfessorDisciplina::
disciplina (const disciplina_type& x)
{
  this->disciplina_.set (x);
}

void ItemProfessorDisciplina::
disciplina (const disciplina_optional& x)
{
  this->disciplina_ = x;
}

void ItemProfessorDisciplina::
disciplina (::std::auto_ptr< disciplina_type > x)
{
  this->disciplina_.set (x);
}


// GrupoProfessorDisciplina
// 

const GrupoProfessorDisciplina::ProfessorDisciplina_sequence& GrupoProfessorDisciplina::
ProfessorDisciplina () const
{
  return this->ProfessorDisciplina_;
}

GrupoProfessorDisciplina::ProfessorDisciplina_sequence& GrupoProfessorDisciplina::
ProfessorDisciplina ()
{
  return this->ProfessorDisciplina_;
}

void GrupoProfessorDisciplina::
ProfessorDisciplina (const ProfessorDisciplina_sequence& s)
{
  this->ProfessorDisciplina_ = s;
}


// ItemProfessor
// 

const ItemProfessor::id_type& ItemProfessor::
id () const
{
  return this->id_.get ();
}

ItemProfessor::id_type& ItemProfessor::
id ()
{
  return this->id_.get ();
}

void ItemProfessor::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemProfessor::contrato_type& ItemProfessor::
contrato () const
{
  return this->contrato_.get ();
}

ItemProfessor::contrato_type& ItemProfessor::
contrato ()
{
  return this->contrato_.get ();
}

void ItemProfessor::
contrato (const contrato_type& x)
{
  this->contrato_.set (x);
}

void ItemProfessor::
contrato (::std::auto_ptr< contrato_type > x)
{
  this->contrato_.set (x);
}

const ItemProfessor::titulacao_type& ItemProfessor::
titulacao () const
{
  return this->titulacao_.get ();
}

ItemProfessor::titulacao_type& ItemProfessor::
titulacao ()
{
  return this->titulacao_.get ();
}

void ItemProfessor::
titulacao (const titulacao_type& x)
{
  this->titulacao_.set (x);
}

void ItemProfessor::
titulacao (::std::auto_ptr< titulacao_type > x)
{
  this->titulacao_.set (x);
}

const ItemProfessor::areaTitulacao_type& ItemProfessor::
areaTitulacao () const
{
  return this->areaTitulacao_.get ();
}

ItemProfessor::areaTitulacao_type& ItemProfessor::
areaTitulacao ()
{
  return this->areaTitulacao_.get ();
}

void ItemProfessor::
areaTitulacao (const areaTitulacao_type& x)
{
  this->areaTitulacao_.set (x);
}

void ItemProfessor::
areaTitulacao (::std::auto_ptr< areaTitulacao_type > x)
{
  this->areaTitulacao_.set (x);
}

const ItemProfessor::cpf_type& ItemProfessor::
cpf () const
{
  return this->cpf_.get ();
}

ItemProfessor::cpf_type& ItemProfessor::
cpf ()
{
  return this->cpf_.get ();
}

void ItemProfessor::
cpf (const cpf_type& x)
{
  this->cpf_.set (x);
}

void ItemProfessor::
cpf (::std::auto_ptr< cpf_type > x)
{
  this->cpf_.set (x);
}

const ItemProfessor::nome_type& ItemProfessor::
nome () const
{
  return this->nome_.get ();
}

ItemProfessor::nome_type& ItemProfessor::
nome ()
{
  return this->nome_.get ();
}

void ItemProfessor::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemProfessor::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemProfessor::chMin_type& ItemProfessor::
chMin () const
{
  return this->chMin_.get ();
}

ItemProfessor::chMin_type& ItemProfessor::
chMin ()
{
  return this->chMin_.get ();
}

void ItemProfessor::
chMin (const chMin_type& x)
{
  this->chMin_.set (x);
}

const ItemProfessor::chMax_type& ItemProfessor::
chMax () const
{
  return this->chMax_.get ();
}

ItemProfessor::chMax_type& ItemProfessor::
chMax ()
{
  return this->chMax_.get ();
}

void ItemProfessor::
chMax (const chMax_type& x)
{
  this->chMax_.set (x);
}

const ItemProfessor::credAnterior_type& ItemProfessor::
credAnterior () const
{
  return this->credAnterior_.get ();
}

ItemProfessor::credAnterior_type& ItemProfessor::
credAnterior ()
{
  return this->credAnterior_.get ();
}

void ItemProfessor::
credAnterior (const credAnterior_type& x)
{
  this->credAnterior_.set (x);
}

const ItemProfessor::valorCred_type& ItemProfessor::
valorCred () const
{
  return this->valorCred_.get ();
}

ItemProfessor::valorCred_type& ItemProfessor::
valorCred ()
{
  return this->valorCred_.get ();
}

void ItemProfessor::
valorCred (const valorCred_type& x)
{
  this->valorCred_.set (x);
}

const ItemProfessor::unidades_type& ItemProfessor::
unidades () const
{
  return this->unidades_.get ();
}

ItemProfessor::unidades_type& ItemProfessor::
unidades ()
{
  return this->unidades_.get ();
}

void ItemProfessor::
unidades (const unidades_type& x)
{
  this->unidades_.set (x);
}

void ItemProfessor::
unidades (::std::auto_ptr< unidades_type > x)
{
  this->unidades_.set (x);
}

const ItemProfessor::horarios_type& ItemProfessor::
horarios () const
{
  return this->horarios_.get ();
}

ItemProfessor::horarios_type& ItemProfessor::
horarios ()
{
  return this->horarios_.get ();
}

void ItemProfessor::
horarios (const horarios_type& x)
{
  this->horarios_.set (x);
}

void ItemProfessor::
horarios (::std::auto_ptr< horarios_type > x)
{
  this->horarios_.set (x);
}

const ItemProfessor::disciplinas_type& ItemProfessor::
disciplinas () const
{
  return this->disciplinas_.get ();
}

ItemProfessor::disciplinas_type& ItemProfessor::
disciplinas ()
{
  return this->disciplinas_.get ();
}

void ItemProfessor::
disciplinas (const disciplinas_type& x)
{
  this->disciplinas_.set (x);
}

void ItemProfessor::
disciplinas (::std::auto_ptr< disciplinas_type > x)
{
  this->disciplinas_.set (x);
}


// GrupoProfessor
// 

const GrupoProfessor::Professor_sequence& GrupoProfessor::
Professor () const
{
  return this->Professor_;
}

GrupoProfessor::Professor_sequence& GrupoProfessor::
Professor ()
{
  return this->Professor_;
}

void GrupoProfessor::
Professor (const Professor_sequence& s)
{
  this->Professor_ = s;
}


// ItemDivisaoCreditos
// 

const ItemDivisaoCreditos::id_type& ItemDivisaoCreditos::
id () const
{
  return this->id_.get ();
}

ItemDivisaoCreditos::id_type& ItemDivisaoCreditos::
id ()
{
  return this->id_.get ();
}

void ItemDivisaoCreditos::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemDivisaoCreditos::creditos_type& ItemDivisaoCreditos::
creditos () const
{
  return this->creditos_.get ();
}

ItemDivisaoCreditos::creditos_type& ItemDivisaoCreditos::
creditos ()
{
  return this->creditos_.get ();
}

void ItemDivisaoCreditos::
creditos (const creditos_type& x)
{
  this->creditos_.set (x);
}

const ItemDivisaoCreditos::dia1_type& ItemDivisaoCreditos::
dia1 () const
{
  return this->dia1_.get ();
}

ItemDivisaoCreditos::dia1_type& ItemDivisaoCreditos::
dia1 ()
{
  return this->dia1_.get ();
}

void ItemDivisaoCreditos::
dia1 (const dia1_type& x)
{
  this->dia1_.set (x);
}

const ItemDivisaoCreditos::dia2_type& ItemDivisaoCreditos::
dia2 () const
{
  return this->dia2_.get ();
}

ItemDivisaoCreditos::dia2_type& ItemDivisaoCreditos::
dia2 ()
{
  return this->dia2_.get ();
}

void ItemDivisaoCreditos::
dia2 (const dia2_type& x)
{
  this->dia2_.set (x);
}

const ItemDivisaoCreditos::dia3_type& ItemDivisaoCreditos::
dia3 () const
{
  return this->dia3_.get ();
}

ItemDivisaoCreditos::dia3_type& ItemDivisaoCreditos::
dia3 ()
{
  return this->dia3_.get ();
}

void ItemDivisaoCreditos::
dia3 (const dia3_type& x)
{
  this->dia3_.set (x);
}

const ItemDivisaoCreditos::dia4_type& ItemDivisaoCreditos::
dia4 () const
{
  return this->dia4_.get ();
}

ItemDivisaoCreditos::dia4_type& ItemDivisaoCreditos::
dia4 ()
{
  return this->dia4_.get ();
}

void ItemDivisaoCreditos::
dia4 (const dia4_type& x)
{
  this->dia4_.set (x);
}

const ItemDivisaoCreditos::dia5_type& ItemDivisaoCreditos::
dia5 () const
{
  return this->dia5_.get ();
}

ItemDivisaoCreditos::dia5_type& ItemDivisaoCreditos::
dia5 ()
{
  return this->dia5_.get ();
}

void ItemDivisaoCreditos::
dia5 (const dia5_type& x)
{
  this->dia5_.set (x);
}

const ItemDivisaoCreditos::dia6_type& ItemDivisaoCreditos::
dia6 () const
{
  return this->dia6_.get ();
}

ItemDivisaoCreditos::dia6_type& ItemDivisaoCreditos::
dia6 ()
{
  return this->dia6_.get ();
}

void ItemDivisaoCreditos::
dia6 (const dia6_type& x)
{
  this->dia6_.set (x);
}

const ItemDivisaoCreditos::dia7_type& ItemDivisaoCreditos::
dia7 () const
{
  return this->dia7_.get ();
}

ItemDivisaoCreditos::dia7_type& ItemDivisaoCreditos::
dia7 ()
{
  return this->dia7_.get ();
}

void ItemDivisaoCreditos::
dia7 (const dia7_type& x)
{
  this->dia7_.set (x);
}


// GrupoDivisaoCreditos
// 

const GrupoDivisaoCreditos::DivisaoCreditos_sequence& GrupoDivisaoCreditos::
DivisaoCreditos () const
{
  return this->DivisaoCreditos_;
}

GrupoDivisaoCreditos::DivisaoCreditos_sequence& GrupoDivisaoCreditos::
DivisaoCreditos ()
{
  return this->DivisaoCreditos_;
}

void GrupoDivisaoCreditos::
DivisaoCreditos (const DivisaoCreditos_sequence& s)
{
  this->DivisaoCreditos_ = s;
}


// GrupoDeslocamento
// 

const GrupoDeslocamento::Deslocamento_sequence& GrupoDeslocamento::
Deslocamento () const
{
  return this->Deslocamento_;
}

GrupoDeslocamento::Deslocamento_sequence& GrupoDeslocamento::
Deslocamento ()
{
  return this->Deslocamento_;
}

void GrupoDeslocamento::
Deslocamento (const Deslocamento_sequence& s)
{
  this->Deslocamento_ = s;
}


// ItemDeslocamento
// 

const ItemDeslocamento::tempo_type& ItemDeslocamento::
tempo () const
{
  return this->tempo_.get ();
}

ItemDeslocamento::tempo_type& ItemDeslocamento::
tempo ()
{
  return this->tempo_.get ();
}

void ItemDeslocamento::
tempo (const tempo_type& x)
{
  this->tempo_.set (x);
}

const ItemDeslocamento::unidade_type& ItemDeslocamento::
unidade () const
{
  return this->unidade_.get ();
}

ItemDeslocamento::unidade_type& ItemDeslocamento::
unidade ()
{
  return this->unidade_.get ();
}

void ItemDeslocamento::
unidade (const unidade_type& x)
{
  this->unidade_.set (x);
}

void ItemDeslocamento::
unidade (::std::auto_ptr< unidade_type > x)
{
  this->unidade_.set (x);
}


// GrupoUnidade
// 

const GrupoUnidade::Unidade_sequence& GrupoUnidade::
Unidade () const
{
  return this->Unidade_;
}

GrupoUnidade::Unidade_sequence& GrupoUnidade::
Unidade ()
{
  return this->Unidade_;
}

void GrupoUnidade::
Unidade (const Unidade_sequence& s)
{
  this->Unidade_ = s;
}


// ItemUnidade
// 

const ItemUnidade::id_type& ItemUnidade::
id () const
{
  return this->id_.get ();
}

ItemUnidade::id_type& ItemUnidade::
id ()
{
  return this->id_.get ();
}

void ItemUnidade::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemUnidade::codigo_type& ItemUnidade::
codigo () const
{
  return this->codigo_.get ();
}

ItemUnidade::codigo_type& ItemUnidade::
codigo ()
{
  return this->codigo_.get ();
}

void ItemUnidade::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemUnidade::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemUnidade::nome_type& ItemUnidade::
nome () const
{
  return this->nome_.get ();
}

ItemUnidade::nome_type& ItemUnidade::
nome ()
{
  return this->nome_.get ();
}

void ItemUnidade::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemUnidade::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemUnidade::endereco_type& ItemUnidade::
endereco () const
{
  return this->endereco_.get ();
}

ItemUnidade::endereco_type& ItemUnidade::
endereco ()
{
  return this->endereco_.get ();
}

void ItemUnidade::
endereco (const endereco_type& x)
{
  this->endereco_.set (x);
}

void ItemUnidade::
endereco (::std::auto_ptr< endereco_type > x)
{
  this->endereco_.set (x);
}

const ItemUnidade::numMedSalas_type& ItemUnidade::
numMedSalas () const
{
  return this->numMedSalas_.get ();
}

ItemUnidade::numMedSalas_type& ItemUnidade::
numMedSalas ()
{
  return this->numMedSalas_.get ();
}

void ItemUnidade::
numMedSalas (const numMedSalas_type& x)
{
  this->numMedSalas_.set (x);
}

const ItemUnidade::custoMedCred_type& ItemUnidade::
custoMedCred () const
{
  return this->custoMedCred_.get ();
}

ItemUnidade::custoMedCred_type& ItemUnidade::
custoMedCred ()
{
  return this->custoMedCred_.get ();
}

void ItemUnidade::
custoMedCred (const custoMedCred_type& x)
{
  this->custoMedCred_.set (x);
}

const ItemUnidade::salas_type& ItemUnidade::
salas () const
{
  return this->salas_.get ();
}

ItemUnidade::salas_type& ItemUnidade::
salas ()
{
  return this->salas_.get ();
}

void ItemUnidade::
salas (const salas_type& x)
{
  this->salas_.set (x);
}

void ItemUnidade::
salas (::std::auto_ptr< salas_type > x)
{
  this->salas_.set (x);
}

const ItemUnidade::horarios_type& ItemUnidade::
horarios () const
{
  return this->horarios_.get ();
}

ItemUnidade::horarios_type& ItemUnidade::
horarios ()
{
  return this->horarios_.get ();
}

void ItemUnidade::
horarios (const horarios_type& x)
{
  this->horarios_.set (x);
}

void ItemUnidade::
horarios (::std::auto_ptr< horarios_type > x)
{
  this->horarios_.set (x);
}

const ItemUnidade::demanda_sequence& ItemUnidade::
demanda () const
{
  return this->demanda_;
}

ItemUnidade::demanda_sequence& ItemUnidade::
demanda ()
{
  return this->demanda_;
}

void ItemUnidade::
demanda (const demanda_sequence& s)
{
  this->demanda_ = s;
}

const ItemUnidade::unidadeCurriculo_type& ItemUnidade::
unidadeCurriculo () const
{
  return this->unidadeCurriculo_.get ();
}

ItemUnidade::unidadeCurriculo_type& ItemUnidade::
unidadeCurriculo ()
{
  return this->unidadeCurriculo_.get ();
}

void ItemUnidade::
unidadeCurriculo (const unidadeCurriculo_type& x)
{
  this->unidadeCurriculo_.set (x);
}

void ItemUnidade::
unidadeCurriculo (::std::auto_ptr< unidadeCurriculo_type > x)
{
  this->unidadeCurriculo_.set (x);
}

const ItemUnidade::deslocamentos_type& ItemUnidade::
deslocamentos () const
{
  return this->deslocamentos_.get ();
}

ItemUnidade::deslocamentos_type& ItemUnidade::
deslocamentos ()
{
  return this->deslocamentos_.get ();
}

void ItemUnidade::
deslocamentos (const deslocamentos_type& x)
{
  this->deslocamentos_.set (x);
}

void ItemUnidade::
deslocamentos (::std::auto_ptr< deslocamentos_type > x)
{
  this->deslocamentos_.set (x);
}


// ItemDisciplina
// 

const ItemDisciplina::id_type& ItemDisciplina::
id () const
{
  return this->id_.get ();
}

ItemDisciplina::id_type& ItemDisciplina::
id ()
{
  return this->id_.get ();
}

void ItemDisciplina::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemDisciplina::codigo_type& ItemDisciplina::
codigo () const
{
  return this->codigo_.get ();
}

ItemDisciplina::codigo_type& ItemDisciplina::
codigo ()
{
  return this->codigo_.get ();
}

void ItemDisciplina::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemDisciplina::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemDisciplina::nome_type& ItemDisciplina::
nome () const
{
  return this->nome_.get ();
}

ItemDisciplina::nome_type& ItemDisciplina::
nome ()
{
  return this->nome_.get ();
}

void ItemDisciplina::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemDisciplina::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemDisciplina::cred_teoricos_type& ItemDisciplina::
cred_teoricos () const
{
  return this->cred_teoricos_.get ();
}

ItemDisciplina::cred_teoricos_type& ItemDisciplina::
cred_teoricos ()
{
  return this->cred_teoricos_.get ();
}

void ItemDisciplina::
cred_teoricos (const cred_teoricos_type& x)
{
  this->cred_teoricos_.set (x);
}

void ItemDisciplina::
cred_teoricos (::std::auto_ptr< cred_teoricos_type > x)
{
  this->cred_teoricos_.set (x);
}

const ItemDisciplina::cred_praticos_type& ItemDisciplina::
cred_praticos () const
{
  return this->cred_praticos_.get ();
}

ItemDisciplina::cred_praticos_type& ItemDisciplina::
cred_praticos ()
{
  return this->cred_praticos_.get ();
}

void ItemDisciplina::
cred_praticos (const cred_praticos_type& x)
{
  this->cred_praticos_.set (x);
}

void ItemDisciplina::
cred_praticos (::std::auto_ptr< cred_praticos_type > x)
{
  this->cred_praticos_.set (x);
}

const ItemDisciplina::laboratorio_type& ItemDisciplina::
laboratorio () const
{
  return this->laboratorio_.get ();
}

ItemDisciplina::laboratorio_type& ItemDisciplina::
laboratorio ()
{
  return this->laboratorio_.get ();
}

void ItemDisciplina::
laboratorio (const laboratorio_type& x)
{
  this->laboratorio_.set (x);
}

const ItemDisciplina::TipoDisciplina_type& ItemDisciplina::
TipoDisciplina () const
{
  return this->TipoDisciplina_.get ();
}

ItemDisciplina::TipoDisciplina_type& ItemDisciplina::
TipoDisciplina ()
{
  return this->TipoDisciplina_.get ();
}

void ItemDisciplina::
TipoDisciplina (const TipoDisciplina_type& x)
{
  this->TipoDisciplina_.set (x);
}

void ItemDisciplina::
TipoDisciplina (::std::auto_ptr< TipoDisciplina_type > x)
{
  this->TipoDisciplina_.set (x);
}

const ItemDisciplina::DivisaoCreditos_type& ItemDisciplina::
DivisaoCreditos () const
{
  return this->DivisaoCreditos_.get ();
}

ItemDisciplina::DivisaoCreditos_type& ItemDisciplina::
DivisaoCreditos ()
{
  return this->DivisaoCreditos_.get ();
}

void ItemDisciplina::
DivisaoCreditos (const DivisaoCreditos_type& x)
{
  this->DivisaoCreditos_.set (x);
}

void ItemDisciplina::
DivisaoCreditos (::std::auto_ptr< DivisaoCreditos_type > x)
{
  this->DivisaoCreditos_.set (x);
}

const ItemDisciplina::compatibilidades_type& ItemDisciplina::
compatibilidades () const
{
  return this->compatibilidades_.get ();
}

ItemDisciplina::compatibilidades_type& ItemDisciplina::
compatibilidades ()
{
  return this->compatibilidades_.get ();
}

void ItemDisciplina::
compatibilidades (const compatibilidades_type& x)
{
  this->compatibilidades_.set (x);
}

void ItemDisciplina::
compatibilidades (::std::auto_ptr< compatibilidades_type > x)
{
  this->compatibilidades_.set (x);
}

const ItemDisciplina::equivalencia_type& ItemDisciplina::
equivalencia () const
{
  return this->equivalencia_.get ();
}

ItemDisciplina::equivalencia_type& ItemDisciplina::
equivalencia ()
{
  return this->equivalencia_.get ();
}

void ItemDisciplina::
equivalencia (const equivalencia_type& x)
{
  this->equivalencia_.set (x);
}

void ItemDisciplina::
equivalencia (::std::auto_ptr< equivalencia_type > x)
{
  this->equivalencia_.set (x);
}

const ItemDisciplina::horarios_type& ItemDisciplina::
horarios () const
{
  return this->horarios_.get ();
}

ItemDisciplina::horarios_type& ItemDisciplina::
horarios ()
{
  return this->horarios_.get ();
}

void ItemDisciplina::
horarios (const horarios_type& x)
{
  this->horarios_.set (x);
}

void ItemDisciplina::
horarios (::std::auto_ptr< horarios_type > x)
{
  this->horarios_.set (x);
}

const ItemDisciplina::salas_type& ItemDisciplina::
salas () const
{
  return this->salas_.get ();
}

ItemDisciplina::salas_type& ItemDisciplina::
salas ()
{
  return this->salas_.get ();
}

void ItemDisciplina::
salas (const salas_type& x)
{
  this->salas_.set (x);
}

void ItemDisciplina::
salas (::std::auto_ptr< salas_type > x)
{
  this->salas_.set (x);
}

const ItemDisciplina::divisaoDeCreditos_type& ItemDisciplina::
divisaoDeCreditos () const
{
  return this->divisaoDeCreditos_.get ();
}

ItemDisciplina::divisaoDeCreditos_type& ItemDisciplina::
divisaoDeCreditos ()
{
  return this->divisaoDeCreditos_.get ();
}

void ItemDisciplina::
divisaoDeCreditos (const divisaoDeCreditos_type& x)
{
  this->divisaoDeCreditos_.set (x);
}

void ItemDisciplina::
divisaoDeCreditos (::std::auto_ptr< divisaoDeCreditos_type > x)
{
  this->divisaoDeCreditos_.set (x);
}

const ItemDisciplina::turmas_type& ItemDisciplina::
turmas () const
{
  return this->turmas_.get ();
}

ItemDisciplina::turmas_type& ItemDisciplina::
turmas ()
{
  return this->turmas_.get ();
}

void ItemDisciplina::
turmas (const turmas_type& x)
{
  this->turmas_.set (x);
}

void ItemDisciplina::
turmas (::std::auto_ptr< turmas_type > x)
{
  this->turmas_.set (x);
}


// GrupoDisciplina
// 

const GrupoDisciplina::Disciplina_sequence& GrupoDisciplina::
Disciplina () const
{
  return this->Disciplina_;
}

GrupoDisciplina::Disciplina_sequence& GrupoDisciplina::
Disciplina ()
{
  return this->Disciplina_;
}

void GrupoDisciplina::
Disciplina (const Disciplina_sequence& s)
{
  this->Disciplina_ = s;
}


// ItemCalendario
// 

const ItemCalendario::id_type& ItemCalendario::
id () const
{
  return this->id_.get ();
}

ItemCalendario::id_type& ItemCalendario::
id ()
{
  return this->id_.get ();
}

void ItemCalendario::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemCalendario::turnos_type& ItemCalendario::
turnos () const
{
  return this->turnos_.get ();
}

ItemCalendario::turnos_type& ItemCalendario::
turnos ()
{
  return this->turnos_.get ();
}

void ItemCalendario::
turnos (const turnos_type& x)
{
  this->turnos_.set (x);
}

void ItemCalendario::
turnos (::std::auto_ptr< turnos_type > x)
{
  this->turnos_.set (x);
}

const ItemCalendario::codigo_type& ItemCalendario::
codigo () const
{
  return this->codigo_.get ();
}

ItemCalendario::codigo_type& ItemCalendario::
codigo ()
{
  return this->codigo_.get ();
}

void ItemCalendario::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemCalendario::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemCalendario::descricao_type& ItemCalendario::
descricao () const
{
  return this->descricao_.get ();
}

ItemCalendario::descricao_type& ItemCalendario::
descricao ()
{
  return this->descricao_.get ();
}

void ItemCalendario::
descricao (const descricao_type& x)
{
  this->descricao_.set (x);
}

void ItemCalendario::
descricao (::std::auto_ptr< descricao_type > x)
{
  this->descricao_.set (x);
}

const ItemCalendario::tempoAula_type& ItemCalendario::
tempoAula () const
{
  return this->tempoAula_.get ();
}

ItemCalendario::tempoAula_type& ItemCalendario::
tempoAula ()
{
  return this->tempoAula_.get ();
}

void ItemCalendario::
tempoAula (const tempoAula_type& x)
{
  this->tempoAula_.set (x);
}


// ItemHorarioDisponivel
// 

const ItemHorarioDisponivel::id_type& ItemHorarioDisponivel::
id () const
{
  return this->id_.get ();
}

ItemHorarioDisponivel::id_type& ItemHorarioDisponivel::
id ()
{
  return this->id_.get ();
}

void ItemHorarioDisponivel::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemHorarioDisponivel::semana_type& ItemHorarioDisponivel::
semana () const
{
  return this->semana_.get ();
}

ItemHorarioDisponivel::semana_type& ItemHorarioDisponivel::
semana ()
{
  return this->semana_.get ();
}

void ItemHorarioDisponivel::
semana (const semana_type& x)
{
  this->semana_.set (x);
}

const ItemHorarioDisponivel::horarioAula_type& ItemHorarioDisponivel::
horarioAula () const
{
  return this->horarioAula_.get ();
}

ItemHorarioDisponivel::horarioAula_type& ItemHorarioDisponivel::
horarioAula ()
{
  return this->horarioAula_.get ();
}

void ItemHorarioDisponivel::
horarioAula (const horarioAula_type& x)
{
  this->horarioAula_.set (x);
}

void ItemHorarioDisponivel::
horarioAula (::std::auto_ptr< horarioAula_type > x)
{
  this->horarioAula_.set (x);
}


// GrupoHorarioDisponivel
// 

const GrupoHorarioDisponivel::HorarioDisponivel_sequence& GrupoHorarioDisponivel::
HorarioDisponivel () const
{
  return this->HorarioDisponivel_;
}

GrupoHorarioDisponivel::HorarioDisponivel_sequence& GrupoHorarioDisponivel::
HorarioDisponivel ()
{
  return this->HorarioDisponivel_;
}

void GrupoHorarioDisponivel::
HorarioDisponivel (const HorarioDisponivel_sequence& s)
{
  this->HorarioDisponivel_ = s;
}


// ItemHorarioAula
// 

const ItemHorarioAula::horariosDisponiveis_type& ItemHorarioAula::
horariosDisponiveis () const
{
  return this->horariosDisponiveis_.get ();
}

ItemHorarioAula::horariosDisponiveis_type& ItemHorarioAula::
horariosDisponiveis ()
{
  return this->horariosDisponiveis_.get ();
}

void ItemHorarioAula::
horariosDisponiveis (const horariosDisponiveis_type& x)
{
  this->horariosDisponiveis_.set (x);
}

void ItemHorarioAula::
horariosDisponiveis (::std::auto_ptr< horariosDisponiveis_type > x)
{
  this->horariosDisponiveis_.set (x);
}

const ItemHorarioAula::id_type& ItemHorarioAula::
id () const
{
  return this->id_.get ();
}

ItemHorarioAula::id_type& ItemHorarioAula::
id ()
{
  return this->id_.get ();
}

void ItemHorarioAula::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemHorarioAula::inicio_type& ItemHorarioAula::
inicio () const
{
  return this->inicio_.get ();
}

ItemHorarioAula::inicio_type& ItemHorarioAula::
inicio ()
{
  return this->inicio_.get ();
}

void ItemHorarioAula::
inicio (const inicio_type& x)
{
  this->inicio_.set (x);
}

void ItemHorarioAula::
inicio (::std::auto_ptr< inicio_type > x)
{
  this->inicio_.set (x);
}

const ItemHorarioAula::Turno_type& ItemHorarioAula::
Turno () const
{
  return this->Turno_.get ();
}

ItemHorarioAula::Turno_type& ItemHorarioAula::
Turno ()
{
  return this->Turno_.get ();
}

void ItemHorarioAula::
Turno (const Turno_type& x)
{
  this->Turno_.set (x);
}

void ItemHorarioAula::
Turno (::std::auto_ptr< Turno_type > x)
{
  this->Turno_.set (x);
}


// GrupoHorarioAula
// 

const GrupoHorarioAula::HorarioAula_sequence& GrupoHorarioAula::
HorarioAula () const
{
  return this->HorarioAula_;
}

GrupoHorarioAula::HorarioAula_sequence& GrupoHorarioAula::
HorarioAula ()
{
  return this->HorarioAula_;
}

void GrupoHorarioAula::
HorarioAula (const HorarioAula_sequence& s)
{
  this->HorarioAula_ = s;
}


// ItemTurno
// 

const ItemTurno::id_type& ItemTurno::
id () const
{
  return this->id_.get ();
}

ItemTurno::id_type& ItemTurno::
id ()
{
  return this->id_.get ();
}

void ItemTurno::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTurno::nome_type& ItemTurno::
nome () const
{
  return this->nome_.get ();
}

ItemTurno::nome_type& ItemTurno::
nome ()
{
  return this->nome_.get ();
}

void ItemTurno::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTurno::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemTurno::HorariosAula_type& ItemTurno::
HorariosAula () const
{
  return this->HorariosAula_.get ();
}

ItemTurno::HorariosAula_type& ItemTurno::
HorariosAula ()
{
  return this->HorariosAula_.get ();
}

void ItemTurno::
HorariosAula (const HorariosAula_type& x)
{
  this->HorariosAula_.set (x);
}

void ItemTurno::
HorariosAula (::std::auto_ptr< HorariosAula_type > x)
{
  this->HorariosAula_.set (x);
}

const ItemTurno::Calendario_type& ItemTurno::
Calendario () const
{
  return this->Calendario_.get ();
}

ItemTurno::Calendario_type& ItemTurno::
Calendario ()
{
  return this->Calendario_.get ();
}

void ItemTurno::
Calendario (const Calendario_type& x)
{
  this->Calendario_.set (x);
}

void ItemTurno::
Calendario (::std::auto_ptr< Calendario_type > x)
{
  this->Calendario_.set (x);
}


// GrupoTurno
// 

const GrupoTurno::Turno_sequence& GrupoTurno::
Turno () const
{
  return this->Turno_;
}

GrupoTurno::Turno_sequence& GrupoTurno::
Turno ()
{
  return this->Turno_;
}

void GrupoTurno::
Turno (const Turno_sequence& s)
{
  this->Turno_ = s;
}


// ItemSala
// 

const ItemSala::id_type& ItemSala::
id () const
{
  return this->id_.get ();
}

ItemSala::id_type& ItemSala::
id ()
{
  return this->id_.get ();
}

void ItemSala::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemSala::tipoSala_type& ItemSala::
tipoSala () const
{
  return this->tipoSala_.get ();
}

ItemSala::tipoSala_type& ItemSala::
tipoSala ()
{
  return this->tipoSala_.get ();
}

void ItemSala::
tipoSala (const tipoSala_type& x)
{
  this->tipoSala_.set (x);
}

void ItemSala::
tipoSala (::std::auto_ptr< tipoSala_type > x)
{
  this->tipoSala_.set (x);
}

const ItemSala::HorariosDisponiveis_type& ItemSala::
HorariosDisponiveis () const
{
  return this->HorariosDisponiveis_.get ();
}

ItemSala::HorariosDisponiveis_type& ItemSala::
HorariosDisponiveis ()
{
  return this->HorariosDisponiveis_.get ();
}

void ItemSala::
HorariosDisponiveis (const HorariosDisponiveis_type& x)
{
  this->HorariosDisponiveis_.set (x);
}

void ItemSala::
HorariosDisponiveis (::std::auto_ptr< HorariosDisponiveis_type > x)
{
  this->HorariosDisponiveis_.set (x);
}

const ItemSala::codigo_type& ItemSala::
codigo () const
{
  return this->codigo_.get ();
}

ItemSala::codigo_type& ItemSala::
codigo ()
{
  return this->codigo_.get ();
}

void ItemSala::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemSala::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemSala::numSalas_type& ItemSala::
numSalas () const
{
  return this->numSalas_.get ();
}

ItemSala::numSalas_type& ItemSala::
numSalas ()
{
  return this->numSalas_.get ();
}

void ItemSala::
numSalas (const numSalas_type& x)
{
  this->numSalas_.set (x);
}

const ItemSala::andar_type& ItemSala::
andar () const
{
  return this->andar_.get ();
}

ItemSala::andar_type& ItemSala::
andar ()
{
  return this->andar_.get ();
}

void ItemSala::
andar (const andar_type& x)
{
  this->andar_.set (x);
}

void ItemSala::
andar (::std::auto_ptr< andar_type > x)
{
  this->andar_.set (x);
}

const ItemSala::capacidade_type& ItemSala::
capacidade () const
{
  return this->capacidade_.get ();
}

ItemSala::capacidade_type& ItemSala::
capacidade ()
{
  return this->capacidade_.get ();
}

void ItemSala::
capacidade (const capacidade_type& x)
{
  this->capacidade_.set (x);
}


// ItemDisciplinaPeriodo
// 

const ItemDisciplinaPeriodo::periodo_type& ItemDisciplinaPeriodo::
periodo () const
{
  return this->periodo_.get ();
}

ItemDisciplinaPeriodo::periodo_type& ItemDisciplinaPeriodo::
periodo ()
{
  return this->periodo_.get ();
}

void ItemDisciplinaPeriodo::
periodo (const periodo_type& x)
{
  this->periodo_.set (x);
}

const ItemDisciplinaPeriodo::disciplina_type& ItemDisciplinaPeriodo::
disciplina () const
{
  return this->disciplina_.get ();
}

ItemDisciplinaPeriodo::disciplina_type& ItemDisciplinaPeriodo::
disciplina ()
{
  return this->disciplina_.get ();
}

void ItemDisciplinaPeriodo::
disciplina (const disciplina_type& x)
{
  this->disciplina_.set (x);
}

void ItemDisciplinaPeriodo::
disciplina (::std::auto_ptr< disciplina_type > x)
{
  this->disciplina_.set (x);
}


// ItemCurriculo
// 

const ItemCurriculo::id_type& ItemCurriculo::
id () const
{
  return this->id_.get ();
}

ItemCurriculo::id_type& ItemCurriculo::
id ()
{
  return this->id_.get ();
}

void ItemCurriculo::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemCurriculo::codigo_type& ItemCurriculo::
codigo () const
{
  return this->codigo_.get ();
}

ItemCurriculo::codigo_type& ItemCurriculo::
codigo ()
{
  return this->codigo_.get ();
}

void ItemCurriculo::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemCurriculo::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemCurriculo::descricao_type& ItemCurriculo::
descricao () const
{
  return this->descricao_.get ();
}

ItemCurriculo::descricao_type& ItemCurriculo::
descricao ()
{
  return this->descricao_.get ();
}

void ItemCurriculo::
descricao (const descricao_type& x)
{
  this->descricao_.set (x);
}

void ItemCurriculo::
descricao (::std::auto_ptr< descricao_type > x)
{
  this->descricao_.set (x);
}

const ItemCurriculo::DisciplinasPeriodo_type& ItemCurriculo::
DisciplinasPeriodo () const
{
  return this->DisciplinasPeriodo_.get ();
}

ItemCurriculo::DisciplinasPeriodo_type& ItemCurriculo::
DisciplinasPeriodo ()
{
  return this->DisciplinasPeriodo_.get ();
}

void ItemCurriculo::
DisciplinasPeriodo (const DisciplinasPeriodo_type& x)
{
  this->DisciplinasPeriodo_.set (x);
}

void ItemCurriculo::
DisciplinasPeriodo (::std::auto_ptr< DisciplinasPeriodo_type > x)
{
  this->DisciplinasPeriodo_.set (x);
}


// GrupoCurriculo
// 

const GrupoCurriculo::Curriculo_sequence& GrupoCurriculo::
Curriculo () const
{
  return this->Curriculo_;
}

GrupoCurriculo::Curriculo_sequence& GrupoCurriculo::
Curriculo ()
{
  return this->Curriculo_;
}

void GrupoCurriculo::
Curriculo (const Curriculo_sequence& s)
{
  this->Curriculo_ = s;
}


// GrupoSala
// 

const GrupoSala::Sala_sequence& GrupoSala::
Sala () const
{
  return this->Sala_;
}

GrupoSala::Sala_sequence& GrupoSala::
Sala ()
{
  return this->Sala_;
}

void GrupoSala::
Sala (const Sala_sequence& s)
{
  this->Sala_ = s;
}


// ItemCurso
// 

const ItemCurso::id_type& ItemCurso::
id () const
{
  return this->id_.get ();
}

ItemCurso::id_type& ItemCurso::
id ()
{
  return this->id_.get ();
}

void ItemCurso::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemCurso::codigo_type& ItemCurso::
codigo () const
{
  return this->codigo_.get ();
}

ItemCurso::codigo_type& ItemCurso::
codigo ()
{
  return this->codigo_.get ();
}

void ItemCurso::
codigo (const codigo_type& x)
{
  this->codigo_.set (x);
}

void ItemCurso::
codigo (::std::auto_ptr< codigo_type > x)
{
  this->codigo_.set (x);
}

const ItemCurso::tipo_type& ItemCurso::
tipo () const
{
  return this->tipo_.get ();
}

ItemCurso::tipo_type& ItemCurso::
tipo ()
{
  return this->tipo_.get ();
}

void ItemCurso::
tipo (const tipo_type& x)
{
  this->tipo_.set (x);
}

void ItemCurso::
tipo (::std::auto_ptr< tipo_type > x)
{
  this->tipo_.set (x);
}

const ItemCurso::numPeriodos_type& ItemCurso::
numPeriodos () const
{
  return this->numPeriodos_.get ();
}

ItemCurso::numPeriodos_type& ItemCurso::
numPeriodos ()
{
  return this->numPeriodos_.get ();
}

void ItemCurso::
numPeriodos (const numPeriodos_type& x)
{
  this->numPeriodos_.set (x);
}

const ItemCurso::qtdMinDoutores_type& ItemCurso::
qtdMinDoutores () const
{
  return this->qtdMinDoutores_.get ();
}

ItemCurso::qtdMinDoutores_type& ItemCurso::
qtdMinDoutores ()
{
  return this->qtdMinDoutores_.get ();
}

void ItemCurso::
qtdMinDoutores (const qtdMinDoutores_type& x)
{
  this->qtdMinDoutores_.set (x);
}

const ItemCurso::qtdMinMestres_type& ItemCurso::
qtdMinMestres () const
{
  return this->qtdMinMestres_.get ();
}

ItemCurso::qtdMinMestres_type& ItemCurso::
qtdMinMestres ()
{
  return this->qtdMinMestres_.get ();
}

void ItemCurso::
qtdMinMestres (const qtdMinMestres_type& x)
{
  this->qtdMinMestres_.set (x);
}

const ItemCurso::qtdMaxProfDisc_type& ItemCurso::
qtdMaxProfDisc () const
{
  return this->qtdMaxProfDisc_.get ();
}

ItemCurso::qtdMaxProfDisc_type& ItemCurso::
qtdMaxProfDisc ()
{
  return this->qtdMaxProfDisc_.get ();
}

void ItemCurso::
qtdMaxProfDisc (const qtdMaxProfDisc_type& x)
{
  this->qtdMaxProfDisc_.set (x);
}

const ItemCurso::areaTitulacao_type& ItemCurso::
areaTitulacao () const
{
  return this->areaTitulacao_.get ();
}

ItemCurso::areaTitulacao_type& ItemCurso::
areaTitulacao ()
{
  return this->areaTitulacao_.get ();
}

void ItemCurso::
areaTitulacao (const areaTitulacao_type& x)
{
  this->areaTitulacao_.set (x);
}

void ItemCurso::
areaTitulacao (::std::auto_ptr< areaTitulacao_type > x)
{
  this->areaTitulacao_.set (x);
}

const ItemCurso::Curriculos_type& ItemCurso::
Curriculos () const
{
  return this->Curriculos_.get ();
}

ItemCurso::Curriculos_type& ItemCurso::
Curriculos ()
{
  return this->Curriculos_.get ();
}

void ItemCurso::
Curriculos (const Curriculos_type& x)
{
  this->Curriculos_.set (x);
}

void ItemCurso::
Curriculos (::std::auto_ptr< Curriculos_type > x)
{
  this->Curriculos_.set (x);
}


// GrupoCurso
// 

const GrupoCurso::Curso_sequence& GrupoCurso::
Curso () const
{
  return this->Curso_;
}

GrupoCurso::Curso_sequence& GrupoCurso::
Curso ()
{
  return this->Curso_;
}

void GrupoCurso::
Curso (const Curso_sequence& s)
{
  this->Curso_ = s;
}


// ItemDemanda
// 

const ItemDemanda::quantidade_type& ItemDemanda::
quantidade () const
{
  return this->quantidade_.get ();
}

ItemDemanda::quantidade_type& ItemDemanda::
quantidade ()
{
  return this->quantidade_.get ();
}

void ItemDemanda::
quantidade (const quantidade_type& x)
{
  this->quantidade_.set (x);
}

const ItemDemanda::turno_type& ItemDemanda::
turno () const
{
  return this->turno_.get ();
}

ItemDemanda::turno_type& ItemDemanda::
turno ()
{
  return this->turno_.get ();
}

void ItemDemanda::
turno (const turno_type& x)
{
  this->turno_.set (x);
}

void ItemDemanda::
turno (::std::auto_ptr< turno_type > x)
{
  this->turno_.set (x);
}

const ItemDemanda::disciplina_type& ItemDemanda::
disciplina () const
{
  return this->disciplina_.get ();
}

ItemDemanda::disciplina_type& ItemDemanda::
disciplina ()
{
  return this->disciplina_.get ();
}

void ItemDemanda::
disciplina (const disciplina_type& x)
{
  this->disciplina_.set (x);
}

void ItemDemanda::
disciplina (::std::auto_ptr< disciplina_type > x)
{
  this->disciplina_.set (x);
}

const ItemDemanda::curso_type& ItemDemanda::
curso () const
{
  return this->curso_.get ();
}

ItemDemanda::curso_type& ItemDemanda::
curso ()
{
  return this->curso_.get ();
}

void ItemDemanda::
curso (const curso_type& x)
{
  this->curso_.set (x);
}

void ItemDemanda::
curso (::std::auto_ptr< curso_type > x)
{
  this->curso_.set (x);
}


// GrupoDemanda
// 

const GrupoDemanda::Demanda_sequence& GrupoDemanda::
Demanda () const
{
  return this->Demanda_;
}

GrupoDemanda::Demanda_sequence& GrupoDemanda::
Demanda ()
{
  return this->Demanda_;
}

void GrupoDemanda::
Demanda (const Demanda_sequence& s)
{
  this->Demanda_ = s;
}


// ItemUnidadeCurriculo
// 

const ItemUnidadeCurriculo::turno_type& ItemUnidadeCurriculo::
turno () const
{
  return this->turno_.get ();
}

ItemUnidadeCurriculo::turno_type& ItemUnidadeCurriculo::
turno ()
{
  return this->turno_.get ();
}

void ItemUnidadeCurriculo::
turno (const turno_type& x)
{
  this->turno_.set (x);
}

void ItemUnidadeCurriculo::
turno (::std::auto_ptr< turno_type > x)
{
  this->turno_.set (x);
}

const ItemUnidadeCurriculo::curriculo_type& ItemUnidadeCurriculo::
curriculo () const
{
  return this->curriculo_.get ();
}

ItemUnidadeCurriculo::curriculo_type& ItemUnidadeCurriculo::
curriculo ()
{
  return this->curriculo_.get ();
}

void ItemUnidadeCurriculo::
curriculo (const curriculo_type& x)
{
  this->curriculo_.set (x);
}

void ItemUnidadeCurriculo::
curriculo (::std::auto_ptr< curriculo_type > x)
{
  this->curriculo_.set (x);
}


// GrupoUnidadeCurriculo
// 

const GrupoUnidadeCurriculo::UnidadeCurriculo_sequence& GrupoUnidadeCurriculo::
UnidadeCurriculo () const
{
  return this->UnidadeCurriculo_;
}

GrupoUnidadeCurriculo::UnidadeCurriculo_sequence& GrupoUnidadeCurriculo::
UnidadeCurriculo ()
{
  return this->UnidadeCurriculo_;
}

void GrupoUnidadeCurriculo::
UnidadeCurriculo (const UnidadeCurriculo_sequence& s)
{
  this->UnidadeCurriculo_ = s;
}


// ItemAlocacao
// 

const ItemAlocacao::professor_type& ItemAlocacao::
professor () const
{
  return this->professor_.get ();
}

ItemAlocacao::professor_type& ItemAlocacao::
professor ()
{
  return this->professor_.get ();
}

void ItemAlocacao::
professor (const professor_type& x)
{
  this->professor_.set (x);
}

void ItemAlocacao::
professor (::std::auto_ptr< professor_type > x)
{
  this->professor_.set (x);
}

const ItemAlocacao::horario_type& ItemAlocacao::
horario () const
{
  return this->horario_.get ();
}

ItemAlocacao::horario_type& ItemAlocacao::
horario ()
{
  return this->horario_.get ();
}

void ItemAlocacao::
horario (const horario_type& x)
{
  this->horario_.set (x);
}

void ItemAlocacao::
horario (::std::auto_ptr< horario_type > x)
{
  this->horario_.set (x);
}

const ItemAlocacao::oferecimento_type& ItemAlocacao::
oferecimento () const
{
  return this->oferecimento_.get ();
}

ItemAlocacao::oferecimento_type& ItemAlocacao::
oferecimento ()
{
  return this->oferecimento_.get ();
}

void ItemAlocacao::
oferecimento (const oferecimento_type& x)
{
  this->oferecimento_.set (x);
}

void ItemAlocacao::
oferecimento (::std::auto_ptr< oferecimento_type > x)
{
  this->oferecimento_.set (x);
}


// ItemOferecimento
// 

const ItemOferecimento::id_type& ItemOferecimento::
id () const
{
  return this->id_.get ();
}

ItemOferecimento::id_type& ItemOferecimento::
id ()
{
  return this->id_.get ();
}

void ItemOferecimento::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemOferecimento::sala_type& ItemOferecimento::
sala () const
{
  return this->sala_.get ();
}

ItemOferecimento::sala_type& ItemOferecimento::
sala ()
{
  return this->sala_.get ();
}

void ItemOferecimento::
sala (const sala_type& x)
{
  this->sala_.set (x);
}

void ItemOferecimento::
sala (::std::auto_ptr< sala_type > x)
{
  this->sala_.set (x);
}

const ItemOferecimento::semana_type& ItemOferecimento::
semana () const
{
  return this->semana_.get ();
}

ItemOferecimento::semana_type& ItemOferecimento::
semana ()
{
  return this->semana_.get ();
}

void ItemOferecimento::
semana (const semana_type& x)
{
  this->semana_.set (x);
}

const ItemOferecimento::creditos_type& ItemOferecimento::
creditos () const
{
  return this->creditos_.get ();
}

ItemOferecimento::creditos_type& ItemOferecimento::
creditos ()
{
  return this->creditos_.get ();
}

void ItemOferecimento::
creditos (const creditos_type& x)
{
  this->creditos_.set (x);
}

const ItemOferecimento::turma_type& ItemOferecimento::
turma () const
{
  return this->turma_.get ();
}

ItemOferecimento::turma_type& ItemOferecimento::
turma ()
{
  return this->turma_.get ();
}

void ItemOferecimento::
turma (const turma_type& x)
{
  this->turma_.set (x);
}

void ItemOferecimento::
turma (::std::auto_ptr< turma_type > x)
{
  this->turma_.set (x);
}

const ItemOferecimento::alocacao_type& ItemOferecimento::
alocacao () const
{
  return this->alocacao_.get ();
}

ItemOferecimento::alocacao_type& ItemOferecimento::
alocacao ()
{
  return this->alocacao_.get ();
}

void ItemOferecimento::
alocacao (const alocacao_type& x)
{
  this->alocacao_.set (x);
}

void ItemOferecimento::
alocacao (::std::auto_ptr< alocacao_type > x)
{
  this->alocacao_.set (x);
}


// GrupoOferecimento
// 

const GrupoOferecimento::Oferecimento_sequence& GrupoOferecimento::
Oferecimento () const
{
  return this->Oferecimento_;
}

GrupoOferecimento::Oferecimento_sequence& GrupoOferecimento::
Oferecimento ()
{
  return this->Oferecimento_;
}

void GrupoOferecimento::
Oferecimento (const Oferecimento_sequence& s)
{
  this->Oferecimento_ = s;
}


// ItemTurma
// 

const ItemTurma::id_type& ItemTurma::
id () const
{
  return this->id_.get ();
}

ItemTurma::id_type& ItemTurma::
id ()
{
  return this->id_.get ();
}

void ItemTurma::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTurma::nome_type& ItemTurma::
nome () const
{
  return this->nome_.get ();
}

ItemTurma::nome_type& ItemTurma::
nome ()
{
  return this->nome_.get ();
}

void ItemTurma::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTurma::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemTurma::disciplina_type& ItemTurma::
disciplina () const
{
  return this->disciplina_.get ();
}

ItemTurma::disciplina_type& ItemTurma::
disciplina ()
{
  return this->disciplina_.get ();
}

void ItemTurma::
disciplina (const disciplina_type& x)
{
  this->disciplina_.set (x);
}

void ItemTurma::
disciplina (::std::auto_ptr< disciplina_type > x)
{
  this->disciplina_.set (x);
}

const ItemTurma::oferecimentos_type& ItemTurma::
oferecimentos () const
{
  return this->oferecimentos_.get ();
}

ItemTurma::oferecimentos_type& ItemTurma::
oferecimentos ()
{
  return this->oferecimentos_.get ();
}

void ItemTurma::
oferecimentos (const oferecimentos_type& x)
{
  this->oferecimentos_.set (x);
}

void ItemTurma::
oferecimentos (::std::auto_ptr< oferecimentos_type > x)
{
  this->oferecimentos_.set (x);
}


// GrupoTurma
// 

const GrupoTurma::Turma_sequence& GrupoTurma::
Turma () const
{
  return this->Turma_;
}

GrupoTurma::Turma_sequence& GrupoTurma::
Turma ()
{
  return this->Turma_;
}

void GrupoTurma::
Turma (const Turma_sequence& s)
{
  this->Turma_ = s;
}


// ItemTipoSala
// 

const ItemTipoSala::id_optional& ItemTipoSala::
id () const
{
  return this->id_;
}

ItemTipoSala::id_optional& ItemTipoSala::
id ()
{
  return this->id_;
}

void ItemTipoSala::
id (const id_type& x)
{
  this->id_.set (x);
}

void ItemTipoSala::
id (const id_optional& x)
{
  this->id_ = x;
}

const ItemTipoSala::nome_optional& ItemTipoSala::
nome () const
{
  return this->nome_;
}

ItemTipoSala::nome_optional& ItemTipoSala::
nome ()
{
  return this->nome_;
}

void ItemTipoSala::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoSala::
nome (const nome_optional& x)
{
  this->nome_ = x;
}

void ItemTipoSala::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}

const ItemTipoSala::descricao_optional& ItemTipoSala::
descricao () const
{
  return this->descricao_;
}

ItemTipoSala::descricao_optional& ItemTipoSala::
descricao ()
{
  return this->descricao_;
}

void ItemTipoSala::
descricao (const descricao_type& x)
{
  this->descricao_.set (x);
}

void ItemTipoSala::
descricao (const descricao_optional& x)
{
  this->descricao_ = x;
}

void ItemTipoSala::
descricao (::std::auto_ptr< descricao_type > x)
{
  this->descricao_.set (x);
}


// ItemTipoContrato
// 

const ItemTipoContrato::id_type& ItemTipoContrato::
id () const
{
  return this->id_.get ();
}

ItemTipoContrato::id_type& ItemTipoContrato::
id ()
{
  return this->id_.get ();
}

void ItemTipoContrato::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoContrato::nome_type& ItemTipoContrato::
nome () const
{
  return this->nome_.get ();
}

ItemTipoContrato::nome_type& ItemTipoContrato::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoContrato::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoContrato::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemTipoTitulacao
// 

const ItemTipoTitulacao::id_type& ItemTipoTitulacao::
id () const
{
  return this->id_.get ();
}

ItemTipoTitulacao::id_type& ItemTipoTitulacao::
id ()
{
  return this->id_.get ();
}

void ItemTipoTitulacao::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoTitulacao::nome_type& ItemTipoTitulacao::
nome () const
{
  return this->nome_.get ();
}

ItemTipoTitulacao::nome_type& ItemTipoTitulacao::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoTitulacao::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoTitulacao::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemAreaTitulacao
// 

const ItemAreaTitulacao::id_type& ItemAreaTitulacao::
id () const
{
  return this->id_.get ();
}

ItemAreaTitulacao::id_type& ItemAreaTitulacao::
id ()
{
  return this->id_.get ();
}

void ItemAreaTitulacao::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemAreaTitulacao::nome_type& ItemAreaTitulacao::
nome () const
{
  return this->nome_.get ();
}

ItemAreaTitulacao::nome_type& ItemAreaTitulacao::
nome ()
{
  return this->nome_.get ();
}

void ItemAreaTitulacao::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemAreaTitulacao::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemTipoDisciplina
// 

const ItemTipoDisciplina::id_type& ItemTipoDisciplina::
id () const
{
  return this->id_.get ();
}

ItemTipoDisciplina::id_type& ItemTipoDisciplina::
id ()
{
  return this->id_.get ();
}

void ItemTipoDisciplina::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoDisciplina::nome_type& ItemTipoDisciplina::
nome () const
{
  return this->nome_.get ();
}

ItemTipoDisciplina::nome_type& ItemTipoDisciplina::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoDisciplina::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoDisciplina::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// ItemTipoCurso
// 

const ItemTipoCurso::id_type& ItemTipoCurso::
id () const
{
  return this->id_.get ();
}

ItemTipoCurso::id_type& ItemTipoCurso::
id ()
{
  return this->id_.get ();
}

void ItemTipoCurso::
id (const id_type& x)
{
  this->id_.set (x);
}

const ItemTipoCurso::nome_type& ItemTipoCurso::
nome () const
{
  return this->nome_.get ();
}

ItemTipoCurso::nome_type& ItemTipoCurso::
nome ()
{
  return this->nome_.get ();
}

void ItemTipoCurso::
nome (const nome_type& x)
{
  this->nome_.set (x);
}

void ItemTipoCurso::
nome (::std::auto_ptr< nome_type > x)
{
  this->nome_.set (x);
}


// Trieda
// 

const Trieda::unidades_type& Trieda::
unidades () const
{
  return this->unidades_.get ();
}

Trieda::unidades_type& Trieda::
unidades ()
{
  return this->unidades_.get ();
}

void Trieda::
unidades (const unidades_type& x)
{
  this->unidades_.set (x);
}

void Trieda::
unidades (::std::auto_ptr< unidades_type > x)
{
  this->unidades_.set (x);
}

const Trieda::cursos_type& Trieda::
cursos () const
{
  return this->cursos_.get ();
}

Trieda::cursos_type& Trieda::
cursos ()
{
  return this->cursos_.get ();
}

void Trieda::
cursos (const cursos_type& x)
{
  this->cursos_.set (x);
}

void Trieda::
cursos (::std::auto_ptr< cursos_type > x)
{
  this->cursos_.set (x);
}

const Trieda::calendario_type& Trieda::
calendario () const
{
  return this->calendario_.get ();
}

Trieda::calendario_type& Trieda::
calendario ()
{
  return this->calendario_.get ();
}

void Trieda::
calendario (const calendario_type& x)
{
  this->calendario_.set (x);
}

void Trieda::
calendario (::std::auto_ptr< calendario_type > x)
{
  this->calendario_.set (x);
}

const Trieda::professores_type& Trieda::
professores () const
{
  return this->professores_.get ();
}

Trieda::professores_type& Trieda::
professores ()
{
  return this->professores_.get ();
}

void Trieda::
professores (const professores_type& x)
{
  this->professores_.set (x);
}

void Trieda::
professores (::std::auto_ptr< professores_type > x)
{
  this->professores_.set (x);
}

const Trieda::disciplinas_type& Trieda::
disciplinas () const
{
  return this->disciplinas_.get ();
}

Trieda::disciplinas_type& Trieda::
disciplinas ()
{
  return this->disciplinas_.get ();
}

void Trieda::
disciplinas (const disciplinas_type& x)
{
  this->disciplinas_.set (x);
}

void Trieda::
disciplinas (::std::auto_ptr< disciplinas_type > x)
{
  this->disciplinas_.set (x);
}

const Trieda::regrasCredito_type& Trieda::
regrasCredito () const
{
  return this->regrasCredito_.get ();
}

Trieda::regrasCredito_type& Trieda::
regrasCredito ()
{
  return this->regrasCredito_.get ();
}

void Trieda::
regrasCredito (const regrasCredito_type& x)
{
  this->regrasCredito_.set (x);
}

void Trieda::
regrasCredito (::std::auto_ptr< regrasCredito_type > x)
{
  this->regrasCredito_.set (x);
}


// UnidadeCurriculo
// 


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// ItemProfessorDisciplina
//

ItemProfessorDisciplina::
ItemProfessorDisciplina ()
: ::xml_schema::type (),
  nota_ (::xml_schema::flags (), this),
  ranking_ (::xml_schema::flags (), this),
  disciplina_ (::xml_schema::flags (), this)
{
}

ItemProfessorDisciplina::
ItemProfessorDisciplina (const ItemProfessorDisciplina& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  nota_ (x.nota_, f, this),
  ranking_ (x.ranking_, f, this),
  disciplina_ (x.disciplina_, f, this)
{
}

ItemProfessorDisciplina::
ItemProfessorDisciplina (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  nota_ (f, this),
  ranking_ (f, this),
  disciplina_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemProfessorDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // nota
    //
    if (n.name () == "nota" && n.namespace_ ().empty ())
    {
      if (!this->nota_)
      {
        this->nota_.set (nota_traits::create (i, f, this));
        continue;
      }
    }

    // ranking
    //
    if (n.name () == "ranking" && n.namespace_ ().empty ())
    {
      if (!this->ranking_)
      {
        this->ranking_.set (ranking_traits::create (i, f, this));
        continue;
      }
    }

    // disciplina
    //
    if (n.name () == "disciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplina_type > r (
        disciplina_traits::create (i, f, this));

      if (!this->disciplina_)
      {
        this->disciplina_.set (r);
        continue;
      }
    }

    break;
  }
}

ItemProfessorDisciplina* ItemProfessorDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemProfessorDisciplina (*this, f, c);
}

ItemProfessorDisciplina::
~ItemProfessorDisciplina ()
{
}

// GrupoProfessorDisciplina
//

GrupoProfessorDisciplina::
GrupoProfessorDisciplina ()
: ::xml_schema::type (),
  ProfessorDisciplina_ (::xml_schema::flags (), this)
{
}

GrupoProfessorDisciplina::
GrupoProfessorDisciplina (const GrupoProfessorDisciplina& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ProfessorDisciplina_ (x.ProfessorDisciplina_, f, this)
{
}

GrupoProfessorDisciplina::
GrupoProfessorDisciplina (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ProfessorDisciplina_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoProfessorDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ProfessorDisciplina
    //
    if (n.name () == "ProfessorDisciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ProfessorDisciplina_type > r (
        ProfessorDisciplina_traits::create (i, f, this));

      this->ProfessorDisciplina_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoProfessorDisciplina* GrupoProfessorDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoProfessorDisciplina (*this, f, c);
}

GrupoProfessorDisciplina::
~GrupoProfessorDisciplina ()
{
}

// ItemProfessor
//

ItemProfessor::
ItemProfessor (const id_type& id,
               const contrato_type& contrato,
               const titulacao_type& titulacao,
               const areaTitulacao_type& areaTitulacao,
               const cpf_type& cpf,
               const nome_type& nome,
               const chMin_type& chMin,
               const chMax_type& chMax,
               const credAnterior_type& credAnterior,
               const valorCred_type& valorCred,
               const unidades_type& unidades,
               const horarios_type& horarios,
               const disciplinas_type& disciplinas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  contrato_ (contrato, ::xml_schema::flags (), this),
  titulacao_ (titulacao, ::xml_schema::flags (), this),
  areaTitulacao_ (areaTitulacao, ::xml_schema::flags (), this),
  cpf_ (cpf, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  chMin_ (chMin, ::xml_schema::flags (), this),
  chMax_ (chMax, ::xml_schema::flags (), this),
  credAnterior_ (credAnterior, ::xml_schema::flags (), this),
  valorCred_ (valorCred, ::xml_schema::flags (), this),
  unidades_ (unidades, ::xml_schema::flags (), this),
  horarios_ (horarios, ::xml_schema::flags (), this),
  disciplinas_ (disciplinas, ::xml_schema::flags (), this)
{
}

ItemProfessor::
ItemProfessor (const id_type& id,
               ::std::auto_ptr< contrato_type >& contrato,
               ::std::auto_ptr< titulacao_type >& titulacao,
               ::std::auto_ptr< areaTitulacao_type >& areaTitulacao,
               const cpf_type& cpf,
               const nome_type& nome,
               const chMin_type& chMin,
               const chMax_type& chMax,
               const credAnterior_type& credAnterior,
               const valorCred_type& valorCred,
               ::std::auto_ptr< unidades_type >& unidades,
               ::std::auto_ptr< horarios_type >& horarios,
               ::std::auto_ptr< disciplinas_type >& disciplinas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  contrato_ (contrato, ::xml_schema::flags (), this),
  titulacao_ (titulacao, ::xml_schema::flags (), this),
  areaTitulacao_ (areaTitulacao, ::xml_schema::flags (), this),
  cpf_ (cpf, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  chMin_ (chMin, ::xml_schema::flags (), this),
  chMax_ (chMax, ::xml_schema::flags (), this),
  credAnterior_ (credAnterior, ::xml_schema::flags (), this),
  valorCred_ (valorCred, ::xml_schema::flags (), this),
  unidades_ (unidades, ::xml_schema::flags (), this),
  horarios_ (horarios, ::xml_schema::flags (), this),
  disciplinas_ (disciplinas, ::xml_schema::flags (), this)
{
}

ItemProfessor::
ItemProfessor (const ItemProfessor& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  contrato_ (x.contrato_, f, this),
  titulacao_ (x.titulacao_, f, this),
  areaTitulacao_ (x.areaTitulacao_, f, this),
  cpf_ (x.cpf_, f, this),
  nome_ (x.nome_, f, this),
  chMin_ (x.chMin_, f, this),
  chMax_ (x.chMax_, f, this),
  credAnterior_ (x.credAnterior_, f, this),
  valorCred_ (x.valorCred_, f, this),
  unidades_ (x.unidades_, f, this),
  horarios_ (x.horarios_, f, this),
  disciplinas_ (x.disciplinas_, f, this)
{
}

ItemProfessor::
ItemProfessor (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  contrato_ (f, this),
  titulacao_ (f, this),
  areaTitulacao_ (f, this),
  cpf_ (f, this),
  nome_ (f, this),
  chMin_ (f, this),
  chMax_ (f, this),
  credAnterior_ (f, this),
  valorCred_ (f, this),
  unidades_ (f, this),
  horarios_ (f, this),
  disciplinas_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemProfessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // contrato
    //
    if (n.name () == "contrato" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< contrato_type > r (
        contrato_traits::create (i, f, this));

      if (!contrato_.present ())
      {
        this->contrato_.set (r);
        continue;
      }
    }

    // titulacao
    //
    if (n.name () == "titulacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< titulacao_type > r (
        titulacao_traits::create (i, f, this));

      if (!titulacao_.present ())
      {
        this->titulacao_.set (r);
        continue;
      }
    }

    // areaTitulacao
    //
    if (n.name () == "areaTitulacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< areaTitulacao_type > r (
        areaTitulacao_traits::create (i, f, this));

      if (!areaTitulacao_.present ())
      {
        this->areaTitulacao_.set (r);
        continue;
      }
    }

    // cpf
    //
    if (n.name () == "cpf" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cpf_type > r (
        cpf_traits::create (i, f, this));

      if (!cpf_.present ())
      {
        this->cpf_.set (r);
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // chMin
    //
    if (n.name () == "chMin" && n.namespace_ ().empty ())
    {
      if (!chMin_.present ())
      {
        this->chMin_.set (chMin_traits::create (i, f, this));
        continue;
      }
    }

    // chMax
    //
    if (n.name () == "chMax" && n.namespace_ ().empty ())
    {
      if (!chMax_.present ())
      {
        this->chMax_.set (chMax_traits::create (i, f, this));
        continue;
      }
    }

    // credAnterior
    //
    if (n.name () == "credAnterior" && n.namespace_ ().empty ())
    {
      if (!credAnterior_.present ())
      {
        this->credAnterior_.set (credAnterior_traits::create (i, f, this));
        continue;
      }
    }

    // valorCred
    //
    if (n.name () == "valorCred" && n.namespace_ ().empty ())
    {
      if (!valorCred_.present ())
      {
        this->valorCred_.set (valorCred_traits::create (i, f, this));
        continue;
      }
    }

    // unidades
    //
    if (n.name () == "unidades" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< unidades_type > r (
        unidades_traits::create (i, f, this));

      if (!unidades_.present ())
      {
        this->unidades_.set (r);
        continue;
      }
    }

    // horarios
    //
    if (n.name () == "horarios" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horarios_type > r (
        horarios_traits::create (i, f, this));

      if (!horarios_.present ())
      {
        this->horarios_.set (r);
        continue;
      }
    }

    // disciplinas
    //
    if (n.name () == "disciplinas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplinas_type > r (
        disciplinas_traits::create (i, f, this));

      if (!disciplinas_.present ())
      {
        this->disciplinas_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!contrato_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "contrato",
      "");
  }

  if (!titulacao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "titulacao",
      "");
  }

  if (!areaTitulacao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "areaTitulacao",
      "");
  }

  if (!cpf_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cpf",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!chMin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "chMin",
      "");
  }

  if (!chMax_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "chMax",
      "");
  }

  if (!credAnterior_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "credAnterior",
      "");
  }

  if (!valorCred_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "valorCred",
      "");
  }

  if (!unidades_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "unidades",
      "");
  }

  if (!horarios_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horarios",
      "");
  }

  if (!disciplinas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinas",
      "");
  }
}

ItemProfessor* ItemProfessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemProfessor (*this, f, c);
}

ItemProfessor::
~ItemProfessor ()
{
}

// GrupoProfessor
//

GrupoProfessor::
GrupoProfessor ()
: ::xml_schema::type (),
  Professor_ (::xml_schema::flags (), this)
{
}

GrupoProfessor::
GrupoProfessor (const GrupoProfessor& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Professor_ (x.Professor_, f, this)
{
}

GrupoProfessor::
GrupoProfessor (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Professor_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoProfessor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Professor
    //
    if (n.name () == "Professor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Professor_type > r (
        Professor_traits::create (i, f, this));

      this->Professor_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoProfessor* GrupoProfessor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoProfessor (*this, f, c);
}

GrupoProfessor::
~GrupoProfessor ()
{
}

// ItemDivisaoCreditos
//

ItemDivisaoCreditos::
ItemDivisaoCreditos (const id_type& id,
                     const creditos_type& creditos,
                     const dia1_type& dia1,
                     const dia2_type& dia2,
                     const dia3_type& dia3,
                     const dia4_type& dia4,
                     const dia5_type& dia5,
                     const dia6_type& dia6,
                     const dia7_type& dia7)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  creditos_ (creditos, ::xml_schema::flags (), this),
  dia1_ (dia1, ::xml_schema::flags (), this),
  dia2_ (dia2, ::xml_schema::flags (), this),
  dia3_ (dia3, ::xml_schema::flags (), this),
  dia4_ (dia4, ::xml_schema::flags (), this),
  dia5_ (dia5, ::xml_schema::flags (), this),
  dia6_ (dia6, ::xml_schema::flags (), this),
  dia7_ (dia7, ::xml_schema::flags (), this)
{
}

ItemDivisaoCreditos::
ItemDivisaoCreditos (const ItemDivisaoCreditos& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  creditos_ (x.creditos_, f, this),
  dia1_ (x.dia1_, f, this),
  dia2_ (x.dia2_, f, this),
  dia3_ (x.dia3_, f, this),
  dia4_ (x.dia4_, f, this),
  dia5_ (x.dia5_, f, this),
  dia6_ (x.dia6_, f, this),
  dia7_ (x.dia7_, f, this)
{
}

ItemDivisaoCreditos::
ItemDivisaoCreditos (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  creditos_ (f, this),
  dia1_ (f, this),
  dia2_ (f, this),
  dia3_ (f, this),
  dia4_ (f, this),
  dia5_ (f, this),
  dia6_ (f, this),
  dia7_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDivisaoCreditos::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // creditos
    //
    if (n.name () == "creditos" && n.namespace_ ().empty ())
    {
      if (!creditos_.present ())
      {
        this->creditos_.set (creditos_traits::create (i, f, this));
        continue;
      }
    }

    // dia1
    //
    if (n.name () == "dia1" && n.namespace_ ().empty ())
    {
      if (!dia1_.present ())
      {
        this->dia1_.set (dia1_traits::create (i, f, this));
        continue;
      }
    }

    // dia2
    //
    if (n.name () == "dia2" && n.namespace_ ().empty ())
    {
      if (!dia2_.present ())
      {
        this->dia2_.set (dia2_traits::create (i, f, this));
        continue;
      }
    }

    // dia3
    //
    if (n.name () == "dia3" && n.namespace_ ().empty ())
    {
      if (!dia3_.present ())
      {
        this->dia3_.set (dia3_traits::create (i, f, this));
        continue;
      }
    }

    // dia4
    //
    if (n.name () == "dia4" && n.namespace_ ().empty ())
    {
      if (!dia4_.present ())
      {
        this->dia4_.set (dia4_traits::create (i, f, this));
        continue;
      }
    }

    // dia5
    //
    if (n.name () == "dia5" && n.namespace_ ().empty ())
    {
      if (!dia5_.present ())
      {
        this->dia5_.set (dia5_traits::create (i, f, this));
        continue;
      }
    }

    // dia6
    //
    if (n.name () == "dia6" && n.namespace_ ().empty ())
    {
      if (!dia6_.present ())
      {
        this->dia6_.set (dia6_traits::create (i, f, this));
        continue;
      }
    }

    // dia7
    //
    if (n.name () == "dia7" && n.namespace_ ().empty ())
    {
      if (!dia7_.present ())
      {
        this->dia7_.set (dia7_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!creditos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "creditos",
      "");
  }

  if (!dia1_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia1",
      "");
  }

  if (!dia2_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia2",
      "");
  }

  if (!dia3_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia3",
      "");
  }

  if (!dia4_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia4",
      "");
  }

  if (!dia5_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia5",
      "");
  }

  if (!dia6_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia6",
      "");
  }

  if (!dia7_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dia7",
      "");
  }
}

ItemDivisaoCreditos* ItemDivisaoCreditos::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDivisaoCreditos (*this, f, c);
}

ItemDivisaoCreditos::
~ItemDivisaoCreditos ()
{
}

// GrupoDivisaoCreditos
//

GrupoDivisaoCreditos::
GrupoDivisaoCreditos ()
: ::xml_schema::type (),
  DivisaoCreditos_ (::xml_schema::flags (), this)
{
}

GrupoDivisaoCreditos::
GrupoDivisaoCreditos (const GrupoDivisaoCreditos& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DivisaoCreditos_ (x.DivisaoCreditos_, f, this)
{
}

GrupoDivisaoCreditos::
GrupoDivisaoCreditos (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DivisaoCreditos_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDivisaoCreditos::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DivisaoCreditos
    //
    if (n.name () == "DivisaoCreditos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DivisaoCreditos_type > r (
        DivisaoCreditos_traits::create (i, f, this));

      this->DivisaoCreditos_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDivisaoCreditos* GrupoDivisaoCreditos::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDivisaoCreditos (*this, f, c);
}

GrupoDivisaoCreditos::
~GrupoDivisaoCreditos ()
{
}

// GrupoDeslocamento
//

GrupoDeslocamento::
GrupoDeslocamento ()
: ::xml_schema::type (),
  Deslocamento_ (::xml_schema::flags (), this)
{
}

GrupoDeslocamento::
GrupoDeslocamento (const GrupoDeslocamento& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Deslocamento_ (x.Deslocamento_, f, this)
{
}

GrupoDeslocamento::
GrupoDeslocamento (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Deslocamento_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDeslocamento::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Deslocamento
    //
    if (n.name () == "Deslocamento" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Deslocamento_type > r (
        Deslocamento_traits::create (i, f, this));

      this->Deslocamento_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDeslocamento* GrupoDeslocamento::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDeslocamento (*this, f, c);
}

GrupoDeslocamento::
~GrupoDeslocamento ()
{
}

// ItemDeslocamento
//

ItemDeslocamento::
ItemDeslocamento (const tempo_type& tempo,
                  const unidade_type& unidade)
: ::xml_schema::type (),
  tempo_ (tempo, ::xml_schema::flags (), this),
  unidade_ (unidade, ::xml_schema::flags (), this)
{
}

ItemDeslocamento::
ItemDeslocamento (const tempo_type& tempo,
                  ::std::auto_ptr< unidade_type >& unidade)
: ::xml_schema::type (),
  tempo_ (tempo, ::xml_schema::flags (), this),
  unidade_ (unidade, ::xml_schema::flags (), this)
{
}

ItemDeslocamento::
ItemDeslocamento (const ItemDeslocamento& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  tempo_ (x.tempo_, f, this),
  unidade_ (x.unidade_, f, this)
{
}

ItemDeslocamento::
ItemDeslocamento (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  tempo_ (f, this),
  unidade_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDeslocamento::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // tempo
    //
    if (n.name () == "tempo" && n.namespace_ ().empty ())
    {
      if (!tempo_.present ())
      {
        this->tempo_.set (tempo_traits::create (i, f, this));
        continue;
      }
    }

    // unidade
    //
    if (n.name () == "unidade" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< unidade_type > r (
        unidade_traits::create (i, f, this));

      if (!unidade_.present ())
      {
        this->unidade_.set (r);
        continue;
      }
    }

    break;
  }

  if (!tempo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tempo",
      "");
  }

  if (!unidade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "unidade",
      "");
  }
}

ItemDeslocamento* ItemDeslocamento::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDeslocamento (*this, f, c);
}

ItemDeslocamento::
~ItemDeslocamento ()
{
}

// GrupoUnidade
//

GrupoUnidade::
GrupoUnidade ()
: ::xml_schema::type (),
  Unidade_ (::xml_schema::flags (), this)
{
}

GrupoUnidade::
GrupoUnidade (const GrupoUnidade& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Unidade_ (x.Unidade_, f, this)
{
}

GrupoUnidade::
GrupoUnidade (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Unidade_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoUnidade::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Unidade
    //
    if (n.name () == "Unidade" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Unidade_type > r (
        Unidade_traits::create (i, f, this));

      this->Unidade_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoUnidade* GrupoUnidade::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoUnidade (*this, f, c);
}

GrupoUnidade::
~GrupoUnidade ()
{
}

// ItemUnidade
//

ItemUnidade::
ItemUnidade (const id_type& id,
             const codigo_type& codigo,
             const nome_type& nome,
             const endereco_type& endereco,
             const numMedSalas_type& numMedSalas,
             const custoMedCred_type& custoMedCred,
             const salas_type& salas,
             const horarios_type& horarios,
             const unidadeCurriculo_type& unidadeCurriculo,
             const deslocamentos_type& deslocamentos)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  endereco_ (endereco, ::xml_schema::flags (), this),
  numMedSalas_ (numMedSalas, ::xml_schema::flags (), this),
  custoMedCred_ (custoMedCred, ::xml_schema::flags (), this),
  salas_ (salas, ::xml_schema::flags (), this),
  horarios_ (horarios, ::xml_schema::flags (), this),
  demanda_ (::xml_schema::flags (), this),
  unidadeCurriculo_ (unidadeCurriculo, ::xml_schema::flags (), this),
  deslocamentos_ (deslocamentos, ::xml_schema::flags (), this)
{
}

ItemUnidade::
ItemUnidade (const id_type& id,
             const codigo_type& codigo,
             const nome_type& nome,
             const endereco_type& endereco,
             const numMedSalas_type& numMedSalas,
             const custoMedCred_type& custoMedCred,
             ::std::auto_ptr< salas_type >& salas,
             ::std::auto_ptr< horarios_type >& horarios,
             ::std::auto_ptr< unidadeCurriculo_type >& unidadeCurriculo,
             ::std::auto_ptr< deslocamentos_type >& deslocamentos)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  endereco_ (endereco, ::xml_schema::flags (), this),
  numMedSalas_ (numMedSalas, ::xml_schema::flags (), this),
  custoMedCred_ (custoMedCred, ::xml_schema::flags (), this),
  salas_ (salas, ::xml_schema::flags (), this),
  horarios_ (horarios, ::xml_schema::flags (), this),
  demanda_ (::xml_schema::flags (), this),
  unidadeCurriculo_ (unidadeCurriculo, ::xml_schema::flags (), this),
  deslocamentos_ (deslocamentos, ::xml_schema::flags (), this)
{
}

ItemUnidade::
ItemUnidade (const ItemUnidade& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  nome_ (x.nome_, f, this),
  endereco_ (x.endereco_, f, this),
  numMedSalas_ (x.numMedSalas_, f, this),
  custoMedCred_ (x.custoMedCred_, f, this),
  salas_ (x.salas_, f, this),
  horarios_ (x.horarios_, f, this),
  demanda_ (x.demanda_, f, this),
  unidadeCurriculo_ (x.unidadeCurriculo_, f, this),
  deslocamentos_ (x.deslocamentos_, f, this)
{
}

ItemUnidade::
ItemUnidade (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  nome_ (f, this),
  endereco_ (f, this),
  numMedSalas_ (f, this),
  custoMedCred_ (f, this),
  salas_ (f, this),
  horarios_ (f, this),
  demanda_ (f, this),
  unidadeCurriculo_ (f, this),
  deslocamentos_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemUnidade::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // endereco
    //
    if (n.name () == "endereco" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< endereco_type > r (
        endereco_traits::create (i, f, this));

      if (!endereco_.present ())
      {
        this->endereco_.set (r);
        continue;
      }
    }

    // numMedSalas
    //
    if (n.name () == "numMedSalas" && n.namespace_ ().empty ())
    {
      if (!numMedSalas_.present ())
      {
        this->numMedSalas_.set (numMedSalas_traits::create (i, f, this));
        continue;
      }
    }

    // custoMedCred
    //
    if (n.name () == "custoMedCred" && n.namespace_ ().empty ())
    {
      if (!custoMedCred_.present ())
      {
        this->custoMedCred_.set (custoMedCred_traits::create (i, f, this));
        continue;
      }
    }

    // salas
    //
    if (n.name () == "salas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< salas_type > r (
        salas_traits::create (i, f, this));

      if (!salas_.present ())
      {
        this->salas_.set (r);
        continue;
      }
    }

    // horarios
    //
    if (n.name () == "horarios" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horarios_type > r (
        horarios_traits::create (i, f, this));

      if (!horarios_.present ())
      {
        this->horarios_.set (r);
        continue;
      }
    }

    // demanda
    //
    if (n.name () == "demanda" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< demanda_type > r (
        demanda_traits::create (i, f, this));

      this->demanda_.push_back (r);
      continue;
    }

    // unidadeCurriculo
    //
    if (n.name () == "unidadeCurriculo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< unidadeCurriculo_type > r (
        unidadeCurriculo_traits::create (i, f, this));

      if (!unidadeCurriculo_.present ())
      {
        this->unidadeCurriculo_.set (r);
        continue;
      }
    }

    // deslocamentos
    //
    if (n.name () == "deslocamentos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< deslocamentos_type > r (
        deslocamentos_traits::create (i, f, this));

      if (!deslocamentos_.present ())
      {
        this->deslocamentos_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!endereco_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "endereco",
      "");
  }

  if (!numMedSalas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numMedSalas",
      "");
  }

  if (!custoMedCred_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "custoMedCred",
      "");
  }

  if (!salas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "salas",
      "");
  }

  if (!horarios_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horarios",
      "");
  }

  if (!unidadeCurriculo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "unidadeCurriculo",
      "");
  }

  if (!deslocamentos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "deslocamentos",
      "");
  }
}

ItemUnidade* ItemUnidade::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemUnidade (*this, f, c);
}

ItemUnidade::
~ItemUnidade ()
{
}

// ItemDisciplina
//

ItemDisciplina::
ItemDisciplina (const id_type& id,
                const codigo_type& codigo,
                const nome_type& nome,
                const cred_teoricos_type& cred_teoricos,
                const cred_praticos_type& cred_praticos,
                const laboratorio_type& laboratorio,
                const TipoDisciplina_type& TipoDisciplina,
                const DivisaoCreditos_type& DivisaoCreditos,
                const compatibilidades_type& compatibilidades,
                const equivalencia_type& equivalencia,
                const horarios_type& horarios,
                const salas_type& salas,
                const divisaoDeCreditos_type& divisaoDeCreditos,
                const turmas_type& turmas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  cred_teoricos_ (cred_teoricos, ::xml_schema::flags (), this),
  cred_praticos_ (cred_praticos, ::xml_schema::flags (), this),
  laboratorio_ (laboratorio, ::xml_schema::flags (), this),
  TipoDisciplina_ (TipoDisciplina, ::xml_schema::flags (), this),
  DivisaoCreditos_ (DivisaoCreditos, ::xml_schema::flags (), this),
  compatibilidades_ (compatibilidades, ::xml_schema::flags (), this),
  equivalencia_ (equivalencia, ::xml_schema::flags (), this),
  horarios_ (horarios, ::xml_schema::flags (), this),
  salas_ (salas, ::xml_schema::flags (), this),
  divisaoDeCreditos_ (divisaoDeCreditos, ::xml_schema::flags (), this),
  turmas_ (turmas, ::xml_schema::flags (), this)
{
}

ItemDisciplina::
ItemDisciplina (const id_type& id,
                const codigo_type& codigo,
                const nome_type& nome,
                const cred_teoricos_type& cred_teoricos,
                const cred_praticos_type& cred_praticos,
                const laboratorio_type& laboratorio,
                ::std::auto_ptr< TipoDisciplina_type >& TipoDisciplina,
                ::std::auto_ptr< DivisaoCreditos_type >& DivisaoCreditos,
                ::std::auto_ptr< compatibilidades_type >& compatibilidades,
                ::std::auto_ptr< equivalencia_type >& equivalencia,
                ::std::auto_ptr< horarios_type >& horarios,
                ::std::auto_ptr< salas_type >& salas,
                ::std::auto_ptr< divisaoDeCreditos_type >& divisaoDeCreditos,
                ::std::auto_ptr< turmas_type >& turmas)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  cred_teoricos_ (cred_teoricos, ::xml_schema::flags (), this),
  cred_praticos_ (cred_praticos, ::xml_schema::flags (), this),
  laboratorio_ (laboratorio, ::xml_schema::flags (), this),
  TipoDisciplina_ (TipoDisciplina, ::xml_schema::flags (), this),
  DivisaoCreditos_ (DivisaoCreditos, ::xml_schema::flags (), this),
  compatibilidades_ (compatibilidades, ::xml_schema::flags (), this),
  equivalencia_ (equivalencia, ::xml_schema::flags (), this),
  horarios_ (horarios, ::xml_schema::flags (), this),
  salas_ (salas, ::xml_schema::flags (), this),
  divisaoDeCreditos_ (divisaoDeCreditos, ::xml_schema::flags (), this),
  turmas_ (turmas, ::xml_schema::flags (), this)
{
}

ItemDisciplina::
ItemDisciplina (const ItemDisciplina& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  nome_ (x.nome_, f, this),
  cred_teoricos_ (x.cred_teoricos_, f, this),
  cred_praticos_ (x.cred_praticos_, f, this),
  laboratorio_ (x.laboratorio_, f, this),
  TipoDisciplina_ (x.TipoDisciplina_, f, this),
  DivisaoCreditos_ (x.DivisaoCreditos_, f, this),
  compatibilidades_ (x.compatibilidades_, f, this),
  equivalencia_ (x.equivalencia_, f, this),
  horarios_ (x.horarios_, f, this),
  salas_ (x.salas_, f, this),
  divisaoDeCreditos_ (x.divisaoDeCreditos_, f, this),
  turmas_ (x.turmas_, f, this)
{
}

ItemDisciplina::
ItemDisciplina (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  nome_ (f, this),
  cred_teoricos_ (f, this),
  cred_praticos_ (f, this),
  laboratorio_ (f, this),
  TipoDisciplina_ (f, this),
  DivisaoCreditos_ (f, this),
  compatibilidades_ (f, this),
  equivalencia_ (f, this),
  horarios_ (f, this),
  salas_ (f, this),
  divisaoDeCreditos_ (f, this),
  turmas_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // cred_teoricos
    //
    if (n.name () == "cred_teoricos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cred_teoricos_type > r (
        cred_teoricos_traits::create (i, f, this));

      if (!cred_teoricos_.present ())
      {
        this->cred_teoricos_.set (r);
        continue;
      }
    }

    // cred_praticos
    //
    if (n.name () == "cred_praticos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cred_praticos_type > r (
        cred_praticos_traits::create (i, f, this));

      if (!cred_praticos_.present ())
      {
        this->cred_praticos_.set (r);
        continue;
      }
    }

    // laboratorio
    //
    if (n.name () == "laboratorio" && n.namespace_ ().empty ())
    {
      if (!laboratorio_.present ())
      {
        this->laboratorio_.set (laboratorio_traits::create (i, f, this));
        continue;
      }
    }

    // TipoDisciplina
    //
    if (n.name () == "TipoDisciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TipoDisciplina_type > r (
        TipoDisciplina_traits::create (i, f, this));

      if (!TipoDisciplina_.present ())
      {
        this->TipoDisciplina_.set (r);
        continue;
      }
    }

    // DivisaoCreditos
    //
    if (n.name () == "DivisaoCreditos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DivisaoCreditos_type > r (
        DivisaoCreditos_traits::create (i, f, this));

      if (!DivisaoCreditos_.present ())
      {
        this->DivisaoCreditos_.set (r);
        continue;
      }
    }

    // compatibilidades
    //
    if (n.name () == "compatibilidades" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< compatibilidades_type > r (
        compatibilidades_traits::create (i, f, this));

      if (!compatibilidades_.present ())
      {
        this->compatibilidades_.set (r);
        continue;
      }
    }

    // equivalencia
    //
    if (n.name () == "equivalencia" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< equivalencia_type > r (
        equivalencia_traits::create (i, f, this));

      if (!equivalencia_.present ())
      {
        this->equivalencia_.set (r);
        continue;
      }
    }

    // horarios
    //
    if (n.name () == "horarios" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horarios_type > r (
        horarios_traits::create (i, f, this));

      if (!horarios_.present ())
      {
        this->horarios_.set (r);
        continue;
      }
    }

    // salas
    //
    if (n.name () == "salas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< salas_type > r (
        salas_traits::create (i, f, this));

      if (!salas_.present ())
      {
        this->salas_.set (r);
        continue;
      }
    }

    // divisaoDeCreditos
    //
    if (n.name () == "divisaoDeCreditos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< divisaoDeCreditos_type > r (
        divisaoDeCreditos_traits::create (i, f, this));

      if (!divisaoDeCreditos_.present ())
      {
        this->divisaoDeCreditos_.set (r);
        continue;
      }
    }

    // turmas
    //
    if (n.name () == "turmas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< turmas_type > r (
        turmas_traits::create (i, f, this));

      if (!turmas_.present ())
      {
        this->turmas_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!cred_teoricos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cred_teoricos",
      "");
  }

  if (!cred_praticos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cred_praticos",
      "");
  }

  if (!laboratorio_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "laboratorio",
      "");
  }

  if (!TipoDisciplina_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "TipoDisciplina",
      "");
  }

  if (!DivisaoCreditos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DivisaoCreditos",
      "");
  }

  if (!compatibilidades_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "compatibilidades",
      "");
  }

  if (!equivalencia_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "equivalencia",
      "");
  }

  if (!horarios_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horarios",
      "");
  }

  if (!salas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "salas",
      "");
  }

  if (!divisaoDeCreditos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "divisaoDeCreditos",
      "");
  }

  if (!turmas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turmas",
      "");
  }
}

ItemDisciplina* ItemDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDisciplina (*this, f, c);
}

ItemDisciplina::
~ItemDisciplina ()
{
}

// GrupoDisciplina
//

GrupoDisciplina::
GrupoDisciplina ()
: ::xml_schema::type (),
  Disciplina_ (::xml_schema::flags (), this)
{
}

GrupoDisciplina::
GrupoDisciplina (const GrupoDisciplina& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Disciplina_ (x.Disciplina_, f, this)
{
}

GrupoDisciplina::
GrupoDisciplina (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Disciplina_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Disciplina
    //
    if (n.name () == "Disciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Disciplina_type > r (
        Disciplina_traits::create (i, f, this));

      this->Disciplina_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDisciplina* GrupoDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDisciplina (*this, f, c);
}

GrupoDisciplina::
~GrupoDisciplina ()
{
}

// ItemCalendario
//

ItemCalendario::
ItemCalendario (const id_type& id,
                const turnos_type& turnos,
                const codigo_type& codigo,
                const descricao_type& descricao,
                const tempoAula_type& tempoAula)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  turnos_ (turnos, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  descricao_ (descricao, ::xml_schema::flags (), this),
  tempoAula_ (tempoAula, ::xml_schema::flags (), this)
{
}

ItemCalendario::
ItemCalendario (const id_type& id,
                ::std::auto_ptr< turnos_type >& turnos,
                const codigo_type& codigo,
                const descricao_type& descricao,
                const tempoAula_type& tempoAula)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  turnos_ (turnos, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  descricao_ (descricao, ::xml_schema::flags (), this),
  tempoAula_ (tempoAula, ::xml_schema::flags (), this)
{
}

ItemCalendario::
ItemCalendario (const ItemCalendario& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  turnos_ (x.turnos_, f, this),
  codigo_ (x.codigo_, f, this),
  descricao_ (x.descricao_, f, this),
  tempoAula_ (x.tempoAula_, f, this)
{
}

ItemCalendario::
ItemCalendario (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  turnos_ (f, this),
  codigo_ (f, this),
  descricao_ (f, this),
  tempoAula_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemCalendario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // turnos
    //
    if (n.name () == "turnos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< turnos_type > r (
        turnos_traits::create (i, f, this));

      if (!turnos_.present ())
      {
        this->turnos_.set (r);
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // descricao
    //
    if (n.name () == "descricao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< descricao_type > r (
        descricao_traits::create (i, f, this));

      if (!descricao_.present ())
      {
        this->descricao_.set (r);
        continue;
      }
    }

    // tempoAula
    //
    if (n.name () == "tempoAula" && n.namespace_ ().empty ())
    {
      if (!tempoAula_.present ())
      {
        this->tempoAula_.set (tempoAula_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!turnos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turnos",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!descricao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "descricao",
      "");
  }

  if (!tempoAula_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tempoAula",
      "");
  }
}

ItemCalendario* ItemCalendario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemCalendario (*this, f, c);
}

ItemCalendario::
~ItemCalendario ()
{
}

// ItemHorarioDisponivel
//

ItemHorarioDisponivel::
ItemHorarioDisponivel (const id_type& id,
                       const semana_type& semana,
                       const horarioAula_type& horarioAula)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  semana_ (semana, ::xml_schema::flags (), this),
  horarioAula_ (horarioAula, ::xml_schema::flags (), this)
{
}

ItemHorarioDisponivel::
ItemHorarioDisponivel (const id_type& id,
                       const semana_type& semana,
                       ::std::auto_ptr< horarioAula_type >& horarioAula)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  semana_ (semana, ::xml_schema::flags (), this),
  horarioAula_ (horarioAula, ::xml_schema::flags (), this)
{
}

ItemHorarioDisponivel::
ItemHorarioDisponivel (const ItemHorarioDisponivel& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  semana_ (x.semana_, f, this),
  horarioAula_ (x.horarioAula_, f, this)
{
}

ItemHorarioDisponivel::
ItemHorarioDisponivel (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  semana_ (f, this),
  horarioAula_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemHorarioDisponivel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // semana
    //
    if (n.name () == "semana" && n.namespace_ ().empty ())
    {
      if (!semana_.present ())
      {
        this->semana_.set (semana_traits::create (i, f, this));
        continue;
      }
    }

    // horarioAula
    //
    if (n.name () == "horarioAula" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horarioAula_type > r (
        horarioAula_traits::create (i, f, this));

      if (!horarioAula_.present ())
      {
        this->horarioAula_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!semana_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "semana",
      "");
  }

  if (!horarioAula_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horarioAula",
      "");
  }
}

ItemHorarioDisponivel* ItemHorarioDisponivel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemHorarioDisponivel (*this, f, c);
}

ItemHorarioDisponivel::
~ItemHorarioDisponivel ()
{
}

// GrupoHorarioDisponivel
//

GrupoHorarioDisponivel::
GrupoHorarioDisponivel ()
: ::xml_schema::type (),
  HorarioDisponivel_ (::xml_schema::flags (), this)
{
}

GrupoHorarioDisponivel::
GrupoHorarioDisponivel (const GrupoHorarioDisponivel& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  HorarioDisponivel_ (x.HorarioDisponivel_, f, this)
{
}

GrupoHorarioDisponivel::
GrupoHorarioDisponivel (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  HorarioDisponivel_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoHorarioDisponivel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // HorarioDisponivel
    //
    if (n.name () == "HorarioDisponivel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HorarioDisponivel_type > r (
        HorarioDisponivel_traits::create (i, f, this));

      this->HorarioDisponivel_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoHorarioDisponivel* GrupoHorarioDisponivel::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoHorarioDisponivel (*this, f, c);
}

GrupoHorarioDisponivel::
~GrupoHorarioDisponivel ()
{
}

// ItemHorarioAula
//

ItemHorarioAula::
ItemHorarioAula (const horariosDisponiveis_type& horariosDisponiveis,
                 const id_type& id,
                 const inicio_type& inicio,
                 const Turno_type& Turno)
: ::xml_schema::type (),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this),
  inicio_ (inicio, ::xml_schema::flags (), this),
  Turno_ (Turno, ::xml_schema::flags (), this)
{
}

ItemHorarioAula::
ItemHorarioAula (::std::auto_ptr< horariosDisponiveis_type >& horariosDisponiveis,
                 const id_type& id,
                 const inicio_type& inicio,
                 ::std::auto_ptr< Turno_type >& Turno)
: ::xml_schema::type (),
  horariosDisponiveis_ (horariosDisponiveis, ::xml_schema::flags (), this),
  id_ (id, ::xml_schema::flags (), this),
  inicio_ (inicio, ::xml_schema::flags (), this),
  Turno_ (Turno, ::xml_schema::flags (), this)
{
}

ItemHorarioAula::
ItemHorarioAula (const ItemHorarioAula& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  horariosDisponiveis_ (x.horariosDisponiveis_, f, this),
  id_ (x.id_, f, this),
  inicio_ (x.inicio_, f, this),
  Turno_ (x.Turno_, f, this)
{
}

ItemHorarioAula::
ItemHorarioAula (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  horariosDisponiveis_ (f, this),
  id_ (f, this),
  inicio_ (f, this),
  Turno_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemHorarioAula::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // horariosDisponiveis
    //
    if (n.name () == "horariosDisponiveis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horariosDisponiveis_type > r (
        horariosDisponiveis_traits::create (i, f, this));

      if (!horariosDisponiveis_.present ())
      {
        this->horariosDisponiveis_.set (r);
        continue;
      }
    }

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // inicio
    //
    if (n.name () == "inicio" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inicio_type > r (
        inicio_traits::create (i, f, this));

      if (!inicio_.present ())
      {
        this->inicio_.set (r);
        continue;
      }
    }

    // Turno
    //
    if (n.name () == "Turno" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Turno_type > r (
        Turno_traits::create (i, f, this));

      if (!Turno_.present ())
      {
        this->Turno_.set (r);
        continue;
      }
    }

    break;
  }

  if (!horariosDisponiveis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horariosDisponiveis",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!inicio_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "inicio",
      "");
  }

  if (!Turno_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Turno",
      "");
  }
}

ItemHorarioAula* ItemHorarioAula::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemHorarioAula (*this, f, c);
}

ItemHorarioAula::
~ItemHorarioAula ()
{
}

// GrupoHorarioAula
//

GrupoHorarioAula::
GrupoHorarioAula ()
: ::xml_schema::type (),
  HorarioAula_ (::xml_schema::flags (), this)
{
}

GrupoHorarioAula::
GrupoHorarioAula (const GrupoHorarioAula& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  HorarioAula_ (x.HorarioAula_, f, this)
{
}

GrupoHorarioAula::
GrupoHorarioAula (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  HorarioAula_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoHorarioAula::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // HorarioAula
    //
    if (n.name () == "HorarioAula" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HorarioAula_type > r (
        HorarioAula_traits::create (i, f, this));

      this->HorarioAula_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoHorarioAula* GrupoHorarioAula::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoHorarioAula (*this, f, c);
}

GrupoHorarioAula::
~GrupoHorarioAula ()
{
}

// ItemTurno
//

ItemTurno::
ItemTurno (const id_type& id,
           const nome_type& nome,
           const HorariosAula_type& HorariosAula,
           const Calendario_type& Calendario)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  HorariosAula_ (HorariosAula, ::xml_schema::flags (), this),
  Calendario_ (Calendario, ::xml_schema::flags (), this)
{
}

ItemTurno::
ItemTurno (const id_type& id,
           const nome_type& nome,
           ::std::auto_ptr< HorariosAula_type >& HorariosAula,
           ::std::auto_ptr< Calendario_type >& Calendario)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  HorariosAula_ (HorariosAula, ::xml_schema::flags (), this),
  Calendario_ (Calendario, ::xml_schema::flags (), this)
{
}

ItemTurno::
ItemTurno (const ItemTurno& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this),
  HorariosAula_ (x.HorariosAula_, f, this),
  Calendario_ (x.Calendario_, f, this)
{
}

ItemTurno::
ItemTurno (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this),
  HorariosAula_ (f, this),
  Calendario_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTurno::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // HorariosAula
    //
    if (n.name () == "HorariosAula" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HorariosAula_type > r (
        HorariosAula_traits::create (i, f, this));

      if (!HorariosAula_.present ())
      {
        this->HorariosAula_.set (r);
        continue;
      }
    }

    // Calendario
    //
    if (n.name () == "Calendario" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Calendario_type > r (
        Calendario_traits::create (i, f, this));

      if (!Calendario_.present ())
      {
        this->Calendario_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!HorariosAula_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "HorariosAula",
      "");
  }

  if (!Calendario_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Calendario",
      "");
  }
}

ItemTurno* ItemTurno::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTurno (*this, f, c);
}

ItemTurno::
~ItemTurno ()
{
}

// GrupoTurno
//

GrupoTurno::
GrupoTurno ()
: ::xml_schema::type (),
  Turno_ (::xml_schema::flags (), this)
{
}

GrupoTurno::
GrupoTurno (const GrupoTurno& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Turno_ (x.Turno_, f, this)
{
}

GrupoTurno::
GrupoTurno (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Turno_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoTurno::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Turno
    //
    if (n.name () == "Turno" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Turno_type > r (
        Turno_traits::create (i, f, this));

      this->Turno_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoTurno* GrupoTurno::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoTurno (*this, f, c);
}

GrupoTurno::
~GrupoTurno ()
{
}

// ItemSala
//

ItemSala::
ItemSala (const id_type& id,
          const tipoSala_type& tipoSala,
          const HorariosDisponiveis_type& HorariosDisponiveis,
          const codigo_type& codigo,
          const numSalas_type& numSalas,
          const andar_type& andar,
          const capacidade_type& capacidade)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  tipoSala_ (tipoSala, ::xml_schema::flags (), this),
  HorariosDisponiveis_ (HorariosDisponiveis, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  numSalas_ (numSalas, ::xml_schema::flags (), this),
  andar_ (andar, ::xml_schema::flags (), this),
  capacidade_ (capacidade, ::xml_schema::flags (), this)
{
}

ItemSala::
ItemSala (const id_type& id,
          ::std::auto_ptr< tipoSala_type >& tipoSala,
          ::std::auto_ptr< HorariosDisponiveis_type >& HorariosDisponiveis,
          const codigo_type& codigo,
          const numSalas_type& numSalas,
          const andar_type& andar,
          const capacidade_type& capacidade)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  tipoSala_ (tipoSala, ::xml_schema::flags (), this),
  HorariosDisponiveis_ (HorariosDisponiveis, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  numSalas_ (numSalas, ::xml_schema::flags (), this),
  andar_ (andar, ::xml_schema::flags (), this),
  capacidade_ (capacidade, ::xml_schema::flags (), this)
{
}

ItemSala::
ItemSala (const ItemSala& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  tipoSala_ (x.tipoSala_, f, this),
  HorariosDisponiveis_ (x.HorariosDisponiveis_, f, this),
  codigo_ (x.codigo_, f, this),
  numSalas_ (x.numSalas_, f, this),
  andar_ (x.andar_, f, this),
  capacidade_ (x.capacidade_, f, this)
{
}

ItemSala::
ItemSala (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  tipoSala_ (f, this),
  HorariosDisponiveis_ (f, this),
  codigo_ (f, this),
  numSalas_ (f, this),
  andar_ (f, this),
  capacidade_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemSala::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // tipoSala
    //
    if (n.name () == "tipoSala" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tipoSala_type > r (
        tipoSala_traits::create (i, f, this));

      if (!tipoSala_.present ())
      {
        this->tipoSala_.set (r);
        continue;
      }
    }

    // HorariosDisponiveis
    //
    if (n.name () == "HorariosDisponiveis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< HorariosDisponiveis_type > r (
        HorariosDisponiveis_traits::create (i, f, this));

      if (!HorariosDisponiveis_.present ())
      {
        this->HorariosDisponiveis_.set (r);
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // numSalas
    //
    if (n.name () == "numSalas" && n.namespace_ ().empty ())
    {
      if (!numSalas_.present ())
      {
        this->numSalas_.set (numSalas_traits::create (i, f, this));
        continue;
      }
    }

    // andar
    //
    if (n.name () == "andar" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< andar_type > r (
        andar_traits::create (i, f, this));

      if (!andar_.present ())
      {
        this->andar_.set (r);
        continue;
      }
    }

    // capacidade
    //
    if (n.name () == "capacidade" && n.namespace_ ().empty ())
    {
      if (!capacidade_.present ())
      {
        this->capacidade_.set (capacidade_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!tipoSala_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tipoSala",
      "");
  }

  if (!HorariosDisponiveis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "HorariosDisponiveis",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!numSalas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numSalas",
      "");
  }

  if (!andar_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "andar",
      "");
  }

  if (!capacidade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "capacidade",
      "");
  }
}

ItemSala* ItemSala::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemSala (*this, f, c);
}

ItemSala::
~ItemSala ()
{
}

// ItemDisciplinaPeriodo
//

ItemDisciplinaPeriodo::
ItemDisciplinaPeriodo (const periodo_type& periodo,
                       const disciplina_type& disciplina)
: ::xml_schema::type (),
  periodo_ (periodo, ::xml_schema::flags (), this),
  disciplina_ (disciplina, ::xml_schema::flags (), this)
{
}

ItemDisciplinaPeriodo::
ItemDisciplinaPeriodo (const periodo_type& periodo,
                       ::std::auto_ptr< disciplina_type >& disciplina)
: ::xml_schema::type (),
  periodo_ (periodo, ::xml_schema::flags (), this),
  disciplina_ (disciplina, ::xml_schema::flags (), this)
{
}

ItemDisciplinaPeriodo::
ItemDisciplinaPeriodo (const ItemDisciplinaPeriodo& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  periodo_ (x.periodo_, f, this),
  disciplina_ (x.disciplina_, f, this)
{
}

ItemDisciplinaPeriodo::
ItemDisciplinaPeriodo (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  periodo_ (f, this),
  disciplina_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDisciplinaPeriodo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // periodo
    //
    if (n.name () == "periodo" && n.namespace_ ().empty ())
    {
      if (!periodo_.present ())
      {
        this->periodo_.set (periodo_traits::create (i, f, this));
        continue;
      }
    }

    // disciplina
    //
    if (n.name () == "disciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplina_type > r (
        disciplina_traits::create (i, f, this));

      if (!disciplina_.present ())
      {
        this->disciplina_.set (r);
        continue;
      }
    }

    break;
  }

  if (!periodo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "periodo",
      "");
  }

  if (!disciplina_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplina",
      "");
  }
}

ItemDisciplinaPeriodo* ItemDisciplinaPeriodo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDisciplinaPeriodo (*this, f, c);
}

ItemDisciplinaPeriodo::
~ItemDisciplinaPeriodo ()
{
}

// ItemCurriculo
//

ItemCurriculo::
ItemCurriculo (const id_type& id,
               const codigo_type& codigo,
               const descricao_type& descricao,
               const DisciplinasPeriodo_type& DisciplinasPeriodo)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  descricao_ (descricao, ::xml_schema::flags (), this),
  DisciplinasPeriodo_ (DisciplinasPeriodo, ::xml_schema::flags (), this)
{
}

ItemCurriculo::
ItemCurriculo (const id_type& id,
               const codigo_type& codigo,
               const descricao_type& descricao,
               ::std::auto_ptr< DisciplinasPeriodo_type >& DisciplinasPeriodo)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  descricao_ (descricao, ::xml_schema::flags (), this),
  DisciplinasPeriodo_ (DisciplinasPeriodo, ::xml_schema::flags (), this)
{
}

ItemCurriculo::
ItemCurriculo (const ItemCurriculo& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  descricao_ (x.descricao_, f, this),
  DisciplinasPeriodo_ (x.DisciplinasPeriodo_, f, this)
{
}

ItemCurriculo::
ItemCurriculo (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  descricao_ (f, this),
  DisciplinasPeriodo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemCurriculo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // descricao
    //
    if (n.name () == "descricao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< descricao_type > r (
        descricao_traits::create (i, f, this));

      if (!descricao_.present ())
      {
        this->descricao_.set (r);
        continue;
      }
    }

    // DisciplinasPeriodo
    //
    if (n.name () == "DisciplinasPeriodo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DisciplinasPeriodo_type > r (
        DisciplinasPeriodo_traits::create (i, f, this));

      if (!DisciplinasPeriodo_.present ())
      {
        this->DisciplinasPeriodo_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!descricao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "descricao",
      "");
  }

  if (!DisciplinasPeriodo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "DisciplinasPeriodo",
      "");
  }
}

ItemCurriculo* ItemCurriculo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemCurriculo (*this, f, c);
}

ItemCurriculo::
~ItemCurriculo ()
{
}

// GrupoCurriculo
//

GrupoCurriculo::
GrupoCurriculo ()
: ::xml_schema::type (),
  Curriculo_ (::xml_schema::flags (), this)
{
}

GrupoCurriculo::
GrupoCurriculo (const GrupoCurriculo& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Curriculo_ (x.Curriculo_, f, this)
{
}

GrupoCurriculo::
GrupoCurriculo (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Curriculo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoCurriculo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Curriculo
    //
    if (n.name () == "Curriculo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Curriculo_type > r (
        Curriculo_traits::create (i, f, this));

      this->Curriculo_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoCurriculo* GrupoCurriculo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoCurriculo (*this, f, c);
}

GrupoCurriculo::
~GrupoCurriculo ()
{
}

// GrupoSala
//

GrupoSala::
GrupoSala ()
: ::xml_schema::type (),
  Sala_ (::xml_schema::flags (), this)
{
}

GrupoSala::
GrupoSala (const GrupoSala& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Sala_ (x.Sala_, f, this)
{
}

GrupoSala::
GrupoSala (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Sala_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoSala::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Sala
    //
    if (n.name () == "Sala" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Sala_type > r (
        Sala_traits::create (i, f, this));

      this->Sala_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoSala* GrupoSala::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoSala (*this, f, c);
}

GrupoSala::
~GrupoSala ()
{
}

// ItemCurso
//

ItemCurso::
ItemCurso (const id_type& id,
           const codigo_type& codigo,
           const tipo_type& tipo,
           const numPeriodos_type& numPeriodos,
           const qtdMinDoutores_type& qtdMinDoutores,
           const qtdMinMestres_type& qtdMinMestres,
           const qtdMaxProfDisc_type& qtdMaxProfDisc,
           const areaTitulacao_type& areaTitulacao,
           const Curriculos_type& Curriculos)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  tipo_ (tipo, ::xml_schema::flags (), this),
  numPeriodos_ (numPeriodos, ::xml_schema::flags (), this),
  qtdMinDoutores_ (qtdMinDoutores, ::xml_schema::flags (), this),
  qtdMinMestres_ (qtdMinMestres, ::xml_schema::flags (), this),
  qtdMaxProfDisc_ (qtdMaxProfDisc, ::xml_schema::flags (), this),
  areaTitulacao_ (areaTitulacao, ::xml_schema::flags (), this),
  Curriculos_ (Curriculos, ::xml_schema::flags (), this)
{
}

ItemCurso::
ItemCurso (const id_type& id,
           const codigo_type& codigo,
           ::std::auto_ptr< tipo_type >& tipo,
           const numPeriodos_type& numPeriodos,
           const qtdMinDoutores_type& qtdMinDoutores,
           const qtdMinMestres_type& qtdMinMestres,
           const qtdMaxProfDisc_type& qtdMaxProfDisc,
           ::std::auto_ptr< areaTitulacao_type >& areaTitulacao,
           ::std::auto_ptr< Curriculos_type >& Curriculos)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  codigo_ (codigo, ::xml_schema::flags (), this),
  tipo_ (tipo, ::xml_schema::flags (), this),
  numPeriodos_ (numPeriodos, ::xml_schema::flags (), this),
  qtdMinDoutores_ (qtdMinDoutores, ::xml_schema::flags (), this),
  qtdMinMestres_ (qtdMinMestres, ::xml_schema::flags (), this),
  qtdMaxProfDisc_ (qtdMaxProfDisc, ::xml_schema::flags (), this),
  areaTitulacao_ (areaTitulacao, ::xml_schema::flags (), this),
  Curriculos_ (Curriculos, ::xml_schema::flags (), this)
{
}

ItemCurso::
ItemCurso (const ItemCurso& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  codigo_ (x.codigo_, f, this),
  tipo_ (x.tipo_, f, this),
  numPeriodos_ (x.numPeriodos_, f, this),
  qtdMinDoutores_ (x.qtdMinDoutores_, f, this),
  qtdMinMestres_ (x.qtdMinMestres_, f, this),
  qtdMaxProfDisc_ (x.qtdMaxProfDisc_, f, this),
  areaTitulacao_ (x.areaTitulacao_, f, this),
  Curriculos_ (x.Curriculos_, f, this)
{
}

ItemCurso::
ItemCurso (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  codigo_ (f, this),
  tipo_ (f, this),
  numPeriodos_ (f, this),
  qtdMinDoutores_ (f, this),
  qtdMinMestres_ (f, this),
  qtdMaxProfDisc_ (f, this),
  areaTitulacao_ (f, this),
  Curriculos_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // codigo
    //
    if (n.name () == "codigo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< codigo_type > r (
        codigo_traits::create (i, f, this));

      if (!codigo_.present ())
      {
        this->codigo_.set (r);
        continue;
      }
    }

    // tipo
    //
    if (n.name () == "tipo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tipo_type > r (
        tipo_traits::create (i, f, this));

      if (!tipo_.present ())
      {
        this->tipo_.set (r);
        continue;
      }
    }

    // numPeriodos
    //
    if (n.name () == "numPeriodos" && n.namespace_ ().empty ())
    {
      if (!numPeriodos_.present ())
      {
        this->numPeriodos_.set (numPeriodos_traits::create (i, f, this));
        continue;
      }
    }

    // qtdMinDoutores
    //
    if (n.name () == "qtdMinDoutores" && n.namespace_ ().empty ())
    {
      if (!qtdMinDoutores_.present ())
      {
        this->qtdMinDoutores_.set (qtdMinDoutores_traits::create (i, f, this));
        continue;
      }
    }

    // qtdMinMestres
    //
    if (n.name () == "qtdMinMestres" && n.namespace_ ().empty ())
    {
      if (!qtdMinMestres_.present ())
      {
        this->qtdMinMestres_.set (qtdMinMestres_traits::create (i, f, this));
        continue;
      }
    }

    // qtdMaxProfDisc
    //
    if (n.name () == "qtdMaxProfDisc" && n.namespace_ ().empty ())
    {
      if (!qtdMaxProfDisc_.present ())
      {
        this->qtdMaxProfDisc_.set (qtdMaxProfDisc_traits::create (i, f, this));
        continue;
      }
    }

    // areaTitulacao
    //
    if (n.name () == "areaTitulacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< areaTitulacao_type > r (
        areaTitulacao_traits::create (i, f, this));

      if (!areaTitulacao_.present ())
      {
        this->areaTitulacao_.set (r);
        continue;
      }
    }

    // Curriculos
    //
    if (n.name () == "Curriculos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Curriculos_type > r (
        Curriculos_traits::create (i, f, this));

      if (!Curriculos_.present ())
      {
        this->Curriculos_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!codigo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "codigo",
      "");
  }

  if (!tipo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "tipo",
      "");
  }

  if (!numPeriodos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numPeriodos",
      "");
  }

  if (!qtdMinDoutores_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qtdMinDoutores",
      "");
  }

  if (!qtdMinMestres_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qtdMinMestres",
      "");
  }

  if (!qtdMaxProfDisc_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "qtdMaxProfDisc",
      "");
  }

  if (!areaTitulacao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "areaTitulacao",
      "");
  }

  if (!Curriculos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Curriculos",
      "");
  }
}

ItemCurso* ItemCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemCurso (*this, f, c);
}

ItemCurso::
~ItemCurso ()
{
}

// GrupoCurso
//

GrupoCurso::
GrupoCurso ()
: ::xml_schema::type (),
  Curso_ (::xml_schema::flags (), this)
{
}

GrupoCurso::
GrupoCurso (const GrupoCurso& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Curso_ (x.Curso_, f, this)
{
}

GrupoCurso::
GrupoCurso (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Curso_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Curso
    //
    if (n.name () == "Curso" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Curso_type > r (
        Curso_traits::create (i, f, this));

      this->Curso_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoCurso* GrupoCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoCurso (*this, f, c);
}

GrupoCurso::
~GrupoCurso ()
{
}

// ItemDemanda
//

ItemDemanda::
ItemDemanda (const quantidade_type& quantidade,
             const turno_type& turno,
             const disciplina_type& disciplina,
             const curso_type& curso)
: ::xml_schema::type (),
  quantidade_ (quantidade, ::xml_schema::flags (), this),
  turno_ (turno, ::xml_schema::flags (), this),
  disciplina_ (disciplina, ::xml_schema::flags (), this),
  curso_ (curso, ::xml_schema::flags (), this)
{
}

ItemDemanda::
ItemDemanda (const quantidade_type& quantidade,
             ::std::auto_ptr< turno_type >& turno,
             ::std::auto_ptr< disciplina_type >& disciplina,
             ::std::auto_ptr< curso_type >& curso)
: ::xml_schema::type (),
  quantidade_ (quantidade, ::xml_schema::flags (), this),
  turno_ (turno, ::xml_schema::flags (), this),
  disciplina_ (disciplina, ::xml_schema::flags (), this),
  curso_ (curso, ::xml_schema::flags (), this)
{
}

ItemDemanda::
ItemDemanda (const ItemDemanda& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  quantidade_ (x.quantidade_, f, this),
  turno_ (x.turno_, f, this),
  disciplina_ (x.disciplina_, f, this),
  curso_ (x.curso_, f, this)
{
}

ItemDemanda::
ItemDemanda (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  quantidade_ (f, this),
  turno_ (f, this),
  disciplina_ (f, this),
  curso_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemDemanda::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // quantidade
    //
    if (n.name () == "quantidade" && n.namespace_ ().empty ())
    {
      if (!quantidade_.present ())
      {
        this->quantidade_.set (quantidade_traits::create (i, f, this));
        continue;
      }
    }

    // turno
    //
    if (n.name () == "turno" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< turno_type > r (
        turno_traits::create (i, f, this));

      if (!turno_.present ())
      {
        this->turno_.set (r);
        continue;
      }
    }

    // disciplina
    //
    if (n.name () == "disciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplina_type > r (
        disciplina_traits::create (i, f, this));

      if (!disciplina_.present ())
      {
        this->disciplina_.set (r);
        continue;
      }
    }

    // curso
    //
    if (n.name () == "curso" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< curso_type > r (
        curso_traits::create (i, f, this));

      if (!curso_.present ())
      {
        this->curso_.set (r);
        continue;
      }
    }

    break;
  }

  if (!quantidade_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "quantidade",
      "");
  }

  if (!turno_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turno",
      "");
  }

  if (!disciplina_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplina",
      "");
  }

  if (!curso_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "curso",
      "");
  }
}

ItemDemanda* ItemDemanda::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemDemanda (*this, f, c);
}

ItemDemanda::
~ItemDemanda ()
{
}

// GrupoDemanda
//

GrupoDemanda::
GrupoDemanda ()
: ::xml_schema::type (),
  Demanda_ (::xml_schema::flags (), this)
{
}

GrupoDemanda::
GrupoDemanda (const GrupoDemanda& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Demanda_ (x.Demanda_, f, this)
{
}

GrupoDemanda::
GrupoDemanda (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Demanda_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoDemanda::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Demanda
    //
    if (n.name () == "Demanda" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Demanda_type > r (
        Demanda_traits::create (i, f, this));

      this->Demanda_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoDemanda* GrupoDemanda::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoDemanda (*this, f, c);
}

GrupoDemanda::
~GrupoDemanda ()
{
}

// ItemUnidadeCurriculo
//

ItemUnidadeCurriculo::
ItemUnidadeCurriculo (const turno_type& turno,
                      const curriculo_type& curriculo)
: ::xml_schema::type (),
  turno_ (turno, ::xml_schema::flags (), this),
  curriculo_ (curriculo, ::xml_schema::flags (), this)
{
}

ItemUnidadeCurriculo::
ItemUnidadeCurriculo (::std::auto_ptr< turno_type >& turno,
                      ::std::auto_ptr< curriculo_type >& curriculo)
: ::xml_schema::type (),
  turno_ (turno, ::xml_schema::flags (), this),
  curriculo_ (curriculo, ::xml_schema::flags (), this)
{
}

ItemUnidadeCurriculo::
ItemUnidadeCurriculo (const ItemUnidadeCurriculo& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  turno_ (x.turno_, f, this),
  curriculo_ (x.curriculo_, f, this)
{
}

ItemUnidadeCurriculo::
ItemUnidadeCurriculo (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  turno_ (f, this),
  curriculo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemUnidadeCurriculo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // turno
    //
    if (n.name () == "turno" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< turno_type > r (
        turno_traits::create (i, f, this));

      if (!turno_.present ())
      {
        this->turno_.set (r);
        continue;
      }
    }

    // curriculo
    //
    if (n.name () == "curriculo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< curriculo_type > r (
        curriculo_traits::create (i, f, this));

      if (!curriculo_.present ())
      {
        this->curriculo_.set (r);
        continue;
      }
    }

    break;
  }

  if (!turno_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turno",
      "");
  }

  if (!curriculo_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "curriculo",
      "");
  }
}

ItemUnidadeCurriculo* ItemUnidadeCurriculo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemUnidadeCurriculo (*this, f, c);
}

ItemUnidadeCurriculo::
~ItemUnidadeCurriculo ()
{
}

// GrupoUnidadeCurriculo
//

GrupoUnidadeCurriculo::
GrupoUnidadeCurriculo ()
: ::xml_schema::type (),
  UnidadeCurriculo_ (::xml_schema::flags (), this)
{
}

GrupoUnidadeCurriculo::
GrupoUnidadeCurriculo (const GrupoUnidadeCurriculo& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  UnidadeCurriculo_ (x.UnidadeCurriculo_, f, this)
{
}

GrupoUnidadeCurriculo::
GrupoUnidadeCurriculo (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  UnidadeCurriculo_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoUnidadeCurriculo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // UnidadeCurriculo
    //
    if (n.name () == "UnidadeCurriculo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< UnidadeCurriculo_type > r (
        UnidadeCurriculo_traits::create (i, f, this));

      this->UnidadeCurriculo_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoUnidadeCurriculo* GrupoUnidadeCurriculo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoUnidadeCurriculo (*this, f, c);
}

GrupoUnidadeCurriculo::
~GrupoUnidadeCurriculo ()
{
}

// ItemAlocacao
//

ItemAlocacao::
ItemAlocacao (const professor_type& professor,
              const horario_type& horario,
              const oferecimento_type& oferecimento)
: ::xml_schema::type (),
  professor_ (professor, ::xml_schema::flags (), this),
  horario_ (horario, ::xml_schema::flags (), this),
  oferecimento_ (oferecimento, ::xml_schema::flags (), this)
{
}

ItemAlocacao::
ItemAlocacao (::std::auto_ptr< professor_type >& professor,
              ::std::auto_ptr< horario_type >& horario,
              ::std::auto_ptr< oferecimento_type >& oferecimento)
: ::xml_schema::type (),
  professor_ (professor, ::xml_schema::flags (), this),
  horario_ (horario, ::xml_schema::flags (), this),
  oferecimento_ (oferecimento, ::xml_schema::flags (), this)
{
}

ItemAlocacao::
ItemAlocacao (const ItemAlocacao& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  professor_ (x.professor_, f, this),
  horario_ (x.horario_, f, this),
  oferecimento_ (x.oferecimento_, f, this)
{
}

ItemAlocacao::
ItemAlocacao (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  professor_ (f, this),
  horario_ (f, this),
  oferecimento_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAlocacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // professor
    //
    if (n.name () == "professor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< professor_type > r (
        professor_traits::create (i, f, this));

      if (!professor_.present ())
      {
        this->professor_.set (r);
        continue;
      }
    }

    // horario
    //
    if (n.name () == "horario" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horario_type > r (
        horario_traits::create (i, f, this));

      if (!horario_.present ())
      {
        this->horario_.set (r);
        continue;
      }
    }

    // oferecimento
    //
    if (n.name () == "oferecimento" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< oferecimento_type > r (
        oferecimento_traits::create (i, f, this));

      if (!oferecimento_.present ())
      {
        this->oferecimento_.set (r);
        continue;
      }
    }

    break;
  }

  if (!professor_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "professor",
      "");
  }

  if (!horario_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "horario",
      "");
  }

  if (!oferecimento_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "oferecimento",
      "");
  }
}

ItemAlocacao* ItemAlocacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAlocacao (*this, f, c);
}

ItemAlocacao::
~ItemAlocacao ()
{
}

// ItemOferecimento
//

ItemOferecimento::
ItemOferecimento (const id_type& id,
                  const sala_type& sala,
                  const semana_type& semana,
                  const creditos_type& creditos,
                  const turma_type& turma,
                  const alocacao_type& alocacao)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  sala_ (sala, ::xml_schema::flags (), this),
  semana_ (semana, ::xml_schema::flags (), this),
  creditos_ (creditos, ::xml_schema::flags (), this),
  turma_ (turma, ::xml_schema::flags (), this),
  alocacao_ (alocacao, ::xml_schema::flags (), this)
{
}

ItemOferecimento::
ItemOferecimento (const id_type& id,
                  ::std::auto_ptr< sala_type >& sala,
                  const semana_type& semana,
                  const creditos_type& creditos,
                  ::std::auto_ptr< turma_type >& turma,
                  ::std::auto_ptr< alocacao_type >& alocacao)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  sala_ (sala, ::xml_schema::flags (), this),
  semana_ (semana, ::xml_schema::flags (), this),
  creditos_ (creditos, ::xml_schema::flags (), this),
  turma_ (turma, ::xml_schema::flags (), this),
  alocacao_ (alocacao, ::xml_schema::flags (), this)
{
}

ItemOferecimento::
ItemOferecimento (const ItemOferecimento& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  sala_ (x.sala_, f, this),
  semana_ (x.semana_, f, this),
  creditos_ (x.creditos_, f, this),
  turma_ (x.turma_, f, this),
  alocacao_ (x.alocacao_, f, this)
{
}

ItemOferecimento::
ItemOferecimento (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  sala_ (f, this),
  semana_ (f, this),
  creditos_ (f, this),
  turma_ (f, this),
  alocacao_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemOferecimento::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // sala
    //
    if (n.name () == "sala" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sala_type > r (
        sala_traits::create (i, f, this));

      if (!sala_.present ())
      {
        this->sala_.set (r);
        continue;
      }
    }

    // semana
    //
    if (n.name () == "semana" && n.namespace_ ().empty ())
    {
      if (!semana_.present ())
      {
        this->semana_.set (semana_traits::create (i, f, this));
        continue;
      }
    }

    // creditos
    //
    if (n.name () == "creditos" && n.namespace_ ().empty ())
    {
      if (!creditos_.present ())
      {
        this->creditos_.set (creditos_traits::create (i, f, this));
        continue;
      }
    }

    // turma
    //
    if (n.name () == "turma" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< turma_type > r (
        turma_traits::create (i, f, this));

      if (!turma_.present ())
      {
        this->turma_.set (r);
        continue;
      }
    }

    // alocacao
    //
    if (n.name () == "alocacao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< alocacao_type > r (
        alocacao_traits::create (i, f, this));

      if (!alocacao_.present ())
      {
        this->alocacao_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!sala_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sala",
      "");
  }

  if (!semana_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "semana",
      "");
  }

  if (!creditos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "creditos",
      "");
  }

  if (!turma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "turma",
      "");
  }

  if (!alocacao_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "alocacao",
      "");
  }
}

ItemOferecimento* ItemOferecimento::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemOferecimento (*this, f, c);
}

ItemOferecimento::
~ItemOferecimento ()
{
}

// GrupoOferecimento
//

GrupoOferecimento::
GrupoOferecimento ()
: ::xml_schema::type (),
  Oferecimento_ (::xml_schema::flags (), this)
{
}

GrupoOferecimento::
GrupoOferecimento (const GrupoOferecimento& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Oferecimento_ (x.Oferecimento_, f, this)
{
}

GrupoOferecimento::
GrupoOferecimento (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Oferecimento_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoOferecimento::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Oferecimento
    //
    if (n.name () == "Oferecimento" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Oferecimento_type > r (
        Oferecimento_traits::create (i, f, this));

      this->Oferecimento_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoOferecimento* GrupoOferecimento::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoOferecimento (*this, f, c);
}

GrupoOferecimento::
~GrupoOferecimento ()
{
}

// ItemTurma
//

ItemTurma::
ItemTurma (const id_type& id,
           const nome_type& nome,
           const disciplina_type& disciplina,
           const oferecimentos_type& oferecimentos)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  disciplina_ (disciplina, ::xml_schema::flags (), this),
  oferecimentos_ (oferecimentos, ::xml_schema::flags (), this)
{
}

ItemTurma::
ItemTurma (const id_type& id,
           const nome_type& nome,
           ::std::auto_ptr< disciplina_type >& disciplina,
           ::std::auto_ptr< oferecimentos_type >& oferecimentos)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this),
  disciplina_ (disciplina, ::xml_schema::flags (), this),
  oferecimentos_ (oferecimentos, ::xml_schema::flags (), this)
{
}

ItemTurma::
ItemTurma (const ItemTurma& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this),
  disciplina_ (x.disciplina_, f, this),
  oferecimentos_ (x.oferecimentos_, f, this)
{
}

ItemTurma::
ItemTurma (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this),
  disciplina_ (f, this),
  oferecimentos_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTurma::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    // disciplina
    //
    if (n.name () == "disciplina" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplina_type > r (
        disciplina_traits::create (i, f, this));

      if (!disciplina_.present ())
      {
        this->disciplina_.set (r);
        continue;
      }
    }

    // oferecimentos
    //
    if (n.name () == "oferecimentos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< oferecimentos_type > r (
        oferecimentos_traits::create (i, f, this));

      if (!oferecimentos_.present ())
      {
        this->oferecimentos_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }

  if (!disciplina_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplina",
      "");
  }

  if (!oferecimentos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "oferecimentos",
      "");
  }
}

ItemTurma* ItemTurma::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTurma (*this, f, c);
}

ItemTurma::
~ItemTurma ()
{
}

// GrupoTurma
//

GrupoTurma::
GrupoTurma ()
: ::xml_schema::type (),
  Turma_ (::xml_schema::flags (), this)
{
}

GrupoTurma::
GrupoTurma (const GrupoTurma& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Turma_ (x.Turma_, f, this)
{
}

GrupoTurma::
GrupoTurma (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Turma_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void GrupoTurma::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Turma
    //
    if (n.name () == "Turma" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Turma_type > r (
        Turma_traits::create (i, f, this));

      this->Turma_.push_back (r);
      continue;
    }

    break;
  }
}

GrupoTurma* GrupoTurma::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GrupoTurma (*this, f, c);
}

GrupoTurma::
~GrupoTurma ()
{
}

// ItemTipoSala
//

ItemTipoSala::
ItemTipoSala ()
: ::xml_schema::type (),
  id_ (::xml_schema::flags (), this),
  nome_ (::xml_schema::flags (), this),
  descricao_ (::xml_schema::flags (), this)
{
}

ItemTipoSala::
ItemTipoSala (const ItemTipoSala& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this),
  descricao_ (x.descricao_, f, this)
{
}

ItemTipoSala::
ItemTipoSala (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this),
  descricao_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoSala::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!this->id_)
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!this->nome_)
      {
        this->nome_.set (r);
        continue;
      }
    }

    // descricao
    //
    if (n.name () == "descricao" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< descricao_type > r (
        descricao_traits::create (i, f, this));

      if (!this->descricao_)
      {
        this->descricao_.set (r);
        continue;
      }
    }

    break;
  }
}

ItemTipoSala* ItemTipoSala::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoSala (*this, f, c);
}

ItemTipoSala::
~ItemTipoSala ()
{
}

// ItemTipoContrato
//

ItemTipoContrato::
ItemTipoContrato (const id_type& id,
                  const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoContrato::
ItemTipoContrato (const ItemTipoContrato& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoContrato::
ItemTipoContrato (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoContrato::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoContrato* ItemTipoContrato::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoContrato (*this, f, c);
}

ItemTipoContrato::
~ItemTipoContrato ()
{
}

// ItemTipoTitulacao
//

ItemTipoTitulacao::
ItemTipoTitulacao (const id_type& id,
                   const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoTitulacao::
ItemTipoTitulacao (const ItemTipoTitulacao& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoTitulacao::
ItemTipoTitulacao (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoTitulacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoTitulacao* ItemTipoTitulacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoTitulacao (*this, f, c);
}

ItemTipoTitulacao::
~ItemTipoTitulacao ()
{
}

// ItemAreaTitulacao
//

ItemAreaTitulacao::
ItemAreaTitulacao (const id_type& id,
                   const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemAreaTitulacao::
ItemAreaTitulacao (const ItemAreaTitulacao& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemAreaTitulacao::
ItemAreaTitulacao (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemAreaTitulacao::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemAreaTitulacao* ItemAreaTitulacao::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemAreaTitulacao (*this, f, c);
}

ItemAreaTitulacao::
~ItemAreaTitulacao ()
{
}

// ItemTipoDisciplina
//

ItemTipoDisciplina::
ItemTipoDisciplina (const id_type& id,
                    const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoDisciplina::
ItemTipoDisciplina (const ItemTipoDisciplina& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoDisciplina::
ItemTipoDisciplina (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoDisciplina::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoDisciplina* ItemTipoDisciplina::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoDisciplina (*this, f, c);
}

ItemTipoDisciplina::
~ItemTipoDisciplina ()
{
}

// ItemTipoCurso
//

ItemTipoCurso::
ItemTipoCurso (const id_type& id,
               const nome_type& nome)
: ::xml_schema::type (),
  id_ (id, ::xml_schema::flags (), this),
  nome_ (nome, ::xml_schema::flags (), this)
{
}

ItemTipoCurso::
ItemTipoCurso (const ItemTipoCurso& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  nome_ (x.nome_, f, this)
{
}

ItemTipoCurso::
ItemTipoCurso (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (f, this),
  nome_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void ItemTipoCurso::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // id
    //
    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      if (!id_.present ())
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }
    }

    // nome
    //
    if (n.name () == "nome" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nome_type > r (
        nome_traits::create (i, f, this));

      if (!nome_.present ())
      {
        this->nome_.set (r);
        continue;
      }
    }

    break;
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "id",
      "");
  }

  if (!nome_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "nome",
      "");
  }
}

ItemTipoCurso* ItemTipoCurso::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ItemTipoCurso (*this, f, c);
}

ItemTipoCurso::
~ItemTipoCurso ()
{
}

// Trieda
//

Trieda::
Trieda (const unidades_type& unidades,
        const cursos_type& cursos,
        const calendario_type& calendario,
        const professores_type& professores,
        const disciplinas_type& disciplinas,
        const regrasCredito_type& regrasCredito)
: ::xml_schema::type (),
  unidades_ (unidades, ::xml_schema::flags (), this),
  cursos_ (cursos, ::xml_schema::flags (), this),
  calendario_ (calendario, ::xml_schema::flags (), this),
  professores_ (professores, ::xml_schema::flags (), this),
  disciplinas_ (disciplinas, ::xml_schema::flags (), this),
  regrasCredito_ (regrasCredito, ::xml_schema::flags (), this)
{
}

Trieda::
Trieda (::std::auto_ptr< unidades_type >& unidades,
        ::std::auto_ptr< cursos_type >& cursos,
        ::std::auto_ptr< calendario_type >& calendario,
        ::std::auto_ptr< professores_type >& professores,
        ::std::auto_ptr< disciplinas_type >& disciplinas,
        ::std::auto_ptr< regrasCredito_type >& regrasCredito)
: ::xml_schema::type (),
  unidades_ (unidades, ::xml_schema::flags (), this),
  cursos_ (cursos, ::xml_schema::flags (), this),
  calendario_ (calendario, ::xml_schema::flags (), this),
  professores_ (professores, ::xml_schema::flags (), this),
  disciplinas_ (disciplinas, ::xml_schema::flags (), this),
  regrasCredito_ (regrasCredito, ::xml_schema::flags (), this)
{
}

Trieda::
Trieda (const Trieda& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  unidades_ (x.unidades_, f, this),
  cursos_ (x.cursos_, f, this),
  calendario_ (x.calendario_, f, this),
  professores_ (x.professores_, f, this),
  disciplinas_ (x.disciplinas_, f, this),
  regrasCredito_ (x.regrasCredito_, f, this)
{
}

Trieda::
Trieda (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  unidades_ (f, this),
  cursos_ (f, this),
  calendario_ (f, this),
  professores_ (f, this),
  disciplinas_ (f, this),
  regrasCredito_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void Trieda::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // unidades
    //
    if (n.name () == "unidades" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< unidades_type > r (
        unidades_traits::create (i, f, this));

      if (!unidades_.present ())
      {
        this->unidades_.set (r);
        continue;
      }
    }

    // cursos
    //
    if (n.name () == "cursos" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cursos_type > r (
        cursos_traits::create (i, f, this));

      if (!cursos_.present ())
      {
        this->cursos_.set (r);
        continue;
      }
    }

    // calendario
    //
    if (n.name () == "calendario" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< calendario_type > r (
        calendario_traits::create (i, f, this));

      if (!calendario_.present ())
      {
        this->calendario_.set (r);
        continue;
      }
    }

    // professores
    //
    if (n.name () == "professores" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< professores_type > r (
        professores_traits::create (i, f, this));

      if (!professores_.present ())
      {
        this->professores_.set (r);
        continue;
      }
    }

    // disciplinas
    //
    if (n.name () == "disciplinas" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disciplinas_type > r (
        disciplinas_traits::create (i, f, this));

      if (!disciplinas_.present ())
      {
        this->disciplinas_.set (r);
        continue;
      }
    }

    // regrasCredito
    //
    if (n.name () == "regrasCredito" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< regrasCredito_type > r (
        regrasCredito_traits::create (i, f, this));

      if (!regrasCredito_.present ())
      {
        this->regrasCredito_.set (r);
        continue;
      }
    }

    break;
  }

  if (!unidades_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "unidades",
      "");
  }

  if (!cursos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cursos",
      "");
  }

  if (!calendario_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "calendario",
      "");
  }

  if (!professores_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "professores",
      "");
  }

  if (!disciplinas_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "disciplinas",
      "");
  }

  if (!regrasCredito_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "regrasCredito",
      "");
  }
}

Trieda* Trieda::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Trieda (*this, f, c);
}

Trieda::
~Trieda ()
{
}

// UnidadeCurriculo
//

UnidadeCurriculo::
UnidadeCurriculo (const turno_type& turno,
                  const curriculo_type& curriculo)
: ::ItemUnidadeCurriculo (turno,
                          curriculo)
{
}

UnidadeCurriculo::
UnidadeCurriculo (::std::auto_ptr< turno_type >& turno,
                  ::std::auto_ptr< curriculo_type >& curriculo)
: ::ItemUnidadeCurriculo (turno,
                          curriculo)
{
}

UnidadeCurriculo::
UnidadeCurriculo (const UnidadeCurriculo& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::ItemUnidadeCurriculo (x, f, c)
{
}

UnidadeCurriculo::
UnidadeCurriculo (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::ItemUnidadeCurriculo (e, f, c)
{
}

UnidadeCurriculo* UnidadeCurriculo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class UnidadeCurriculo (*this, f, c);
}

UnidadeCurriculo::
~UnidadeCurriculo ()
{
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, const ItemProfessorDisciplina& i)
{
  if (i.nota ())
  {
    o << ::std::endl << "nota: " << *i.nota ();
  }

  if (i.ranking ())
  {
    o << ::std::endl << "ranking: " << *i.ranking ();
  }

  if (i.disciplina ())
  {
    o << ::std::endl << "disciplina: " << *i.disciplina ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoProfessorDisciplina& i)
{
  for (GrupoProfessorDisciplina::ProfessorDisciplina_const_iterator
       b (i.ProfessorDisciplina ().begin ()), e (i.ProfessorDisciplina ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ProfessorDisciplina: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemProfessor& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "contrato: " << i.contrato ();
  o << ::std::endl << "titulacao: " << i.titulacao ();
  o << ::std::endl << "areaTitulacao: " << i.areaTitulacao ();
  o << ::std::endl << "cpf: " << i.cpf ();
  o << ::std::endl << "nome: " << i.nome ();
  o << ::std::endl << "chMin: " << i.chMin ();
  o << ::std::endl << "chMax: " << i.chMax ();
  o << ::std::endl << "credAnterior: " << i.credAnterior ();
  o << ::std::endl << "valorCred: " << i.valorCred ();
  o << ::std::endl << "unidades: " << i.unidades ();
  o << ::std::endl << "horarios: " << i.horarios ();
  o << ::std::endl << "disciplinas: " << i.disciplinas ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoProfessor& i)
{
  for (GrupoProfessor::Professor_const_iterator
       b (i.Professor ().begin ()), e (i.Professor ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Professor: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemDivisaoCreditos& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "creditos: " << i.creditos ();
  o << ::std::endl << "dia1: " << i.dia1 ();
  o << ::std::endl << "dia2: " << i.dia2 ();
  o << ::std::endl << "dia3: " << i.dia3 ();
  o << ::std::endl << "dia4: " << i.dia4 ();
  o << ::std::endl << "dia5: " << i.dia5 ();
  o << ::std::endl << "dia6: " << i.dia6 ();
  o << ::std::endl << "dia7: " << i.dia7 ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoDivisaoCreditos& i)
{
  for (GrupoDivisaoCreditos::DivisaoCreditos_const_iterator
       b (i.DivisaoCreditos ().begin ()), e (i.DivisaoCreditos ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "DivisaoCreditos: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoDeslocamento& i)
{
  for (GrupoDeslocamento::Deslocamento_const_iterator
       b (i.Deslocamento ().begin ()), e (i.Deslocamento ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Deslocamento: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemDeslocamento& i)
{
  o << ::std::endl << "tempo: " << i.tempo ();
  o << ::std::endl << "unidade: " << i.unidade ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoUnidade& i)
{
  for (GrupoUnidade::Unidade_const_iterator
       b (i.Unidade ().begin ()), e (i.Unidade ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Unidade: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemUnidade& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "codigo: " << i.codigo ();
  o << ::std::endl << "nome: " << i.nome ();
  o << ::std::endl << "endereco: " << i.endereco ();
  o << ::std::endl << "numMedSalas: " << i.numMedSalas ();
  o << ::std::endl << "custoMedCred: " << i.custoMedCred ();
  o << ::std::endl << "salas: " << i.salas ();
  o << ::std::endl << "horarios: " << i.horarios ();
  for (ItemUnidade::demanda_const_iterator
       b (i.demanda ().begin ()), e (i.demanda ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "demanda: " << *b;
  }

  o << ::std::endl << "unidadeCurriculo: " << i.unidadeCurriculo ();
  o << ::std::endl << "deslocamentos: " << i.deslocamentos ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemDisciplina& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "codigo: " << i.codigo ();
  o << ::std::endl << "nome: " << i.nome ();
  o << ::std::endl << "cred_teoricos: " << i.cred_teoricos ();
  o << ::std::endl << "cred_praticos: " << i.cred_praticos ();
  o << ::std::endl << "laboratorio: " << i.laboratorio ();
  o << ::std::endl << "TipoDisciplina: " << i.TipoDisciplina ();
  o << ::std::endl << "DivisaoCreditos: " << i.DivisaoCreditos ();
  o << ::std::endl << "compatibilidades: " << i.compatibilidades ();
  o << ::std::endl << "equivalencia: " << i.equivalencia ();
  o << ::std::endl << "horarios: " << i.horarios ();
  o << ::std::endl << "salas: " << i.salas ();
  o << ::std::endl << "divisaoDeCreditos: " << i.divisaoDeCreditos ();
  o << ::std::endl << "turmas: " << i.turmas ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoDisciplina& i)
{
  for (GrupoDisciplina::Disciplina_const_iterator
       b (i.Disciplina ().begin ()), e (i.Disciplina ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Disciplina: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemCalendario& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "turnos: " << i.turnos ();
  o << ::std::endl << "codigo: " << i.codigo ();
  o << ::std::endl << "descricao: " << i.descricao ();
  o << ::std::endl << "tempoAula: " << i.tempoAula ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemHorarioDisponivel& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "semana: " << i.semana ();
  o << ::std::endl << "horarioAula: " << i.horarioAula ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoHorarioDisponivel& i)
{
  for (GrupoHorarioDisponivel::HorarioDisponivel_const_iterator
       b (i.HorarioDisponivel ().begin ()), e (i.HorarioDisponivel ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "HorarioDisponivel: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemHorarioAula& i)
{
  o << ::std::endl << "horariosDisponiveis: " << i.horariosDisponiveis ();
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "inicio: " << i.inicio ();
  o << ::std::endl << "Turno: " << i.Turno ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoHorarioAula& i)
{
  for (GrupoHorarioAula::HorarioAula_const_iterator
       b (i.HorarioAula ().begin ()), e (i.HorarioAula ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "HorarioAula: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemTurno& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "nome: " << i.nome ();
  o << ::std::endl << "HorariosAula: " << i.HorariosAula ();
  o << ::std::endl << "Calendario: " << i.Calendario ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoTurno& i)
{
  for (GrupoTurno::Turno_const_iterator
       b (i.Turno ().begin ()), e (i.Turno ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Turno: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemSala& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "tipoSala: " << i.tipoSala ();
  o << ::std::endl << "HorariosDisponiveis: " << i.HorariosDisponiveis ();
  o << ::std::endl << "codigo: " << i.codigo ();
  o << ::std::endl << "numSalas: " << i.numSalas ();
  o << ::std::endl << "andar: " << i.andar ();
  o << ::std::endl << "capacidade: " << i.capacidade ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemDisciplinaPeriodo& i)
{
  o << ::std::endl << "periodo: " << i.periodo ();
  o << ::std::endl << "disciplina: " << i.disciplina ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemCurriculo& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "codigo: " << i.codigo ();
  o << ::std::endl << "descricao: " << i.descricao ();
  o << ::std::endl << "DisciplinasPeriodo: " << i.DisciplinasPeriodo ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoCurriculo& i)
{
  for (GrupoCurriculo::Curriculo_const_iterator
       b (i.Curriculo ().begin ()), e (i.Curriculo ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Curriculo: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoSala& i)
{
  for (GrupoSala::Sala_const_iterator
       b (i.Sala ().begin ()), e (i.Sala ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Sala: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemCurso& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "codigo: " << i.codigo ();
  o << ::std::endl << "tipo: " << i.tipo ();
  o << ::std::endl << "numPeriodos: " << i.numPeriodos ();
  o << ::std::endl << "qtdMinDoutores: " << i.qtdMinDoutores ();
  o << ::std::endl << "qtdMinMestres: " << i.qtdMinMestres ();
  o << ::std::endl << "qtdMaxProfDisc: " << i.qtdMaxProfDisc ();
  o << ::std::endl << "areaTitulacao: " << i.areaTitulacao ();
  o << ::std::endl << "Curriculos: " << i.Curriculos ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoCurso& i)
{
  for (GrupoCurso::Curso_const_iterator
       b (i.Curso ().begin ()), e (i.Curso ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Curso: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemDemanda& i)
{
  o << ::std::endl << "quantidade: " << i.quantidade ();
  o << ::std::endl << "turno: " << i.turno ();
  o << ::std::endl << "disciplina: " << i.disciplina ();
  o << ::std::endl << "curso: " << i.curso ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoDemanda& i)
{
  for (GrupoDemanda::Demanda_const_iterator
       b (i.Demanda ().begin ()), e (i.Demanda ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Demanda: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemUnidadeCurriculo& i)
{
  o << ::std::endl << "turno: " << i.turno ();
  o << ::std::endl << "curriculo: " << i.curriculo ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoUnidadeCurriculo& i)
{
  for (GrupoUnidadeCurriculo::UnidadeCurriculo_const_iterator
       b (i.UnidadeCurriculo ().begin ()), e (i.UnidadeCurriculo ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "UnidadeCurriculo: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemAlocacao& i)
{
  o << ::std::endl << "professor: " << i.professor ();
  o << ::std::endl << "horario: " << i.horario ();
  o << ::std::endl << "oferecimento: " << i.oferecimento ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemOferecimento& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "sala: " << i.sala ();
  o << ::std::endl << "semana: " << i.semana ();
  o << ::std::endl << "creditos: " << i.creditos ();
  o << ::std::endl << "turma: " << i.turma ();
  o << ::std::endl << "alocacao: " << i.alocacao ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoOferecimento& i)
{
  for (GrupoOferecimento::Oferecimento_const_iterator
       b (i.Oferecimento ().begin ()), e (i.Oferecimento ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Oferecimento: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemTurma& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "nome: " << i.nome ();
  o << ::std::endl << "disciplina: " << i.disciplina ();
  o << ::std::endl << "oferecimentos: " << i.oferecimentos ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const GrupoTurma& i)
{
  for (GrupoTurma::Turma_const_iterator
       b (i.Turma ().begin ()), e (i.Turma ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "Turma: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemTipoSala& i)
{
  if (i.id ())
  {
    o << ::std::endl << "id: " << *i.id ();
  }

  if (i.nome ())
  {
    o << ::std::endl << "nome: " << *i.nome ();
  }

  if (i.descricao ())
  {
    o << ::std::endl << "descricao: " << *i.descricao ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemTipoContrato& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "nome: " << i.nome ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemTipoTitulacao& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "nome: " << i.nome ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemAreaTitulacao& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "nome: " << i.nome ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemTipoDisciplina& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "nome: " << i.nome ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const ItemTipoCurso& i)
{
  o << ::std::endl << "id: " << i.id ();
  o << ::std::endl << "nome: " << i.nome ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const Trieda& i)
{
  o << ::std::endl << "unidades: " << i.unidades ();
  o << ::std::endl << "cursos: " << i.cursos ();
  o << ::std::endl << "calendario: " << i.calendario ();
  o << ::std::endl << "professores: " << i.professores ();
  o << ::std::endl << "disciplinas: " << i.disciplinas ();
  o << ::std::endl << "regrasCredito: " << i.regrasCredito ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const UnidadeCurriculo& i)
{
  o << static_cast< const ::ItemUnidadeCurriculo& > (i);

  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::Trieda >
Trieda_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Trieda > r (
    ::Trieda_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Trieda >
Trieda_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Trieda > r (
    ::Trieda_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Trieda >
Trieda_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Trieda > r (
    ::Trieda_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Trieda_ (isrc, f, p);
}

::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Trieda_ (isrc, h, f, p);
}

::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Trieda_ (isrc, h, f, p);
}

::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Trieda_ (isrc, f, p);
}

::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Trieda_ (isrc, h, f, p);
}

::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Trieda_ (isrc, h, f, p);
}

::std::auto_ptr< ::Trieda >
Trieda_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::Trieda > r (
    ::Trieda_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Trieda >
Trieda_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Trieda > r (
    ::Trieda_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Trieda >
Trieda_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::Trieda > r (
    ::Trieda_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::Trieda >
Trieda_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::Trieda > r (
      ::Trieda_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Trieda" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Trieda > r (
      ::xsd::cxx::tree::traits< ::Trieda, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Trieda",
    "");
}

::std::auto_ptr< ::Trieda >
Trieda_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Trieda" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::Trieda > r (
      ::xsd::cxx::tree::traits< ::Trieda, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Trieda",
    "");
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

void
Trieda_ (::std::ostream& o,
         const ::Trieda& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Trieda_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Trieda_ (::std::ostream& o,
         const ::Trieda& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Trieda_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Trieda_ (::std::ostream& o,
         const ::Trieda& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Trieda_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Trieda_ (::xercesc::XMLFormatTarget& t,
         const ::Trieda& s,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Trieda_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Trieda_ (::xercesc::XMLFormatTarget& t,
         const ::Trieda& s,
         ::xml_schema::error_handler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Trieda_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Trieda_ (::xercesc::XMLFormatTarget& t,
         const ::Trieda& s,
         ::xercesc::DOMErrorHandler& h,
         const ::xml_schema::namespace_infomap& m,
         const ::std::string& e,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::Trieda_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Trieda_ (::xercesc::DOMDocument& d,
         const ::Trieda& s,
         ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Trieda" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Trieda",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Trieda_ (const ::Trieda& s,
         const ::xml_schema::namespace_infomap& m,
         ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "Trieda",
      "",
      m, f));

  ::Trieda_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const ItemProfessorDisciplina& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // nota
  //
  if (i.nota ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nota",
        e));

    s << *i.nota ();
  }

  // ranking
  //
  if (i.ranking ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ranking",
        e));

    s << *i.ranking ();
  }

  // disciplina
  //
  if (i.disciplina ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "disciplina",
        e));

    s << *i.disciplina ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoProfessorDisciplina& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // ProfessorDisciplina
  //
  for (GrupoProfessorDisciplina::ProfessorDisciplina_const_iterator
       b (i.ProfessorDisciplina ().begin ()), n (i.ProfessorDisciplina ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ProfessorDisciplina",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemProfessor& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // contrato
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "contrato",
        e));

    s << i.contrato ();
  }

  // titulacao
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "titulacao",
        e));

    s << i.titulacao ();
  }

  // areaTitulacao
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "areaTitulacao",
        e));

    s << i.areaTitulacao ();
  }

  // cpf
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cpf",
        e));

    s << i.cpf ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }

  // chMin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "chMin",
        e));

    s << i.chMin ();
  }

  // chMax
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "chMax",
        e));

    s << i.chMax ();
  }

  // credAnterior
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "credAnterior",
        e));

    s << i.credAnterior ();
  }

  // valorCred
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "valorCred",
        e));

    s << ::xml_schema::as_double(i.valorCred ());
  }

  // unidades
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "unidades",
        e));

    s << i.unidades ();
  }

  // horarios
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "horarios",
        e));

    s << i.horarios ();
  }

  // disciplinas
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "disciplinas",
        e));

    s << i.disciplinas ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoProfessor& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Professor
  //
  for (GrupoProfessor::Professor_const_iterator
       b (i.Professor ().begin ()), n (i.Professor ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Professor",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemDivisaoCreditos& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // creditos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "creditos",
        e));

    s << i.creditos ();
  }

  // dia1
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dia1",
        e));

    s << i.dia1 ();
  }

  // dia2
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dia2",
        e));

    s << i.dia2 ();
  }

  // dia3
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dia3",
        e));

    s << i.dia3 ();
  }

  // dia4
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dia4",
        e));

    s << i.dia4 ();
  }

  // dia5
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dia5",
        e));

    s << i.dia5 ();
  }

  // dia6
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dia6",
        e));

    s << i.dia6 ();
  }

  // dia7
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dia7",
        e));

    s << i.dia7 ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoDivisaoCreditos& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // DivisaoCreditos
  //
  for (GrupoDivisaoCreditos::DivisaoCreditos_const_iterator
       b (i.DivisaoCreditos ().begin ()), n (i.DivisaoCreditos ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DivisaoCreditos",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoDeslocamento& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Deslocamento
  //
  for (GrupoDeslocamento::Deslocamento_const_iterator
       b (i.Deslocamento ().begin ()), n (i.Deslocamento ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Deslocamento",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemDeslocamento& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // tempo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tempo",
        e));

    s << i.tempo ();
  }

  // unidade
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "unidade",
        e));

    s << i.unidade ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoUnidade& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Unidade
  //
  for (GrupoUnidade::Unidade_const_iterator
       b (i.Unidade ().begin ()), n (i.Unidade ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Unidade",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemUnidade& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // codigo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "codigo",
        e));

    s << i.codigo ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }

  // endereco
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "endereco",
        e));

    s << i.endereco ();
  }

  // numMedSalas
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numMedSalas",
        e));

    s << i.numMedSalas ();
  }

  // custoMedCred
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "custoMedCred",
        e));

    s << i.custoMedCred ();
  }

  // salas
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "salas",
        e));

    s << i.salas ();
  }

  // horarios
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "horarios",
        e));

    s << i.horarios ();
  }

  // demanda
  //
  for (ItemUnidade::demanda_const_iterator
       b (i.demanda ().begin ()), n (i.demanda ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "demanda",
        e));

    s << *b;
  }

  // unidadeCurriculo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "unidadeCurriculo",
        e));

    s << i.unidadeCurriculo ();
  }

  // deslocamentos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "deslocamentos",
        e));

    s << i.deslocamentos ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemDisciplina& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // codigo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "codigo",
        e));

    s << i.codigo ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }

  // cred_teoricos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cred_teoricos",
        e));

    s << i.cred_teoricos ();
  }

  // cred_praticos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cred_praticos",
        e));

    s << i.cred_praticos ();
  }

  // laboratorio
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "laboratorio",
        e));

    s << i.laboratorio ();
  }

  // TipoDisciplina
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TipoDisciplina",
        e));

    s << i.TipoDisciplina ();
  }

  // DivisaoCreditos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DivisaoCreditos",
        e));

    s << i.DivisaoCreditos ();
  }

  // compatibilidades
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "compatibilidades",
        e));

    s << i.compatibilidades ();
  }

  // equivalencia
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "equivalencia",
        e));

    s << i.equivalencia ();
  }

  // horarios
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "horarios",
        e));

    s << i.horarios ();
  }

  // salas
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "salas",
        e));

    s << i.salas ();
  }

  // divisaoDeCreditos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "divisaoDeCreditos",
        e));

    s << i.divisaoDeCreditos ();
  }

  // turmas
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "turmas",
        e));

    s << i.turmas ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoDisciplina& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Disciplina
  //
  for (GrupoDisciplina::Disciplina_const_iterator
       b (i.Disciplina ().begin ()), n (i.Disciplina ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Disciplina",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemCalendario& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // turnos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "turnos",
        e));

    s << i.turnos ();
  }

  // codigo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "codigo",
        e));

    s << i.codigo ();
  }

  // descricao
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "descricao",
        e));

    s << i.descricao ();
  }

  // tempoAula
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tempoAula",
        e));

    s << i.tempoAula ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemHorarioDisponivel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // semana
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "semana",
        e));

    s << i.semana ();
  }

  // horarioAula
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "horarioAula",
        e));

    s << i.horarioAula ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoHorarioDisponivel& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // HorarioDisponivel
  //
  for (GrupoHorarioDisponivel::HorarioDisponivel_const_iterator
       b (i.HorarioDisponivel ().begin ()), n (i.HorarioDisponivel ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HorarioDisponivel",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemHorarioAula& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // horariosDisponiveis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "horariosDisponiveis",
        e));

    s << i.horariosDisponiveis ();
  }

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // inicio
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "inicio",
        e));

    s << i.inicio ();
  }

  // Turno
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Turno",
        e));

    s << i.Turno ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoHorarioAula& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // HorarioAula
  //
  for (GrupoHorarioAula::HorarioAula_const_iterator
       b (i.HorarioAula ().begin ()), n (i.HorarioAula ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HorarioAula",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemTurno& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }

  // HorariosAula
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HorariosAula",
        e));

    s << i.HorariosAula ();
  }

  // Calendario
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Calendario",
        e));

    s << i.Calendario ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoTurno& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Turno
  //
  for (GrupoTurno::Turno_const_iterator
       b (i.Turno ().begin ()), n (i.Turno ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Turno",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemSala& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // tipoSala
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tipoSala",
        e));

    s << i.tipoSala ();
  }

  // HorariosDisponiveis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HorariosDisponiveis",
        e));

    s << i.HorariosDisponiveis ();
  }

  // codigo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "codigo",
        e));

    s << i.codigo ();
  }

  // numSalas
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numSalas",
        e));

    s << i.numSalas ();
  }

  // andar
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "andar",
        e));

    s << i.andar ();
  }

  // capacidade
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "capacidade",
        e));

    s << i.capacidade ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemDisciplinaPeriodo& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // periodo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "periodo",
        e));

    s << i.periodo ();
  }

  // disciplina
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "disciplina",
        e));

    s << i.disciplina ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemCurriculo& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // codigo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "codigo",
        e));

    s << i.codigo ();
  }

  // descricao
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "descricao",
        e));

    s << i.descricao ();
  }

  // DisciplinasPeriodo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DisciplinasPeriodo",
        e));

    s << i.DisciplinasPeriodo ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoCurriculo& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Curriculo
  //
  for (GrupoCurriculo::Curriculo_const_iterator
       b (i.Curriculo ().begin ()), n (i.Curriculo ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Curriculo",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoSala& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Sala
  //
  for (GrupoSala::Sala_const_iterator
       b (i.Sala ().begin ()), n (i.Sala ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sala",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemCurso& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // codigo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "codigo",
        e));

    s << i.codigo ();
  }

  // tipo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tipo",
        e));

    s << i.tipo ();
  }

  // numPeriodos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numPeriodos",
        e));

    s << i.numPeriodos ();
  }

  // qtdMinDoutores
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "qtdMinDoutores",
        e));

    s << i.qtdMinDoutores ();
  }

  // qtdMinMestres
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "qtdMinMestres",
        e));

    s << i.qtdMinMestres ();
  }

  // qtdMaxProfDisc
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "qtdMaxProfDisc",
        e));

    s << i.qtdMaxProfDisc ();
  }

  // areaTitulacao
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "areaTitulacao",
        e));

    s << i.areaTitulacao ();
  }

  // Curriculos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Curriculos",
        e));

    s << i.Curriculos ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoCurso& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Curso
  //
  for (GrupoCurso::Curso_const_iterator
       b (i.Curso ().begin ()), n (i.Curso ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Curso",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemDemanda& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // quantidade
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "quantidade",
        e));

    s << i.quantidade ();
  }

  // turno
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "turno",
        e));

    s << i.turno ();
  }

  // disciplina
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "disciplina",
        e));

    s << i.disciplina ();
  }

  // curso
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "curso",
        e));

    s << i.curso ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoDemanda& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Demanda
  //
  for (GrupoDemanda::Demanda_const_iterator
       b (i.Demanda ().begin ()), n (i.Demanda ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Demanda",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemUnidadeCurriculo& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // turno
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "turno",
        e));

    s << i.turno ();
  }

  // curriculo
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "curriculo",
        e));

    s << i.curriculo ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoUnidadeCurriculo& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // UnidadeCurriculo
  //
  for (GrupoUnidadeCurriculo::UnidadeCurriculo_const_iterator
       b (i.UnidadeCurriculo ().begin ()), n (i.UnidadeCurriculo ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "UnidadeCurriculo",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemAlocacao& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // professor
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "professor",
        e));

    s << i.professor ();
  }

  // horario
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "horario",
        e));

    s << i.horario ();
  }

  // oferecimento
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "oferecimento",
        e));

    s << i.oferecimento ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemOferecimento& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // sala
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sala",
        e));

    s << i.sala ();
  }

  // semana
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "semana",
        e));

    s << i.semana ();
  }

  // creditos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "creditos",
        e));

    s << i.creditos ();
  }

  // turma
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "turma",
        e));

    s << i.turma ();
  }

  // alocacao
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "alocacao",
        e));

    s << i.alocacao ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoOferecimento& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Oferecimento
  //
  for (GrupoOferecimento::Oferecimento_const_iterator
       b (i.Oferecimento ().begin ()), n (i.Oferecimento ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Oferecimento",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemTurma& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }

  // disciplina
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "disciplina",
        e));

    s << i.disciplina ();
  }

  // oferecimentos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "oferecimentos",
        e));

    s << i.oferecimentos ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const GrupoTurma& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Turma
  //
  for (GrupoTurma::Turma_const_iterator
       b (i.Turma ().begin ()), n (i.Turma ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Turma",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemTipoSala& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  if (i.id ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << *i.id ();
  }

  // nome
  //
  if (i.nome ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << *i.nome ();
  }

  // descricao
  //
  if (i.descricao ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "descricao",
        e));

    s << *i.descricao ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemTipoContrato& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemTipoTitulacao& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemAreaTitulacao& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemTipoDisciplina& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ItemTipoCurso& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "id",
        e));

    s << i.id ();
  }

  // nome
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nome",
        e));

    s << i.nome ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Trieda& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // unidades
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "unidades",
        e));

    s << i.unidades ();
  }

  // cursos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cursos",
        e));

    s << i.cursos ();
  }

  // calendario
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "calendario",
        e));

    s << i.calendario ();
  }

  // professores
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "professores",
        e));

    s << i.professores ();
  }

  // disciplinas
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "disciplinas",
        e));

    s << i.disciplinas ();
  }

  // regrasCredito
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "regrasCredito",
        e));

    s << i.regrasCredito ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const UnidadeCurriculo& i)
{
  e << static_cast< const ::ItemUnidadeCurriculo& > (i);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

