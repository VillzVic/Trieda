// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from TRIEDA-OutputXSD.xsd.
 */

#ifndef CXX_________DOC_COMMON_COMMUNICATION_PROTOCOL_TRIEDA_OUTPUT_XSD_H
#define CXX_________DOC_COMMON_COMMUNICATION_PROTOCOL_TRIEDA_OUTPUT_XSD_H

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;


  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class ItemOperacional;
class ItemAtendimentoCampus;
class ItemAtendimentoUnidade;
class ItemAtendimentoSala;
class ItemAtendimentoDiaSemana;
class ItemAtendimentoTurno;
class ItemAtendimentoHorarioAula;
class ItemAtendimentoOferta;
class ItemAtendimentoTatico;
class GrupoAtendimentoCampus;
class GrupoAtendimentoUnidade;
class GrupoAtendimentoSala;
class GrupoAtendimentoDiaSemana;
class GrupoAtendimentoTurno;
class GrupoAtendimentoHorarioAula;
class GrupoAtendimentoOferta;
class GrupoAtendimentoTatico;
class ItemWarning;
class GrupoWarning;
class ItemError;
class GrupoError;
class TriedaOutput;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Class corresponding to the %ItemOperacional schema type.
 *
 * @nosubgrouping
 */
class ItemOperacional: public ::xml_schema::type
{
  public:
  /**
   * @name horarioAulaId
   *
   * @brief Accessor and modifier functions for the %horarioAulaId
   * required element.
   *
   * identificador (ItemHorarioAula) do hor?rio em que a turma ser?
  atendida */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ horarioAulaId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horarioAulaId_type, char > horarioAulaId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const horarioAulaId_type&
  horarioAulaId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  horarioAulaId_type&
  horarioAulaId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  horarioAulaId (const horarioAulaId_type& x);

  //@}

  /**
   * @name professorId
   *
   * @brief Accessor and modifier functions for the %professorId
   * required element.
   *
   * identificador (ItemProfessor) do professor que ir? ministrar a aula
   * para a turma
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ professorId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< professorId_type, char > professorId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const professorId_type&
  professorId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  professorId_type&
  professorId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  professorId (const professorId_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemOperacional (const horarioAulaId_type&,
                   const professorId_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemOperacional (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemOperacional (const ItemOperacional& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemOperacional*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemOperacional ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< horarioAulaId_type > horarioAulaId_;
  ::xsd::cxx::tree::one< professorId_type > professorId_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAtendimentoCampus schema type.
 *
 * @nosubgrouping
 */
class ItemAtendimentoCampus: public ::xml_schema::type
{
  public:
  /**
   * @name campusId
   *
   * @brief Accessor and modifier functions for the %campusId
   * required element.
   *
   * identificador do campus que cont?m os atendimentos
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ campusId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< campusId_type, char > campusId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const campusId_type&
  campusId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  campusId_type&
  campusId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  campusId (const campusId_type& x);

  //@}

  /**
   * @name campusCodigo
   *
   * @brief Accessor and modifier functions for the %campusCodigo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string campusCodigo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< campusCodigo_type, char > campusCodigo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const campusCodigo_type&
  campusCodigo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  campusCodigo_type&
  campusCodigo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  campusCodigo (const campusCodigo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  campusCodigo (::std::auto_ptr< campusCodigo_type > p);

  //@}

  /**
   * @name atendimentosUnidades
   *
   * @brief Accessor and modifier functions for the %atendimentosUnidades
   * required element.
   *
   * lista de todos os atendimentos realizados em cada unidade de um
   * determinado campus que foi considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoAtendimentoUnidade atendimentosUnidades_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentosUnidades_type, char > atendimentosUnidades_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const atendimentosUnidades_type&
  atendimentosUnidades () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  atendimentosUnidades_type&
  atendimentosUnidades ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentosUnidades (const atendimentosUnidades_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  atendimentosUnidades (::std::auto_ptr< atendimentosUnidades_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAtendimentoCampus (const campusId_type&,
                         const campusCodigo_type&,
                         const atendimentosUnidades_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemAtendimentoCampus (const campusId_type&,
                         const campusCodigo_type&,
                         ::std::auto_ptr< atendimentosUnidades_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAtendimentoCampus (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAtendimentoCampus (const ItemAtendimentoCampus& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAtendimentoCampus*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAtendimentoCampus ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< campusId_type > campusId_;
  ::xsd::cxx::tree::one< campusCodigo_type > campusCodigo_;
  ::xsd::cxx::tree::one< atendimentosUnidades_type > atendimentosUnidades_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAtendimentoUnidade schema type.
 *
 * @nosubgrouping
 */
class ItemAtendimentoUnidade: public ::xml_schema::type
{
  public:
  /**
   * @name unidadeId
   *
   * @brief Accessor and modifier functions for the %unidadeId
   * required element.
   *
   * identificador da unidade (de um determinado campus) que cont?m os
   * atendimentos
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ unidadeId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< unidadeId_type, char > unidadeId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const unidadeId_type&
  unidadeId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  unidadeId_type&
  unidadeId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  unidadeId (const unidadeId_type& x);

  //@}

  /**
   * @name unidadeCodigo
   *
   * @brief Accessor and modifier functions for the %unidadeCodigo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string unidadeCodigo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< unidadeCodigo_type, char > unidadeCodigo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const unidadeCodigo_type&
  unidadeCodigo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  unidadeCodigo_type&
  unidadeCodigo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  unidadeCodigo (const unidadeCodigo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  unidadeCodigo (::std::auto_ptr< unidadeCodigo_type > p);

  //@}

  /**
   * @name atendimentosSalas
   *
   * @brief Accessor and modifier functions for the %atendimentosSalas
   * required element.
   *
   * lista de todos os atendimentos realizados em cada sala de uma
   * determinada unidade de um determinado campus que foi considerado no
   * planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoAtendimentoSala atendimentosSalas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentosSalas_type, char > atendimentosSalas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const atendimentosSalas_type&
  atendimentosSalas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  atendimentosSalas_type&
  atendimentosSalas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentosSalas (const atendimentosSalas_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  atendimentosSalas (::std::auto_ptr< atendimentosSalas_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAtendimentoUnidade (const unidadeId_type&,
                          const unidadeCodigo_type&,
                          const atendimentosSalas_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemAtendimentoUnidade (const unidadeId_type&,
                          const unidadeCodigo_type&,
                          ::std::auto_ptr< atendimentosSalas_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAtendimentoUnidade (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAtendimentoUnidade (const ItemAtendimentoUnidade& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAtendimentoUnidade*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAtendimentoUnidade ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< unidadeId_type > unidadeId_;
  ::xsd::cxx::tree::one< unidadeCodigo_type > unidadeCodigo_;
  ::xsd::cxx::tree::one< atendimentosSalas_type > atendimentosSalas_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAtendimentoSala schema type.
 *
 * @nosubgrouping
 */
class ItemAtendimentoSala: public ::xml_schema::type
{
  public:
  /**
   * @name salaId
   *
   * @brief Accessor and modifier functions for the %salaId
   * required element.
   *
   * identificador da sala (de uma determinada unidade de um determinado
   * campus) que cont?m os atendimentos
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ salaId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< salaId_type, char > salaId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const salaId_type&
  salaId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  salaId_type&
  salaId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  salaId (const salaId_type& x);

  //@}

  /**
   * @name salaNome
   *
   * @brief Accessor and modifier functions for the %salaNome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string salaNome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< salaNome_type, char > salaNome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const salaNome_type&
  salaNome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  salaNome_type&
  salaNome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  salaNome (const salaNome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  salaNome (::std::auto_ptr< salaNome_type > p);

  //@}

  /**
   * @name atendimentosDiasSemana
   *
   * @brief Accessor and modifier functions for the %atendimentosDiasSemana
   * required element.
   *
   * lista de todos os atendimentos realizados em cada dia da semana numa
   * determinada sala de uma determinada unidade de um determinado campus
   * que foi considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoAtendimentoDiaSemana atendimentosDiasSemana_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentosDiasSemana_type, char > atendimentosDiasSemana_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const atendimentosDiasSemana_type&
  atendimentosDiasSemana () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  atendimentosDiasSemana_type&
  atendimentosDiasSemana ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentosDiasSemana (const atendimentosDiasSemana_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  atendimentosDiasSemana (::std::auto_ptr< atendimentosDiasSemana_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAtendimentoSala (const salaId_type&,
                       const salaNome_type&,
                       const atendimentosDiasSemana_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemAtendimentoSala (const salaId_type&,
                       const salaNome_type&,
                       ::std::auto_ptr< atendimentosDiasSemana_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAtendimentoSala (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAtendimentoSala (const ItemAtendimentoSala& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAtendimentoSala*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAtendimentoSala ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< salaId_type > salaId_;
  ::xsd::cxx::tree::one< salaNome_type > salaNome_;
  ::xsd::cxx::tree::one< atendimentosDiasSemana_type > atendimentosDiasSemana_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAtendimentoDiaSemana schema type.
 *
 * @nosubgrouping
 */
class ItemAtendimentoDiaSemana: public ::xml_schema::type
{
  public:
  /**
   * @name diaSemana
   *
   * @brief Accessor and modifier functions for the %diaSemana
   * required element.
   *
   * identificador do dia da semana que cont?m os atendimentos em uma
   * determinada sala de uma determinada unidade de um determinado campus
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ diaSemana_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< diaSemana_type, char > diaSemana_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const diaSemana_type&
  diaSemana () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  diaSemana_type&
  diaSemana ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  diaSemana (const diaSemana_type& x);

  //@}

  /**
   * @name atendimentosTatico
   *
   * @brief Accessor and modifier functions for the %atendimentosTatico
   * optional element.
   *
   * lista de todas as ofertas atendidas no dia da semana em quest?o numa
   * determinada sala de uma determinada unidade de um determinado campus
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoAtendimentoTatico atendimentosTatico_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< atendimentosTatico_type > atendimentosTatico_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentosTatico_type, char > atendimentosTatico_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const atendimentosTatico_optional&
  atendimentosTatico () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  atendimentosTatico_optional&
  atendimentosTatico ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentosTatico (const atendimentosTatico_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  atendimentosTatico (const atendimentosTatico_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  atendimentosTatico (::std::auto_ptr< atendimentosTatico_type > p);

  //@}

  /**
   * @name atendimentosTurnos
   *
   * @brief Accessor and modifier functions for the %atendimentosTurnos
   * optional element.
   *
   * lista de todos os atendimentos realizados em cada turno de um
   * determinado dia da semana numa determinada sala de uma determinada
   * unidade de um determinado campus que foi considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoAtendimentoTurno atendimentosTurnos_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< atendimentosTurnos_type > atendimentosTurnos_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentosTurnos_type, char > atendimentosTurnos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const atendimentosTurnos_optional&
  atendimentosTurnos () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  atendimentosTurnos_optional&
  atendimentosTurnos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentosTurnos (const atendimentosTurnos_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  atendimentosTurnos (const atendimentosTurnos_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  atendimentosTurnos (::std::auto_ptr< atendimentosTurnos_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAtendimentoDiaSemana (const diaSemana_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAtendimentoDiaSemana (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAtendimentoDiaSemana (const ItemAtendimentoDiaSemana& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAtendimentoDiaSemana*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAtendimentoDiaSemana ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< diaSemana_type > diaSemana_;
  atendimentosTatico_optional atendimentosTatico_;
  atendimentosTurnos_optional atendimentosTurnos_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAtendimentoTurno schema type.
 *
 * @nosubgrouping
 */
class ItemAtendimentoTurno: public ::xml_schema::type
{
  public:
  /**
   * @name turnoId
   *
   * @brief Accessor and modifier functions for the %turnoId
   * required element.
   *
   * identificador do turno (de um determinado dia da semana) que cont?m os
   * atendimentos em uma determinada sala de uma determinada unidade de um
   * determinado campus
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ turnoId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< turnoId_type, char > turnoId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const turnoId_type&
  turnoId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  turnoId_type&
  turnoId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  turnoId (const turnoId_type& x);

  //@}

  /**
   * @name atendimentosHorariosAula
   *
   * @brief Accessor and modifier functions for the %atendimentosHorariosAula
   * required element.
   *
   * lista de todos os atendimentos realizados em cada horario de aula (ou
   * tempo de aula) de um determinado turno de um determinado dia da semana
   * numa determinada sala de uma determinada unidade de um determinado
   * campus que foi considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoAtendimentoHorarioAula atendimentosHorariosAula_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentosHorariosAula_type, char > atendimentosHorariosAula_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const atendimentosHorariosAula_type&
  atendimentosHorariosAula () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  atendimentosHorariosAula_type&
  atendimentosHorariosAula ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentosHorariosAula (const atendimentosHorariosAula_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  atendimentosHorariosAula (::std::auto_ptr< atendimentosHorariosAula_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAtendimentoTurno (const turnoId_type&,
                        const atendimentosHorariosAula_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemAtendimentoTurno (const turnoId_type&,
                        ::std::auto_ptr< atendimentosHorariosAula_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAtendimentoTurno (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAtendimentoTurno (const ItemAtendimentoTurno& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAtendimentoTurno*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAtendimentoTurno ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< turnoId_type > turnoId_;
  ::xsd::cxx::tree::one< atendimentosHorariosAula_type > atendimentosHorariosAula_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAtendimentoHorarioAula schema type.
 *
 * @nosubgrouping
 */
class ItemAtendimentoHorarioAula: public ::xml_schema::type
{
  public:
  /**
   * @name horarioAulaId
   *
   * @brief Accessor and modifier functions for the %horarioAulaId
   * required element.
   *
   * identificador do hor?rio de aula  (de um determinado turno de um
   * determinado dia da semana) que cont?m os atendimentos em uma
   * determinada sala de uma determinada unidade de um determinado campus
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ horarioAulaId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horarioAulaId_type, char > horarioAulaId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const horarioAulaId_type&
  horarioAulaId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  horarioAulaId_type&
  horarioAulaId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  horarioAulaId (const horarioAulaId_type& x);

  //@}

  /**
   * @name professorId
   *
   * @brief Accessor and modifier functions for the %professorId
   * required element.
   *
   * identificador do professor que dar? aula no hor?rio de aula em quest?o
   * (de um determinado turno de um determinado dia da semana) que cont?m
   * os atendimentos em uma determinada sala de uma determinada unidade de
   * um determinado campus
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ professorId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< professorId_type, char > professorId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const professorId_type&
  professorId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  professorId_type&
  professorId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  professorId (const professorId_type& x);

  //@}

  /**
   * @name creditoTeorico
   *
   * @brief Accessor and modifier functions for the %creditoTeorico
   * required element.
   *
   * informa se o cr?dito do hor?rio de aula em quest?o se refere a cr?dito
   * te?rico ou n?o (caso n?o seja te?rico significa que ? pr?tico)
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean creditoTeorico_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< creditoTeorico_type, char > creditoTeorico_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const creditoTeorico_type&
  creditoTeorico () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  creditoTeorico_type&
  creditoTeorico ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  creditoTeorico (const creditoTeorico_type& x);

  //@}

  /**
   * @name atendimentosOfertas
   *
   * @brief Accessor and modifier functions for the %atendimentosOfertas
   * required element.
   *
   * lista de todas as ofertas atendidas pelo professor em quest?o no
   * horario de aula (ou tempo de aula) em quest?o de um determinado turno
   * de um determinado dia da semana numa determinada sala de uma
   * determinada unidade de um determinado campus
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoAtendimentoOferta atendimentosOfertas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentosOfertas_type, char > atendimentosOfertas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const atendimentosOfertas_type&
  atendimentosOfertas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  atendimentosOfertas_type&
  atendimentosOfertas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentosOfertas (const atendimentosOfertas_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  atendimentosOfertas (::std::auto_ptr< atendimentosOfertas_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAtendimentoHorarioAula (const horarioAulaId_type&,
                              const professorId_type&,
                              const creditoTeorico_type&,
                              const atendimentosOfertas_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemAtendimentoHorarioAula (const horarioAulaId_type&,
                              const professorId_type&,
                              const creditoTeorico_type&,
                              ::std::auto_ptr< atendimentosOfertas_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAtendimentoHorarioAula (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAtendimentoHorarioAula (const ItemAtendimentoHorarioAula& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAtendimentoHorarioAula*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAtendimentoHorarioAula ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< horarioAulaId_type > horarioAulaId_;
  ::xsd::cxx::tree::one< professorId_type > professorId_;
  ::xsd::cxx::tree::one< creditoTeorico_type > creditoTeorico_;
  ::xsd::cxx::tree::one< atendimentosOfertas_type > atendimentosOfertas_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAtendimentoOferta schema type.
 *
 * @nosubgrouping
 */
class ItemAtendimentoOferta: public ::xml_schema::type
{
  public:
  /**
   * @name ofertaCursoCampiId
   *
   * @brief Accessor and modifier functions for the %ofertaCursoCampiId
   * required element.
   *
   * identificador da oferta atendida
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ ofertaCursoCampiId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ofertaCursoCampiId_type, char > ofertaCursoCampiId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const ofertaCursoCampiId_type&
  ofertaCursoCampiId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  ofertaCursoCampiId_type&
  ofertaCursoCampiId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  ofertaCursoCampiId (const ofertaCursoCampiId_type& x);

  //@}

  /**
   * @name disciplinaId
   *
   * @brief Accessor and modifier functions for the %disciplinaId
   * required element.
   *
   * identificador da disciplina atendida
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ disciplinaId_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< disciplinaId_type, char > disciplinaId_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const disciplinaId_type&
  disciplinaId () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  disciplinaId_type&
  disciplinaId ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  disciplinaId (const disciplinaId_type& x);

  //@}

  /**
   * @name quantidade
   *
   * @brief Accessor and modifier functions for the %quantidade
   * required element.
   *
   * quantidade de alunos atendidos da oferta
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ quantidade_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< quantidade_type, char > quantidade_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const quantidade_type&
  quantidade () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  quantidade_type&
  quantidade ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  quantidade (const quantidade_type& x);

  //@}

  /**
   * @name turma
   *
   * @brief Accessor and modifier functions for the %turma
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string turma_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< turma_type, char > turma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const turma_type&
  turma () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  turma_type&
  turma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  turma (const turma_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  turma (::std::auto_ptr< turma_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAtendimentoOferta (const ofertaCursoCampiId_type&,
                         const disciplinaId_type&,
                         const quantidade_type&,
                         const turma_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAtendimentoOferta (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAtendimentoOferta (const ItemAtendimentoOferta& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAtendimentoOferta*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAtendimentoOferta ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ofertaCursoCampiId_type > ofertaCursoCampiId_;
  ::xsd::cxx::tree::one< disciplinaId_type > disciplinaId_;
  ::xsd::cxx::tree::one< quantidade_type > quantidade_;
  ::xsd::cxx::tree::one< turma_type > turma_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAtendimentoTatico schema type.
 *
 * @nosubgrouping
 */
class ItemAtendimentoTatico: public ::xml_schema::type
{
  public:
  /**
   * @name atendimentoOferta
   *
   * @brief Accessor and modifier functions for the %atendimentoOferta
   * required element.
   *
   * representa uma oferta atendida
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoOferta atendimentoOferta_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentoOferta_type, char > atendimentoOferta_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const atendimentoOferta_type&
  atendimentoOferta () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  atendimentoOferta_type&
  atendimentoOferta ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentoOferta (const atendimentoOferta_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  atendimentoOferta (::std::auto_ptr< atendimentoOferta_type > p);

  //@}

  /**
   * @name qtdeCreditosTeoricos
   *
   * @brief Accessor and modifier functions for the %qtdeCreditosTeoricos
   * required element.
   *
   * informa a quantidade de cr?ditos te?ricos consumidos pela atendimento
   * da oferta em quest?o
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ qtdeCreditosTeoricos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< qtdeCreditosTeoricos_type, char > qtdeCreditosTeoricos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const qtdeCreditosTeoricos_type&
  qtdeCreditosTeoricos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  qtdeCreditosTeoricos_type&
  qtdeCreditosTeoricos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  qtdeCreditosTeoricos (const qtdeCreditosTeoricos_type& x);

  //@}

  /**
   * @name qtdeCreditosPraticos
   *
   * @brief Accessor and modifier functions for the %qtdeCreditosPraticos
   * required element.
   *
   * informa a quantidade de cr?ditos pr?ticos consumidos pela atendimento
   * da oferta em quest?o
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ qtdeCreditosPraticos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< qtdeCreditosPraticos_type, char > qtdeCreditosPraticos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const qtdeCreditosPraticos_type&
  qtdeCreditosPraticos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  qtdeCreditosPraticos_type&
  qtdeCreditosPraticos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  qtdeCreditosPraticos (const qtdeCreditosPraticos_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAtendimentoTatico (const atendimentoOferta_type&,
                         const qtdeCreditosTeoricos_type&,
                         const qtdeCreditosPraticos_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemAtendimentoTatico (::std::auto_ptr< atendimentoOferta_type >&,
                         const qtdeCreditosTeoricos_type&,
                         const qtdeCreditosPraticos_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAtendimentoTatico (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAtendimentoTatico (const ItemAtendimentoTatico& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAtendimentoTatico*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAtendimentoTatico ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< atendimentoOferta_type > atendimentoOferta_;
  ::xsd::cxx::tree::one< qtdeCreditosTeoricos_type > qtdeCreditosTeoricos_;
  ::xsd::cxx::tree::one< qtdeCreditosPraticos_type > qtdeCreditosPraticos_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoAtendimentoCampus schema type.
 *
 * @nosubgrouping
 */
class GrupoAtendimentoCampus: public ::xml_schema::type
{
  public:
  /**
   * @name AtendimentoCampus
   *
   * @brief Accessor and modifier functions for the %AtendimentoCampus
   * sequence element.
   *
   * cont?m os atendimentos realizados em um determinado campus que foi
   * considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoCampus AtendimentoCampus_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AtendimentoCampus_type > AtendimentoCampus_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AtendimentoCampus_sequence::iterator AtendimentoCampus_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AtendimentoCampus_sequence::const_iterator AtendimentoCampus_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AtendimentoCampus_type, char > AtendimentoCampus_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AtendimentoCampus_sequence&
  AtendimentoCampus () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AtendimentoCampus_sequence&
  AtendimentoCampus ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AtendimentoCampus (const AtendimentoCampus_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoAtendimentoCampus ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoAtendimentoCampus (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoAtendimentoCampus (const GrupoAtendimentoCampus& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoAtendimentoCampus*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoAtendimentoCampus ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AtendimentoCampus_sequence AtendimentoCampus_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoAtendimentoUnidade schema type.
 *
 * @nosubgrouping
 */
class GrupoAtendimentoUnidade: public ::xml_schema::type
{
  public:
  /**
   * @name AtendimentoUnidade
   *
   * @brief Accessor and modifier functions for the %AtendimentoUnidade
   * sequence element.
   *
   * cont?m os atendimentos realizados em uma determinada unidade de um
   * determinado campus que foi considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoUnidade AtendimentoUnidade_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AtendimentoUnidade_type > AtendimentoUnidade_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AtendimentoUnidade_sequence::iterator AtendimentoUnidade_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AtendimentoUnidade_sequence::const_iterator AtendimentoUnidade_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AtendimentoUnidade_type, char > AtendimentoUnidade_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AtendimentoUnidade_sequence&
  AtendimentoUnidade () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AtendimentoUnidade_sequence&
  AtendimentoUnidade ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AtendimentoUnidade (const AtendimentoUnidade_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoAtendimentoUnidade ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoAtendimentoUnidade (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoAtendimentoUnidade (const GrupoAtendimentoUnidade& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoAtendimentoUnidade*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoAtendimentoUnidade ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AtendimentoUnidade_sequence AtendimentoUnidade_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoAtendimentoSala schema type.
 *
 * @nosubgrouping
 */
class GrupoAtendimentoSala: public ::xml_schema::type
{
  public:
  /**
   * @name AtendimentoSala
   *
   * @brief Accessor and modifier functions for the %AtendimentoSala
   * sequence element.
   *
   * cont?m os atendimentos realizados em uma determinada sala de uma
   * determinada unidade de um determinado campus que foi considerado no
   * planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoSala AtendimentoSala_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AtendimentoSala_type > AtendimentoSala_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AtendimentoSala_sequence::iterator AtendimentoSala_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AtendimentoSala_sequence::const_iterator AtendimentoSala_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AtendimentoSala_type, char > AtendimentoSala_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AtendimentoSala_sequence&
  AtendimentoSala () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AtendimentoSala_sequence&
  AtendimentoSala ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AtendimentoSala (const AtendimentoSala_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoAtendimentoSala ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoAtendimentoSala (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoAtendimentoSala (const GrupoAtendimentoSala& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoAtendimentoSala*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoAtendimentoSala ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AtendimentoSala_sequence AtendimentoSala_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoAtendimentoDiaSemana schema type.
 *
 * @nosubgrouping
 */
class GrupoAtendimentoDiaSemana: public ::xml_schema::type
{
  public:
  /**
   * @name AtendimentoDiaSemana
   *
   * @brief Accessor and modifier functions for the %AtendimentoDiaSemana
   * sequence element.
   *
   * cont?m os atendimentos realizados num determinado dia da semana em uma
   * determinada sala de uma determinada unidade de um determinado campus
   * que foi considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoDiaSemana AtendimentoDiaSemana_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AtendimentoDiaSemana_type > AtendimentoDiaSemana_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AtendimentoDiaSemana_sequence::iterator AtendimentoDiaSemana_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AtendimentoDiaSemana_sequence::const_iterator AtendimentoDiaSemana_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AtendimentoDiaSemana_type, char > AtendimentoDiaSemana_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AtendimentoDiaSemana_sequence&
  AtendimentoDiaSemana () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AtendimentoDiaSemana_sequence&
  AtendimentoDiaSemana ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AtendimentoDiaSemana (const AtendimentoDiaSemana_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoAtendimentoDiaSemana ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoAtendimentoDiaSemana (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoAtendimentoDiaSemana (const GrupoAtendimentoDiaSemana& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoAtendimentoDiaSemana*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoAtendimentoDiaSemana ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AtendimentoDiaSemana_sequence AtendimentoDiaSemana_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoAtendimentoTurno schema type.
 *
 * @nosubgrouping
 */
class GrupoAtendimentoTurno: public ::xml_schema::type
{
  public:
  /**
   * @name AtendimentoTurno
   *
   * @brief Accessor and modifier functions for the %AtendimentoTurno
   * sequence element.
   *
   * cont?m os atendimentos realizados num determinado turno de um
   * determinado dia da semana em uma determinada sala de uma determinada
   * unidade de um determinado campus que foi considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoTurno AtendimentoTurno_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AtendimentoTurno_type > AtendimentoTurno_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AtendimentoTurno_sequence::iterator AtendimentoTurno_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AtendimentoTurno_sequence::const_iterator AtendimentoTurno_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AtendimentoTurno_type, char > AtendimentoTurno_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AtendimentoTurno_sequence&
  AtendimentoTurno () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AtendimentoTurno_sequence&
  AtendimentoTurno ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AtendimentoTurno (const AtendimentoTurno_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoAtendimentoTurno ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoAtendimentoTurno (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoAtendimentoTurno (const GrupoAtendimentoTurno& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoAtendimentoTurno*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoAtendimentoTurno ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AtendimentoTurno_sequence AtendimentoTurno_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoAtendimentoHorarioAula schema type.
 *
 * @nosubgrouping
 */
class GrupoAtendimentoHorarioAula: public ::xml_schema::type
{
  public:
  /**
   * @name AtendimentoHorarioAula
   *
   * @brief Accessor and modifier functions for the %AtendimentoHorarioAula
   * sequence element.
   *
   * cont?m os atendimentos realizados num determinado horario de aula (ou
   * tempo de aula) de um determinado turno de um determinado dia da semana
   * em uma determinada sala de uma determinada unidade de um determinado
   * campus que foi considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoHorarioAula AtendimentoHorarioAula_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AtendimentoHorarioAula_type > AtendimentoHorarioAula_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AtendimentoHorarioAula_sequence::iterator AtendimentoHorarioAula_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AtendimentoHorarioAula_sequence::const_iterator AtendimentoHorarioAula_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AtendimentoHorarioAula_type, char > AtendimentoHorarioAula_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AtendimentoHorarioAula_sequence&
  AtendimentoHorarioAula () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AtendimentoHorarioAula_sequence&
  AtendimentoHorarioAula ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AtendimentoHorarioAula (const AtendimentoHorarioAula_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoAtendimentoHorarioAula ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoAtendimentoHorarioAula (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoAtendimentoHorarioAula (const GrupoAtendimentoHorarioAula& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoAtendimentoHorarioAula*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoAtendimentoHorarioAula ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AtendimentoHorarioAula_sequence AtendimentoHorarioAula_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoAtendimentoOferta schema type.
 *
 * @nosubgrouping
 */
class GrupoAtendimentoOferta: public ::xml_schema::type
{
  public:
  /**
   * @name AtendimentoOferta
   *
   * @brief Accessor and modifier functions for the %AtendimentoOferta
   * sequence element.
   *
   * representa uma oferta atendida
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoOferta AtendimentoOferta_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AtendimentoOferta_type > AtendimentoOferta_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AtendimentoOferta_sequence::iterator AtendimentoOferta_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AtendimentoOferta_sequence::const_iterator AtendimentoOferta_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AtendimentoOferta_type, char > AtendimentoOferta_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AtendimentoOferta_sequence&
  AtendimentoOferta () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AtendimentoOferta_sequence&
  AtendimentoOferta ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AtendimentoOferta (const AtendimentoOferta_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoAtendimentoOferta ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoAtendimentoOferta (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoAtendimentoOferta (const GrupoAtendimentoOferta& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoAtendimentoOferta*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoAtendimentoOferta ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AtendimentoOferta_sequence AtendimentoOferta_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoAtendimentoTatico schema type.
 *
 * @nosubgrouping
 */
class GrupoAtendimentoTatico: public ::xml_schema::type
{
  public:
  /**
   * @name AtendimentoTatico
   *
   * @brief Accessor and modifier functions for the %AtendimentoTatico
   * sequence element.
   *
   * representa uma oferta atendida
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAtendimentoTatico AtendimentoTatico_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< AtendimentoTatico_type > AtendimentoTatico_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef AtendimentoTatico_sequence::iterator AtendimentoTatico_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef AtendimentoTatico_sequence::const_iterator AtendimentoTatico_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< AtendimentoTatico_type, char > AtendimentoTatico_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const AtendimentoTatico_sequence&
  AtendimentoTatico () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  AtendimentoTatico_sequence&
  AtendimentoTatico ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  AtendimentoTatico (const AtendimentoTatico_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoAtendimentoTatico ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoAtendimentoTatico (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoAtendimentoTatico (const GrupoAtendimentoTatico& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoAtendimentoTatico*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoAtendimentoTatico ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AtendimentoTatico_sequence AtendimentoTatico_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemWarning schema type.
 *
 * @nosubgrouping
 */
class ItemWarning: public ::xml_schema::type
{
  public:
  /**
   * @name Code
   *
   * @brief Accessor and modifier functions for the %Code
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Code_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Code_type, char > Code_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Code_type&
  Code () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Code_type&
  Code ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Code (const Code_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Code (::std::auto_ptr< Code_type > p);

  //@}

  /**
   * @name Message
   *
   * @brief Accessor and modifier functions for the %Message
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Message_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Message_type, char > Message_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Message_type&
  Message () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Message_type&
  Message ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Message (const Message_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Message (::std::auto_ptr< Message_type > p);

  //@}

  /**
   * @name Detail
   *
   * @brief Accessor and modifier functions for the %Detail
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Detail_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Detail_type, char > Detail_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Detail_type&
  Detail () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Detail_type&
  Detail ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Detail (const Detail_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Detail (::std::auto_ptr< Detail_type > p);

  //@}

  /**
   * @name Location
   *
   * @brief Accessor and modifier functions for the %Location
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Location_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Location_type&
  Location () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Location_type&
  Location ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Location (const Location_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Location (::std::auto_ptr< Location_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemWarning (const Code_type&,
               const Message_type&,
               const Detail_type&,
               const Location_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemWarning (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemWarning (const ItemWarning& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemWarning*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemWarning ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Code_type > Code_;
  ::xsd::cxx::tree::one< Message_type > Message_;
  ::xsd::cxx::tree::one< Detail_type > Detail_;
  ::xsd::cxx::tree::one< Location_type > Location_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoWarning schema type.
 *
 * @nosubgrouping
 */
class GrupoWarning: public ::xml_schema::type
{
  public:
  /**
   * @name Warning
   *
   * @brief Accessor and modifier functions for the %Warning
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemWarning Warning_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Warning_type > Warning_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Warning_sequence::iterator Warning_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Warning_sequence::const_iterator Warning_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Warning_type, char > Warning_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Warning_sequence&
  Warning () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Warning_sequence&
  Warning ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Warning (const Warning_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoWarning ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoWarning (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoWarning (const GrupoWarning& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoWarning*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoWarning ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Warning_sequence Warning_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemError schema type.
 *
 * @nosubgrouping
 */
class ItemError: public ::xml_schema::type
{
  public:
  /**
   * @name Code
   *
   * @brief Accessor and modifier functions for the %Code
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Code_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Code_type, char > Code_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Code_type&
  Code () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Code_type&
  Code ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Code (const Code_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Code (::std::auto_ptr< Code_type > p);

  //@}

  /**
   * @name Message
   *
   * @brief Accessor and modifier functions for the %Message
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Message_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Message_type, char > Message_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Message_type&
  Message () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Message_type&
  Message ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Message (const Message_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Message (::std::auto_ptr< Message_type > p);

  //@}

  /**
   * @name Detail
   *
   * @brief Accessor and modifier functions for the %Detail
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Detail_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Detail_type, char > Detail_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Detail_type&
  Detail () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Detail_type&
  Detail ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Detail (const Detail_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Detail (::std::auto_ptr< Detail_type > p);

  //@}

  /**
   * @name Location
   *
   * @brief Accessor and modifier functions for the %Location
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string Location_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Location_type, char > Location_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Location_type&
  Location () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Location_type&
  Location ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Location (const Location_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Location (::std::auto_ptr< Location_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemError (const Code_type&,
             const Message_type&,
             const Detail_type&,
             const Location_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemError (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemError (const ItemError& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemError*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemError ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Code_type > Code_;
  ::xsd::cxx::tree::one< Message_type > Message_;
  ::xsd::cxx::tree::one< Detail_type > Detail_;
  ::xsd::cxx::tree::one< Location_type > Location_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoError schema type.
 *
 * @nosubgrouping
 */
class GrupoError: public ::xml_schema::type
{
  public:
  /**
   * @name Error
   *
   * @brief Accessor and modifier functions for the %Error
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemError Error_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Error_type > Error_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Error_sequence::iterator Error_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Error_sequence::const_iterator Error_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Error_type, char > Error_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Error_sequence&
  Error () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Error_sequence&
  Error ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Error (const Error_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoError ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoError (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoError (const GrupoError& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoError*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoError ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Error_sequence Error_;

  //@endcond
};

/**
 * @brief Class corresponding to the %TriedaOutput schema type.
 *
 * @nosubgrouping
 */
class TriedaOutput: public ::xml_schema::type
{
  public:
  /**
   * @name atendimentos
   *
   * @brief Accessor and modifier functions for the %atendimentos
   * required element.
   *
   * lista de todos os atendimentos realizados em cada campus que foi
   * considerado no planejamento
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoAtendimentoCampus atendimentos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< atendimentos_type, char > atendimentos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const atendimentos_type&
  atendimentos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  atendimentos_type&
  atendimentos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  atendimentos (const atendimentos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  atendimentos (::std::auto_ptr< atendimentos_type > p);

  //@}

  /**
   * @name Warnings
   *
   * @brief Accessor and modifier functions for the %Warnings
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoWarning Warnings_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Warnings_type, char > Warnings_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Warnings_type&
  Warnings () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Warnings_type&
  Warnings ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Warnings (const Warnings_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Warnings (::std::auto_ptr< Warnings_type > p);

  //@}

  /**
   * @name Errors
   *
   * @brief Accessor and modifier functions for the %Errors
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoError Errors_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Errors_type, char > Errors_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Errors_type&
  Errors () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Errors_type&
  Errors ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Errors (const Errors_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Errors (::std::auto_ptr< Errors_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  TriedaOutput (const atendimentos_type&,
                const Warnings_type&,
                const Errors_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  TriedaOutput (::std::auto_ptr< atendimentos_type >&,
                ::std::auto_ptr< Warnings_type >&,
                ::std::auto_ptr< Errors_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  TriedaOutput (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  TriedaOutput (const TriedaOutput& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual TriedaOutput*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~TriedaOutput ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< atendimentos_type > atendimentos_;
  ::xsd::cxx::tree::one< Warnings_type > Warnings_;
  ::xsd::cxx::tree::one< Errors_type > Errors_;

  //@endcond
};

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const ItemOperacional&);

::std::ostream&
operator<< (::std::ostream&, const ItemAtendimentoCampus&);

::std::ostream&
operator<< (::std::ostream&, const ItemAtendimentoUnidade&);

::std::ostream&
operator<< (::std::ostream&, const ItemAtendimentoSala&);

::std::ostream&
operator<< (::std::ostream&, const ItemAtendimentoDiaSemana&);

::std::ostream&
operator<< (::std::ostream&, const ItemAtendimentoTurno&);

::std::ostream&
operator<< (::std::ostream&, const ItemAtendimentoHorarioAula&);

::std::ostream&
operator<< (::std::ostream&, const ItemAtendimentoOferta&);

::std::ostream&
operator<< (::std::ostream&, const ItemAtendimentoTatico&);

::std::ostream&
operator<< (::std::ostream&, const GrupoAtendimentoCampus&);

::std::ostream&
operator<< (::std::ostream&, const GrupoAtendimentoUnidade&);

::std::ostream&
operator<< (::std::ostream&, const GrupoAtendimentoSala&);

::std::ostream&
operator<< (::std::ostream&, const GrupoAtendimentoDiaSemana&);

::std::ostream&
operator<< (::std::ostream&, const GrupoAtendimentoTurno&);

::std::ostream&
operator<< (::std::ostream&, const GrupoAtendimentoHorarioAula&);

::std::ostream&
operator<< (::std::ostream&, const GrupoAtendimentoOferta&);

::std::ostream&
operator<< (::std::ostream&, const GrupoAtendimentoTatico&);

::std::ostream&
operator<< (::std::ostream&, const ItemWarning&);

::std::ostream&
operator<< (::std::ostream&, const GrupoWarning&);

::std::ostream&
operator<< (::std::ostream&, const ItemError&);

::std::ostream&
operator<< (::std::ostream&, const GrupoError&);

::std::ostream&
operator<< (::std::ostream&, const TriedaOutput&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %TriedaOutput document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (const ::std::string& uri,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (const ::std::string& uri,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (const ::std::string& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::std::istream& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::std::istream& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::std::istream& is,
               const ::std::string& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::xercesc::InputSource& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::xercesc::InputSource& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::auto_ptr< ::TriedaOutput >
TriedaOutput_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

/**
 * @name Serialization functions for the %TriedaOutput document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
TriedaOutput_ (::std::ostream& os,
               const ::TriedaOutput& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
TriedaOutput_ (::std::ostream& os,
               const ::TriedaOutput& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
TriedaOutput_ (::std::ostream& os,
               const ::TriedaOutput& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
TriedaOutput_ (::xercesc::XMLFormatTarget& ft,
               const ::TriedaOutput& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
TriedaOutput_ (::xercesc::XMLFormatTarget& ft,
               const ::TriedaOutput& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
TriedaOutput_ (::xercesc::XMLFormatTarget& ft,
               const ::TriedaOutput& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::string& e = "UTF-8",
               ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void
TriedaOutput_ (::xercesc::DOMDocument& d,
               const ::TriedaOutput& x,
               ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
TriedaOutput_ (const ::TriedaOutput& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

//@}

void
operator<< (::xercesc::DOMElement&, const ItemOperacional&);

void
operator<< (::xercesc::DOMElement&, const ItemAtendimentoCampus&);

void
operator<< (::xercesc::DOMElement&, const ItemAtendimentoUnidade&);

void
operator<< (::xercesc::DOMElement&, const ItemAtendimentoSala&);

void
operator<< (::xercesc::DOMElement&, const ItemAtendimentoDiaSemana&);

void
operator<< (::xercesc::DOMElement&, const ItemAtendimentoTurno&);

void
operator<< (::xercesc::DOMElement&, const ItemAtendimentoHorarioAula&);

void
operator<< (::xercesc::DOMElement&, const ItemAtendimentoOferta&);

void
operator<< (::xercesc::DOMElement&, const ItemAtendimentoTatico&);

void
operator<< (::xercesc::DOMElement&, const GrupoAtendimentoCampus&);

void
operator<< (::xercesc::DOMElement&, const GrupoAtendimentoUnidade&);

void
operator<< (::xercesc::DOMElement&, const GrupoAtendimentoSala&);

void
operator<< (::xercesc::DOMElement&, const GrupoAtendimentoDiaSemana&);

void
operator<< (::xercesc::DOMElement&, const GrupoAtendimentoTurno&);

void
operator<< (::xercesc::DOMElement&, const GrupoAtendimentoHorarioAula&);

void
operator<< (::xercesc::DOMElement&, const GrupoAtendimentoOferta&);

void
operator<< (::xercesc::DOMElement&, const GrupoAtendimentoTatico&);

void
operator<< (::xercesc::DOMElement&, const ItemWarning&);

void
operator<< (::xercesc::DOMElement&, const GrupoWarning&);

void
operator<< (::xercesc::DOMElement&, const ItemError&);

void
operator<< (::xercesc::DOMElement&, const GrupoError&);

void
operator<< (::xercesc::DOMElement&, const TriedaOutput&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_________DOC_COMMON_COMMUNICATION_PROTOCOL_TRIEDA_OUTPUT_XSD_H
