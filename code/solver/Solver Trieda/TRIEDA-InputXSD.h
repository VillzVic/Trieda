// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from TRIEDA-InputXSD.xsd.
 */

#ifndef CXX_________DOC_COMMON_COMMUNICATION_PROTOCOL_TRIEDA_INPUT_XSD_H
#define CXX_________DOC_COMMON_COMMUNICATION_PROTOCOL_TRIEDA_INPUT_XSD_H

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3020000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;


  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info < char > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap < char > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream < char > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double < double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal < decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class ItemProfessorDisciplina;
class GrupoProfessorDisciplina;
class ItemProfessor;
class GrupoProfessor;
class ItemDivisaoCreditos;
class GrupoDivisaoCreditos;
class GrupoDeslocamento;
class ItemDeslocamento;
class GrupoUnidade;
class ItemUnidade;
class ItemDisciplina;
class GrupoDisciplina;
class ItemCalendario;
class ItemHorarioDisponivel;
class GrupoHorarioDisponivel;
class ItemHorarioAula;
class GrupoHorarioAula;
class ItemTurno;
class GrupoTurno;
class ItemSala;
class ItemDisciplinaPeriodo;
class ItemCurriculo;
class GrupoCurriculo;
class GrupoSala;
class ItemCurso;
class GrupoCurso;
class ItemDemanda;
class GrupoDemanda;
class ItemUnidadeCurriculo;
class GrupoUnidadeCurriculo;
class ItemAlocacao;
class ItemOferecimento;
class GrupoOferecimento;
class ItemTurma;
class GrupoTurma;
class ItemTipoSala;
class ItemTipoContrato;
class ItemTipoTitulacao;
class ItemAreaTitulacao;
class ItemTipoDisciplina;
class ItemTipoCurso;
class Trieda;
class unidadeCurriculo;

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Class corresponding to the %ItemProfessorDisciplina schema type.
 *
 * @nosubgrouping
 */
class ItemProfessorDisciplina: public ::xml_schema::type
{
  public:
  /**
   * @name nota
   *
   * @brief Accessor and modifier functions for the %nota
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ nota_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< nota_type > nota_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nota_type, char > nota_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const nota_optional&
  nota () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  nota_optional&
  nota ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nota (const nota_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  nota (const nota_optional& x);

  //@}

  /**
   * @name ranking
   *
   * @brief Accessor and modifier functions for the %ranking
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ ranking_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< ranking_type > ranking_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ranking_type, char > ranking_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const ranking_optional&
  ranking () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  ranking_optional&
  ranking ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  ranking (const ranking_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  ranking (const ranking_optional& x);

  //@}

  /**
   * @name disciplina
   *
   * @brief Accessor and modifier functions for the %disciplina
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDisciplina disciplina_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< disciplina_type > disciplina_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< disciplina_type, char > disciplina_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const disciplina_optional&
  disciplina () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  disciplina_optional&
  disciplina ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  disciplina (const disciplina_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  disciplina (const disciplina_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  disciplina (::std::auto_ptr< disciplina_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemProfessorDisciplina ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemProfessorDisciplina (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemProfessorDisciplina (const ItemProfessorDisciplina& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemProfessorDisciplina*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemProfessorDisciplina ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  nota_optional nota_;
  ranking_optional ranking_;
  disciplina_optional disciplina_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoProfessorDisciplina schema type.
 *
 * @nosubgrouping
 */
class GrupoProfessorDisciplina: public ::xml_schema::type
{
  public:
  /**
   * @name professorDisciplina
   *
   * @brief Accessor and modifier functions for the %professorDisciplina
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemProfessorDisciplina professorDisciplina_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< professorDisciplina_type > professorDisciplina_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef professorDisciplina_sequence::iterator professorDisciplina_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef professorDisciplina_sequence::const_iterator professorDisciplina_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< professorDisciplina_type, char > professorDisciplina_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const professorDisciplina_sequence&
  professorDisciplina () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  professorDisciplina_sequence&
  professorDisciplina ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  professorDisciplina (const professorDisciplina_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoProfessorDisciplina ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoProfessorDisciplina (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoProfessorDisciplina (const GrupoProfessorDisciplina& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoProfessorDisciplina*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoProfessorDisciplina ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  professorDisciplina_sequence professorDisciplina_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemProfessor schema type.
 *
 * @nosubgrouping
 */
class ItemProfessor: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name contrato
   *
   * @brief Accessor and modifier functions for the %contrato
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTipoContrato contrato_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< contrato_type, char > contrato_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const contrato_type&
  contrato () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  contrato_type&
  contrato ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  contrato (const contrato_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  contrato (::std::auto_ptr< contrato_type > p);

  //@}

  /**
   * @name titulacao
   *
   * @brief Accessor and modifier functions for the %titulacao
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTipoTitulacao titulacao_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< titulacao_type, char > titulacao_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const titulacao_type&
  titulacao () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  titulacao_type&
  titulacao ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  titulacao (const titulacao_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  titulacao (::std::auto_ptr< titulacao_type > p);

  //@}

  /**
   * @name areaTitulacao
   *
   * @brief Accessor and modifier functions for the %areaTitulacao
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAreaTitulacao areaTitulacao_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< areaTitulacao_type, char > areaTitulacao_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const areaTitulacao_type&
  areaTitulacao () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  areaTitulacao_type&
  areaTitulacao ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  areaTitulacao (const areaTitulacao_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  areaTitulacao (::std::auto_ptr< areaTitulacao_type > p);

  //@}

  /**
   * @name cpf
   *
   * @brief Accessor and modifier functions for the %cpf
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string cpf_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cpf_type, char > cpf_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const cpf_type&
  cpf () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  cpf_type&
  cpf ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  cpf (const cpf_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  cpf (::std::auto_ptr< cpf_type > p);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name chMin
   *
   * @brief Accessor and modifier functions for the %chMin
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ chMin_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< chMin_type, char > chMin_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const chMin_type&
  chMin () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  chMin_type&
  chMin ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  chMin (const chMin_type& x);

  //@}

  /**
   * @name chMax
   *
   * @brief Accessor and modifier functions for the %chMax
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ chMax_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< chMax_type, char > chMax_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const chMax_type&
  chMax () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  chMax_type&
  chMax ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  chMax (const chMax_type& x);

  //@}

  /**
   * @name credAnterior
   *
   * @brief Accessor and modifier functions for the %credAnterior
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ credAnterior_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< credAnterior_type, char > credAnterior_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const credAnterior_type&
  credAnterior () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  credAnterior_type&
  credAnterior ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  credAnterior (const credAnterior_type& x);

  //@}

  /**
   * @name valorCred
   *
   * @brief Accessor and modifier functions for the %valorCred
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ valorCred_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< valorCred_type, char, ::xsd::cxx::tree::schema_type::double_ > valorCred_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const valorCred_type&
  valorCred () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  valorCred_type&
  valorCred ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  valorCred (const valorCred_type& x);

  //@}

  /**
   * @name unidades
   *
   * @brief Accessor and modifier functions for the %unidades
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoUnidade unidades_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< unidades_type, char > unidades_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const unidades_type&
  unidades () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  unidades_type&
  unidades ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  unidades (const unidades_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  unidades (::std::auto_ptr< unidades_type > p);

  //@}

  /**
   * @name horarios
   *
   * @brief Accessor and modifier functions for the %horarios
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemHorarioDisponivel horarios_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horarios_type, char > horarios_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const horarios_type&
  horarios () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  horarios_type&
  horarios ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  horarios (const horarios_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  horarios (::std::auto_ptr< horarios_type > p);

  //@}

  /**
   * @name disciplinas
   *
   * @brief Accessor and modifier functions for the %disciplinas
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoProfessorDisciplina disciplinas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< disciplinas_type, char > disciplinas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const disciplinas_type&
  disciplinas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  disciplinas_type&
  disciplinas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  disciplinas (const disciplinas_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  disciplinas (::std::auto_ptr< disciplinas_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemProfessor (const id_type&,
                 const contrato_type&,
                 const titulacao_type&,
                 const areaTitulacao_type&,
                 const cpf_type&,
                 const nome_type&,
                 const chMin_type&,
                 const chMax_type&,
                 const credAnterior_type&,
                 const valorCred_type&,
                 const unidades_type&,
                 const horarios_type&,
                 const disciplinas_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemProfessor (const id_type&,
                 ::std::auto_ptr< contrato_type >&,
                 ::std::auto_ptr< titulacao_type >&,
                 ::std::auto_ptr< areaTitulacao_type >&,
                 const cpf_type&,
                 const nome_type&,
                 const chMin_type&,
                 const chMax_type&,
                 const credAnterior_type&,
                 const valorCred_type&,
                 ::std::auto_ptr< unidades_type >&,
                 ::std::auto_ptr< horarios_type >&,
                 ::std::auto_ptr< disciplinas_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemProfessor (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemProfessor (const ItemProfessor& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemProfessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemProfessor ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< contrato_type > contrato_;
  ::xsd::cxx::tree::one< titulacao_type > titulacao_;
  ::xsd::cxx::tree::one< areaTitulacao_type > areaTitulacao_;
  ::xsd::cxx::tree::one< cpf_type > cpf_;
  ::xsd::cxx::tree::one< nome_type > nome_;
  ::xsd::cxx::tree::one< chMin_type > chMin_;
  ::xsd::cxx::tree::one< chMax_type > chMax_;
  ::xsd::cxx::tree::one< credAnterior_type > credAnterior_;
  ::xsd::cxx::tree::one< valorCred_type > valorCred_;
  ::xsd::cxx::tree::one< unidades_type > unidades_;
  ::xsd::cxx::tree::one< horarios_type > horarios_;
  ::xsd::cxx::tree::one< disciplinas_type > disciplinas_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoProfessor schema type.
 *
 * @nosubgrouping
 */
class GrupoProfessor: public ::xml_schema::type
{
  public:
  /**
   * @name professor
   *
   * @brief Accessor and modifier functions for the %professor
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemProfessor professor_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< professor_type > professor_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef professor_sequence::iterator professor_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef professor_sequence::const_iterator professor_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< professor_type, char > professor_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const professor_sequence&
  professor () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  professor_sequence&
  professor ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  professor (const professor_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoProfessor ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoProfessor (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoProfessor (const GrupoProfessor& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoProfessor*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoProfessor ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  professor_sequence professor_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemDivisaoCreditos schema type.
 *
 * @nosubgrouping
 */
class ItemDivisaoCreditos: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const id_optional&
  id () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  id_optional&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  id (const id_optional& x);

  //@}

  /**
   * @name creditos
   *
   * @brief Accessor and modifier functions for the %creditos
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ creditos_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< creditos_type > creditos_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< creditos_type, char > creditos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const creditos_optional&
  creditos () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  creditos_optional&
  creditos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  creditos (const creditos_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  creditos (const creditos_optional& x);

  //@}

  /**
   * @name dia1
   *
   * @brief Accessor and modifier functions for the %dia1
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ dia1_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< dia1_type > dia1_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dia1_type, char > dia1_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dia1_optional&
  dia1 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  dia1_optional&
  dia1 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dia1 (const dia1_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  dia1 (const dia1_optional& x);

  //@}

  /**
   * @name dia2
   *
   * @brief Accessor and modifier functions for the %dia2
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ dia2_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< dia2_type > dia2_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dia2_type, char > dia2_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dia2_optional&
  dia2 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  dia2_optional&
  dia2 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dia2 (const dia2_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  dia2 (const dia2_optional& x);

  //@}

  /**
   * @name dia3
   *
   * @brief Accessor and modifier functions for the %dia3
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ dia3_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< dia3_type > dia3_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dia3_type, char > dia3_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dia3_optional&
  dia3 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  dia3_optional&
  dia3 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dia3 (const dia3_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  dia3 (const dia3_optional& x);

  //@}

  /**
   * @name dia4
   *
   * @brief Accessor and modifier functions for the %dia4
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ dia4_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< dia4_type > dia4_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dia4_type, char > dia4_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dia4_optional&
  dia4 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  dia4_optional&
  dia4 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dia4 (const dia4_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  dia4 (const dia4_optional& x);

  //@}

  /**
   * @name dia5
   *
   * @brief Accessor and modifier functions for the %dia5
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ dia5_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< dia5_type > dia5_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dia5_type, char > dia5_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dia5_optional&
  dia5 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  dia5_optional&
  dia5 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dia5 (const dia5_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  dia5 (const dia5_optional& x);

  //@}

  /**
   * @name dia6
   *
   * @brief Accessor and modifier functions for the %dia6
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ dia6_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< dia6_type > dia6_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dia6_type, char > dia6_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dia6_optional&
  dia6 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  dia6_optional&
  dia6 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dia6 (const dia6_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  dia6 (const dia6_optional& x);

  //@}

  /**
   * @name dia7
   *
   * @brief Accessor and modifier functions for the %dia7
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ dia7_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< dia7_type > dia7_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dia7_type, char > dia7_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const dia7_optional&
  dia7 () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  dia7_optional&
  dia7 ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dia7 (const dia7_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  dia7 (const dia7_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemDivisaoCreditos ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemDivisaoCreditos (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemDivisaoCreditos (const ItemDivisaoCreditos& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemDivisaoCreditos*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemDivisaoCreditos ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  creditos_optional creditos_;
  dia1_optional dia1_;
  dia2_optional dia2_;
  dia3_optional dia3_;
  dia4_optional dia4_;
  dia5_optional dia5_;
  dia6_optional dia6_;
  dia7_optional dia7_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoDivisaoCreditos schema type.
 *
 * @nosubgrouping
 */
class GrupoDivisaoCreditos: public ::xml_schema::type
{
  public:
  /**
   * @name DivisaoCreditos
   *
   * @brief Accessor and modifier functions for the %DivisaoCreditos
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDivisaoCreditos DivisaoCreditos_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< DivisaoCreditos_type > DivisaoCreditos_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef DivisaoCreditos_sequence::iterator DivisaoCreditos_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef DivisaoCreditos_sequence::const_iterator DivisaoCreditos_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DivisaoCreditos_type, char > DivisaoCreditos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const DivisaoCreditos_sequence&
  DivisaoCreditos () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  DivisaoCreditos_sequence&
  DivisaoCreditos ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  DivisaoCreditos (const DivisaoCreditos_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoDivisaoCreditos ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoDivisaoCreditos (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoDivisaoCreditos (const GrupoDivisaoCreditos& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoDivisaoCreditos*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoDivisaoCreditos ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DivisaoCreditos_sequence DivisaoCreditos_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoDeslocamento schema type.
 *
 * @nosubgrouping
 */
class GrupoDeslocamento: public ::xml_schema::type
{
  public:
  /**
   * @name Deslocamento
   *
   * @brief Accessor and modifier functions for the %Deslocamento
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDeslocamento Deslocamento_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Deslocamento_type > Deslocamento_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Deslocamento_sequence::iterator Deslocamento_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Deslocamento_sequence::const_iterator Deslocamento_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Deslocamento_type, char > Deslocamento_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Deslocamento_sequence&
  Deslocamento () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Deslocamento_sequence&
  Deslocamento ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Deslocamento (const Deslocamento_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoDeslocamento ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoDeslocamento (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoDeslocamento (const GrupoDeslocamento& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoDeslocamento*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoDeslocamento ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Deslocamento_sequence Deslocamento_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemDeslocamento schema type.
 *
 * @nosubgrouping
 */
class ItemDeslocamento: public ::xml_schema::type
{
  public:
  /**
   * @name tempo
   *
   * @brief Accessor and modifier functions for the %tempo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ tempo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< tempo_type, char > tempo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const tempo_type&
  tempo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  tempo_type&
  tempo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  tempo (const tempo_type& x);

  //@}

  /**
   * @name unidade
   *
   * @brief Accessor and modifier functions for the %unidade
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemUnidade unidade_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< unidade_type, char > unidade_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const unidade_type&
  unidade () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  unidade_type&
  unidade ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  unidade (const unidade_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  unidade (::std::auto_ptr< unidade_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemDeslocamento (const tempo_type&,
                    const unidade_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemDeslocamento (const tempo_type&,
                    ::std::auto_ptr< unidade_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemDeslocamento (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemDeslocamento (const ItemDeslocamento& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemDeslocamento*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemDeslocamento ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< tempo_type > tempo_;
  ::xsd::cxx::tree::one< unidade_type > unidade_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoUnidade schema type.
 *
 * @nosubgrouping
 */
class GrupoUnidade: public ::xml_schema::type
{
  public:
  /**
   * @name ItemUnidade
   *
   * @brief Accessor and modifier functions for the %ItemUnidade
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemUnidade ItemUnidade_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< ItemUnidade_type > ItemUnidade_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef ItemUnidade_sequence::iterator ItemUnidade_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef ItemUnidade_sequence::const_iterator ItemUnidade_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< ItemUnidade_type, char > ItemUnidade_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const ItemUnidade_sequence&
  ItemUnidade () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  ItemUnidade_sequence&
  ItemUnidade ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  ItemUnidade (const ItemUnidade_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoUnidade ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoUnidade (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoUnidade (const GrupoUnidade& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoUnidade*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoUnidade ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ItemUnidade_sequence ItemUnidade_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemUnidade schema type.
 *
 * @nosubgrouping
 */
class ItemUnidade: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name codigo
   *
   * @brief Accessor and modifier functions for the %codigo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string codigo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< codigo_type, char > codigo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const codigo_type&
  codigo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  codigo_type&
  codigo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  codigo (const codigo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  codigo (::std::auto_ptr< codigo_type > p);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name endereco
   *
   * @brief Accessor and modifier functions for the %endereco
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string endereco_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< endereco_type, char > endereco_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const endereco_type&
  endereco () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  endereco_type&
  endereco ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  endereco (const endereco_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  endereco (::std::auto_ptr< endereco_type > p);

  //@}

  /**
   * @name numMedSalas
   *
   * @brief Accessor and modifier functions for the %numMedSalas
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ numMedSalas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< numMedSalas_type, char > numMedSalas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const numMedSalas_type&
  numMedSalas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  numMedSalas_type&
  numMedSalas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  numMedSalas (const numMedSalas_type& x);

  //@}

  /**
   * @name custoMedCred
   *
   * @brief Accessor and modifier functions for the %custoMedCred
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ custoMedCred_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< custoMedCred_type, char > custoMedCred_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const custoMedCred_type&
  custoMedCred () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  custoMedCred_type&
  custoMedCred ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  custoMedCred (const custoMedCred_type& x);

  //@}

  /**
   * @name salas
   *
   * @brief Accessor and modifier functions for the %salas
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoSala salas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< salas_type, char > salas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const salas_type&
  salas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  salas_type&
  salas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  salas (const salas_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  salas (::std::auto_ptr< salas_type > p);

  //@}

  /**
   * @name horarios
   *
   * @brief Accessor and modifier functions for the %horarios
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoHorarioDisponivel horarios_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horarios_type, char > horarios_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const horarios_type&
  horarios () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  horarios_type&
  horarios ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  horarios (const horarios_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  horarios (::std::auto_ptr< horarios_type > p);

  //@}

  /**
   * @name demanda
   *
   * @brief Accessor and modifier functions for the %demanda
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoDemanda demanda_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< demanda_type > demanda_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef demanda_sequence::iterator demanda_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef demanda_sequence::const_iterator demanda_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< demanda_type, char > demanda_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const demanda_sequence&
  demanda () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  demanda_sequence&
  demanda ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  demanda (const demanda_sequence& s);

  //@}

  /**
   * @name unidadeCurriculo
   *
   * @brief Accessor and modifier functions for the %unidadeCurriculo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoUnidadeCurriculo unidadeCurriculo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< unidadeCurriculo_type, char > unidadeCurriculo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const unidadeCurriculo_type&
  unidadeCurriculo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  unidadeCurriculo_type&
  unidadeCurriculo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  unidadeCurriculo (const unidadeCurriculo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  unidadeCurriculo (::std::auto_ptr< unidadeCurriculo_type > p);

  //@}

  /**
   * @name deslocamentos
   *
   * @brief Accessor and modifier functions for the %deslocamentos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoDeslocamento deslocamentos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< deslocamentos_type, char > deslocamentos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const deslocamentos_type&
  deslocamentos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  deslocamentos_type&
  deslocamentos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  deslocamentos (const deslocamentos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  deslocamentos (::std::auto_ptr< deslocamentos_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemUnidade (const id_type&,
               const codigo_type&,
               const nome_type&,
               const endereco_type&,
               const numMedSalas_type&,
               const custoMedCred_type&,
               const salas_type&,
               const horarios_type&,
               const unidadeCurriculo_type&,
               const deslocamentos_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemUnidade (const id_type&,
               const codigo_type&,
               const nome_type&,
               const endereco_type&,
               const numMedSalas_type&,
               const custoMedCred_type&,
               ::std::auto_ptr< salas_type >&,
               ::std::auto_ptr< horarios_type >&,
               ::std::auto_ptr< unidadeCurriculo_type >&,
               ::std::auto_ptr< deslocamentos_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemUnidade (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemUnidade (const ItemUnidade& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemUnidade*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemUnidade ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< codigo_type > codigo_;
  ::xsd::cxx::tree::one< nome_type > nome_;
  ::xsd::cxx::tree::one< endereco_type > endereco_;
  ::xsd::cxx::tree::one< numMedSalas_type > numMedSalas_;
  ::xsd::cxx::tree::one< custoMedCred_type > custoMedCred_;
  ::xsd::cxx::tree::one< salas_type > salas_;
  ::xsd::cxx::tree::one< horarios_type > horarios_;
  demanda_sequence demanda_;
  ::xsd::cxx::tree::one< unidadeCurriculo_type > unidadeCurriculo_;
  ::xsd::cxx::tree::one< deslocamentos_type > deslocamentos_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemDisciplina schema type.
 *
 * @nosubgrouping
 */
class ItemDisciplina: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name codigo
   *
   * @brief Accessor and modifier functions for the %codigo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string codigo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< codigo_type, char > codigo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const codigo_type&
  codigo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  codigo_type&
  codigo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  codigo (const codigo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  codigo (::std::auto_ptr< codigo_type > p);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name cred_teoricos
   *
   * @brief Accessor and modifier functions for the %cred_teoricos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string cred_teoricos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cred_teoricos_type, char > cred_teoricos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const cred_teoricos_type&
  cred_teoricos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  cred_teoricos_type&
  cred_teoricos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  cred_teoricos (const cred_teoricos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  cred_teoricos (::std::auto_ptr< cred_teoricos_type > p);

  //@}

  /**
   * @name cred_praticos
   *
   * @brief Accessor and modifier functions for the %cred_praticos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string cred_praticos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cred_praticos_type, char > cred_praticos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const cred_praticos_type&
  cred_praticos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  cred_praticos_type&
  cred_praticos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  cred_praticos (const cred_praticos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  cred_praticos (::std::auto_ptr< cred_praticos_type > p);

  //@}

  /**
   * @name laboratorio
   *
   * @brief Accessor and modifier functions for the %laboratorio
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean laboratorio_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< laboratorio_type, char > laboratorio_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const laboratorio_type&
  laboratorio () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  laboratorio_type&
  laboratorio ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  laboratorio (const laboratorio_type& x);

  //@}

  /**
   * @name TipoDisciplina
   *
   * @brief Accessor and modifier functions for the %TipoDisciplina
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTipoDisciplina TipoDisciplina_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< TipoDisciplina_type, char > TipoDisciplina_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const TipoDisciplina_type&
  TipoDisciplina () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  TipoDisciplina_type&
  TipoDisciplina ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  TipoDisciplina (const TipoDisciplina_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  TipoDisciplina (::std::auto_ptr< TipoDisciplina_type > p);

  //@}

  /**
   * @name DivisaoCreditos
   *
   * @brief Accessor and modifier functions for the %DivisaoCreditos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDivisaoCreditos DivisaoCreditos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DivisaoCreditos_type, char > DivisaoCreditos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const DivisaoCreditos_type&
  DivisaoCreditos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  DivisaoCreditos_type&
  DivisaoCreditos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DivisaoCreditos (const DivisaoCreditos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DivisaoCreditos (::std::auto_ptr< DivisaoCreditos_type > p);

  //@}

  /**
   * @name compatibilidades
   *
   * @brief Accessor and modifier functions for the %compatibilidades
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoDisciplina compatibilidades_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< compatibilidades_type, char > compatibilidades_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const compatibilidades_type&
  compatibilidades () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  compatibilidades_type&
  compatibilidades ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  compatibilidades (const compatibilidades_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  compatibilidades (::std::auto_ptr< compatibilidades_type > p);

  //@}

  /**
   * @name equivalencia
   *
   * @brief Accessor and modifier functions for the %equivalencia
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoDisciplina equivalencia_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< equivalencia_type, char > equivalencia_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const equivalencia_type&
  equivalencia () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  equivalencia_type&
  equivalencia ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  equivalencia (const equivalencia_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  equivalencia (::std::auto_ptr< equivalencia_type > p);

  //@}

  /**
   * @name horarios
   *
   * @brief Accessor and modifier functions for the %horarios
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoHorarioDisponivel horarios_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horarios_type, char > horarios_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const horarios_type&
  horarios () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  horarios_type&
  horarios ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  horarios (const horarios_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  horarios (::std::auto_ptr< horarios_type > p);

  //@}

  /**
   * @name salas
   *
   * @brief Accessor and modifier functions for the %salas
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoSala salas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< salas_type, char > salas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const salas_type&
  salas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  salas_type&
  salas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  salas (const salas_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  salas (::std::auto_ptr< salas_type > p);

  //@}

  /**
   * @name divisaoDeCreditos
   *
   * @brief Accessor and modifier functions for the %divisaoDeCreditos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDivisaoCreditos divisaoDeCreditos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< divisaoDeCreditos_type, char > divisaoDeCreditos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const divisaoDeCreditos_type&
  divisaoDeCreditos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  divisaoDeCreditos_type&
  divisaoDeCreditos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  divisaoDeCreditos (const divisaoDeCreditos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  divisaoDeCreditos (::std::auto_ptr< divisaoDeCreditos_type > p);

  //@}

  /**
   * @name turmas
   *
   * @brief Accessor and modifier functions for the %turmas
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoTurma turmas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< turmas_type, char > turmas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const turmas_type&
  turmas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  turmas_type&
  turmas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  turmas (const turmas_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  turmas (::std::auto_ptr< turmas_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemDisciplina (const id_type&,
                  const codigo_type&,
                  const nome_type&,
                  const cred_teoricos_type&,
                  const cred_praticos_type&,
                  const laboratorio_type&,
                  const TipoDisciplina_type&,
                  const DivisaoCreditos_type&,
                  const compatibilidades_type&,
                  const equivalencia_type&,
                  const horarios_type&,
                  const salas_type&,
                  const divisaoDeCreditos_type&,
                  const turmas_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemDisciplina (const id_type&,
                  const codigo_type&,
                  const nome_type&,
                  const cred_teoricos_type&,
                  const cred_praticos_type&,
                  const laboratorio_type&,
                  ::std::auto_ptr< TipoDisciplina_type >&,
                  ::std::auto_ptr< DivisaoCreditos_type >&,
                  ::std::auto_ptr< compatibilidades_type >&,
                  ::std::auto_ptr< equivalencia_type >&,
                  ::std::auto_ptr< horarios_type >&,
                  ::std::auto_ptr< salas_type >&,
                  ::std::auto_ptr< divisaoDeCreditos_type >&,
                  ::std::auto_ptr< turmas_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemDisciplina (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemDisciplina (const ItemDisciplina& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemDisciplina*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemDisciplina ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< codigo_type > codigo_;
  ::xsd::cxx::tree::one< nome_type > nome_;
  ::xsd::cxx::tree::one< cred_teoricos_type > cred_teoricos_;
  ::xsd::cxx::tree::one< cred_praticos_type > cred_praticos_;
  ::xsd::cxx::tree::one< laboratorio_type > laboratorio_;
  ::xsd::cxx::tree::one< TipoDisciplina_type > TipoDisciplina_;
  ::xsd::cxx::tree::one< DivisaoCreditos_type > DivisaoCreditos_;
  ::xsd::cxx::tree::one< compatibilidades_type > compatibilidades_;
  ::xsd::cxx::tree::one< equivalencia_type > equivalencia_;
  ::xsd::cxx::tree::one< horarios_type > horarios_;
  ::xsd::cxx::tree::one< salas_type > salas_;
  ::xsd::cxx::tree::one< divisaoDeCreditos_type > divisaoDeCreditos_;
  ::xsd::cxx::tree::one< turmas_type > turmas_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoDisciplina schema type.
 *
 * @nosubgrouping
 */
class GrupoDisciplina: public ::xml_schema::type
{
  public:
  /**
   * @name Disciplina
   *
   * @brief Accessor and modifier functions for the %Disciplina
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDisciplina Disciplina_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Disciplina_type > Disciplina_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Disciplina_sequence::iterator Disciplina_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Disciplina_sequence::const_iterator Disciplina_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Disciplina_type, char > Disciplina_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Disciplina_sequence&
  Disciplina () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Disciplina_sequence&
  Disciplina ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Disciplina (const Disciplina_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoDisciplina ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoDisciplina (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoDisciplina (const GrupoDisciplina& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoDisciplina*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoDisciplina ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Disciplina_sequence Disciplina_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemCalendario schema type.
 *
 * @nosubgrouping
 */
class ItemCalendario: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const id_optional&
  id () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  id_optional&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  id (const id_optional& x);

  //@}

  /**
   * @name turnos
   *
   * @brief Accessor and modifier functions for the %turnos
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoTurno turnos_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< turnos_type > turnos_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< turnos_type, char > turnos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const turnos_optional&
  turnos () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  turnos_optional&
  turnos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  turnos (const turnos_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  turnos (const turnos_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  turnos (::std::auto_ptr< turnos_type > p);

  //@}

  /**
   * @name codigo
   *
   * @brief Accessor and modifier functions for the %codigo
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string codigo_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< codigo_type > codigo_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< codigo_type, char > codigo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const codigo_optional&
  codigo () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  codigo_optional&
  codigo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  codigo (const codigo_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  codigo (const codigo_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  codigo (::std::auto_ptr< codigo_type > p);

  //@}

  /**
   * @name descricao
   *
   * @brief Accessor and modifier functions for the %descricao
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string descricao_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< descricao_type > descricao_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< descricao_type, char > descricao_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const descricao_optional&
  descricao () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  descricao_optional&
  descricao ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  descricao (const descricao_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  descricao (const descricao_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  descricao (::std::auto_ptr< descricao_type > p);

  //@}

  /**
   * @name tempoAula
   *
   * @brief Accessor and modifier functions for the %tempoAula
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ tempoAula_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< tempoAula_type > tempoAula_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< tempoAula_type, char > tempoAula_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tempoAula_optional&
  tempoAula () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tempoAula_optional&
  tempoAula ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  tempoAula (const tempoAula_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  tempoAula (const tempoAula_optional& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemCalendario ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemCalendario (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemCalendario (const ItemCalendario& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemCalendario*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemCalendario ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  turnos_optional turnos_;
  codigo_optional codigo_;
  descricao_optional descricao_;
  tempoAula_optional tempoAula_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemHorarioDisponivel schema type.
 *
 * @nosubgrouping
 */
class ItemHorarioDisponivel: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const id_optional&
  id () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  id_optional&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  id (const id_optional& x);

  //@}

  /**
   * @name semana
   *
   * @brief Accessor and modifier functions for the %semana
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ semana_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< semana_type > semana_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< semana_type, char > semana_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const semana_optional&
  semana () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  semana_optional&
  semana ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  semana (const semana_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  semana (const semana_optional& x);

  //@}

  /**
   * @name horarioAula
   *
   * @brief Accessor and modifier functions for the %horarioAula
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemHorarioAula horarioAula_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< horarioAula_type > horarioAula_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horarioAula_type, char > horarioAula_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const horarioAula_optional&
  horarioAula () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  horarioAula_optional&
  horarioAula ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  horarioAula (const horarioAula_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  horarioAula (const horarioAula_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  horarioAula (::std::auto_ptr< horarioAula_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemHorarioDisponivel ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemHorarioDisponivel (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemHorarioDisponivel (const ItemHorarioDisponivel& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemHorarioDisponivel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemHorarioDisponivel ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  semana_optional semana_;
  horarioAula_optional horarioAula_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoHorarioDisponivel schema type.
 *
 * @nosubgrouping
 */
class GrupoHorarioDisponivel: public ::xml_schema::type
{
  public:
  /**
   * @name horarioDisponivel
   *
   * @brief Accessor and modifier functions for the %horarioDisponivel
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemHorarioDisponivel horarioDisponivel_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< horarioDisponivel_type > horarioDisponivel_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef horarioDisponivel_sequence::iterator horarioDisponivel_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef horarioDisponivel_sequence::const_iterator horarioDisponivel_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horarioDisponivel_type, char > horarioDisponivel_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const horarioDisponivel_sequence&
  horarioDisponivel () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  horarioDisponivel_sequence&
  horarioDisponivel ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  horarioDisponivel (const horarioDisponivel_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoHorarioDisponivel ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoHorarioDisponivel (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoHorarioDisponivel (const GrupoHorarioDisponivel& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoHorarioDisponivel*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoHorarioDisponivel ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  horarioDisponivel_sequence horarioDisponivel_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemHorarioAula schema type.
 *
 * @nosubgrouping
 */
class ItemHorarioAula: public ::xml_schema::type
{
  public:
  /**
   * @name horariosDisponiveis
   *
   * @brief Accessor and modifier functions for the %horariosDisponiveis
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoHorarioDisponivel horariosDisponiveis_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horariosDisponiveis_type, char > horariosDisponiveis_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const horariosDisponiveis_type&
  horariosDisponiveis () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  horariosDisponiveis_type&
  horariosDisponiveis ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  horariosDisponiveis (const horariosDisponiveis_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  horariosDisponiveis (::std::auto_ptr< horariosDisponiveis_type > p);

  //@}

  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name inicio
   *
   * @brief Accessor and modifier functions for the %inicio
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::time inicio_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< inicio_type, char > inicio_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const inicio_type&
  inicio () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  inicio_type&
  inicio ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  inicio (const inicio_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  inicio (::std::auto_ptr< inicio_type > p);

  //@}

  /**
   * @name Turno
   *
   * @brief Accessor and modifier functions for the %Turno
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTurno Turno_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Turno_type, char > Turno_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Turno_type&
  Turno () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Turno_type&
  Turno ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Turno (const Turno_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Turno (::std::auto_ptr< Turno_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemHorarioAula (const horariosDisponiveis_type&,
                   const id_type&,
                   const inicio_type&,
                   const Turno_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemHorarioAula (::std::auto_ptr< horariosDisponiveis_type >&,
                   const id_type&,
                   const inicio_type&,
                   ::std::auto_ptr< Turno_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemHorarioAula (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemHorarioAula (const ItemHorarioAula& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemHorarioAula*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemHorarioAula ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< horariosDisponiveis_type > horariosDisponiveis_;
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< inicio_type > inicio_;
  ::xsd::cxx::tree::one< Turno_type > Turno_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoHorarioAula schema type.
 *
 * @nosubgrouping
 */
class GrupoHorarioAula: public ::xml_schema::type
{
  public:
  /**
   * @name HorarioAula
   *
   * @brief Accessor and modifier functions for the %HorarioAula
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemHorarioAula HorarioAula_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< HorarioAula_type > HorarioAula_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef HorarioAula_sequence::iterator HorarioAula_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef HorarioAula_sequence::const_iterator HorarioAula_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< HorarioAula_type, char > HorarioAula_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const HorarioAula_sequence&
  HorarioAula () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  HorarioAula_sequence&
  HorarioAula ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  HorarioAula (const HorarioAula_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoHorarioAula ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoHorarioAula (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoHorarioAula (const GrupoHorarioAula& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoHorarioAula*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoHorarioAula ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  HorarioAula_sequence HorarioAula_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemTurno schema type.
 *
 * @nosubgrouping
 */
class ItemTurno: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name HorariosAula
   *
   * @brief Accessor and modifier functions for the %HorariosAula
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoHorarioAula HorariosAula_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< HorariosAula_type, char > HorariosAula_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const HorariosAula_type&
  HorariosAula () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  HorariosAula_type&
  HorariosAula ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  HorariosAula (const HorariosAula_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  HorariosAula (::std::auto_ptr< HorariosAula_type > p);

  //@}

  /**
   * @name Calendario
   *
   * @brief Accessor and modifier functions for the %Calendario
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemCalendario Calendario_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Calendario_type, char > Calendario_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Calendario_type&
  Calendario () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Calendario_type&
  Calendario ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Calendario (const Calendario_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Calendario (::std::auto_ptr< Calendario_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemTurno (const id_type&,
             const nome_type&,
             const HorariosAula_type&,
             const Calendario_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemTurno (const id_type&,
             const nome_type&,
             ::std::auto_ptr< HorariosAula_type >&,
             ::std::auto_ptr< Calendario_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemTurno (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemTurno (const ItemTurno& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemTurno*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemTurno ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< nome_type > nome_;
  ::xsd::cxx::tree::one< HorariosAula_type > HorariosAula_;
  ::xsd::cxx::tree::one< Calendario_type > Calendario_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoTurno schema type.
 *
 * @nosubgrouping
 */
class GrupoTurno: public ::xml_schema::type
{
  public:
  /**
   * @name Turno
   *
   * @brief Accessor and modifier functions for the %Turno
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTurno Turno_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< Turno_type > Turno_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef Turno_sequence::iterator Turno_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef Turno_sequence::const_iterator Turno_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Turno_type, char > Turno_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const Turno_sequence&
  Turno () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  Turno_sequence&
  Turno ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  Turno (const Turno_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoTurno ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoTurno (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoTurno (const GrupoTurno& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoTurno*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoTurno ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Turno_sequence Turno_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemSala schema type.
 *
 * @nosubgrouping
 */
class ItemSala: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name tipoSala
   *
   * @brief Accessor and modifier functions for the %tipoSala
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTipoSala tipoSala_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< tipoSala_type, char > tipoSala_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const tipoSala_type&
  tipoSala () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  tipoSala_type&
  tipoSala ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  tipoSala (const tipoSala_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  tipoSala (::std::auto_ptr< tipoSala_type > p);

  //@}

  /**
   * @name HorariosDisponiveis
   *
   * @brief Accessor and modifier functions for the %HorariosDisponiveis
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoHorarioDisponivel HorariosDisponiveis_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< HorariosDisponiveis_type, char > HorariosDisponiveis_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const HorariosDisponiveis_type&
  HorariosDisponiveis () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  HorariosDisponiveis_type&
  HorariosDisponiveis ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  HorariosDisponiveis (const HorariosDisponiveis_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  HorariosDisponiveis (::std::auto_ptr< HorariosDisponiveis_type > p);

  //@}

  /**
   * @name codigo
   *
   * @brief Accessor and modifier functions for the %codigo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string codigo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< codigo_type, char > codigo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const codigo_type&
  codigo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  codigo_type&
  codigo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  codigo (const codigo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  codigo (::std::auto_ptr< codigo_type > p);

  //@}

  /**
   * @name numSalas
   *
   * @brief Accessor and modifier functions for the %numSalas
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ numSalas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< numSalas_type, char > numSalas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const numSalas_type&
  numSalas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  numSalas_type&
  numSalas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  numSalas (const numSalas_type& x);

  //@}

  /**
   * @name andar
   *
   * @brief Accessor and modifier functions for the %andar
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string andar_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< andar_type, char > andar_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const andar_type&
  andar () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  andar_type&
  andar ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  andar (const andar_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  andar (::std::auto_ptr< andar_type > p);

  //@}

  /**
   * @name capacidade
   *
   * @brief Accessor and modifier functions for the %capacidade
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ capacidade_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< capacidade_type, char > capacidade_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const capacidade_type&
  capacidade () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  capacidade_type&
  capacidade ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  capacidade (const capacidade_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemSala (const id_type&,
            const tipoSala_type&,
            const HorariosDisponiveis_type&,
            const codigo_type&,
            const numSalas_type&,
            const andar_type&,
            const capacidade_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemSala (const id_type&,
            ::std::auto_ptr< tipoSala_type >&,
            ::std::auto_ptr< HorariosDisponiveis_type >&,
            const codigo_type&,
            const numSalas_type&,
            const andar_type&,
            const capacidade_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemSala (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemSala (const ItemSala& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemSala*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemSala ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< tipoSala_type > tipoSala_;
  ::xsd::cxx::tree::one< HorariosDisponiveis_type > HorariosDisponiveis_;
  ::xsd::cxx::tree::one< codigo_type > codigo_;
  ::xsd::cxx::tree::one< numSalas_type > numSalas_;
  ::xsd::cxx::tree::one< andar_type > andar_;
  ::xsd::cxx::tree::one< capacidade_type > capacidade_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemDisciplinaPeriodo schema type.
 *
 * @nosubgrouping
 */
class ItemDisciplinaPeriodo: public ::xml_schema::type
{
  public:
  /**
   * @name periodo
   *
   * @brief Accessor and modifier functions for the %periodo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ periodo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< periodo_type, char > periodo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const periodo_type&
  periodo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  periodo_type&
  periodo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  periodo (const periodo_type& x);

  //@}

  /**
   * @name disciplina
   *
   * @brief Accessor and modifier functions for the %disciplina
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDisciplina disciplina_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< disciplina_type, char > disciplina_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const disciplina_type&
  disciplina () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  disciplina_type&
  disciplina ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  disciplina (const disciplina_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  disciplina (::std::auto_ptr< disciplina_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemDisciplinaPeriodo (const periodo_type&,
                         const disciplina_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemDisciplinaPeriodo (const periodo_type&,
                         ::std::auto_ptr< disciplina_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemDisciplinaPeriodo (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemDisciplinaPeriodo (const ItemDisciplinaPeriodo& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemDisciplinaPeriodo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemDisciplinaPeriodo ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< periodo_type > periodo_;
  ::xsd::cxx::tree::one< disciplina_type > disciplina_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemCurriculo schema type.
 *
 * @nosubgrouping
 */
class ItemCurriculo: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name codigo
   *
   * @brief Accessor and modifier functions for the %codigo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string codigo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< codigo_type, char > codigo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const codigo_type&
  codigo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  codigo_type&
  codigo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  codigo (const codigo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  codigo (::std::auto_ptr< codigo_type > p);

  //@}

  /**
   * @name descricao
   *
   * @brief Accessor and modifier functions for the %descricao
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string descricao_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< descricao_type, char > descricao_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const descricao_type&
  descricao () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  descricao_type&
  descricao ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  descricao (const descricao_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  descricao (::std::auto_ptr< descricao_type > p);

  //@}

  /**
   * @name DisciplinaPeriodo
   *
   * @brief Accessor and modifier functions for the %DisciplinaPeriodo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDisciplinaPeriodo DisciplinaPeriodo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< DisciplinaPeriodo_type, char > DisciplinaPeriodo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const DisciplinaPeriodo_type&
  DisciplinaPeriodo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  DisciplinaPeriodo_type&
  DisciplinaPeriodo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  DisciplinaPeriodo (const DisciplinaPeriodo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  DisciplinaPeriodo (::std::auto_ptr< DisciplinaPeriodo_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemCurriculo (const id_type&,
                 const codigo_type&,
                 const descricao_type&,
                 const DisciplinaPeriodo_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemCurriculo (const id_type&,
                 const codigo_type&,
                 const descricao_type&,
                 ::std::auto_ptr< DisciplinaPeriodo_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemCurriculo (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemCurriculo (const ItemCurriculo& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemCurriculo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemCurriculo ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< codigo_type > codigo_;
  ::xsd::cxx::tree::one< descricao_type > descricao_;
  ::xsd::cxx::tree::one< DisciplinaPeriodo_type > DisciplinaPeriodo_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoCurriculo schema type.
 *
 * @nosubgrouping
 */
class GrupoCurriculo: public ::xml_schema::type
{
  public:
  /**
   * @name curriculo
   *
   * @brief Accessor and modifier functions for the %curriculo
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemCurriculo curriculo_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< curriculo_type > curriculo_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef curriculo_sequence::iterator curriculo_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef curriculo_sequence::const_iterator curriculo_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< curriculo_type, char > curriculo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const curriculo_sequence&
  curriculo () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  curriculo_sequence&
  curriculo ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  curriculo (const curriculo_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoCurriculo ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoCurriculo (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoCurriculo (const GrupoCurriculo& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoCurriculo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoCurriculo ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  curriculo_sequence curriculo_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoSala schema type.
 *
 * @nosubgrouping
 */
class GrupoSala: public ::xml_schema::type
{
  public:
  /**
   * @name sala
   *
   * @brief Accessor and modifier functions for the %sala
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemSala sala_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< sala_type > sala_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sala_sequence::iterator sala_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sala_sequence::const_iterator sala_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sala_type, char > sala_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sala_sequence&
  sala () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sala_sequence&
  sala ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  sala (const sala_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoSala ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoSala (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoSala (const GrupoSala& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoSala*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoSala ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  sala_sequence sala_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemCurso schema type.
 *
 * @nosubgrouping
 */
class ItemCurso: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name codigo
   *
   * @brief Accessor and modifier functions for the %codigo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string codigo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< codigo_type, char > codigo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const codigo_type&
  codigo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  codigo_type&
  codigo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  codigo (const codigo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  codigo (::std::auto_ptr< codigo_type > p);

  //@}

  /**
   * @name tipo
   *
   * @brief Accessor and modifier functions for the %tipo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTipoCurso tipo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< tipo_type, char > tipo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const tipo_type&
  tipo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  tipo_type&
  tipo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  tipo (const tipo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  tipo (::std::auto_ptr< tipo_type > p);

  //@}

  /**
   * @name numPeriodos
   *
   * @brief Accessor and modifier functions for the %numPeriodos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ numPeriodos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< numPeriodos_type, char > numPeriodos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const numPeriodos_type&
  numPeriodos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  numPeriodos_type&
  numPeriodos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  numPeriodos (const numPeriodos_type& x);

  //@}

  /**
   * @name qtdMinDoutores
   *
   * @brief Accessor and modifier functions for the %qtdMinDoutores
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ qtdMinDoutores_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< qtdMinDoutores_type, char > qtdMinDoutores_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const qtdMinDoutores_type&
  qtdMinDoutores () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  qtdMinDoutores_type&
  qtdMinDoutores ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  qtdMinDoutores (const qtdMinDoutores_type& x);

  //@}

  /**
   * @name qtdMinMestres
   *
   * @brief Accessor and modifier functions for the %qtdMinMestres
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ qtdMinMestres_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< qtdMinMestres_type, char > qtdMinMestres_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const qtdMinMestres_type&
  qtdMinMestres () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  qtdMinMestres_type&
  qtdMinMestres ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  qtdMinMestres (const qtdMinMestres_type& x);

  //@}

  /**
   * @name qtdMaxProfDisc
   *
   * @brief Accessor and modifier functions for the %qtdMaxProfDisc
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ qtdMaxProfDisc_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< qtdMaxProfDisc_type, char > qtdMaxProfDisc_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const qtdMaxProfDisc_type&
  qtdMaxProfDisc () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  qtdMaxProfDisc_type&
  qtdMaxProfDisc ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  qtdMaxProfDisc (const qtdMaxProfDisc_type& x);

  //@}

  /**
   * @name areaTitulacao
   *
   * @brief Accessor and modifier functions for the %areaTitulacao
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAreaTitulacao areaTitulacao_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< areaTitulacao_type, char > areaTitulacao_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const areaTitulacao_type&
  areaTitulacao () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  areaTitulacao_type&
  areaTitulacao ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  areaTitulacao (const areaTitulacao_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  areaTitulacao (::std::auto_ptr< areaTitulacao_type > p);

  //@}

  /**
   * @name Curriculos
   *
   * @brief Accessor and modifier functions for the %Curriculos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoCurriculo Curriculos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Curriculos_type, char > Curriculos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Curriculos_type&
  Curriculos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Curriculos_type&
  Curriculos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Curriculos (const Curriculos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  Curriculos (::std::auto_ptr< Curriculos_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemCurso (const id_type&,
             const codigo_type&,
             const tipo_type&,
             const numPeriodos_type&,
             const qtdMinDoutores_type&,
             const qtdMinMestres_type&,
             const qtdMaxProfDisc_type&,
             const areaTitulacao_type&,
             const Curriculos_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemCurso (const id_type&,
             const codigo_type&,
             ::std::auto_ptr< tipo_type >&,
             const numPeriodos_type&,
             const qtdMinDoutores_type&,
             const qtdMinMestres_type&,
             const qtdMaxProfDisc_type&,
             ::std::auto_ptr< areaTitulacao_type >&,
             ::std::auto_ptr< Curriculos_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemCurso (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemCurso (const ItemCurso& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemCurso*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemCurso ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< codigo_type > codigo_;
  ::xsd::cxx::tree::one< tipo_type > tipo_;
  ::xsd::cxx::tree::one< numPeriodos_type > numPeriodos_;
  ::xsd::cxx::tree::one< qtdMinDoutores_type > qtdMinDoutores_;
  ::xsd::cxx::tree::one< qtdMinMestres_type > qtdMinMestres_;
  ::xsd::cxx::tree::one< qtdMaxProfDisc_type > qtdMaxProfDisc_;
  ::xsd::cxx::tree::one< areaTitulacao_type > areaTitulacao_;
  ::xsd::cxx::tree::one< Curriculos_type > Curriculos_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoCurso schema type.
 *
 * @nosubgrouping
 */
class GrupoCurso: public ::xml_schema::type
{
  public:
  /**
   * @name curso
   *
   * @brief Accessor and modifier functions for the %curso
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemCurso curso_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< curso_type > curso_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef curso_sequence::iterator curso_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef curso_sequence::const_iterator curso_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< curso_type, char > curso_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const curso_sequence&
  curso () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  curso_sequence&
  curso ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  curso (const curso_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoCurso ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoCurso (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoCurso (const GrupoCurso& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoCurso*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoCurso ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  curso_sequence curso_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemDemanda schema type.
 *
 * @nosubgrouping
 */
class ItemDemanda: public ::xml_schema::type
{
  public:
  /**
   * @name quantidade
   *
   * @brief Accessor and modifier functions for the %quantidade
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ quantidade_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< quantidade_type, char > quantidade_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const quantidade_type&
  quantidade () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  quantidade_type&
  quantidade ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  quantidade (const quantidade_type& x);

  //@}

  /**
   * @name turno
   *
   * @brief Accessor and modifier functions for the %turno
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTurno turno_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< turno_type, char > turno_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const turno_type&
  turno () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  turno_type&
  turno ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  turno (const turno_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  turno (::std::auto_ptr< turno_type > p);

  //@}

  /**
   * @name disciplina
   *
   * @brief Accessor and modifier functions for the %disciplina
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDisciplina disciplina_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< disciplina_type, char > disciplina_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const disciplina_type&
  disciplina () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  disciplina_type&
  disciplina ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  disciplina (const disciplina_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  disciplina (::std::auto_ptr< disciplina_type > p);

  //@}

  /**
   * @name curso
   *
   * @brief Accessor and modifier functions for the %curso
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemCurso curso_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< curso_type, char > curso_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const curso_type&
  curso () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  curso_type&
  curso ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  curso (const curso_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  curso (::std::auto_ptr< curso_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemDemanda (const quantidade_type&,
               const turno_type&,
               const disciplina_type&,
               const curso_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemDemanda (const quantidade_type&,
               ::std::auto_ptr< turno_type >&,
               ::std::auto_ptr< disciplina_type >&,
               ::std::auto_ptr< curso_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemDemanda (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemDemanda (const ItemDemanda& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemDemanda*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemDemanda ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< quantidade_type > quantidade_;
  ::xsd::cxx::tree::one< turno_type > turno_;
  ::xsd::cxx::tree::one< disciplina_type > disciplina_;
  ::xsd::cxx::tree::one< curso_type > curso_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoDemanda schema type.
 *
 * @nosubgrouping
 */
class GrupoDemanda: public ::xml_schema::type
{
  public:
  /**
   * @name demanda
   *
   * @brief Accessor and modifier functions for the %demanda
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDemanda demanda_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< demanda_type > demanda_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef demanda_sequence::iterator demanda_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef demanda_sequence::const_iterator demanda_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< demanda_type, char > demanda_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const demanda_sequence&
  demanda () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  demanda_sequence&
  demanda ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  demanda (const demanda_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoDemanda ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoDemanda (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoDemanda (const GrupoDemanda& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoDemanda*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoDemanda ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  demanda_sequence demanda_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemUnidadeCurriculo schema type.
 *
 * @nosubgrouping
 */
class ItemUnidadeCurriculo: public ::xml_schema::type
{
  public:
  /**
   * @name turno
   *
   * @brief Accessor and modifier functions for the %turno
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTurno turno_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< turno_type, char > turno_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const turno_type&
  turno () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  turno_type&
  turno ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  turno (const turno_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  turno (::std::auto_ptr< turno_type > p);

  //@}

  /**
   * @name curriculo
   *
   * @brief Accessor and modifier functions for the %curriculo
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemCurriculo curriculo_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< curriculo_type, char > curriculo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const curriculo_type&
  curriculo () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  curriculo_type&
  curriculo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  curriculo (const curriculo_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  curriculo (::std::auto_ptr< curriculo_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemUnidadeCurriculo (const turno_type&,
                        const curriculo_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemUnidadeCurriculo (::std::auto_ptr< turno_type >&,
                        ::std::auto_ptr< curriculo_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemUnidadeCurriculo (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemUnidadeCurriculo (const ItemUnidadeCurriculo& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemUnidadeCurriculo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemUnidadeCurriculo ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< turno_type > turno_;
  ::xsd::cxx::tree::one< curriculo_type > curriculo_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoUnidadeCurriculo schema type.
 *
 * @nosubgrouping
 */
class GrupoUnidadeCurriculo: public ::xml_schema::type
{
  public:
  /**
   * @name unidadeCurriculo
   *
   * @brief Accessor and modifier functions for the %unidadeCurriculo
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::unidadeCurriculo unidadeCurriculo_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< unidadeCurriculo_type > unidadeCurriculo_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef unidadeCurriculo_sequence::iterator unidadeCurriculo_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef unidadeCurriculo_sequence::const_iterator unidadeCurriculo_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< unidadeCurriculo_type, char > unidadeCurriculo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const unidadeCurriculo_sequence&
  unidadeCurriculo () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  unidadeCurriculo_sequence&
  unidadeCurriculo ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  unidadeCurriculo (const unidadeCurriculo_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoUnidadeCurriculo ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoUnidadeCurriculo (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoUnidadeCurriculo (const GrupoUnidadeCurriculo& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoUnidadeCurriculo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoUnidadeCurriculo ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  unidadeCurriculo_sequence unidadeCurriculo_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAlocacao schema type.
 *
 * @nosubgrouping
 */
class ItemAlocacao: public ::xml_schema::type
{
  public:
  /**
   * @name professor
   *
   * @brief Accessor and modifier functions for the %professor
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemProfessor professor_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< professor_type, char > professor_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const professor_type&
  professor () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  professor_type&
  professor ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  professor (const professor_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  professor (::std::auto_ptr< professor_type > p);

  //@}

  /**
   * @name horario
   *
   * @brief Accessor and modifier functions for the %horario
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemHorarioDisponivel horario_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< horario_type, char > horario_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const horario_type&
  horario () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  horario_type&
  horario ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  horario (const horario_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  horario (::std::auto_ptr< horario_type > p);

  //@}

  /**
   * @name oferecimento
   *
   * @brief Accessor and modifier functions for the %oferecimento
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemOferecimento oferecimento_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< oferecimento_type, char > oferecimento_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const oferecimento_type&
  oferecimento () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  oferecimento_type&
  oferecimento ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  oferecimento (const oferecimento_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  oferecimento (::std::auto_ptr< oferecimento_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAlocacao (const professor_type&,
                const horario_type&,
                const oferecimento_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemAlocacao (::std::auto_ptr< professor_type >&,
                ::std::auto_ptr< horario_type >&,
                ::std::auto_ptr< oferecimento_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAlocacao (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAlocacao (const ItemAlocacao& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAlocacao*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAlocacao ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< professor_type > professor_;
  ::xsd::cxx::tree::one< horario_type > horario_;
  ::xsd::cxx::tree::one< oferecimento_type > oferecimento_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemOferecimento schema type.
 *
 * @nosubgrouping
 */
class ItemOferecimento: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name sala
   *
   * @brief Accessor and modifier functions for the %sala
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemSala sala_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sala_type, char > sala_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const sala_type&
  sala () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  sala_type&
  sala ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sala (const sala_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  sala (::std::auto_ptr< sala_type > p);

  //@}

  /**
   * @name semana
   *
   * @brief Accessor and modifier functions for the %semana
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ semana_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< semana_type, char > semana_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const semana_type&
  semana () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  semana_type&
  semana ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  semana (const semana_type& x);

  //@}

  /**
   * @name creditos
   *
   * @brief Accessor and modifier functions for the %creditos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ creditos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< creditos_type, char > creditos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const creditos_type&
  creditos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  creditos_type&
  creditos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  creditos (const creditos_type& x);

  //@}

  /**
   * @name turma
   *
   * @brief Accessor and modifier functions for the %turma
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTurma turma_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< turma_type, char > turma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const turma_type&
  turma () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  turma_type&
  turma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  turma (const turma_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  turma (::std::auto_ptr< turma_type > p);

  //@}

  /**
   * @name alocacao
   *
   * @brief Accessor and modifier functions for the %alocacao
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemAlocacao alocacao_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< alocacao_type, char > alocacao_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const alocacao_type&
  alocacao () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  alocacao_type&
  alocacao ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  alocacao (const alocacao_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  alocacao (::std::auto_ptr< alocacao_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemOferecimento (const id_type&,
                    const sala_type&,
                    const semana_type&,
                    const creditos_type&,
                    const turma_type&,
                    const alocacao_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemOferecimento (const id_type&,
                    ::std::auto_ptr< sala_type >&,
                    const semana_type&,
                    const creditos_type&,
                    ::std::auto_ptr< turma_type >&,
                    ::std::auto_ptr< alocacao_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemOferecimento (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemOferecimento (const ItemOferecimento& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemOferecimento*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemOferecimento ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< sala_type > sala_;
  ::xsd::cxx::tree::one< semana_type > semana_;
  ::xsd::cxx::tree::one< creditos_type > creditos_;
  ::xsd::cxx::tree::one< turma_type > turma_;
  ::xsd::cxx::tree::one< alocacao_type > alocacao_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoOferecimento schema type.
 *
 * @nosubgrouping
 */
class GrupoOferecimento: public ::xml_schema::type
{
  public:
  /**
   * @name oferecimento
   *
   * @brief Accessor and modifier functions for the %oferecimento
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemOferecimento oferecimento_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< oferecimento_type > oferecimento_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef oferecimento_sequence::iterator oferecimento_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef oferecimento_sequence::const_iterator oferecimento_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< oferecimento_type, char > oferecimento_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const oferecimento_sequence&
  oferecimento () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  oferecimento_sequence&
  oferecimento ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  oferecimento (const oferecimento_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoOferecimento ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoOferecimento (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoOferecimento (const GrupoOferecimento& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoOferecimento*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoOferecimento ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  oferecimento_sequence oferecimento_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemTurma schema type.
 *
 * @nosubgrouping
 */
class ItemTurma: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name disciplina
   *
   * @brief Accessor and modifier functions for the %disciplina
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemDisciplina disciplina_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< disciplina_type, char > disciplina_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const disciplina_type&
  disciplina () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  disciplina_type&
  disciplina ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  disciplina (const disciplina_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  disciplina (::std::auto_ptr< disciplina_type > p);

  //@}

  /**
   * @name oferecimentos
   *
   * @brief Accessor and modifier functions for the %oferecimentos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoOferecimento oferecimentos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< oferecimentos_type, char > oferecimentos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const oferecimentos_type&
  oferecimentos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  oferecimentos_type&
  oferecimentos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  oferecimentos (const oferecimentos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  oferecimentos (::std::auto_ptr< oferecimentos_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemTurma (const id_type&,
             const nome_type&,
             const disciplina_type&,
             const oferecimentos_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  ItemTurma (const id_type&,
             const nome_type&,
             ::std::auto_ptr< disciplina_type >&,
             ::std::auto_ptr< oferecimentos_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemTurma (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemTurma (const ItemTurma& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemTurma*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemTurma ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< nome_type > nome_;
  ::xsd::cxx::tree::one< disciplina_type > disciplina_;
  ::xsd::cxx::tree::one< oferecimentos_type > oferecimentos_;

  //@endcond
};

/**
 * @brief Class corresponding to the %GrupoTurma schema type.
 *
 * @nosubgrouping
 */
class GrupoTurma: public ::xml_schema::type
{
  public:
  /**
   * @name turma
   *
   * @brief Accessor and modifier functions for the %turma
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemTurma turma_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< turma_type > turma_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef turma_sequence::iterator turma_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef turma_sequence::const_iterator turma_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< turma_type, char > turma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const turma_sequence&
  turma () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  turma_sequence&
  turma ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  turma (const turma_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  GrupoTurma ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  GrupoTurma (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  GrupoTurma (const GrupoTurma& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual GrupoTurma*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~GrupoTurma ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  turma_sequence turma_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemTipoSala schema type.
 *
 * @nosubgrouping
 */
class ItemTipoSala: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< id_type > id_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const id_optional&
  id () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  id_optional&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  id (const id_optional& x);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< nome_type > nome_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const nome_optional&
  nome () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  nome_optional&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  nome (const nome_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name descricao
   *
   * @brief Accessor and modifier functions for the %descricao
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string descricao_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< descricao_type > descricao_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< descricao_type, char > descricao_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const descricao_optional&
  descricao () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  descricao_optional&
  descricao ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  descricao (const descricao_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  descricao (const descricao_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  descricao (::std::auto_ptr< descricao_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemTipoSala ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemTipoSala (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemTipoSala (const ItemTipoSala& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemTipoSala*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemTipoSala ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  id_optional id_;
  nome_optional nome_;
  descricao_optional descricao_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemTipoContrato schema type.
 *
 * @nosubgrouping
 */
class ItemTipoContrato: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemTipoContrato (const id_type&,
                    const nome_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemTipoContrato (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemTipoContrato (const ItemTipoContrato& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemTipoContrato*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemTipoContrato ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< nome_type > nome_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemTipoTitulacao schema type.
 *
 * @nosubgrouping
 */
class ItemTipoTitulacao: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemTipoTitulacao (const id_type&,
                     const nome_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemTipoTitulacao (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemTipoTitulacao (const ItemTipoTitulacao& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemTipoTitulacao*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemTipoTitulacao ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< nome_type > nome_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemAreaTitulacao schema type.
 *
 * @nosubgrouping
 */
class ItemAreaTitulacao: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemAreaTitulacao (const id_type&,
                     const nome_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemAreaTitulacao (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemAreaTitulacao (const ItemAreaTitulacao& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemAreaTitulacao*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemAreaTitulacao ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< nome_type > nome_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemTipoDisciplina schema type.
 *
 * @nosubgrouping
 */
class ItemTipoDisciplina: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemTipoDisciplina (const id_type&,
                      const nome_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemTipoDisciplina (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemTipoDisciplina (const ItemTipoDisciplina& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemTipoDisciplina*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemTipoDisciplina ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< nome_type > nome_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ItemTipoCurso schema type.
 *
 * @nosubgrouping
 */
class ItemTipoCurso: public ::xml_schema::type
{
  public:
  /**
   * @name id
   *
   * @brief Accessor and modifier functions for the %id
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ id_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< id_type, char > id_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const id_type&
  id () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  id_type&
  id ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  id (const id_type& x);

  //@}

  /**
   * @name nome
   *
   * @brief Accessor and modifier functions for the %nome
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string nome_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< nome_type, char > nome_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const nome_type&
  nome () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  nome_type&
  nome ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  nome (const nome_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  nome (::std::auto_ptr< nome_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ItemTipoCurso (const id_type&,
                 const nome_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ItemTipoCurso (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ItemTipoCurso (const ItemTipoCurso& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ItemTipoCurso*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ItemTipoCurso ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< id_type > id_;
  ::xsd::cxx::tree::one< nome_type > nome_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Trieda schema type.
 *
 * @nosubgrouping
 */
class Trieda: public ::xml_schema::type
{
  public:
  /**
   * @name unidades
   *
   * @brief Accessor and modifier functions for the %unidades
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoUnidade unidades_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< unidades_type, char > unidades_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const unidades_type&
  unidades () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  unidades_type&
  unidades ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  unidades (const unidades_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  unidades (::std::auto_ptr< unidades_type > p);

  //@}

  /**
   * @name cursos
   *
   * @brief Accessor and modifier functions for the %cursos
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoCurso cursos_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cursos_type, char > cursos_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const cursos_type&
  cursos () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  cursos_type&
  cursos ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  cursos (const cursos_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  cursos (::std::auto_ptr< cursos_type > p);

  //@}

  /**
   * @name calendario
   *
   * @brief Accessor and modifier functions for the %calendario
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ItemCalendario calendario_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< calendario_type, char > calendario_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const calendario_type&
  calendario () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  calendario_type&
  calendario ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  calendario (const calendario_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  calendario (::std::auto_ptr< calendario_type > p);

  //@}

  /**
   * @name professores
   *
   * @brief Accessor and modifier functions for the %professores
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoProfessor professores_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< professores_type, char > professores_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const professores_type&
  professores () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  professores_type&
  professores ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  professores (const professores_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  professores (::std::auto_ptr< professores_type > p);

  //@}

  /**
   * @name disciplinas
   *
   * @brief Accessor and modifier functions for the %disciplinas
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoDisciplina disciplinas_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< disciplinas_type, char > disciplinas_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const disciplinas_type&
  disciplinas () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  disciplinas_type&
  disciplinas ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  disciplinas (const disciplinas_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  disciplinas (::std::auto_ptr< disciplinas_type > p);

  //@}

  /**
   * @name regrasCredito
   *
   * @brief Accessor and modifier functions for the %regrasCredito
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::GrupoDivisaoCreditos regrasCredito_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< regrasCredito_type, char > regrasCredito_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const regrasCredito_type&
  regrasCredito () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  regrasCredito_type&
  regrasCredito ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  regrasCredito (const regrasCredito_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  regrasCredito (::std::auto_ptr< regrasCredito_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Trieda (const unidades_type&,
          const cursos_type&,
          const calendario_type&,
          const professores_type&,
          const disciplinas_type&,
          const regrasCredito_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Trieda (::std::auto_ptr< unidades_type >&,
          ::std::auto_ptr< cursos_type >&,
          ::std::auto_ptr< calendario_type >&,
          ::std::auto_ptr< professores_type >&,
          ::std::auto_ptr< disciplinas_type >&,
          ::std::auto_ptr< regrasCredito_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Trieda (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Trieda (const Trieda& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Trieda*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Trieda ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< unidades_type > unidades_;
  ::xsd::cxx::tree::one< cursos_type > cursos_;
  ::xsd::cxx::tree::one< calendario_type > calendario_;
  ::xsd::cxx::tree::one< professores_type > professores_;
  ::xsd::cxx::tree::one< disciplinas_type > disciplinas_;
  ::xsd::cxx::tree::one< regrasCredito_type > regrasCredito_;

  //@endcond
};

/**
 * @brief Class corresponding to the %unidadeCurriculo schema type.
 *
 * @nosubgrouping
 */
class unidadeCurriculo: public ::ItemUnidadeCurriculo
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  unidadeCurriculo (const turno_type&,
                    const curriculo_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (auto_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  unidadeCurriculo (::std::auto_ptr< turno_type >&,
                    ::std::auto_ptr< curriculo_type >&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  unidadeCurriculo (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  unidadeCurriculo (const unidadeCurriculo& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual unidadeCurriculo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~unidadeCurriculo ();
};

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, const ItemProfessorDisciplina&);

::std::ostream&
operator<< (::std::ostream&, const GrupoProfessorDisciplina&);

::std::ostream&
operator<< (::std::ostream&, const ItemProfessor&);

::std::ostream&
operator<< (::std::ostream&, const GrupoProfessor&);

::std::ostream&
operator<< (::std::ostream&, const ItemDivisaoCreditos&);

::std::ostream&
operator<< (::std::ostream&, const GrupoDivisaoCreditos&);

::std::ostream&
operator<< (::std::ostream&, const GrupoDeslocamento&);

::std::ostream&
operator<< (::std::ostream&, const ItemDeslocamento&);

::std::ostream&
operator<< (::std::ostream&, const GrupoUnidade&);

::std::ostream&
operator<< (::std::ostream&, const ItemUnidade&);

::std::ostream&
operator<< (::std::ostream&, const ItemDisciplina&);

::std::ostream&
operator<< (::std::ostream&, const GrupoDisciplina&);

::std::ostream&
operator<< (::std::ostream&, const ItemCalendario&);

::std::ostream&
operator<< (::std::ostream&, const ItemHorarioDisponivel&);

::std::ostream&
operator<< (::std::ostream&, const GrupoHorarioDisponivel&);

::std::ostream&
operator<< (::std::ostream&, const ItemHorarioAula&);

::std::ostream&
operator<< (::std::ostream&, const GrupoHorarioAula&);

::std::ostream&
operator<< (::std::ostream&, const ItemTurno&);

::std::ostream&
operator<< (::std::ostream&, const GrupoTurno&);

::std::ostream&
operator<< (::std::ostream&, const ItemSala&);

::std::ostream&
operator<< (::std::ostream&, const ItemDisciplinaPeriodo&);

::std::ostream&
operator<< (::std::ostream&, const ItemCurriculo&);

::std::ostream&
operator<< (::std::ostream&, const GrupoCurriculo&);

::std::ostream&
operator<< (::std::ostream&, const GrupoSala&);

::std::ostream&
operator<< (::std::ostream&, const ItemCurso&);

::std::ostream&
operator<< (::std::ostream&, const GrupoCurso&);

::std::ostream&
operator<< (::std::ostream&, const ItemDemanda&);

::std::ostream&
operator<< (::std::ostream&, const GrupoDemanda&);

::std::ostream&
operator<< (::std::ostream&, const ItemUnidadeCurriculo&);

::std::ostream&
operator<< (::std::ostream&, const GrupoUnidadeCurriculo&);

::std::ostream&
operator<< (::std::ostream&, const ItemAlocacao&);

::std::ostream&
operator<< (::std::ostream&, const ItemOferecimento&);

::std::ostream&
operator<< (::std::ostream&, const GrupoOferecimento&);

::std::ostream&
operator<< (::std::ostream&, const ItemTurma&);

::std::ostream&
operator<< (::std::ostream&, const GrupoTurma&);

::std::ostream&
operator<< (::std::ostream&, const ItemTipoSala&);

::std::ostream&
operator<< (::std::ostream&, const ItemTipoContrato&);

::std::ostream&
operator<< (::std::ostream&, const ItemTipoTitulacao&);

::std::ostream&
operator<< (::std::ostream&, const ItemAreaTitulacao&);

::std::ostream&
operator<< (::std::ostream&, const ItemTipoDisciplina&);

::std::ostream&
operator<< (::std::ostream&, const ItemTipoCurso&);

::std::ostream&
operator<< (::std::ostream&, const Trieda&);

::std::ostream&
operator<< (::std::ostream&, const unidadeCurriculo&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %Trieda document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (const ::std::string& uri,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (const ::std::string& uri,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (const ::std::string& uri,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::std::istream& is,
         const ::std::string& id,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::xercesc::InputSource& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::xercesc::InputSource& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::xercesc::InputSource& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::auto_ptr< ::Trieda >
Trieda_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

//@}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

/**
 * @name Serialization functions for the %Trieda document root.
 */
//@{

/**
 * @brief Serialize to a standard output stream.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
Trieda_ (::std::ostream& os,
         const ::Trieda& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with an error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Trieda_ (::std::ostream& os,
         const ::Trieda& x, 
         ::xml_schema::error_handler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a standard output stream with a Xerces-C++ DOM
 * error handler.
 *
 * @param os A standrad output stream.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Trieda_ (::std::ostream& os,
         const ::Trieda& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function uses exceptions to report serialization errors.
 */
void
Trieda_ (::xercesc::XMLFormatTarget& ft,
         const ::Trieda& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with an error
 * handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh An error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Trieda_ (::xercesc::XMLFormatTarget& ft,
         const ::Trieda& x, 
         ::xml_schema::error_handler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a Xerces-C++ XML format target with a
 * Xerces-C++ DOM error handler.
 *
 * @param ft A Xerces-C++ XML format target.
 * @param x An object model to serialize.
 * @param eh A Xerces-C++ DOM error handler.
 * @param m A namespace information map.
 * @param e A character encoding to produce XML in.
 * @param f Serialization flags.
 *
 * This function reports serialization errors by calling the error
 * handler.
 */
void
Trieda_ (::xercesc::XMLFormatTarget& ft,
         const ::Trieda& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to an existing Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param x An object model to serialize.
 * @param f Serialization flags.
 *
 * Note that it is your responsibility to create the DOM document
 * with the correct root element as well as set the necessary
 * namespace mapping attributes.
 */
void
Trieda_ (::xercesc::DOMDocument& d,
         const ::Trieda& x,
         ::xml_schema::flags f = 0);

/**
 * @brief Serialize to a new Xerces-C++ DOM document.
 *
 * @param x An object model to serialize.
 * @param m A namespace information map.
 * @param f Serialization flags.
 * @return A pointer to the new Xerces-C++ DOM document.
 */
::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
Trieda_ (const ::Trieda& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         ::xml_schema::flags f = 0);

//@}

void
operator<< (::xercesc::DOMElement&, const ItemProfessorDisciplina&);

void
operator<< (::xercesc::DOMElement&, const GrupoProfessorDisciplina&);

void
operator<< (::xercesc::DOMElement&, const ItemProfessor&);

void
operator<< (::xercesc::DOMElement&, const GrupoProfessor&);

void
operator<< (::xercesc::DOMElement&, const ItemDivisaoCreditos&);

void
operator<< (::xercesc::DOMElement&, const GrupoDivisaoCreditos&);

void
operator<< (::xercesc::DOMElement&, const GrupoDeslocamento&);

void
operator<< (::xercesc::DOMElement&, const ItemDeslocamento&);

void
operator<< (::xercesc::DOMElement&, const GrupoUnidade&);

void
operator<< (::xercesc::DOMElement&, const ItemUnidade&);

void
operator<< (::xercesc::DOMElement&, const ItemDisciplina&);

void
operator<< (::xercesc::DOMElement&, const GrupoDisciplina&);

void
operator<< (::xercesc::DOMElement&, const ItemCalendario&);

void
operator<< (::xercesc::DOMElement&, const ItemHorarioDisponivel&);

void
operator<< (::xercesc::DOMElement&, const GrupoHorarioDisponivel&);

void
operator<< (::xercesc::DOMElement&, const ItemHorarioAula&);

void
operator<< (::xercesc::DOMElement&, const GrupoHorarioAula&);

void
operator<< (::xercesc::DOMElement&, const ItemTurno&);

void
operator<< (::xercesc::DOMElement&, const GrupoTurno&);

void
operator<< (::xercesc::DOMElement&, const ItemSala&);

void
operator<< (::xercesc::DOMElement&, const ItemDisciplinaPeriodo&);

void
operator<< (::xercesc::DOMElement&, const ItemCurriculo&);

void
operator<< (::xercesc::DOMElement&, const GrupoCurriculo&);

void
operator<< (::xercesc::DOMElement&, const GrupoSala&);

void
operator<< (::xercesc::DOMElement&, const ItemCurso&);

void
operator<< (::xercesc::DOMElement&, const GrupoCurso&);

void
operator<< (::xercesc::DOMElement&, const ItemDemanda&);

void
operator<< (::xercesc::DOMElement&, const GrupoDemanda&);

void
operator<< (::xercesc::DOMElement&, const ItemUnidadeCurriculo&);

void
operator<< (::xercesc::DOMElement&, const GrupoUnidadeCurriculo&);

void
operator<< (::xercesc::DOMElement&, const ItemAlocacao&);

void
operator<< (::xercesc::DOMElement&, const ItemOferecimento&);

void
operator<< (::xercesc::DOMElement&, const GrupoOferecimento&);

void
operator<< (::xercesc::DOMElement&, const ItemTurma&);

void
operator<< (::xercesc::DOMElement&, const GrupoTurma&);

void
operator<< (::xercesc::DOMElement&, const ItemTipoSala&);

void
operator<< (::xercesc::DOMElement&, const ItemTipoContrato&);

void
operator<< (::xercesc::DOMElement&, const ItemTipoTitulacao&);

void
operator<< (::xercesc::DOMElement&, const ItemAreaTitulacao&);

void
operator<< (::xercesc::DOMElement&, const ItemTipoDisciplina&);

void
operator<< (::xercesc::DOMElement&, const ItemTipoCurso&);

void
operator<< (::xercesc::DOMElement&, const Trieda&);

void
operator<< (::xercesc::DOMElement&, const unidadeCurriculo&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_________DOC_COMMON_COMMUNICATION_PROTOCOL_TRIEDA_INPUT_XSD_H
