#include "SolverMIP.h"
#include <math.h>

#ifdef SOLVER_CPLEX
#include "opt_cplex.cpp"
#endif

#ifdef SOLVER_GUROBI
#include "opt_gurobi.cpp"
#endif

using namespace std;

#define MODELO_INTEGRADO_P2

#ifndef MODELO_INTEGRADO_P2
#define HEURISTICA_P2
#endif

/*==================================================================/
%DocBegin TRIEDA_LOAD_MODEL
%Title Módulo Tático

%ProbSense MIN

%Set CP 
%Desc 
Conjunto de campus. Os elementos desse conjunto são denotados por $cp$.

%Set U
%Desc 
Conjunto de unidades. Os elementos desse conjunto são denotados por $u$.

%Set S_{u}
%Desc 
Conjunto de salas da unidade $u$. Os elementos desse conjunto são 
denotados por $s$.

%Set SCAP_{u}
%Desc 
Conjunto de salas da unidade $u$ classificadas de acordo com as suas 
capacidades. Os elementos desse conjunto são denotados por $tps$.

%Set T 
%Desc 
Conjunto de dias letivos da semana. Os elementos desse conjunto 
são denotados por $t$.

%Set C
%Desc 
Conjunto de cursos. Os elementos desse conjunto são denotados por $c$.

%Set CC
%Desc 
Conjunto de cursos compatíveis.

%Set D
%Desc 
Conjunto de disciplinas. Os elementos desse conjunto são denotados por $d$.

%Set B
%Desc 
Conjunto de blocos curriculares. Os elementos desse conjunto são 
denotados por $bc$.

%Set D_{bc}
%Desc 
Conjunto de disciplinas que pertencem ao bloco curricular $bc$. 
Os elementos desse conjunto são denotados por $d_{bc}$.

%Set I_{bc}
%Desc 
Conjunto de turmas de um bloco curricular $bc$. 
Os elementos desse conjunto são denotados por $i_{bc}$.

%Set O
%Desc 
Conjunto de ofertas de cursos. Os elementos desse conjunto são 
denotados por $oft$.

%Set D_{oft}
%Desc 
Conjunto de disciplinas de uma oferta $oft$. 
Os elementos desse conjunto são denotados por $d_{oft}$.

%Set O_{d}
%Desc 
Conjunto de ofertas de uma uma disciplina $d$. 
Os elementos desse conjunto são denotados por $oft_{d}$.

%Set K_{d}
%Desc 
Conjunto de combinações possíveis de divisão de créditos de uma uma disciplina $d$. 
Os elementos desse conjunto são denotados por $k$.

%DocEnd
/===================================================================*/

/*==================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Data A_{u,s}
%Desc
capacidade da sala $s$ da unidade $u$.


%Data C_{d}
%Desc
Total de créditos da disciplina $d$.

%Data \overline{H_{d}}
%Desc 
máximo de créditos diários da disciplina $d$.

%Data \underline{H_{d}}
%Desc 
mínimo de créditos diários da disciplina $d$.

%Data I_{d}
%Desc 
máximo de turmas que podem ser abertas da disciplina $d$.

%Data P_{d,c,cp}
%Desc 
demanda da disciplina $d$ no campus $cp$ para o curso $c$.

%Data P_{d,oft}
%Desc
demanda da disciplina $d$ da oferta $oft$.

%Data Pmax_{d}
%Desc 
maior demanda da disciplina $d$.

%Data H_{t}
%Desc
máximo de créditos permitidos por dia $t$.

%Data A_{u,s}
%Desc 
capacidade da sala $s$ da unidade $u$.

%Data HTPS_{t,tps}
%Desc 
máximo de créditos permitidos por dia $t$ para o conjunto de salas do tipo (capacidade) $tps$.

%Data A_{u,tps}
%Desc 
capacidade total das salas de um conjunto de salas do tipo (capacidade) $tps$ da unidade $u$.

%Data O_{cp}
%Desc
conjunto de ofertas de um campus $cp$.

%Data FC_{d,t}
%Desc 
número de créditos fixados para a disciplina $d$ no dia $t$.

%Data N_{d,k,t}
%Desc 
número de créditos determinados para a disciplina $d$ no dia $t$ na combinação de divisão de crédito $k$.

%Data M
%Desc 
big $M$.

%Data \alpha
%Desc 
peso associado a função objetivo.
%Data \beta
%Desc 
peso associado a função objetivo.
%Data \gamma
%Desc 
peso associado a função objetivo.
%Data \delta
%Desc 
peso associado a função objetivo.
%Data \lambda
%Desc 
peso associado a função objetivo.
%Data \rho
%Desc 
peso associado a função objetivo.
%Data \xi
%Desc 
pesos associados a cada item da função objetivo.
%Data \psi
%Desc 
peso associado a função objetivo.
%Data \theta
%Desc 
peso associado a função objetivo.
%Data \omega
%Desc 
peso associado a função objetivo.
%Data \tau
%Desc 
peso associado a função objetivo.
%Data \eta
%Desc 
peso associado a função objetivo.

%DocEnd
/===================================================================*/



#ifndef WIN32
struct ordenaDiscSalas {
   bool operator()(const std::pair< int /*Disc id*/, int /*Qtd salas associadas*/ > & left,
                   const std::pair< int /*Disc id*/, int /*Qtd salas associadas*/ > & right) const
   {
      return ( left.second < right.second );
   }
};
#else
bool ordenaDiscSalas( std::pair< int /*Disc id*/, int /*Qtd salas associadas*/ > & left,
                      std::pair< int /*Disc id*/, int /*Qtd salas associadas*/ > & right )
{
   return ( left.second < right.second );
}
#endif

bool ordenaVarsX( Variable * left, Variable * right )
{
   if ( left->getUnidade() > right->getUnidade() )
   {
      return false;
   }
   else
   {
      if ( left->getTurma() > right->getTurma() )
      {
         return false;
      }
      else
      {
         if ( left->getDia() > right->getDia() )
         {
            return false;
         }
      }
   }

   return true;
}


#ifdef SOLVER_CPLEX

static int CPXPUBLIC 
TaticoP2callback (CPXCENVptr xenv, void *cbdata,
                int wherefrom, void *cbhandle, double objval, double *x,
                int *isfeas_p, int *useraction_p)
{  
   SolverMIP *solverMIP = (SolverMIP*)cbhandle;
   bool viavel = false;

   // A solucao encontrada esta em x e o valor da FO em objval

   viavel = solverMIP->solucaoValidaCliquesAux( x );
   
   if ( viavel )
   {
      *isfeas_p = 1;
      *useraction_p = 2;
   }
   else
   {
      *isfeas_p = 0;
      *useraction_p = 2;
   }

   return 0;
} 

#endif

// comparison function.
bool compare_dif_func ( std::pair< AlunoDemanda*, int > first, std::pair< AlunoDemanda*, int > second )
{
  if ( abs(first.second) < abs(second.second) )
	  return true;
  else if ( abs(first.second) > abs(second.second) )
	  return false;
  else if ( first.second < second.second )
	  return true;
  else if ( first.second > second.second )
	  return false;
  else if ( abs( first.first->demanda->getDisciplinaId() ) == abs( second.first->demanda->getDisciplinaId() ) )
  {	  
	  // first/second são um par de pratica-teorica
	  if ( first.first->getId() < second.first->getId() )
		 return true;
	  else
		  return false;
  }
  else if ( first.first->demanda->getDisciplinaId() < second.first->demanda->getDisciplinaId() )
	  return true;
  else
	  return false;
}


SolverMIP::SolverMIP( ProblemData * aProblemData,
  ProblemSolution * _ProblemSolution, ProblemDataLoader * _problemDataLoader )
   : Solver( aProblemData )
{
   problemSolution = _ProblemSolution;
   problemDataLoader = _problemDataLoader;

   alpha = 5.0;
   beta = 10.0;
   gamma = 0;
   delta = 1.0;
   lambda = 10.0;
   epsilon = 1.0;
   M = 1.0;
   rho = 5;

   // Verificar o valor
   psi = 5.0;
   tau = 1.0;

   TEMPO_PRETATICO = 3600;//800;
   TEMPO_TATICO = 3600;//450;

#ifdef TATICO_CJT_ALUNOS
   NAO_CRIAR_RESTRICOES_CJT_ANTERIORES = true;
   FIXAR_P1 = true;
   FIXAR_TATICO_P1 = true;
   PERMITIR_INSERCAO_ALUNODEMANDAP2_EM_TURMAP1 = false;
#endif

   try
   {
#ifdef SOLVER_CPLEX
	   lp = new OPT_CPLEX; 
#endif
#ifdef SOLVER_GUROBI
	   lp = new OPT_GUROBI; 
#endif
   }
   catch(...)
   {
   }

   cliques.clear();
   solVars.clear();
   graph.clear();
   mapVertex.clear();
}

SolverMIP::~SolverMIP()
{
   int i;
   if ( lp != NULL )
   {
      delete lp;
   }

   ITERA_GGROUP_LESSPTR ( it, solVars, Variable )
   {
		delete *it;    
   }

   solVars.clear();

   std::set< VariablePre*, LessPtr<VariablePre> >::iterator it = solVarsPre.begin();
   for ( ; it != solVarsPre.end(); it++ )
   {
		delete *it;    
   }
   solVarsPre.clear();

	// -----------------------------------------------------
	// Deleta as variaveis em solVarsXPre 
	ITERA_GGROUP_LESSPTR ( it, solVarsXPre, VariablePre )
	{
		delete *it;    
	}
	solVarsXPre.clear();

}

int SolverMIP::retornaTempoDeExecucaoPreModelo( int campusId, int cjtAlunosId, int prioridade )
{
	if ( campusId == 19 ) // campus 2, mais dificil
	{
		return TEMPO_PRETATICO*3;
	}
	else if ( campusId == 20 ) // campus 28, mais facil
	{
		return TEMPO_PRETATICO*3;	
	}
	else // geral
	{
		return TEMPO_PRETATICO*3;	
	}
}


int SolverMIP::retornaTempoDeExecucaoTatico( int campusId, int cjtAlunosId, int prioridade )
{
	if ( campusId == 19 ) // campus 2, mais dificil
	{
		if ( prioridade == 1 )
		{
			if ( cjtAlunosId == 1 )
			{
				return TEMPO_TATICO*7;
			}
			else if ( cjtAlunosId == 2 )
			{
				return TEMPO_TATICO*6;
			}
			else
			{
				return TEMPO_TATICO*4;
			}
		}
		else // prioridade 2 em diante
		{
			if ( cjtAlunosId == 1 )
			{
				return TEMPO_TATICO*6;
			}
			else
			{
				return TEMPO_TATICO;
			}		
		}
	}
	else if ( campusId == 20 ) // campus 28, mais facil
	{
		if ( prioridade == 1 )
		{
			if ( cjtAlunosId == 1 )
			{
				return TEMPO_TATICO*5;
			}
			else if ( cjtAlunosId == 2 )
			{
				return TEMPO_TATICO*4;
			}
			else
			{
				return TEMPO_TATICO*3;
			}
		}
		else // prioridade 2 em diante
		{
			if ( cjtAlunosId == 1 )
			{
				return TEMPO_TATICO*6;
			}
			else
			{
				return TEMPO_TATICO;
			}		
		}
	}
	else // geral
	{
		return TEMPO_TATICO;	
	}
}


std::string SolverMIP::getPreLpFileName( int campusId, int prioridade, int cjtAlunosId, int r )
{
   std::string solName( "SolverTriedaPreTatico" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }

   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }

   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }

   if ( r != 0 )
   {
		stringstream ss;
		ss << r;
		solName += "_R"; 
		solName += ss.str();   		
   }
         
   return solName;
}

std::string SolverMIP::getTaticoLpFileName( int campusId, int prioridade, int cjtAlunosId, int r, int tatico )
{
   std::string solName( "SolverTrieda" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }

   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }

   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }
 
   if ( r != 0 )
   {
		stringstream ss;
		ss << r;
		solName += "_R"; 
		solName += ss.str();   		
   }
 
   if ( tatico != 0 )
   {
		stringstream ss;
		ss << tatico;
		solName += "_T"; 
		solName += ss.str();   		
   }        
   return solName;
}

std::string SolverMIP::getSolHeuristBinFileName( int campusId, int prioridade, int cjtAlunosId )
{
   std::string solName( "solHeuristBin" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }

   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }

   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }

   solName += ".bin";
      
   return solName;
}

std::string SolverMIP::getSolBinFileName( int campusId, int prioridade, int cjtAlunosId, int r, int tatico )
{
   std::string solName( "solBin" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }

   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }
   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }
   if ( r != 0 )
   {
		stringstream ss;
		ss << r;
		solName += "_R"; 
		solName += ss.str();   		
   }
   if ( tatico != 0 )
   {
		stringstream ss;
		ss << tatico;
		solName += "_T"; 
		solName += ss.str();   		
   }
   solName += ".bin";
      
   return solName;
}

std::string SolverMIP::getSolPreBinFileName( int campusId, int prioridade, int cjtAlunosId, int r )
{
   std::string solName( "solPreBin" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }

   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }

   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }

   if ( r != 0 )
   {
		stringstream ss;
		ss << r;
		solName += "_R"; 
		solName += ss.str();   		
   }

   solName += ".bin";
      
   return solName;
}

std::string SolverMIP::getSolucaoTaticoFileName( int campusId, int prioridade, int cjtAlunosId, int r, int tatico )
{
   std::string solName( "solucaoTatico" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }
   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }
   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }
   if ( r != 0 )
   {
		stringstream ss;
		ss << r;
		solName += "_R"; 
		solName += ss.str();   		
   }
   if ( tatico != 0 )
   {
		stringstream ss;
		ss << tatico;
		solName += "_T"; 
		solName += ss.str();   		
   }  

   solName += ".txt";
      
   return solName;
}

std::string SolverMIP::getSolucaoPreTaticoFileName( int campusId, int prioridade, int cjtAlunosId, int r )
{
   std::string solName( "solucaoPreTatico" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }

   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }

   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }

   if ( r != 0 )
   {
		stringstream ss;
		ss << r;
		solName += "_R"; 
		solName += ss.str();   		
   }

   solName += ".txt";
      
   return solName;
}

std::string SolverMIP::getSolVarsPreFileName( int campusId, int prioridade, int cjtAlunosId )
{
   std::string solName( "solVarsPre" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }

   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }

   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }

   solName += ".txt";
      
   return solName;
}

std::string SolverMIP::getCliquesFileName( int campusId, int prioridade, int cjtAlunosId )
{
   std::string solName( "cliques" );
   
   if ( campusId != 0 )
   {	   
		 stringstream ss;
		 ss << campusId;
		 solName += "_Cp"; 
		 solName += ss.str();
   }

   if ( prioridade != 0 )
   {
		stringstream ss;
		ss << prioridade;
		solName += "_P"; 
		solName += ss.str();   		
   }

   if ( cjtAlunosId != 0 )
   {
	    stringstream ss;
		ss << cjtAlunosId;		
		solName += "_Cjt"; 
		solName += ss.str();   		
   }

   solName += ".txt";
      
   return solName;
}

void SolverMIP::writeSolBin( int campusId, int prioridade, int cjtAlunosId, int r, int tatico, int type, double *xSol )
{
	char solName[1024];

	switch (type)
	{
		case (PRE_TAT_BIN):
			strcpy( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN1):
			strcpy( solName, "1" );
			strcat( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN2):
			strcpy( solName, "2" );
			strcat( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN3):
			strcpy( solName, "3" );
			strcat( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN4):
			strcpy( solName, "4" );
			strcat( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (TAT_HOR_BIN):
			strcpy( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );			
			break;
		case (TAT_HOR_BIN1):
			strcpy( solName, "1" );
			strcat( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
		case (TAT_HOR_BIN2):
			strcpy( solName, "2" );
			strcat( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
		case (TAT_HOR_BIN3):
			strcpy( solName, "3" );
			strcat( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
	}

	// WRITES SOLUTION
		
	FILE * fout = fopen( solName, "wb" );
	if ( fout == NULL )
	{
		std::cout << "\nErro em SolverMIP::writeSolBin( int campusId, int prioridade, int cjtAlunosId, int r, int tatico, int type ):"
				<< "\nArquivo " << solName << " nao pode ser aberto.\n";
	}
	else
	{
		int nCols = lp->getNumCols();

		fwrite( &nCols, sizeof( int ), 1, fout );
		for ( int i = 0; i < lp->getNumCols(); i++ )
		{
			fwrite( &( xSol[ i ] ), sizeof( double ), 1, fout );
		}

		fclose( fout );
	}
}

int SolverMIP::readSolBin( int campusId, int prioridade, int cjtAlunosId, int r, int tatico, int type, double *&xSol )
{
	char solName[1024];

	switch (type)
	{
		case (PRE_TAT_BIN):
			strcpy( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN1):
			strcpy( solName, "1" );
			strcat( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN2):
			strcpy( solName, "2" );
			strcat( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN3):
			strcpy( solName, "3" );
			strcat( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN4):
			strcpy( solName, "4" );
			strcat( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (TAT_HOR_BIN):
			strcpy( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );			
			break;
		case (TAT_HOR_BIN1):
			strcpy( solName, "1" );
			strcat( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
		case (TAT_HOR_BIN2):
			strcpy( solName, "2" );
			strcat( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
		case (TAT_HOR_BIN3):
			strcpy( solName, "3" );
			strcat( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
	}

	// READS THE SOLUTION
		
	cout<<"====================> carregando solucao " <<solName <<endl; fflush(NULL);
	FILE* fin = fopen( solName,"rb");

	if ( fin == NULL )
	{
		std::cout << "<============ Arquivo " << solName << " nao encontrado. Fim do carregamento de solucao.\n\n"; fflush(NULL);
		return (0);
	}

	int nCols = 0;
    int nroColsLP = lp->getNumCols();

	fread(&nCols,sizeof(int),1,fin);
   
	if ( nCols == nroColsLP )
	{
		for (int i =0; i < nCols; i++)
		{
			double auxDbl;
			fread(&auxDbl,sizeof(double),1,fin);
			(xSol)[i] = auxDbl;
		}
	}
	else
	{
		std::cout << "\nErro em readSolBin(int campusAtualId, int prioridade, int cjtAlunos, int r): "
					<< " \nNumero diferente de variaveis: " << nCols << " != " << nroColsLP; fflush(NULL);
		return (0);
	}
	fclose(fin);
	
	return (1);
}


void SolverMIP::writeSolTxt( int campusId, int prioridade, int cjtAlunosId, int r, int tatico, int type, double *xSol )
{
	char solName[1024];

	switch (type)
	{
		case (PRE_TAT_BIN):
			strcpy( solName, getSolucaoPreTaticoFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN1):
			strcpy( solName, "1" );
			strcat( solName, getSolucaoPreTaticoFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN2):
			strcpy( solName, "2" );
			strcat( solName, getSolucaoPreTaticoFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN3):
			strcpy( solName, "3" );
			strcat( solName, getSolucaoPreTaticoFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (PRE_TAT_BIN4):
			strcpy( solName, "4" );
			strcat( solName, getSolucaoPreTaticoFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
			break;
		case (TAT_HOR_BIN):
			strcpy( solName, getSolucaoTaticoFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );			
			break;
		case (TAT_HOR_BIN1):
			strcpy( solName, "1" );
			strcat( solName, getSolucaoTaticoFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
		case (TAT_HOR_BIN2):
			strcpy( solName, "2" );
			strcat( solName, getSolucaoTaticoFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
		case (TAT_HOR_BIN3):
			strcpy( solName, "3" );
			strcat( solName, getSolucaoTaticoFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
			break;
	}

	// WRITES SOLUTION
		
	ofstream fout( solName, ios_base::out );
	if ( fout == NULL )
	{
		std::cout << "\nErro em SolverMIP::writeSolTxt( int campusId, int prioridade, int cjtAlunosId, int r, int tatico, int type ):"
				<< "\nArquivo " << solName << " nao pode ser aberto.\n";
	}
	else
	{		
		if ( type == PRE_TAT_BIN ||
			 type == PRE_TAT_BIN1 ||
			 type == PRE_TAT_BIN2 ||
			 type == PRE_TAT_BIN3 ||
			 type == PRE_TAT_BIN4 )
		{
			VariablePreHash::iterator vit = vHashPre.begin();
			while ( vit != vHashPre.end() )
			{
				  VariablePre v = vit->first;
				  int col = vit->second;
				  double value = xSol[ col ];
		  
				  fout << v.toString() << " = " << value << endl;
				  
				  vit++;
			}
			fout.close();
		}
		else
		{
			VariableTaticoHash::iterator vit = vHashTatico.begin();
			while ( vit != vHashTatico.end() )
			{
				  VariableTatico v = vit->first;
				  int col = vit->second;
				  double value = xSol[ col ];
		  
				  fout << v.toString() << " = " << value << endl;
				  
				  vit++;
			}
			fout.close();
		}
	}
}

bool SolverMIP::SolVarsFound( VariableTatico v )
{	
	GGroup< VariableTatico *, LessPtr<VariableTatico> >::iterator itSol = solVarsTatico.find(&v);

	if(itSol != solVarsTatico.end())
		return true;
	else
		return false;
}

bool SolverMIP::SolVarsPreFound( VariablePre v )
{	
	/*std::set< VariablePre*, LessPtr<VariablePre> >::iterator itPreSol = solVarsPre.begin();
	for ( ; itPreSol != solVarsPre.end(); itPreSol++ )
	{
		VariablePre var = **itPreSol;
		if ( var == v )
		{
			return true;
		}
	}
	return false;*/
	
	GGroup< VariablePre *, LessPtr<VariablePre> >::iterator itPreSol = solVarsXPre.find(&v);

	if(itPreSol != solVarsXPre.end())
		return true;
	else
		return false;
}

void SolverMIP::carregaVariaveisSolucaoTatico( int campusId )
{
   double * xSol = NULL;
   VariableHash::iterator vit;

   SolutionLoader sLoader( problemData, problemSolution );

   xSol = new double[ lp->getNumCols() ];

#ifndef READ_SOLUTION_TATICO_BIN
   lp->getX( xSol );
#endif

#ifdef READ_SOLUTION_TATICO_BIN

   char solName[1024];

   strcpy( solName, getSolBinFileName( campusId, 0, 0 ).c_str() );
   
   FILE* fin = fopen( solName, "rb" );
         
   if ( fin == NULL )
   {
	   std::cout << "\nErro em carregaVariaveisSolucaoTatico(): arquivo " << solName << " nao encontrado.\n";
	   exit(0);
   }

   int nCols = 0;

   fread(&nCols,sizeof(int),1,fin);

   if ( nCols == lp->getNumCols() )
   {
      for (int i =0; i < nCols; i++)
      {
         double auxDbl;
         fread(&auxDbl,sizeof(double),1,fin);
         xSol[i] = auxDbl;
      }
   }

   fclose(fin);
#endif

   vit = vHash.begin();
   
   char solFilename[1024], id[100];
   strcpy( solFilename, "solucaoTatico" );
   _itoa_s( campusId, id, 100, 10 );
   strcat( solFilename, id );
   strcat( solFilename, ".txt" );

   FILE * fout = fopen( solFilename, "wt" );

   while ( vit != vHash.end() )
   {
      Variable * v = new Variable( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         //#ifdef DEBUG
         char auxName[100];
         lp->getColName( auxName, col, 100 );
         fprintf( fout, "%s = %f\n", auxName, v->getValue() );
         //#endif
         switch( v->getType() )
         {
         case Variable::V_ERROR:
            std::cout << "Variável inválida " << std::endl;
            break;
         case Variable::V_CREDITOS:
            std::cout << "Oferta de " << v->getValue()
                      << " creditos da disciplina " << v->getDisciplina()->getCodigo()
                      << " para a turma " << v->getTurma()
                      << " no dia " << v->getDia()
                      << " para alguma de sala do conjunto de salas " << v->getSubCjtSala()->getId()
                      << std::endl << std::endl;
            vars_x.push_back(v);
            break;
         case Variable::V_OFERECIMENTO: break;
         case Variable::V_ABERTURA: break;
         case Variable::V_ALUNOS:
		 {
            std::cout << "Oferecimento de " << v->getValue()
                      << " vagas da disciplina " << v->getDisciplina()->getCodigo()
                      << " para a turma " << v->getTurma()
                      << " do curso " << v->getOferta()->curso->getCodigo()
                      << std::endl << std::endl;
            vars_a[ std::make_pair( v->getTurma(), v->getDisciplina() ) ].push_back( v );
			break;
		 }
         case Variable::V_ALOC_ALUNO: break;
         case Variable::V_N_SUBBLOCOS: break;
         case Variable::V_DIAS_CONSECUTIVOS: break;
         case Variable::V_MIN_CRED_SEMANA: break;
         case Variable::V_MAX_CRED_SEMANA: break;
         case Variable::V_ALOC_DISCIPLINA: break;
         case Variable::V_N_ABERT_TURMA_BLOCO: break;
         case Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR: break;
         case Variable::V_SLACK_DIST_CRED_DIA_INFERIOR: break;
         }
      }

      vit++;
   }

   vit = vHash.begin();

   for (; vit != vHash.end(); ++vit )
   {
      Variable * v = new Variable( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         sLoader.setFolgas( v );
      }

      delete v;
   }

   //#ifdef DEBUG
   if ( fout )
   {
      fclose( fout );
   }
   //#endif

   if ( xSol )
   {
      delete [] xSol;
   }

   // ---------------------------------------
   // Imprimindo as variáveis x_{i,d,u,tps,t} coletadas.

   std::cout << "x\t\ti\td\t\tu\ttps\tt\n";

   ITERA_VECTOR( it_Vars_x, vars_x, Variable )
   {
      std::cout << ( *it_Vars_x )->getValue() << "\t\t"
                << ( *it_Vars_x )->getTurma() << "\t"
                << ( *it_Vars_x )->getDisciplina()->getCodigo() << "\t\t"
                << ( *it_Vars_x )->getUnidade()->getCodigo() << "\t"
                << ( *it_Vars_x )->getSubCjtSala()->getId() << "\t"
                << ( *it_Vars_x )->getDia() << "\n";
   }

   std::cout << "\n\n\n";

   // Imprimindo as variáveis a_{i,d,o} coletadas.
   std::cout << "a\t\ti\td\to\tCod.Curso\n";

   vars__A___i_d_o::iterator it_Vars_a = vars_a.begin();

   for (; it_Vars_a != vars_a.end(); ++it_Vars_a )
   {
      ITERA_VECTOR( it_Vars_a_TEMP, it_Vars_a->second, Variable )
      {
         std::cout << ( *it_Vars_a_TEMP )->getValue() << "\t\t"
                   << ( *it_Vars_a_TEMP )->getTurma() << "\t"
                   << ( *it_Vars_a_TEMP )->getDisciplina()->getCodigo() << "\t"
                   << ( *it_Vars_a_TEMP )->getOferta()->getId() << "\t"
                   << ( *it_Vars_a_TEMP )->getOferta()->curso->getCodigo() << "\n";
      }
   }
}
/*
// Usada para a modelagem tatico - aluno - com horarios
void SolverMIP::carregaVariaveisSolucaoTaticoPorAluno( int campusId, int prioridade )
{
   double * xSol = NULL;
   VariableTaticoHash::iterator vit;

   SolutionLoader sLoader( problemData, problemSolution );

   xSol = new double[ lp->getNumCols() ];

#ifndef READ_SOLUTION_TATICO_BIN
   lp->getX( xSol );
#endif

#ifdef READ_SOLUTION_TATICO_BIN

   char solName[1024];

   strcpy( solName, getSolBinFileName( campusId, prioridade, 0 ).c_str() );

   FILE* fin = fopen( solName,"rb");

   int nCols = 0;

   fread(&nCols,sizeof(int),1,fin);

   if ( nCols == lp->getNumCols() )
   {
      for (int i =0; i < nCols; i++)
      {
         double auxDbl;
         fread(&auxDbl,sizeof(double),1,fin);
         xSol[i] = auxDbl;
      }
   }

   fclose(fin);
#endif

   std::map< std::pair<Disciplina*, Oferta*>, int > mapSlackDemanda;
   std::map< std::pair<Disciplina*, Oferta*>, int >::iterator itMapSlackDemanda;

   vars_xh.clear();
   
   char solFilename[1024], id[100];
   strcpy( solFilename, "solucaoTatico" );
   _itoa_s( campusId, id, 100, 10 );
   strcat( solFilename, id );
   _itoa_s( prioridade, id, 100, 10 );
   strcat( solFilename, "_P" );
   strcat( solFilename, id );
   strcat( solFilename, ".txt" );

   FILE * fout = fopen( solFilename, "wt" );
   
   vit = vHashTatico.begin();

   while ( vit != vHashTatico.end() )
   {
      VariableTatico * v = new VariableTatico( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         //#ifdef DEBUG
         char auxName[100];
         lp->getColName( auxName, col, 100 );
         fprintf( fout, "%s = %f\n", auxName, v->getValue() );
         //#endif

		 Trio< int, int, Disciplina* > trio;

         switch( v->getType() )
         {
			 case VariableTatico::V_ERROR:
				std::cout << "Variável inválida " << std::endl;
				break;
			 case VariableTatico::V_CREDITOS:				 					 
				 
				 trio.set( v->getUnidade()->getIdCampus(), v->getTurma(), v->getDisciplina() );

				 std::cout << problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size() << " vagas para a oferta"
				   		   << " de " << v->getDisciplina()->getCalendario()->retornaNroCreditosEntreHorarios
															( v->getHorarioAulaInicial(), v->getHorarioAulaFinal() )
						  << " creditos da disciplina " << v->getDisciplina()->getCodigo()
						  << " para a turma " << v->getTurma()
						  << " no dia " << v->getDia()
						  << " no horario " << v->getHorarioAulaInicial()->getId()
						  << " para a sala " << v->getSubCjtSala()->salas.begin()->first
						  << std::endl << std::endl;
				 vars_xh.add(v);
				break;
			 case VariableTatico::V_ABERTURA: break;
			 case VariableTatico::V_DIAS_CONSECUTIVOS: break;
			 case VariableTatico::V_MIN_CRED_SEMANA: break;
			 case VariableTatico::V_MAX_CRED_SEMANA: break;
			 case VariableTatico::V_SLACK_DIST_CRED_DIA_SUPERIOR: break;
			 case VariableTatico::V_SLACK_DIST_CRED_DIA_INFERIOR: break;

			 case VariableTatico::V_SLACK_DEMANDA:

				 // ------------ Preenche mapSlackDemanda ---------------------

				 Disciplina *d = v->getDisciplina();
				 int turma = v->getTurma();
				 int campusId = v->getCampus()->getId();

				 Trio< int, int, Disciplina* > trio;
				 trio.set(campusId, turma, d);

				 GGroup< AlunoDemanda* > alunosDemanda = problemData->mapCampusTurmaDisc_AlunosDemanda[trio];
				 ITERA_GGROUP( itAlDem, alunosDemanda, AlunoDemanda )
				 {
					 problemData->listSlackDemandaAluno.add( *itAlDem );				 

					 itMapSlackDemanda = mapSlackDemanda.find( std::make_pair( d, itAlDem->demanda->oferta ) );
					 if ( itMapSlackDemanda != mapSlackDemanda.end() )
						 itMapSlackDemanda->second = itMapSlackDemanda->second + 1;
					 else
						mapSlackDemanda[ std::make_pair( d, itAlDem->demanda->oferta ) ] = 1;			 
				 }
				 // ------------------------------------------------------------

				 break;
         }
      }
	  else
	  {
		 delete v;
	  }

      vit++;
   }
	std::cout << std::endl;

   // Escreve um resumo do não-atendimento das demandas, juntando
   // as demandas não atendidas por oferta.
	itMapSlackDemanda = mapSlackDemanda.begin();
	for ( ; itMapSlackDemanda != mapSlackDemanda.end() ; itMapSlackDemanda++ )
	{
		fprintf( fout, "FD_{_Disc%d_Oft%d} = %d\n",
			itMapSlackDemanda->first.first->getId(), 
			itMapSlackDemanda->first.second->getId(), 
			itMapSlackDemanda->second );
	}

	std::cout << std::endl;

	

	// -----------------------------------------------------------------------------
	// Retira dos maps mapAluno_CampusTurmaDisc e mapCampusTurmaDisc_AlunosDemanda
	// os atendimentos incompletos ( atendeu só disc pratica ou só teorica ), e os
	// acrescenta em listSlackDemandaAluno.
	// Deleta os atendimentos em vars_xh que não tiverem nenhum aluno alocado.
	#pragma region Retira Atendimentos Incompletos
    ITERA_GGROUP_LESSPTR( itSlack, problemData->listSlackDemandaAluno, AlunoDemanda )
	{		
		Aluno *aluno = problemData->retornaAluno( itSlack->getAlunoId() );
		int campusId = itSlack->demanda->oferta->getCampusId();
		int discId = - itSlack->demanda->getDisciplinaId();

		// Se existir a disciplina teorica/pratica correspondente
		if ( problemData->refDisciplinas.find( discId ) != 
			 problemData->refDisciplinas.end() )
		{
			Disciplina *disciplina = problemData->refDisciplinas[ discId ];

			// Se o aluno estiver alocado em alguma turma da disciplina
			// retira-o, eliminando atendimento parcial
			int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );
			if ( turma != -1 )
			{
				AlunoDemanda *ad = problemData->procuraAlunoDemanda( discId, aluno->getAlunoId() );

				if ( ad == NULL )
				{
					std::cout<<"\nErro em carregaVariaveisSolucaoTaticoPorAluno: AlunoDemanda nao encontrado.\n";
					std::cout<<"Aluno"<<aluno->getAlunoId()<<" Disc"<<discId<<"\n";
				}

				Trio< int, int, Disciplina* > trio;
				trio.set( campusId, turma, disciplina );

				problemData->mapAluno_CampusTurmaDisc[aluno].remove( trio );
				
				problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].remove( ad );
				 
				problemData->listSlackDemandaAluno.add( ad );

				int nroAlunos = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].size();

				if ( nroAlunos == 0 )
				{
					GGroup< VariableTatico *> remover;
					GGroup< VariableTatico *> todos;

					ITERA_GGROUP( itVarXh, vars_xh, VariableTatico )
					{
						VariableTatico *v = *itVarXh;
						
						todos.add( v );

						if ( v->getTurma() == turma &&
							 v->getDisciplina() == disciplina &&
							 problemData->retornaCampus( v->getUnidade()->getId() )->getId() == campusId )
						{
							remover.add( v );
						}
					}
					vars_xh.clear();
					ITERA_GGROUP( itVarXh, todos, VariableTatico )
					{
						bool inserir = true;
						ITERA_GGROUP( itRemover, remover, VariableTatico )
						{
							if ( *itRemover == *itVarXh )
								inserir = false;
						}
						if ( inserir )
							vars_xh.add( *itVarXh );
					}

					problemData->mapCampusTurmaDisc_AlunosDemanda.erase( trio );
				}
			}
		}
	}
	#pragma endregion
	// -----------------------------------------------------------------------------

	

   vit = vHashTatico.begin();
   for (; vit != vHashTatico.end(); ++vit )
   {
      VariableTatico * v = new VariableTatico( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         sLoader.setFolgas( v );
      }

      delete v;
   }

   //#ifdef DEBUG
   if ( fout )
   {
      fclose( fout );
   }
   //#endif

   if ( xSol )
   {
      delete [] xSol;
   }

}
*/

// Usada para a modelagem tatico - aluno - sem horarios



/*
	Retorna o valor minimo a ser assumido pela variavel em sua criação.
	Função usada a partir da iteração de prioridade 2 de demandas, a fim de
	considerar a otimização do tatico da iteração anterior.
*/
int SolverMIP::fixaLimiteInferiorVariavelPre( VariablePre *v )
{
#ifndef PRE_TATICO
	return 0;
#endif

#ifdef PRE_TATICO
			   
	return 0;

	switch( v->getType() )
	{
		
		 case VariablePre::V_ERROR:
		 {
			 return true;
		 }
		 case VariablePre::V_PRE_CREDITOS:  //  x_{i,d,u,s} 
		 {
			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {
					 HorarioAula *hf = vSol->getHorarioAulaFinal();
					 HorarioAula *hi = vSol->getHorarioAulaInicial();

					 int nCreditos = vSol->getDisciplina()->getCalendario()->retornaNroCreditosEntreHorarios( hi, hf );

					 return nCreditos; 
				 }
				
			 }

			 return 0;

		 }
		 case VariablePre::V_PRE_OFERECIMENTO:  //  o_{i,d,u,s}
		 {
			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
					  return 1;
			 }

			 return 0;
		 }
		case VariablePre::V_PRE_ABERTURA: // z_{i,d,cp}
		 {
			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  problemData->retornaCampus( vSol->getUnidade()->getId() ) == v->getCampus() )
					  return 1;
			 }

			 return 0;
		 }
		 case VariablePre::V_PRE_ALUNOS:  //  a_{i,d,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 int nroDeAtendimentos = problemData->atendeTurmaDiscOferta( turma, discId, ofertaId );

			 if ( ! nroDeAtendimentos )
			 {
				return 0;
			 } 

			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {					 
					return nroDeAtendimentos;
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_ALOC_ALUNO:  //  b_{i,d,c}
		 {
			 Curso *curso = v->getCurso();

			 ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
			 {
				 if ( itOft->curso == curso )
				 {
					 int ofertaId = itOft->getId();
					 int discId = v->getDisciplina()->getId();
					 int turma = v->getTurma();

					 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					 {
						return 1;
					 } 					
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_DEMANDA: // fd_{i,d,cp}
		 {	
			 return 0;
		 } 		 
		 case VariablePre::V_PRE_SLACK_COMPARTILHAMENTO:  // fc_{i,d,c1,c2}
		 {
			 Curso* curso1 = v->getParCursos().first;
			 Curso* curso2 = v->getParCursos().second;
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 ITERA_GGROUP_LESSPTR( itOft1, problemData->ofertas, Oferta )
			 {
				 if ( itOft1->curso == curso1 )
				 {
					int ofertaId = itOft1->getId();

					if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					{
						 ITERA_GGROUP_INIC_LESSPTR( itOft2, itOft1, problemData->ofertas, Oferta )
						 {
							 if ( itOft2->curso == curso2 )
							 {
								 int ofertaId = itOft2->getId();

								 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
								 {
									return 1;
								 } 
							 }
						 }
					} 
				 }
			 }

			 return 0;
		 }		 
		 case VariablePre::V_PRE_SLACK_SALA:  //  fs_{d,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int n = 0;

			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {			
					 int turma = vSol->getTurma();
					 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					 {
						n++;
					 }
				 }
			 }

 			 if ( n <= 1 )
				return 0;
			 else
				 return n-1;
		 }
		 case VariablePre::V_PRE_LIM_SUP_CREDS_SALA:  //  Hs_{cp}
		 {
			  return 0;
		 }
		 case VariablePre::V_PRE_ALOC_ALUNO_OFT:  //  c_{i,d,u,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 if ( ! problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
			 {
				return 0;
			 } 

			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {					 
					return 1;
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC:  // s_{a,i,d,cp}
		 {
			 Aluno* aluno = v->getAluno();
			 int campusId = v->getCampus()->getId();
			 Disciplina *disciplina = v->getDisciplina();
			 int turma = v->getTurma();

		 	 std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator itMap =
				problemData->mapAluno_CampusTurmaDisc.find( aluno );
			 
			 if ( itMap == problemData->mapAluno_CampusTurmaDisc.end() )
				 return 0;

			 Trio< int, int, Disciplina* > trio;
			 trio.set( campusId, turma, disciplina );

			 GGroup< Trio< int , int, Disciplina* > >::iterator itGGroup =
				 itMap->second.find( trio );
			 
			 if ( itGGroup != itMap->second.end() )
			 {
				  return 1;
			 }

			 return 0;
		 }

		 default:
		 {
			return 0;
			break;
		 }
	}

#endif

}

bool SolverMIP::criaVariavelTatico_Anterior( VariableTatico *v )
{
	// pesquisa se existe outra x com a turma e disciplina (dia diferente por ex).
	// se existir, não cria a variavel.
	// se não existir, então é pq é turma nova. Cria.

	if ( v->getType() == VariableTatico::V_CREDITOS )  //  x_{i,d,u,s,hi,hf,t} 
	{
		bool turmaExiste=false;
		ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
		{
			VariableTatico *vSol = *it_Vars_x;
			if ( vSol->getTurma() == v->getTurma() &&
				 vSol->getDisciplina() == v->getDisciplina() && 
				 vSol->getUnidade()->getIdCampus() == v->getUnidade()->getIdCampus() )
			{				
				turmaExiste=true;

				if ( vSol->getUnidade() == v->getUnidade() &&
				     vSol->getSubCjtSala() == v->getSubCjtSala() )
				{
					if ( vSol->getDia() == v->getDia() &&
						vSol->getHorarioAulaInicial() == v->getHorarioAulaInicial() &&
						vSol->getHorarioAulaFinal() == v->getHorarioAulaFinal() )
					{
						return true;
					}
				}
				else
				{	// sala diferente, não pode!
					return false;
				}
			}
		}

		if ( turmaExiste ) 
			return false;

		// turma nova. Não existe em iteração tática anterior.
		return true;				
	}

	return true;
}

bool SolverMIP::criaVariavelTatico( VariableTatico *v )
{
#ifndef PRE_TATICO
	return true;
#endif

#ifdef PRE_TATICO

	VariablePre preV;
		   
	switch( v->getType() )
	{
		
		 case VariableTatico::V_ERROR:
		 {
			 return true;
		 }
		 case VariableTatico::V_CREDITOS:  //  x_{i,d,u,s,hi,hf,t} 
		 {
			 preV.reset();
			 preV.setType( VariablePre::V_PRE_CREDITOS ); // x_{i,d,u,s}
			 preV.setTurma( v->getTurma() );
			 preV.setDisciplina( v->getDisciplina() );
			 preV.setUnidade( v->getUnidade() );
			 preV.setSubCjtSala( v->getSubCjtSala() );

			 if ( SolVarsPreFound(preV) )
				return true;
			 else
				return false;
		 }
		case VariableTatico::V_ABERTURA: // z_{i,d,cp}
		 {
			 // z_{i,d,cp}
			 if ( problemData->existeTurmaDiscCampus( v->getTurma(), v->getDisciplina()->getId(), v->getCampus()->getId() ) )
				return true;
			 
			 return false;

			 //preV.reset();
			 //preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
			 //preV.setTurma( v->getTurma() );
			 //preV.setDisciplina( v->getDisciplina() );
			 //preV.setCampus( v->getCampus() );
		 	//	 
			 //if ( SolVarsPreFound(preV) )
				//return true;
			 //else
				//return false;
		 }
		 case VariableTatico::V_DIAS_CONSECUTIVOS: // c_{i,d,t}
		 {
			 // z_{i,d,cp}
			 if ( problemData->existeTurmaDiscCampus( v->getTurma(), v->getDisciplina()->getId(), v->getCampus()->getId() ) )
				return true;
			 
			 return false;

			 //preV.reset();
			 //preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
			 //preV.setTurma( v->getTurma() );
			 //preV.setDisciplina( v->getDisciplina() );
			 //preV.setCampus( v->getCampus() );		 // cp

			 //if ( SolVarsPreFound( preV ) )
				// return true;
			 //else
				//return false;
		 }
		 case VariableTatico::V_MAX_CRED_SEMANA: // H_{a}
		 {
			 Aluno *aluno = v->getAluno();
	
			 if ( problemData->mapAluno_CampusTurmaDisc.find(aluno) !=
				  problemData->mapAluno_CampusTurmaDisc.end() )
			 {
				 if ( problemData->mapAluno_CampusTurmaDisc[aluno].size() > 0 )
					return true;			
			 }

			 return false;
		 }
		 case VariableTatico::V_MIN_CRED_SEMANA: // h_{a}
		 {
			 Aluno *aluno = v->getAluno();
	
			 if ( problemData->mapAluno_CampusTurmaDisc.find(aluno) !=
				  problemData->mapAluno_CampusTurmaDisc.end() )
			 {
				 if ( problemData->mapAluno_CampusTurmaDisc[aluno].size() > 0 )
					return true;			
			 }

			 return false;
		 }
		 case VariableTatico::V_ALUNO_UNID_DIA:// y_{a,u,t}
		 {
			 Aluno *aluno = v->getAluno();
			 Unidade *unid = v->getUnidade();
			 Campus *cp = problemData->retornaCampus( unid->getId() );
	
			 if ( problemData->mapAluno_CampusTurmaDisc.find(aluno) !=
				  problemData->mapAluno_CampusTurmaDisc.end() )
			 {
				 GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >::iterator
					 itTrio = problemData->mapAluno_CampusTurmaDisc[aluno].begin();

				 for ( ; itTrio != problemData->mapAluno_CampusTurmaDisc[aluno].end(); itTrio++ )
				 {
					 if ( (*itTrio).first != cp->getId() ) continue;

					 int turma = (*itTrio).second;
					 Disciplina *disc = (*itTrio).third;
					 
					 ITERA_GGROUP_LESSPTR( itCjtSala, unid->conjutoSalas, ConjuntoSala )
					 {
						preV.reset();
						preV.setType( VariablePre::V_PRE_CREDITOS ); //x_{i,d,u,s}
						preV.setTurma( turma );
						preV.setDisciplina( disc );
						preV.setUnidade( unid );
						preV.setSubCjtSala( *itCjtSala );

						if ( SolVarsPreFound( preV ) )
							return true;
					 }					
				 }						 
			 }
			 return false;
		 }
		 case VariableTatico::V_SLACK_DIST_CRED_DIA_SUPERIOR: // fcp_{i,d,s,t}
		 {
			 preV.reset();
			 preV.setType( VariablePre::V_PRE_CREDITOS ); // x_{i,d,u,s}
			 preV.setTurma( v->getTurma() );
			 preV.setDisciplina( v->getDisciplina() );
			 preV.setUnidade( v->getUnidade() );
			 preV.setSubCjtSala( v->getSubCjtSala() );

			 if ( SolVarsPreFound(preV) )
				return true;
			 else
				return false;
		 }
		 case VariableTatico::V_SLACK_DIST_CRED_DIA_INFERIOR: // fcm_{i,d,s,t}
		 {
			 preV.reset();
			 preV.setType( VariablePre::V_PRE_CREDITOS ); // x_{i,d,u,s}
			 preV.setTurma( v->getTurma() );
			 preV.setDisciplina( v->getDisciplina() );
			 preV.setUnidade( v->getUnidade() );
			 preV.setSubCjtSala( v->getSubCjtSala() );

			 if ( SolVarsPreFound(preV) )
				return true;
			 else
				return false;
		 }
		 case VariableTatico::V_SLACK_DEMANDA: // fd_{i,d,cp}
		 {	
			 // Só cria se a turma existir, criando a possibilidade de desaloca-la, caso não seja fixada depois.
			 if ( !problemData->existeTurmaDiscCampus( v->getTurma(), v->getDisciplina()->getId(), v->getCampus()->getId() ) )
			 	return false;

			 return true;			
		 }
		 case VariableTatico::V_SLACK_SLACKDEMANDA_PT: // ffd_{i,d,i',d',cp}
		 {	
			 // Só cria se as duas turmas existirem, criando a possibilidade de desaloca-las, caso não sejam fixadas depois.
			 if ( !problemData->existeTurmaDiscCampus( v->getTurma1(), v->getDisciplina1()->getId(), v->getCampus()->getId() ) )
				return false;
			 if ( !problemData->existeTurmaDiscCampus( v->getTurma2(), v->getDisciplina2()->getId(), v->getCampus()->getId() ) )
			 	return false;

			 return true;			
		 }
		 case VariableTatico::V_COMBINACAO_DIVISAO_CREDITO: // m{i,d,k}
		 {
			 // z_{i,d,cp}
			 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
			 {
				 int cpId = (*itCp)->getId();
				 if ( problemData->existeTurmaDiscCampus( v->getTurma(), v->getDisciplina()->getId(), cpId ) )
				 	return true;
			 }			 
			 return false;

			 //preV.reset();
			 //preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
			 //preV.setTurma( v->getTurma() );
			 //preV.setDisciplina( v->getDisciplina() );

			 //ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
			 //{
				// preV.setCampus( *itCp );
				// if ( SolVarsPreFound( preV ) )
				//	 return true;
			 //}
			 //return false;
		 }
		 case VariableTatico::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M: // fkm{i,d,k}
		 {
			 // z_{i,d,cp}
			 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
			 {
				 int cpId = (*itCp)->getId();
				 if ( problemData->existeTurmaDiscCampus( v->getTurma(), v->getDisciplina()->getId(), cpId ) )
				 	return true;
			 }			 
			 return false;

			 //preV.reset();
			 //preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
			 //preV.setTurma( v->getTurma() );
			 //preV.setDisciplina( v->getDisciplina() );

			 //ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
			 //{
				// preV.setCampus( *itCp );
				// if ( SolVarsPreFound( preV ) )
				//	 return true;
			 //}
			 //return false;
		 }
		 case VariableTatico::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P: // fkp{i,d,t}
		 {
			 // z_{i,d,cp}
			 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
			 {
				 int cpId = (*itCp)->getId();
				 if ( problemData->existeTurmaDiscCampus( v->getTurma(), v->getDisciplina()->getId(), cpId ) )
				 	return true;
			 }			 
			 return false;

			 //preV.reset();
			 //preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
			 //preV.setTurma( v->getTurma() );
			 //preV.setDisciplina( v->getDisciplina() );

			 //ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
			 //{
				// preV.setCampus( *itCp );
				// if ( SolVarsPreFound( preV ) )
				//	 return true;
			 //}
			 //return false;
		 }
		 case VariableTatico::V_ABERTURA_COMPATIVEL: // zc_{d,t,cp}
		 {
			 // z_{i,d,cp}
			 for ( int turma = 0; turma < v->getDisciplina()->getNumTurmas(); turma++ )
			 {
				 if ( problemData->existeTurmaDiscCampus( turma, v->getDisciplina()->getId(), v->getCampus()->getId() ) )
				 	return true;
			 }			 
			 return false;

			 //preV.reset();
			 //preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
			 //preV.setDisciplina( v->getDisciplina() );
			 //preV.setCampus( v->getCampus() );

			 //for ( int turma = 0; turma < v->getDisciplina()->getNumTurmas(); turma++ )
			 //{
				//preV.setTurma( turma );
				//if	( SolVarsPreFound( preV ) )
				//	return true;
			 //}			 
			 //return false;
		 }		 		 
		 case VariableTatico::V_ALUNO_VARIAS_UNID_DIA: // w_{a,t}
		 {
			 Aluno *aluno = v->getAluno();
	
			 if ( problemData->mapAluno_CampusTurmaDisc.find(aluno) !=
				  problemData->mapAluno_CampusTurmaDisc.end() )
			 {
				 if ( problemData->mapAluno_CampusTurmaDisc[aluno].size() > 0 )
					return true;			
			 }

			 return false;
		 }
		
		 default:
		 {
			return true;
			break;
		 }
	}

#endif

}

GGroup< VariableTatico*, LessPtr<VariableTatico> > SolverMIP::retornaVariableTaticoCreditosAnterior( int turma, Disciplina* disciplina, Campus* campus )
{	
	GGroup< VariableTatico*, LessPtr<VariableTatico> > variaveis;
	VariableTatico v;

	v.reset();
	v.setType( VariableTatico::V_CREDITOS ); // x_{i,d,u,s,hi,hf,t}
	v.setTurma( turma );
	v.setDisciplina( disciplina );

	ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
	{
		v.setUnidade( *itUnid );

		ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
		{			
			v.setSubCjtSala( (*itCjtSala) );
			Sala* s = (*itCjtSala)->salas.begin()->second;
			v.setSala( s );

			ITERA_GGROUP_N_PT( itDia, disciplina->diasLetivos, int )
			{
				v.setDia( *itDia );
				
				ITERA_GGROUP( itHorInic, s->horarios_disponiveis, Horario )
				{			
					v.setHorarioAulaInicial( (*itHorInic)->horario_aula );

					ITERA_GGROUP( itHorFinal, s->horarios_disponiveis, Horario )
					{			
						v.setHorarioAulaFinal( (*itHorFinal)->horario_aula );		

						GGroup< VariableTatico*, LessPtr<VariableTatico> >::iterator
							it = solVarsTatico.find( &v );
						if ( it != solVarsTatico.end() )
						{
							variaveis.add( *it );
						}
					}
				}
			}
		}
	}
	
	return variaveis;
}

Unidade* SolverMIP::retornaUnidadeDeAtendimento( int turma, Disciplina* disciplina, Campus* campus )
{
	Unidade *unid = NULL;

	VariablePre preV;		   
	preV.reset();
	preV.setType( VariablePre::V_PRE_CREDITOS ); // x_{i,d,u,s}
	preV.setTurma( turma );
	preV.setDisciplina( disciplina );

	ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
	{
		unid = *itUnid;
		preV.setUnidade( unid );

		ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
		{
			preV.setSubCjtSala( *itCjtSala );

			if ( SolVarsPreFound(preV) )
				return unid;
		}
	}
	
	return NULL;
}

ConjuntoSala* SolverMIP::retornaSalaDeAtendimento( int turma, Disciplina* disciplina, Campus* campus )
{
	ConjuntoSala *s = NULL;

	VariablePre preV;		   
	preV.reset();
	preV.setType( VariablePre::V_PRE_CREDITOS ); // x_{i,d,u,s}
	preV.setTurma( turma );
	preV.setDisciplina( disciplina );

	ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
	{
		preV.setUnidade( *itUnid );

		ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
		{
			s = *itCjtSala;
			preV.setSubCjtSala( s );

			if ( SolVarsPreFound(preV) )
				return s;
		}
	}
	
	return NULL;
}

Unidade* SolverMIP::retornaUnidadeDeAtendimentoTaticoAnterior( int turma, Disciplina* disciplina, Campus* campus )
{
	Unidade *unid = NULL;

	Variable v;		   
	v.reset();
	v.setType( Variable::V_CREDITOS ); // x_{i,d,u,s,t}
	v.setTurma( turma );
	v.setDisciplina( disciplina );

	ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
	{
		unid = *itUnid;
		v.setUnidade( unid );

		ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
		{
			v.setSubCjtSala( *itCjtSala );
			v.setSala( (*itCjtSala)->salas.begin()->second );

			ITERA_GGROUP_N_PT( itDia, disciplina->diasLetivos, int )
			{
				v.setDia( *itDia );

				if ( solVars.find( &v ) != solVars.end() )
					return unid;
			}
		}
	}
	
	return NULL;
}

ConjuntoSala* SolverMIP::retornaSalaDeAtendimentoTaticoAnterior( int turma, Disciplina* disciplina, Campus* campus )
{
	ConjuntoSala *s = NULL;

	Variable v;		   
	v.reset();
	v.setType( Variable::V_CREDITOS ); // x_{i,d,u,s}
	v.setTurma( turma );
	v.setDisciplina( disciplina );

	ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
	{
		v.setUnidade( *itUnid );

		ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
		{
			s = *itCjtSala;
			v.setSubCjtSala( s );
			v.setSala( s->salas.begin()->second );

			ITERA_GGROUP_N_PT( itDia, disciplina->diasLetivos, int )
			{
				v.setDia( *itDia );

				if ( solVars.find( &v ) != solVars.end() )
					return s;
			}
		}
	}
	
	return NULL;
}


std::pair<ConjuntoSala*, GGroup<int> > SolverMIP::retornaSalaEDiasDeAtendimentoTaticoAnterior( int turma, Disciplina* disciplina, Campus* campus )
{
	std::pair<ConjuntoSala*, GGroup<int> > atendimentos;
	GGroup<int> dias;

	ConjuntoSala *s = NULL;

	Variable v;		   
	v.reset();
	v.setType( Variable::V_CREDITOS ); // x_{i,d,u,s}
	v.setTurma( turma );
	v.setDisciplina( disciplina );

	ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
	{
		v.setUnidade( *itUnid );

		ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
		{
			s = *itCjtSala;
			v.setSubCjtSala( s );
			v.setSala( s->salas.begin()->second );

			ITERA_GGROUP_N_PT( itDia, disciplina->diasLetivos, int )
			{
				v.setDia( *itDia );

				if ( solVars.find( &v ) != solVars.end() )
				{					
					atendimentos.first = s;
					dias.add( *itDia );				
				}
			}
		}
	}

	if ( dias.size() != 0 )
	{		
		atendimentos.second = dias;
	}

	return atendimentos;
}


GGroup< std::pair< int,Disciplina* > > SolverMIP::retornaAtendEmCjtSala( ConjuntoSala * cjtSala )
{
	GGroup< std::pair<int,Disciplina*>  > turmaDiscsAtendidas;

	ITERA_GGROUP_LESSPTR ( it, solVarsXPre, VariablePre )
	{
		VariablePre *var = *it;
		if ( var->getType() == VariablePre::V_PRE_CREDITOS )
		{
			ConjuntoSala *subCjtSala = var->getSubCjtSala();

			if ( subCjtSala == cjtSala )
			{
				int turma = var->getTurma();
				Disciplina * disc = var->getDisciplina();

				std::pair< int, Disciplina* > par = std::make_pair( turma, disc );

				turmaDiscsAtendidas.add( par );
			}
		}
	}

	return turmaDiscsAtendidas;
}

GGroup< std::pair< int,Disciplina* > > SolverMIP::retornaAtendTaticoEmCjtSala( ConjuntoSala * cjtSala )
{
	GGroup< std::pair<int,Disciplina*>  > turmaDiscsAtendidas;

	 GGroup< Variable *, LessPtr<Variable> >::iterator it = solVars.begin();
	for ( ; it != solVars.end() ; it++ )
	{
		Variable *var = *it;
		if ( var->getType() == Variable::V_CREDITOS )
		{
			ConjuntoSala *subCjtSala = var->getSubCjtSala();

			if ( subCjtSala == cjtSala )
			{
				int turma = var->getTurma();
				Disciplina * disc = var->getDisciplina();

				std::pair< int, Disciplina* > par = std::make_pair( turma, disc );

				turmaDiscsAtendidas.add( par );
			}
		}
	}

	return turmaDiscsAtendidas;
}


GGroup< Trio< int, Disciplina*, int > > SolverMIP::retornaAtendEmCjtSalaDia( ConjuntoSala * cjtSala, int dia )
{
	// turma, disciplina, numero de creditos
	GGroup< Trio< int, Disciplina*, int >  > turmaDiscsAtendidas;

	GGroup< Variable *, LessPtr<Variable> >::iterator it = solVars.begin();
	for ( ; it != solVars.end() ; it++ )
	{
		Variable *var = *it;
		if ( var->getType() == Variable::V_CREDITOS )
		{
			ConjuntoSala *var_cjtSala = var->getSubCjtSala();
			int var_dia = var->getDia();

			if ( var_cjtSala == cjtSala &&
				 var_dia == dia )
			{
				int turma = var->getTurma();
				Disciplina * disc = var->getDisciplina();
				int nCreds = var->getValue();

				Trio< int, Disciplina*, int > trio;
				trio.set( turma, disc, nCreds );

				turmaDiscsAtendidas.add( trio );
			}
		}
	}

	return turmaDiscsAtendidas;
}


double SolverMIP::retornaNCredsAlocados( int turma, Disciplina* disciplina, int dia, int campusId )
{
	// numero de creditos
	double nCreds = 0.0;

	GGroup< Variable *, LessPtr<Variable> >::iterator it = solVars.begin();
	for ( ; it != solVars.end() ; it++ )
	{
		Variable *var = *it;
		if ( var->getType() == Variable::V_CREDITOS )
		{
			int var_dia = var->getDia();
			int var_turma = var->getTurma();
			Disciplina *var_disciplina = var->getDisciplina();
			int var_campusId = var->getUnidade()->getIdCampus();

			if ( var_dia == dia &&
				 var_turma == turma &&
				 var_disciplina == disciplina && 
				 var_campusId == campusId )
			{
				int nCreds = var->getValue();
				return nCreds;
			}
		}
	}

	return nCreds;
}

int SolverMIP::retornaCombinacaoSLAlunoTaticoAnterior( Aluno* aluno, int dia )
{
	ITERA_GGROUP_LESSPTR ( itVar, solVars, Variable )
	{
		if( (*itVar)->getType() == Variable::V_COMBINA_SL_ALUNO )
		{
			Variable vSol = **itVar;		

			if ( vSol.getAluno() == aluno &&
				 vSol.getDia() == dia &&
				 abs( vSol.getValue() - 1.0 ) < 1e-5 )
			{
					return vSol.getCombinaSLAluno();
			}			
		}
	}

	//std::cout<<"\nAtencao em SolverMIP::retornaCombinacaoSLAlunoTaticoAnterior."
	//<<"\nVariavel nao encontrada para o aluno "<<aluno->getAlunoId()<<" dia "<<dia;
	
	return -1;
}

bool SolverMIP::criaVariavelTatico( Variable *v )
{
#ifndef PRE_TATICO
	return true;
#endif

#ifdef PRE_TATICO
	
	VariablePre preV;
	
	switch( v->getType() )
	{
	 case Variable::V_ABERTURA: // z_{i,d,cp}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setCampus( v->getCampus() );
		 		 
		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
     case Variable::V_ALUNOS:	// a_{i,d,oft}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALUNOS );  // a_{i,d,u,s,oft}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setOferta( v->getOferta() );
		 
		ITERA_GGROUP_LESSPTR( itUnid, v->getOferta()->campus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
			{
				 preV.setSubCjtSala( *itCjtSala );
				 preV.setUnidade( *itUnid );
				 if ( SolVarsPreFound( preV ) )
					 return true;
			}
		}
		return false;
	 }
     case Variable::V_CREDITOS:  // x_{i,d,u,s,t}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_CREDITOS ); // x_{i,d,u,s}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setUnidade( v->getUnidade() );
		 preV.setSubCjtSala( v->getSubCjtSala() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
     case Variable::V_DIAS_CONSECUTIVOS: // c_{i,d,t,cp}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setCampus( v->getCampus() );		 // cp

		 if ( SolVarsPreFound( preV ) )
		 	 return true;
		 else
			return false;
	 }
     case Variable::V_ERROR:
	 {
		 return true;
	 }
     case Variable::V_MAX_CRED_SEMANA: // H_{bc,i}
	 {
		 Oferta *oft = v->getBloco()->oferta;

		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT ); // c_{i,d,s,oft}
		 preV.setTurma( v->getTurma() );
		 preV.setOferta( oft );
		 	
		 ITERA_GGROUP_LESSPTR( itUnid, oft->campus->unidades, Unidade )
		 {
			preV.setUnidade( *itUnid );
			ITERA_GGROUP_LESSPTR( itCjtSala, (*itUnid)->conjutoSalas, ConjuntoSala )
			{
				 preV.setSubCjtSala( *itCjtSala );
				 ITERA_GGROUP_LESSPTR( itDisc, (*itCjtSala)->disciplinas_associadas, Disciplina )
				 {				 
					preV.setDisciplina( *itDisc );
					if ( SolVarsPreFound( preV ) )
						return true;
				 }
			}			 
		 }
		 return false;
	 }
     case Variable::V_MIN_CRED_SEMANA: // h_{bc,i}
	 {
		 Oferta *oft = v->getBloco()->oferta;

		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT ); // c_{i,d,s,oft}
		 preV.setTurma( v->getTurma() );
		 preV.setOferta( oft );
		 	
		 ITERA_GGROUP_LESSPTR( itUnid, oft->campus->unidades, Unidade )
		 {
			preV.setUnidade( *itUnid );
			ITERA_GGROUP_LESSPTR( itCjtSala, (*itUnid)->conjutoSalas, ConjuntoSala )
			{
				 preV.setSubCjtSala( *itCjtSala );
				 ITERA_GGROUP_LESSPTR( itDisc, (*itCjtSala)->disciplinas_associadas, Disciplina )
				 {				 
					preV.setDisciplina( *itDisc );
					if ( SolVarsPreFound( preV ) )
						return true;
				 }
			}			 
		 }
		 return false;
	 }
     case Variable::V_OFERECIMENTO: // o_{i,d,u,s,t}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_OFERECIMENTO ); // o_{i,d,s}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setUnidade( v->getUnidade() );
		 preV.setSubCjtSala( v->getSubCjtSala() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
     case Variable::V_N_SUBBLOCOS:
	 {
		 return true;
	 }
     case Variable::V_ALOC_ALUNO:// b_{i,d,c,cp}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALOC_ALUNO );		 // b_{i,d,c}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setCurso( v->getCurso() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
     case Variable::V_ALOC_DISCIPLINA:// y_{i,d,tps,u}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_OFERECIMENTO );	// o_{i,d,s}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setUnidade( v->getUnidade() );
		 preV.setSubCjtSala( v->getSubCjtSala() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
     case Variable::V_N_ABERT_TURMA_BLOCO: // v_{bc,t}
	 {
		 return true;
	 }
     case Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR: // fcp_{i,d,tps,t}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_OFERECIMENTO );	// o_{i,d,s}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setUnidade( v->getUnidade() );
		 preV.setSubCjtSala( v->getSubCjtSala() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
     case Variable::V_SLACK_DIST_CRED_DIA_INFERIOR: // fcm_{i,d,tps,t}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_OFERECIMENTO );	// o_{i,d,s}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setUnidade( v->getUnidade() );
		 preV.setSubCjtSala( v->getSubCjtSala() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
     case Variable::V_ABERTURA_SUBBLOCO_DE_BLC_DIA_CAMPUS: // r_{bc,t,cp}
	 {
		 return true;
	 }
     case Variable::V_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT: // bs_{i,d,c,c',cp}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT );	 // bs_{i,d,c1,c2}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setParCursos( v->getParCursos() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
     case Variable::V_SLACK_DEMANDA: // fd_{d,oft}
	 {
		 return true;
		 /*
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_SLACK_DEMANDA );	 // fd_{d,oft}
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setOferta( v->getOferta() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
		*/
	 }
	 case Variable::V_COMBINACAO_DIVISAO_CREDITO: // m{i,d,k}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );

		 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
		 {
			 preV.setCampus( *itCp );
			 if ( SolVarsPreFound( preV ) )
				 return true;
		 }
		 return false;
	 }
     case Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M: // fkm{i,d,t}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );

		 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
		 {
			 preV.setCampus( *itCp );
			 if ( SolVarsPreFound( preV ) )
				 return true;
		 }
		 return false;
	 }
     case Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P: // fkp{i,d,t}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );

		 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
		 {
			 preV.setCampus( *itCp );
			 if ( SolVarsPreFound( preV ) )
				 return true;
		 }
		 return false;
	 }
     case Variable::V_CREDITOS_MODF: // xm_{d,t}
	 {
		 return true;
	 }
     case Variable::V_ABERTURA_COMPATIVEL: // zc_{d,t,cp}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ABERTURA ); // z_{i,d,cp}
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setCampus( v->getCampus() );

		 for ( int turma = 0; turma < v->getDisciplina()->getNumTurmas(); turma++ )
		 {
			 preV.setTurma( turma );
			 if ( SolVarsPreFound( preV ) )
				 return true;
		 }
		 return false;
	 }
	 case Variable::V_ABERTURA_BLOCO_MESMO_TPS: // n_{bc,tps}
	 {
		 return true; // TODO
	 }
	 case Variable::V_SLACK_ABERTURA_BLOCO_MESMO_TPS: //fn_{bc,tps}
	 {
		 return true; // TODO
	 }
	 case Variable::V_SLACK_COMPARTILHAMENTO: // fc_{i,d,c1,c2,cp}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_SLACK_COMPARTILHAMENTO );	 // fc_{i,d,c1,c2}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setParCursos( v->getParCursos() );

		 if ( SolVarsPreFound(preV) )
			return true;
		 else
			return false;
	 }
 	 case Variable::V_ALOC_ALUNOS_OFT: // e_{i,d,oft} 
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALUNOS );	 // a_{i,d,s,oft}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setOferta( v->getOferta() );

		 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
		 {
			ITERA_GGROUP_LESSPTR( itUnid, itCp->unidades, Unidade )
			{
				preV.setUnidade( *itUnid );
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
				{
					preV.setSubCjtSala( *itCjtSala );
					if ( SolVarsPreFound( preV ) )
						return true;
				}
			}
		 }
		 return false;
	 }
	 case Variable::V_CREDITOS_OFT: // q_{i,d,oft,u,s,t}
	 {		 
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALUNOS );	// a_{i,d,s,oft}
		 preV.setTurma( v->getTurma() );
		 preV.setUnidade( v->getUnidade() );
		 preV.setSubCjtSala( v->getSubCjtSala() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setOferta( v->getOferta() );

		 if ( SolVarsPreFound(preV) )
		 {
			return true;
		 }
		 else
			return false;
	 }
	 case Variable::V_CREDITOS_PAR_OFT: // p_{i,d,oft1,oft2,u,s,t}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALUNOS );	 // a_{i,d,s,oft}
		 preV.setTurma( v->getTurma() );
		 preV.setUnidade( v->getUnidade() );
		 preV.setSubCjtSala( v->getSubCjtSala() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setOferta( v->getParOfertas().first );

		 if ( SolVarsPreFound(preV) )
		 {
			 preV.setOferta( v->getParOfertas().second );

			 if ( SolVarsPreFound(preV) )
			 {
				 preV.reset();
				 preV.setType( VariablePre::V_PRE_CREDITOS );  // x_{i,d,s}
				 preV.setTurma( v->getTurma() );
				 preV.setDisciplina( v->getDisciplina() );
				 preV.setUnidade( v->getUnidade() );
				 preV.setSubCjtSala( v->getSubCjtSala() );

				 if ( SolVarsPreFound(preV) )
				 {
					 return true;
				 }
				 else
					 return false;
			 }
			 else
				return false;
		 }
		 else
			return false;
	 }
	 case Variable::V_ALOC_ALUNOS_PAR_OFT: // of_{i,d,oft1,oft2}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALUNOS );	// a_{i,d,s,oft1}
		 preV.setTurma( v->getTurma() );
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setOferta( v->getParOfertas().first );

		 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
		 {
			ITERA_GGROUP_LESSPTR( itUnid, itCp->unidades, Unidade )
			{
				preV.setUnidade( *itUnid );
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
				{
					preV.setSubCjtSala( *itCjtSala );
					if ( SolVarsPreFound( preV ) )
					{
						preV.setOferta( v->getParOfertas().second );	// a_{i,d,s,oft2}

						if ( SolVarsPreFound( preV ) )
						{
							return true;
						}
						else
						{
							return false; //TODO: conferir se está certo retornar falso aqui.
						}
					}
				}
			}
		 }
		 return false;
	 }
	 case Variable::V_MIN_HOR_DISC_OFT_DIA: // g_{d,oft,t}
	 {
		 preV.reset();
		 preV.setType( VariablePre::V_PRE_ALUNOS );	// a_{i,d,s,oft}
		 preV.setDisciplina( v->getDisciplina() );
		 preV.setOferta( v->getOferta() );
		 
		 for ( int turma = 0; turma < v->getDisciplina()->getNumTurmas(); turma++ )
		 { 
			 preV.setTurma( turma );
			 ITERA_GGROUP_LESSPTR( itCp, problemData->campi, Campus )
			 {
				ITERA_GGROUP_LESSPTR( itUnid, itCp->unidades, Unidade )
				{
					preV.setUnidade( *itUnid );
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
					{
						preV.setSubCjtSala( *itCjtSala );
						if ( SolVarsPreFound( preV ) )
							return true;
					}
				}
			 }
		 }
		 return false;

	 }
	 case Variable::V_COMBINA_SL_SALA:  // cs_{s,t,k}
	 {
		 return true;
	 }	
	 case Variable::V_COMBINA_SL_BLOCO: // cbc_{cb,t,k}
	 {
		 return true;
	 }
		
	case Variable::V_MAX_CRED_SEMANA_ALUNO: // H_{a}
	{
		Aluno *aluno = v->getAluno();

		preV.reset();
		preV.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC ); //s_{i,d,a,cp}
		preV.setAluno( aluno );
			 		 	
		ITERA_GGROUP_LESSPTR( itCampi, problemData->campi, Campus )
		{
			preV.setCampus( *itCampi );
			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina* d = (*itAlDemanda)->demanda->disciplina;
				preV.setDisciplina( d );
				 
				for ( int turma = 0; turma < d->getNumTurmas(); turma++ )
				{
					preV.setTurma( turma );
					if ( SolVarsPreFound( preV ) )
						return true;
				}
			}
		}
		return false;
	}
	case Variable::V_MIN_CRED_SEMANA_ALUNO: // h_{a}
	{
		Aluno *aluno = v->getAluno();

		preV.reset();
		preV.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC ); //s_{i,d,a,cp}
		preV.setAluno( aluno );
			 		 	
		ITERA_GGROUP_LESSPTR( itCampi, problemData->campi, Campus )
		{
			preV.setCampus( *itCampi );
			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina* d = itAlDemanda->demanda->disciplina;
				preV.setDisciplina( d );
				 
				for ( int turma = 0; turma < d->getNumTurmas(); turma++ )
				{
					preV.setTurma( turma );
					if ( SolVarsPreFound( preV ) )
						return true;
				}						 
			}
		}
		return false;
	}	 
	case Variable::V_COMBINA_SL_ALUNO: // ca_{a,t,k}
	{
		Aluno *aluno = v->getAluno();

		preV.reset();
		preV.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC ); //s_{i,d,a,cp}
		preV.setAluno( aluno );
			 		 	
		ITERA_GGROUP_LESSPTR( itCampi, problemData->campi, Campus )
		{
			preV.setCampus( *itCampi );
			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina* d = itAlDemanda->demanda->disciplina;
				preV.setDisciplina( d );
				 
				for ( int turma = 0; turma < d->getNumTurmas(); turma++ )
				{
					preV.setTurma( turma );
					if ( SolVarsPreFound( preV ) )
						return true;
				}						 
			}
		}
		return false;
	}	
	 case Variable::V_SLACK_DEMANDA_ALUNO: // fd_{i,d,cp}
	 {
		 if ( problemData->existeTurmaDiscCampus( v->getTurma(), v->getDisciplina()->getId(), v->getCampus()->getId() ) )
			return true;

		 preV.reset();
		 preV.setType( VariablePre::V_PRE_SLACK_DEMANDA ); // fd_{d,a}		 
		 preV.setDisciplina( v->getDisciplina() );
		 		 
		 ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
		 {
			 if ( itAluno->getOferta()->getCampusId() == v->getCampus()->getId() )
			 {
				 preV.setAluno( *itAluno );
				 if ( SolVarsPreFound(preV) )
					return true;
			 }
		 }

		 return false;
	 }
	 case Variable::V_SLACK_SLACKDEMANDA_PT: //  ffd_{i1,d,i2,-d,cp}
	 {
		//if ( ! problemData->existeTurmaDiscCampus( v->getTurma1(), v->getDisciplina1()->getId(), v->getCampus()->getId() ) )
		//	return false;
		//if ( ! problemData->existeTurmaDiscCampus( v->getTurma2(), v->getDisciplina2()->getId(), v->getCampus()->getId() ) )
		//	return false;

		return true;	
	 }
	 case Variable::V_SLACK_ALUNO_VARIAS_UNID_DIA: //  fu_{i1,d1,i2,d2,t}
	 {
		// A criação dessa variavel já contem os filtros necessários para a sua criação.
		return true;	
	 }
	 case Variable::V_FOLGA_ABRE_TURMA_SEQUENCIAL: //  ft_{i,d}
	 {
		// só para prioridade 2 em diante
		return true;	
	 }	 
	 

     default:
	 {
		return true;
		break;
	 }
	}

#endif

}

void SolverMIP::carregaVariaveisSolucaoPreTatico( int campusId, int prioridade )
{
   double * xSol = NULL;
   VariablePreHash::iterator vit;

 //  SolutionLoader sLoader( problemData, problemSolution );

   xSol = new double[ lp->getNumCols() ];


   if ( this->CARREGA_SOLUCAO ) // #ifdef READ_SOLUTION_TATICO_BIN
   {
	   char solName[1024];

	   strcpy( solName, getSolPreBinFileName( campusId, prioridade, 0, 0 ).c_str() );

	   FILE* fin = fopen( solName,"rb");

	   if ( fin == NULL )
	   {
		   std::cout << "\nErro em SolverMIP::carregaVariaveisSolucaoPreTatico( int campusId, int prioridade ): arquivo "
					 << solName << " nao encontrado.\n";
		   exit(0);
	   }

	   int nCols = 0;

	   fread(&nCols,sizeof(int),1,fin);

	   if ( nCols == lp->getNumCols() )
	   {
		  for (int i =0; i < nCols; i++)
		  {
			 double auxDbl;
			 fread(&auxDbl,sizeof(double),1,fin);
			 xSol[i] = auxDbl;
		  }
	   }

	   fclose(fin);
   }
   else
   {
	   lp->getX( xSol );
   }

   // Deleta as variaveis em solVarsPre ----------
   std::set< VariablePre*, LessPtr<VariablePre> >::iterator it = solVarsPre.begin();
   for ( ; it != solVarsPre.end(); it++ )
   {
		delete *it;    
   }
   solVarsPre.clear();
   // --------------------------------------------

   vit = vHashPre.begin();

   char solFilename[1024];   
   strcpy( solFilename, getSolucaoPreTaticoFileName( campusId, prioridade, 0, 0 ).c_str() );

   FILE * fout = fopen( solFilename, "wt" );

   while ( vit != vHashPre.end() )
   {
      VariablePre * v = new VariablePre( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
		 solVarsPre.insert( v );
         
		 char auxName[100];
         lp->getColName( auxName, col, 100 );
         fprintf( fout, "%s = %f\n", auxName, v->getValue() );

         switch( v->getType() )
         {
			 case VariablePre::V_ERROR:
				std::cout << "Variável inválida " << std::endl;
				break;
			 case VariablePre::V_PRE_CREDITOS:
				std::cout << "Oferta de " << v->getValue()
						  << " creditos da disciplina " << v->getDisciplina()->getCodigo()
						  << " para a turma " << v->getTurma()
						  << " para alguma de sala do conjunto de salas " << v->getSubCjtSala()->getId()
						  << std::endl << std::endl;
				break;
			 case VariablePre::V_PRE_OFERECIMENTO: break;
			 case VariablePre::V_PRE_ABERTURA: break;
			 case VariablePre::V_PRE_ALUNOS:
				std::cout << "Oferecimento de " << v->getValue()
						  << " vagas da disciplina " << v->getDisciplina()->getCodigo()
						  << " para a turma " << v->getTurma()
						  << " do curso " << v->getOferta()->curso->getCodigo()
						  << std::endl << std::endl;
				break;
			 case VariablePre::V_PRE_ALOC_ALUNO: break;
			 case VariablePre::V_PRE_SLACK_DEMANDA: 
				 				 
				 // ------------ Preenche listSlackDemandaAluno ----------------
				 if ( problemData->parametros->otimizarPor == "ALUNO" )
				 {
					 Disciplina *d = v->getDisciplina();
					 Aluno *aluno = v->getAluno();

					 AlunoDemanda *ad = aluno->getAlunoDemanda( d->getId() );

					 problemData->listSlackDemandaAluno.add( ad );		 
		 					 
				 }
				 // ------------------------------------------------------------

				 break;			 
			 case VariablePre::V_PRE_SLACK_COMPARTILHAMENTO: break;
			 case VariablePre::V_PRE_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT: break;			 
         }
      }
	  else
	  {
		  delete v;
	  }

      vit++;
   }

   //#ifdef DEBUG
   if ( fout )
   {
      fclose( fout );
   }
   //#endif

   if ( xSol )
   {
      delete [] xSol;
   }

}

void SolverMIP::preencheMapAtendimentoAluno( VariablePre *&var )
{

	// Resultado da alocação de alunos no pre-modelo:
	//std::set< VariablePre*, LessPtr<VariablePre> >::iterator itSol = solVarsPre.begin();

	//for ( ; itSol != solVarsPre.end(); itSol++ )
	//{
	//	VariablePre *var = *itSol;
		if ( var->getType() == VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC )
		{
			Aluno *aluno = var->getAluno();
			int turma = var->getTurma();
			Disciplina *disciplina = var->getDisciplina();
			Campus *cp = var->getCampus();

			Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
			trio.set( cp->getId(), turma, disciplina );
				

			// Verificando consistência -------------------
			
			AlunoDemanda *alunoDemanda = aluno->getAlunoDemanda( disciplina->getId() );

			GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > > atendimentos = 
				problemData->mapAluno_CampusTurmaDisc[ aluno ];
			
			GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >::iterator
				itAtend = atendimentos.begin();

			bool repetido = false;

			for ( ; itAtend != atendimentos.end(); itAtend++ )
			{
				Disciplina *d = (*itAtend).third;
				int i = (*itAtend).second;
				if ( d == disciplina && i != turma )
				{
					if ( alunoDemanda!=NULL && alunoDemanda->getPrioridade() == 1 )
					{
						std::cout<<"\nErro em SolverMIP::preencheMapAtendimentoAluno(): "
							 <<"Aluno " << aluno->getAlunoId() << " ja esta alocado em i"
							 << i << " d"<< d->getId() << ". Alocacao repetida: i"
							 << turma << " d" << disciplina->getId() << "\n";
					}
					repetido = true;
				}
			}
			// --------------------------------------------
			if ( !repetido )
			{
				problemData->mapAluno_CampusTurmaDisc[ aluno ].add( trio );

				GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > ggroup = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ];
				if ( ggroup.find( alunoDemanda ) == ggroup.end() )
					problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].add( alunoDemanda );
			}
		}
//	}
	
}

void SolverMIP::limpaMapAtendimentoAlunoPrioridadeAnterior( int campusId )
{
	// Limpa a solução obtida na iteração de PRIORIDADE de demanda anterior, caso exista, do campusId

	std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator
		itMapAtendeAluno =	problemData->mapAluno_CampusTurmaDisc.begin();

	while ( itMapAtendeAluno != problemData->mapAluno_CampusTurmaDisc.end() )
	{
		Aluno *a = itMapAtendeAluno->first;
		if ( a->getOferta()->getCampusId() == campusId )
		{
			GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >::iterator
			itMapTurmas = itMapAtendeAluno->second.begin();

			for ( ; itMapTurmas != itMapAtendeAluno->second.end(); itMapTurmas++ )
			{
				Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio = *itMapTurmas;
				problemData->mapCampusTurmaDisc_AlunosDemanda.erase( trio );
			}

			problemData->mapAluno_CampusTurmaDisc.erase( a );
			itMapAtendeAluno = problemData->mapAluno_CampusTurmaDisc.begin();
		}
		else
			itMapAtendeAluno++;
	}
}

int SolverMIP::removeAtendimentosParciais( double *xSol, char solFilename[1024], int prioridade )
{	
	int nroAtendsRemovidosAlunoDemanda = 0;

	GGroup< Trio< int, int, Disciplina* > > remocao; // campusId, turma, disc

	// -----------------------------------------------------------------------------
	// Retira dos maps mapAluno_CampusTurmaDisc e mapCampusTurmaDisc_AlunosDemanda
	// os atendimentos incompletos ( atendeu só disc pratica ou só teorica ), e os
	// acrescenta em listSlackDemandaAluno.
	// Deleta os atendimentos em vars_x que não tiverem nenhum aluno alocado.
	#pragma region Retira Atendimentos Incompletos
	
	int itera=1;
	while ( 1 )
	{
		GGroup< AlunoDemanda*, LessPtr<AlunoDemanda> > novasFolgasAlDem;
		ITERA_GGROUP_LESSPTR( itSlack, problemData->listSlackDemandaAluno, AlunoDemanda )
		{		
			Aluno *aluno = problemData->retornaAluno( itSlack->getAlunoId() );
			int campusId = itSlack->demanda->oferta->getCampusId();
			int discId = -itSlack->demanda->getDisciplinaId();
			int prior = itSlack->getPrioridade();

			if ( prior != prioridade )
			{
				continue;
			}

			// Se existir a disciplina teorica/pratica correspondente
			if ( problemData->refDisciplinas.find( discId ) != 
				 problemData->refDisciplinas.end() )
			{
				Disciplina *disciplina = problemData->refDisciplinas[ discId ];

				// Se o aluno estiver alocado em alguma turma da disciplina
				// retira-o, eliminando atendimento parcial
				int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );
				if ( turma != -1 )
				{
					AlunoDemanda *ad = problemData->procuraAlunoDemanda( discId, aluno->getAlunoId(), prioridade );

					if ( ad == NULL )
					{
						std::cout<<"\nErro em carregaVariaveisSolucaoTaticoPorAluno: AlunoDemanda nao encontrado.\n";
						std::cout<<"Aluno"<<aluno->getAlunoId()<<" Disc"<<discId<<"\n";
					}

					Trio< int, int, Disciplina* > trio;
					trio.set( campusId, turma, disciplina );

					problemData->mapAluno_CampusTurmaDisc[aluno].remove( trio );				
					problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].remove( ad );
				
					problemData->mapSlackAluno_CampusTurmaDisc[aluno].add( trio );
					problemData->mapSlackCampusTurmaDisc_AlunosDemanda[ trio ].add( ad );

					std::cout<<"\nRemove "<<itera<<" (1): Aluno"<<aluno->getAlunoId()<<" AlunoDemanda"
						<<ad->getId()<<" Prior"<<ad->getPrioridade()<<" da turma"<<turma<<" disc"<<discId;

					novasFolgasAlDem.add( ad );

					if ( alunoDemandaAtendsHeuristica.find(ad) != alunoDemandaAtendsHeuristica.end() )
						alunoDemandaAtendsHeuristica.remove( ad );

					nroAtendsRemovidosAlunoDemanda++;

					int nroAlunos = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].size();

					if ( nroAlunos == 0 )
					{
						remocao.add( trio );
						problemData->mapCampusTurmaDisc_AlunosDemanda.erase( trio );
					}
					else if ( problemData->violaMinTurma( trio ) )
					{
						std::cout<<"\nViolou o min de alunos:";
						GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > >
							alunosDemanda = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ];
						ITERA_GGROUP_LESSPTR( itAlDem, alunosDemanda, AlunoDemanda )
						{
							novasFolgasAlDem.add( *itAlDem );
							std::cout<<" "<<itAlDem->getId();
						}
					}
				}
			}

			discId = itSlack->demanda->getDisciplinaId();

			// Se existir a disciplina teorica/pratica correspondente
			if ( problemData->refDisciplinas.find( discId ) != 
				 problemData->refDisciplinas.end() )
			{
				Disciplina *disciplina = problemData->refDisciplinas[ discId ];

				// Se o aluno estiver alocado em alguma turma da disciplina
				// retira-o, eliminando atendimento parcial
				int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );
				if ( turma != -1 )
				{
					AlunoDemanda *ad = *itSlack;

					Trio< int, int, Disciplina* > trio;
					trio.set( campusId, turma, disciplina );
				
					problemData->mapAluno_CampusTurmaDisc[aluno].remove( trio );				
					problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].remove( ad );
								
					problemData->mapSlackAluno_CampusTurmaDisc[aluno].add( trio );
					problemData->mapSlackCampusTurmaDisc_AlunosDemanda[ trio ].add( ad );
				
					std::cout<<"\nRemove "<<itera<<" (2): Aluno"<<aluno->getAlunoId()<<" AlunoDemanda"
						<<ad->getId()<<" Prior"<<ad->getPrioridade()<<" da turma"<<turma<<" disc"<<discId;

					if ( alunoDemandaAtendsHeuristica.find(ad) != alunoDemandaAtendsHeuristica.end() )
						alunoDemandaAtendsHeuristica.remove( ad );
										
					int nroAlunos = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].size();

					if ( nroAlunos == 0 )
					{
						remocao.add( trio );
						problemData->mapCampusTurmaDisc_AlunosDemanda.erase( trio );
					}
					else if ( problemData->violaMinTurma( trio ) )
					{
						std::cout<<"\nViolou o min de alunos:";
						GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > >
							alunosDemanda = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ];
						ITERA_GGROUP_LESSPTR( itAlDem, alunosDemanda, AlunoDemanda )
						{
							novasFolgasAlDem.add( *itAlDem );
							std::cout<<" "<<itAlDem->getId();
						}
					}
				}
			}
		}

		ITERA_GGROUP_LESSPTR( itNovasFolgas, novasFolgasAlDem, AlunoDemanda )
		{
			problemData->listSlackDemandaAluno.add( *itNovasFolgas );
		}		

		if ( novasFolgasAlDem.size() == 0 )
			break;
		itera++;
	}

	#pragma endregion
	// -----------------------------------------------------------------------------


	// -----------------------------
	// CONFERÊNCIA (pode deletar se nao estiver havendo problema)
    ITERA_GGROUP_LESSPTR( itSlack, problemData->listSlackDemandaAluno, AlunoDemanda )
	{
		Aluno *aluno = problemData->retornaAluno( itSlack->getAlunoId() );
		int campusId = itSlack->demanda->oferta->getCampusId();
		int discId = itSlack->demanda->getDisciplinaId();
		int prior = itSlack->getPrioridade();
		if ( prior != prioridade )
			continue;

		Disciplina *disciplina = problemData->refDisciplinas[ discId ];

		int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );
		if ( turma != -1 )
		{
			std::cout<<"\nErro: aluno "<<aluno->getAlunoId()<<" nao removido corretamente da turma "<<turma<<" disc "<<discId<<"\n"; fflush(NULL);
			Trio< int, int, Disciplina* > trio;
			trio.set( campusId, turma, disciplina );	
			AlunoDemanda *ad = problemData->procuraAlunoDemanda( discId, aluno->getAlunoId(), prioridade );
			problemData->mapAluno_CampusTurmaDisc[aluno].remove( trio );				
			problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].remove( ad );

			problemData->mapSlackAluno_CampusTurmaDisc[aluno].add( trio );
			problemData->mapSlackCampusTurmaDisc_AlunosDemanda[ trio ].add( ad );

			int nroAlunos = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].size();
			if ( nroAlunos == 0 )
			{
				remocao.add( trio );
				problemData->mapCampusTurmaDisc_AlunosDemanda.erase( trio );
			}

			turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );
			if ( turma != -1 )
			{ std::cout<<"\nErro DE NOVO!! Erro eh no remove entao"; fflush(NULL); }
		}
	}
	// -----------------------------


#ifndef TATICO_COM_HORARIOS

   #pragma region Preenche solVars e vars_x
   VariableHash::iterator vit;
      
   vit = vHash.begin();
   while ( vit != vHash.end() )
   {
      Variable* v = new Variable( vit->first );
      int col = vit->second;
	  double value = xSol[ col ];
      v->setValue( value );

      if ( v->getValue() > 0.00001 )
      {

         switch( v->getType() )
         {
			 case Variable::V_ERROR:
			 {
				break;
			 }
			 case Variable::V_CREDITOS:
			 {
				  Trio< int, int, Disciplina* > trio;
				  trio.set( v->getUnidade()->getIdCampus(), v->getTurma(), v->getDisciplina() );

				  if ( remocao.find( trio ) == remocao.end() )
				  {
					  solVars.add( v );
					  vars_x.push_back( v );	
				  }	
				  break;
			 }
			 case Variable::V_OFERECIMENTO:
			 {			  
				  Trio< int, int, Disciplina* > trio;
				  trio.set( v->getUnidade()->getIdCampus(), v->getTurma(), v->getDisciplina() );

				  if ( remocao.find( trio ) == remocao.end() )
				  {
					  solVars.add( v );
				  }
				  break;
			  }
			 case Variable::V_ABERTURA:
			 {
				  Trio< int, int, Disciplina* > trio;
				  trio.set( v->getCampus()->getId(), v->getTurma(), v->getDisciplina() );

				  if ( remocao.find( trio ) == remocao.end() )
				  {
					  solVars.add( v );
				  }
				  break;
			 }
			 case Variable::V_ABERTURA_COMPATIVEL:
			 {
				 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
					 itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
				 for ( ; itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMapAtend++ )
				 {
					 int discId = itMapAtend->first.third->getId();

					 if ( discId == v->getDisciplina()->getId() )
					 {
						 solVars.add( v );
						 break;
					 }
				 }
				 break;
			 }
			 case Variable::V_DIAS_CONSECUTIVOS:
			 {
				 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
					 itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
				 for ( ; itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMapAtend++ )
				 {
					 int discId = itMapAtend->first.third->getId();
					 int turma = itMapAtend->first.second;
					 int cpId = itMapAtend->first.first;

					 if ( discId == v->getDisciplina()->getId() &&
						  turma == v->getTurma() &&
						  cpId == v->getCampus()->getId() )
					 {
						 solVars.add( v );
						 break;
					 }
				 }
				 break;
			 }
			 case Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR:			// fcp_{i,d,tps,t}
			 case Variable::V_SLACK_DIST_CRED_DIA_INFERIOR:			// fcm_{i,d,tps,t}
			 case Variable::V_COMBINACAO_DIVISAO_CREDITO:			// m_{i,d,k}
			 case Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M:	// fkm{i,d,t}
			 case Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P:	// fkp{i,d,t}
			 {
				 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
					 itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
				 for ( ; itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMapAtend++ )
				 {
					 int discId = itMapAtend->first.third->getId();
					 int turma = itMapAtend->first.second;

					 if ( discId == v->getDisciplina()->getId() &&
						  turma == v->getTurma() )
					 {
						 solVars.add( v );
						 break;
					 }
				 }
				 break;
			 }
			 case Variable::V_SLACK_ALUNO_VARIAS_UNID_DIA:	// fu{i1,d1,i2,d2,t}
			 {
				 bool achou1 = false, achou2 = false;

				 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
					 itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
				 for ( ; itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMapAtend++ )
				 {
					 int discId = itMapAtend->first.third->getId();
					 int turma = itMapAtend->first.second;

					 if ( discId == v->getDisciplina1()->getId() && turma == v->getTurma1() )
					 {
						 achou1 = true;
					 }
					 if ( discId == v->getDisciplina2()->getId() && turma == v->getTurma2() )
					 {
						 achou2 = true;						 
					 }
					 if ( achou1 && achou2 )
					 {
						 solVars.add( v );
						 break;					 
					 }
				 }
				 break;
			 }
			 default:
			 {
				  // Acho que não tem problema adicionar todo o resto
				  solVars.add( v );
			 }		  

		  }
	  }
	  else
	  {
		  delete v;
	  }

	  vit++;
   }
   
   // CRIA FOLGAS e insere em solVars
   GGroup< Trio< int, int, Disciplina* > >::iterator itRemove = remocao.begin();
   for ( ; itRemove != remocao.end(); itRemove++ )
   {
	    Campus *campus = problemData->refCampus[ (*itRemove).first ];
		int turma = (*itRemove).second;
		Disciplina *d = (*itRemove).third;

		Variable *slackVar = new Variable;
		slackVar->setType( Variable::V_SLACK_DEMANDA_ALUNO );
		slackVar->setTurma( turma );
		slackVar->setDisciplina( d );
		slackVar->setCampus( campus );
		slackVar->setValue( 1 );

		solVars.add( slackVar );
   }
	#pragma endregion	    
   

   // teste
   char solPosFilename[1024];
   strcpy( solPosFilename, "pos_" );
   strcat( solPosFilename, solFilename );
   FILE * fout = fopen( solPosFilename, "wt" );
   ITERA_GGROUP_LESSPTR( itSol, solVars, Variable )
   {      
	   Variable *v = *itSol;
	   
	   fprintf( fout, "%s = %f\n", v->toString().c_str(), v->getValue() );
		   
   }
   fprintf( fout, "\nAlunosDemanda removidos = %d", nroAtendsRemovidosAlunoDemanda );
   fclose( fout );
   
#endif

#ifdef TATICO_COM_HORARIOS

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
		(*itAluno)->clearHorariosDiaOcupados();
   }

   #pragma region Preenche solVars e vars_x
   VariableTaticoHash::iterator vit;
      
   vit = vHashTatico.begin();
   while ( vit != vHashTatico.end() )
   {
      VariableTatico* v = new VariableTatico( vit->first );
      int col = vit->second;
	  double value = xSol[ col ];
      v->setValue( value );

      if ( v->getValue() > 0.00001 )
      {

         switch( v->getType() )
         {
			 case VariableTatico::V_ERROR:
			 {
				 delete v;
				 break;
			 }
			 case VariableTatico::V_CREDITOS:
			 {
				  Trio< int, int, Disciplina* > trio;
				  trio.set( v->getUnidade()->getIdCampus(), v->getTurma(), v->getDisciplina() );

				  // Insere
				  if ( remocao.find( trio ) == remocao.end() )
				  {
					  solVarsTatico.add( v );
					  vars_xh.add( v );	
						
					  // Acha horariosDias usados
					  GGroup<HorarioDia*> horariosDias;
					  int dia = v->getDia();
					  HorarioAula *hi = v->getHorarioAulaInicial();
					  HorarioAula *hf = v->getHorarioAulaFinal();
					  int nCreds = v->getDisciplina()->getCalendario()->retornaNroCreditosEntreHorarios( hi, hf );
					  HorarioAula *ha = hi;
					  for ( int i = 1; i <= nCreds; i++ )
					  {
							HorarioDia *hd = problemData->getHorarioDiaCorrespondente( ha, dia );
							horariosDias.add( hd );							
							ha = v->getDisciplina()->getCalendario()->getProximoHorario( ha );				
					  }

					  GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > 
						  alunosDemandaAlocados = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ];
					  ITERA_GGROUP_LESSPTR( itAlDem, alunosDemandaAlocados, AlunoDemanda )
					  {
						  Aluno *aluno = problemData->retornaAluno( (*itAlDem)->getAlunoId() );
						  aluno->addHorarioDiaOcupado( horariosDias );
					  }

					  Sala *sala = v->getSubCjtSala()->salas.begin()->second;
					  sala->addHorarioDiaOcupado( horariosDias );

					  hi = v->getHorarioAulaInicial();
					  hf = v->getHorarioAulaFinal();
					  std::cout << std::endl << problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size() << " vagas para a aula de "
							<< problemData->retornaNroCreditos( hi, hf, sala, v->getDisciplina(), dia )
							<< " creditos da disciplina " << v->getDisciplina()->getCodigo() << " id" <<v->getDisciplina()->getId()
							<< " para a turma " << v->getTurma()
							<< " no dia " << dia
							<< " para a sala " << sala->getId()
							<< std::endl;
				  }
				  else
				  {
					  delete v;
				  }
				  break;
			 }
			 case VariableTatico::V_ABERTURA:
			 {
				  Trio< int, int, Disciplina* > trio;
				  trio.set( v->getCampus()->getId(), v->getTurma(), v->getDisciplina() );

				  if ( remocao.find( trio ) == remocao.end() )
				  {
					  solVarsTatico.add( v );
				  }
				  else
				  {
					  delete v;
				  }
				  break;
			 }
			 case VariableTatico::V_ABERTURA_COMPATIVEL:
			 {
				 bool inseriu = false;
				 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
					 itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
				 for ( ; itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMapAtend++ )
				 {
					 int discId = itMapAtend->first.third->getId();

					 if ( discId == v->getDisciplina()->getId() )
					 {
						 solVarsTatico.add( v );
						 inseriu = true;
						 break;
					 }
				 }
				 if ( !inseriu )
				 {
					 delete v;
				 }
				 break;
			 }
			 case VariableTatico::V_DIAS_CONSECUTIVOS:
			 {
				 bool inseriu = false;
				 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
					 itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
				 for ( ; itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMapAtend++ )
				 {
					 int discId = itMapAtend->first.third->getId();
					 int turma = itMapAtend->first.second;
					 int cpId = itMapAtend->first.first;

					 if ( discId == v->getDisciplina()->getId() &&
						  turma == v->getTurma() &&
						  cpId == v->getCampus()->getId() )
					 {
						 solVarsTatico.add( v );
						 inseriu = true;
						 break;
					 }
				 }
				 if ( !inseriu )
				 {
					 delete v;
				 }
				 break;
			 }
			 case VariableTatico::V_SLACK_DIST_CRED_DIA_SUPERIOR:			// fcp_{i,d,tps,t}
			 case VariableTatico::V_SLACK_DIST_CRED_DIA_INFERIOR:			// fcm_{i,d,tps,t}
			 case VariableTatico::V_COMBINACAO_DIVISAO_CREDITO:			// m_{i,d,k}
			 case VariableTatico::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M:	// fkm{i,d,t}
			 case VariableTatico::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P:	// fkp{i,d,t}
			 {
				 bool inseriu = false;
				 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
					 itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
				 for ( ; itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMapAtend++ )
				 {
					 int discId = itMapAtend->first.third->getId();
					 int turma = itMapAtend->first.second;

					 if ( discId == v->getDisciplina()->getId() &&
						  turma == v->getTurma() )
					 {
						 solVarsTatico.add( v );
						 inseriu = true;
						 break;
					 }
				 }
				 if ( !inseriu )
				 {
					 delete v;
				 }
				 break;
			 }
			 case VariableTatico::V_SLACK_ALUNO_VARIAS_UNID_DIA:	// fu{i1,d1,i2,d2,t}
			 {
				 bool inseriu = false;
				 bool achou1 = false, achou2 = false;

				 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
					 itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
				 for ( ; itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMapAtend++ )
				 {
					 int discId = itMapAtend->first.third->getId();
					 int turma = itMapAtend->first.second;

					 if ( discId == v->getDisciplina1()->getId() && turma == v->getTurma1() )
					 {
						 achou1 = true;
					 }
					 if ( discId == v->getDisciplina2()->getId() && turma == v->getTurma2() )
					 {
						 achou2 = true;						 
					 }
					 if ( achou1 && achou2 )
					 {
						 solVarsTatico.add( v );
						 inseriu = true;
						 break;					 
					 }
				 }
				 if ( !inseriu )
				 {
					 delete v;
				 }
				 break;
			 }
			 case VariableTatico::V_ALUNO_DIA:
			 {	 // Essa variavel será tratada logo depois, pois preciso saber todas as
				 // variaveis de crédito "x" primeiro, para conseguir filtrar esta "du"
				 delete v;
				 break;
			 }
			 default:
			 {
				  // Acho que não tem problema adicionar todo o resto
				  solVarsTatico.add( v );
			 }
		  }
	  }
	  else
	  {
		  delete v;
	  }

	  vit++;
   }

   vit = vHashTatico.begin();
   while ( vit != vHashTatico.end() )
   {
      VariableTatico* v = new VariableTatico( vit->first );
      int col = vit->second;
	  double value = xSol[ col ];
      v->setValue( value );

      if ( v->getValue() > 0.00001 )
      {
         switch( v->getType() )
         {
			 case VariableTatico::V_ALUNO_DIA:
			 {
				 bool inseriu = false;
				 Aluno* aluno = v->getAluno();
				 int dia = v->getDia();

				 GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >	trios = problemData->mapAluno_CampusTurmaDisc[aluno];
				 GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >::iterator it = trios.begin();
				 for ( ; it != trios.end(); it++ )
				 {
					 int campusId = (*it).first;
					 int turma = (*it).second;
					 int discId = (*it).third->getId();

					 ITERA_GGROUP_LESSPTR ( it, vars_xh, VariableTatico )
					 {
						 if ( (*it)->getDisciplina()->getId() == discId &&
							  (*it)->getTurma() == turma &&
							  (*it)->getDia() == dia &&
							  (*it)->getUnidade()->getIdCampus() == campusId )
						 {
							 solVarsTatico.add( v );
							 inseriu = true;
							 break;
						 }
					 }
					 if (inseriu) break;
				 }
				 if ( !inseriu )
				 {
					 delete v;
				 }
				 break;
			 }
			 default:
			 {
				delete v;
			 }
		 }
	  }
	  else
	  {
		  delete v;
	  }

	  vit++;
	}

   // CRIA FOLGAS e insere em solVars
   GGroup< Trio< int, int, Disciplina* > >::iterator itRemove = remocao.begin();
   for ( ; itRemove != remocao.end(); itRemove++ )
   {
	    Campus *campus = problemData->refCampus[ (*itRemove).first ];
		int turma = (*itRemove).second;
		Disciplina *d = (*itRemove).third;

		VariableTatico *slackVar = new VariableTatico;
		slackVar->setType( VariableTatico::V_SLACK_DEMANDA );
		slackVar->setTurma( turma );
		slackVar->setDisciplina( d );
		slackVar->setCampus( campus );
		slackVar->setValue( 1 );

		solVarsTatico.add( slackVar );
   }
	#pragma endregion	    
   

   // teste
   char solPosFilename[1024];
   strcpy( solPosFilename, "pos_" );
   strcat( solPosFilename, solFilename );
   FILE * fout = fopen( solPosFilename, "wt" );
   ITERA_GGROUP_LESSPTR( itSol, solVarsTatico, VariableTatico )
   {      
	   VariableTatico *v = *itSol;
	   
	   fprintf( fout, "%s = %f\n", v->toString().c_str(), v->getValue() );
		   
   }
   fprintf( fout, "\nAlunosDemanda removidos = %d", nroAtendsRemovidosAlunoDemanda );
   fclose( fout );
   
#endif

   return nroAtendsRemovidosAlunoDemanda;
}

void SolverMIP::testeCarregaPreSol( int campusId, int prioridade, int cjtAlunosId, int r )
{
	double * xSol = NULL;

	lp->updateLP();
	int nroColsLP = lp->getNumCols();
	xSol = new double[ nroColsLP ];
   
	char solName[1024];

	strcpy( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
	cout<<"====================> TESTE => carregando pre " <<solName <<endl;
	FILE* fin = fopen( solName,"rb");
	if ( fin == NULL )
	{
		std::cout << "\nErro em SolverMIP::testeCarregaPreSol(int campusId, int prioridade, int cjtAlunosId, int r): arquivo "
					<< solName << " nao encontrado.\n";
		return;
	}

	int nCols = 0;
	fread(&nCols,sizeof(int),1,fin);

	if ( nCols == nroColsLP )
	{
		for (int i =0; i < nCols; i++)
		{
			double auxDbl;
			fread(&auxDbl,sizeof(double),1,fin);
			xSol[i] = auxDbl;
		}
	}
	else
	{
		std::cout << "\nErro em testeCarregaPreSol(int campusAtualId, int prioridade, int cjtAlunos, int r): "
					<< " \nNumero diferente de variaveis: " << nCols << " != " << nroColsLP;
		return;
	}
	fclose(fin);
	
	int nChg = 0;
	int *idx = new int[lp->getNumCols()*2];
	double *valOrigUB = new double[lp->getNumCols()*2];
	double *valOrigLB = new double[lp->getNumCols()*2];
	double *valUB = new double[lp->getNumCols()*2];
	double *valLB = new double[lp->getNumCols()*2];
	BOUNDTYPE *bts1 = new BOUNDTYPE[lp->getNumCols()*2];
	BOUNDTYPE *bts2 = new BOUNDTYPE[lp->getNumCols()*2];
	
	std::cout << "\nChanging bounds...";

    VariablePreHash::iterator vit;
	vit = vHashPre.begin();
	while ( vit != vHashPre.end() )
	{
		int col = vit->second;
		double ub = xSol[ col ];
		double lb = xSol[ col ];
		idx[nChg] = col;
		valOrigUB[nChg] = lp->getUB(col);
		valOrigLB[nChg] = lp->getLB(col);
		valUB[nChg] = ub + 1e-5;
		valLB[nChg] = lb - 1e-5;
		bts1[nChg] = BOUNDTYPE::BOUND_UPPER;
		bts2[nChg] = BOUNDTYPE::BOUND_LOWER;
		nChg++;
	}
	 
	lp->chgBds(nChg,idx,bts1,valUB);
	lp->chgBds(nChg,idx,bts2,valLB);
	lp->updateLP();

	std::cout << " bounds changed!\n";

	lp->setTimeLimit( 1e10 );
	lp->setMIPRelTol( 0.01 );
	lp->setPreSolve(OPT_TRUE);
	lp->setHeurFrequency(1.0);
	lp->setMIPEmphasis(0);
	lp->setSymetry(0);
	lp->setMIPScreenLog( 4 );
	lp->setNumIntSols(1);

	lp->updateLP();
	
	char lpName[1024];
    strcpy( lpName, getPreLpFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
	strcat( lpName, "_teste" );

	lp->writeProbLP(lpName);

	std::cout << "\nOptimizing...";

	int status = lp->optimize( METHOD_MIP );	

	std::cout << " finish!";

	lp->chgBds(nChg,idx,bts1,valOrigUB);
	lp->chgBds(nChg,idx,bts2,valOrigLB);
	lp->updateLP();

}
void SolverMIP::testeCarregaSol( int campusId, int prioridade, int cjtAlunosId, int r, int tatico )
{
	std::cout<<"\nCarregamento de teste...\n"; fflush(NULL);

	double * xSol = NULL;
   
	lp->updateLP();
	int nroColsLP = lp->getNumCols();
	xSol = new double[ nroColsLP ];
   
	char solName[1024];

	strcpy( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
	cout<<"====================> TESTE => carregando tatico " <<solName <<endl; fflush(NULL);
	FILE* fin = fopen( solName,"rb");
	if ( fin == NULL )
	{
		std::cout << "\nErro em SolverMIP::testeCarregaSol(int campusId, int prioridade, int cjtAlunosId, int r): arquivo "
					<< solName << " nao encontrado.\n";fflush(NULL);
		return;
	}

	std::cout<<"\nLendo nro de variaveis...\n"; fflush(NULL);
	int nCols = 0;
	fread(&nCols,sizeof(int),1,fin);

	if ( nCols == nroColsLP )
	{
		for (int i =0; i < nCols; i++)
		{
			double auxDbl;
			fread(&auxDbl,sizeof(double),1,fin);
			xSol[i] = auxDbl;
		}
	}
	else
	{
		std::cout << "\nErro em testeCarregaSol(int campusAtualId, int prioridade, int cjtAlunos, int r): "
					<< " \nNumero diferente de variaveis: " << nCols << " != " << nroColsLP; fflush(NULL);
		return;
	}
	fclose(fin);

	std::cout<<"\Criando arrows...\n"; fflush(NULL);

	int nChg = 0;
	int *idx = new int[lp->getNumCols()*2];
	double *valOrigUB = new double[lp->getNumCols()*2];
	double *valOrigLB = new double[lp->getNumCols()*2];
	double *valUB = new double[lp->getNumCols()*2];
	double *valLB = new double[lp->getNumCols()*2];
	BOUNDTYPE *bts1 = new BOUNDTYPE[lp->getNumCols()*2];
	BOUNDTYPE *bts2 = new BOUNDTYPE[lp->getNumCols()*2];
	
	std::cout<<"\nFixando a solucao lida...\n"; fflush(NULL);

	// Fixação da solucao:
    VariableTaticoHash::iterator vit;
	vit = vHashTatico.begin();
	while ( vit != vHashTatico.end() )
	{
		VariableTatico v = vit->first;
		int col = vit->second;

		// Alteração especifica:
		if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO ||
			 v.getType() == VariableTatico::V_DESALOCA_ALUNO_DIA )
		{
			if ( v.getDisciplina()->getId() == 7369 &&
				 v.getTurma() == 0 )
				continue;
		}
		if ( v.getType() == VariableTatico::V_SLACK_DEMANDA && 
			 v.getTurma() == 0 && 
			 v.getDisciplina()->getId() == 7369 )
		{			
			double ub = 0.0;
			double lb = 0.0;
			idx[nChg] = col;
			valOrigUB[nChg] = lp->getUB(col);
			valOrigLB[nChg] = lp->getLB(col);
			valUB[nChg] = ub + 1e-5;
			valLB[nChg] = lb - 1e-5;
			bts1[nChg] = BOUNDTYPE::BOUND_UPPER;
			bts2[nChg] = BOUNDTYPE::BOUND_LOWER;
			nChg++;
			continue;
		}

		if ( ( xSol[col] > 0.1 &&
				v.getType() != VariableTatico::V_SLACK_DEMANDA &&
				v.getType() != VariableTatico::V_SLACK_SLACKDEMANDA_PT ) ||
			 ( xSol[col] < 0.1 &&
				v.getType() == VariableTatico::V_SLACK_DEMANDA ) )
		{
			double ub = xSol[ col ];
			double lb = xSol[ col ];
			idx[nChg] = col;
			valOrigUB[nChg] = lp->getUB(col);
			valOrigLB[nChg] = lp->getLB(col);
			valUB[nChg] = ub + 1e-5;
			valLB[nChg] = lb - 1e-5;
			bts1[nChg] = BOUNDTYPE::BOUND_UPPER;
			bts2[nChg] = BOUNDTYPE::BOUND_LOWER;
			nChg++;
		}
	}

	std::cout<<"\nAlterando bounds...\n"; fflush(NULL);

	lp->chgBds(nChg,idx,bts1,valUB);
	lp->chgBds(nChg,idx,bts2,valLB);
	lp->updateLP();

	lp->updateLP();
	lp->setTimeLimit( 60 );
	lp->setPreSolve(OPT_TRUE);
	lp->setHeurFrequency(1.0);
	lp->setMIPScreenLog( 4 );
	lp->setMIPEmphasis(0);
	lp->setSymetry(0);
	lp->setCuts(3);
	lp->setNumIntSols(1);	
	lp->updateLP();
	
	char lpName[1024];
    strcpy( lpName, getTaticoLpFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
	strcat( lpName, "_teste" );

	lp->writeProbLP(lpName);
	
	std::cout<<"\nOtimizando o teste..."; fflush(NULL);

	int status = lp->optimize( METHOD_MIP );	

	std::cout<<" otimizado!\n"; fflush(NULL);

	lp->chgBds(nChg,idx,bts1,valOrigUB);
	lp->chgBds(nChg,idx,bts2,valOrigLB);
	lp->updateLP();

	std::cout<<"\nFim do carregamento de teste!\n"; fflush(NULL);
}

void SolverMIP::teste(double *& xSol, int n )
{
	stringstream ss;
	ss << n;
	std::string fileName( "teste_" );
	fileName += ss.str();
	fileName += ".txt";

	ofstream fout;
	fout.open( fileName, ios::app );
	if ( fout == NULL )
	{
		std::cout << "\nErro em SolverMIP::teste(): Arquivo teste.txt nao pode ser aberto.\n";
	}
	else
	{
		int size = vHashTatico.size();
		int nCols = lp->getNumCols();
		
		fout << "nCols: " << nCols;
		fout << "\nhash size: " << size;
		 
		VariableTaticoHash::iterator vit = vHashTatico.begin();
		for ( int i = 0; i < lp->getNumCols(); i++ )
		{
			VariableTatico v = vit->first;

			fout << "\n" << i << ": " << v.toString() << " = " << xSol[ i ];
			  
			vit++;
		}

		fout.close();
	}

}
void SolverMIP::teste( int n )
{
	stringstream ss;
	ss << n;
	std::string fileName( "testeSimples_" );
	fileName += ss.str();
	fileName += ".txt";

	ofstream fout;
	fout.open( fileName, ios::app );
	if ( fout == NULL )
	{
		std::cout << "\nErro em SolverMIP::teste(): Arquivo teste.txt nao pode ser aberto.\n";
	}
	else
	{
		int size = vHashTatico.size();
		int nCols = lp->getNumCols();
		
		fout << "nCols: " << nCols;
		fout << "\nhash size: " << size;
		 
		VariableTaticoHash::iterator vit = vHashTatico.begin();
		for ( int i = 0; i < lp->getNumCols(); i++ )
		{
			VariableTatico v = vit->first;

			fout << "\n" << i << ": " << v.toString();
			  
			vit++;
		}

		fout.close();
	}

}

#ifdef TATICO_CJT_ALUNOS

/*
	Retorna o valor minimo a ser assumido pela variavel em sua criação.
	Função usada na modelagem com conjuntos de alunos, a fim de considerar
	a otimização do tatico para todos os conjuntos de alunos anteriores
	ao atual (iterações anteriores).
*/
int SolverMIP::fixaLimiteInferiorVariavelPre_CjtAlunos( VariablePre *v )
{
#ifndef PRE_TATICO
	return 0;
#endif

#ifdef PRE_TATICO
	   
	switch( v->getType() )
	{
		
		 case VariablePre::V_ERROR:
		 {
			 return true;
		 }
		 case VariablePre::V_PRE_CREDITOS:  //  x_{i,d,u,s} 
		 {
			 int nCreditos = 0;

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {
					 nCreditos += (int) ( vSol->getValue() + 0.5 ); // evita perda de informação por arredondamento
				 }				
			 }
			 return nCreditos;
		 }
		 case VariablePre::V_PRE_OFERECIMENTO:  //  o_{i,d,u,s}
		 {
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
					  return 1;
			 }

			 return 0;
		 }
		case VariablePre::V_PRE_ABERTURA: // z_{i,d,cp}
		 {
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  problemData->retornaCampus( vSol->getUnidade()->getId() ) == v->getCampus() )
					  return 1;
			 }

			 return 0;
		 }
		 case VariablePre::V_PRE_ALUNOS:  //  a_{i,d,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 int nroDeAtendimentos = problemData->atendeTurmaDiscOferta( turma, discId, ofertaId );

			 if ( ! nroDeAtendimentos )
			 {
				return 0;
			 } 

			 // Procura na sala s, se o atendimento for nessa sala, retorna o nro de atendimentos
			 // e a variavel a_{i,d,s,oft} será criada com lowerBound igual a nroDeAtendimentos
			 // Se achar o atendimento feito em outra sala, retorna -1.
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					 vSol->getDisciplina()->getId() == v->getDisciplina()->getId() )
				 {					 
					if ( vSol->getUnidade()->getId() == v->getUnidade()->getId() &&
						 vSol->getSubCjtSala()->getId() == v->getSubCjtSala()->getId() )
					{
						return nroDeAtendimentos;
					}
					else
					{
						return -1; // há atendimento, mas em outra sala
					}
				 }
			 }

			 std::cout<<"\nError em SolverMIP::fixaLimiteInferiorVariavelPre_CjtAlunos: "
					  <<"Acho que nao deveria chegar ate aqui\n";
			 return 0;
		 }
		 case VariablePre::V_PRE_ALOC_ALUNO:  //  b_{i,d,c}
		 {
			 Curso *curso = v->getCurso();

			 ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
			 {
				 if ( itOft->curso == curso )
				 {
					 int ofertaId = itOft->getId();
					 int discId = v->getDisciplina()->getId();
					 int turma = v->getTurma();

					 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					 {
						return 1;
					 } 					
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_DEMANDA: // fd_{d,a}
		 {
			 return 0;
		 } 		 
		 case VariablePre::V_PRE_SLACK_COMPARTILHAMENTO:  // fc_{i,d,c1,c2}
		 {
			 Curso* curso1 = v->getParCursos().first;
			 Curso* curso2 = v->getParCursos().second;
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 ITERA_GGROUP_LESSPTR( itOft1, problemData->ofertas, Oferta )
			 {
				 if ( itOft1->curso == curso1 )
				 {
					int ofertaId = itOft1->getId();

					if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					{
						 ITERA_GGROUP_INIC_LESSPTR( itOft2, itOft1, problemData->ofertas, Oferta )
						 {
							 if ( itOft2->curso == curso2 )
							 {
								 int ofertaId = itOft2->getId();

								 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
								 {
									return 1;
								 } 
							 }
						 }
					} 
				 }
			 }

			 return 0;
		 }		 
		 case VariablePre::V_PRE_SLACK_SALA:  //  fs_{d,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int n = 0;

			 GGroup<int> turmas;

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {			
					 int turma = vSol->getTurma();
					 if ( turmas.find( turma ) == turmas.end() ) // evita somar alocações que diferenciam-se só pelo dia
					 {
						 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
						 {
							n++;
							turmas.add( turma );
						 }
					 }
				 }
			 }

 			 if ( n <= 1 )
				return 0;
			 else
				 return n-1;
		 }
		 case VariablePre::V_PRE_SLACK_DISC_SALA:  //  fs_{d,s}
		 {
			 int n = 0;
			 GGroup<int> turmas;

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {			
					 int turma = vSol->getTurma();
					 if ( turmas.find( turma ) == turmas.end() ) // evita somar alocações que diferenciam-se só pelo dia
					 {
						n++;
						turmas.add( turma );						
					 }
				 }
			 }

 			 if ( n <= 1 )
				return 0;
			 else
				 return n-1;
		 }
		 case VariablePre::V_PRE_LIM_SUP_CREDS_SALA:  //  Hs_{cp}
		 {
			  return 0;
		 }
		 case VariablePre::V_PRE_ALOC_ALUNO_OFT:  //  c_{i,d,u,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 if ( ! problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
			 {
				return 0;
			 } 

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {					 
					return 1;
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC:  // s_{a,i,d,cp}
		 {
			 Aluno* aluno = v->getAluno();
			 int campusId = v->getCampus()->getId();
			 Disciplina *disciplina = v->getDisciplina();
			 int turma = v->getTurma();

		 	 std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator itMap =
				problemData->mapAluno_CampusTurmaDisc.find( aluno );
			 
			 if ( itMap == problemData->mapAluno_CampusTurmaDisc.end() )
				 return 0;

			 Trio< int, int, Disciplina* > trio;
			 trio.set( campusId, turma, disciplina );

			 GGroup< Trio< int , int, Disciplina* > >::iterator itGGroup =
				 itMap->second.find( trio );
			 
			 if ( itGGroup != itMap->second.end() )
			 {
				  return 1;
			 }

			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_PRIOR_INF:	// fpi_{a}
		 {
			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_PRIOR_SUP: 	// fps_{a}
		 {
			 return 0;		 
		 }	 

		 default:
		 {
			return 0;
			break;
		 }
	}

#endif

}

int SolverMIP::fixaLimiteSuperiorVariavelPre_CjtAlunos( VariablePre *v )
{
#ifndef PRE_TATICO
	return 0;
#endif

#ifdef PRE_TATICO
	   
	switch( v->getType() )
	{
		
		 case VariablePre::V_ERROR:
		 {
			 return true;
		 }
		 case VariablePre::V_PRE_CREDITOS:  //  x_{i,d,u,s} 
		 {
			 int nCreditos = 0;

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {
					 nCreditos += (int) ( vSol->getValue() + 0.5 );
				 }				
			 }
			 return nCreditos;
		 }
		 case VariablePre::V_PRE_OFERECIMENTO:  //  o_{i,d,u,s}
		 {
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
					  return 1;
			 }

			 return 0;
		 }
		case VariablePre::V_PRE_ABERTURA: // z_{i,d,cp}
		 {
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  problemData->retornaCampus( vSol->getUnidade()->getId() ) == v->getCampus() )
					  return 1;
			 }

			 return 0;
		 }
		 case VariablePre::V_PRE_ALUNOS:  //  a_{i,d,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 int nroDeAtendimentos = problemData->atendeTurmaDiscOferta( turma, discId, ofertaId );

			 if ( ! nroDeAtendimentos )
			 {
				return 0;
			 } 

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {					 
					return nroDeAtendimentos;
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_ALOC_ALUNO:  //  b_{i,d,c}
		 {
			 Curso *curso = v->getCurso();

			 ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
			 {
				 if ( itOft->curso == curso )
				 {
					 int ofertaId = itOft->getId();
					 int discId = v->getDisciplina()->getId();
					 int turma = v->getTurma();

					 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					 {
						return 1;
					 } 					
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_DEMANDA: // fd_{d,a}
		 {	
			 return 1;
		 } 		 
		 case VariablePre::V_PRE_SLACK_COMPARTILHAMENTO:  // fc_{i,d,c1,c2}
		 {
			 Curso* curso1 = v->getParCursos().first;
			 Curso* curso2 = v->getParCursos().second;
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 ITERA_GGROUP_LESSPTR( itOft1, problemData->ofertas, Oferta )
			 {
				 if ( itOft1->curso == curso1 )
				 {
					int ofertaId = itOft1->getId();

					if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					{
						 ITERA_GGROUP_INIC_LESSPTR( itOft2, itOft1, problemData->ofertas, Oferta )
						 {
							 if ( itOft2->curso == curso2 )
							 {
								 int ofertaId = itOft2->getId();

								 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
								 {
									return 1;
								 } 
							 }
						 }
					} 
				 }
			 }

			 return 0;
		 }		 
		 case VariablePre::V_PRE_SLACK_SALA:  //  fs_{d,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int n = 0;
			 
			 GGroup<int> turmas;

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {			
					 int turma = vSol->getTurma();
					 if ( turmas.find( turma ) == turmas.end() ) // evita somar alocações que diferenciam-se só pelo dia
					 {
						 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
						 {
							n++;
							turmas.add( turma );
						 }
					 }
				 }
			 }

 			 if ( n <= 1 )
				return 0;
			 else
				 return n-1;
		 }
		 case VariablePre::V_PRE_SLACK_DISC_SALA:  //  fs_{d,s}
		 {
			 int n = 0;
			 GGroup<int> turmas;

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {			
					 int turma = vSol->getTurma();
					 if ( turmas.find( turma ) == turmas.end() ) // evita somar alocações que diferenciam-se só pelo dia
					 {
						n++;
						turmas.add( turma );						
					 }
				 }
			 }

 			 if ( n <= 1 )
				return 0;
			 else
				 return n-1;
		 }
		 case VariablePre::V_PRE_LIM_SUP_CREDS_SALA:  //  Hs_{cp}
		 {
			  return 0;
		 }
		 case VariablePre::V_PRE_ALOC_ALUNO_OFT:  //  c_{i,d,u,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 if ( ! problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
			 {
				return 0;
			 } 

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {					 
					return 1;
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC:  // s_{a,i,d,cp}
		 {
			 Aluno* aluno = v->getAluno();
			 int campusId = v->getCampus()->getId();
			 Disciplina *disciplina = v->getDisciplina();
			 int turma = v->getTurma();

		 	 std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator itMap =
				problemData->mapAluno_CampusTurmaDisc.find( aluno );
			 
			 if ( itMap == problemData->mapAluno_CampusTurmaDisc.end() )
				 return 0;

			 Trio< int, int, Disciplina* > trio;
			 trio.set( campusId, turma, disciplina );

			 GGroup< Trio< int , int, Disciplina* > >::iterator itGGroup =
				 itMap->second.find( trio );
			 
			 if ( itGGroup != itMap->second.end() )
			 {
				  return 1;
			 }

			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_PRIOR_INF:	// fpi_{a}
		 {
			 return 0; // ??
		 }
		 case VariablePre::V_PRE_SLACK_PRIOR_SUP: 	// fps_{a}
		 {
			 return 0; // ??		 
		 }	 

		 default:
		 {
			return 0;
			break;
		 }
	}

#endif

}

/*
	Retorna o valor minimo a ser assumido pela variavel em sua criação.
	Função usada nas rodadas de prioridade maior que 1, a fim de considerar
	a otimização do tatico COM horários nas iterações anteriores.
*/
int SolverMIP::fixaLimitesVariavelPre( VariablePre *v )
{
#ifndef PRE_TATICO
	return 0;
#endif

#ifdef PRE_TATICO
	   
	switch( v->getType() )
	{
		
		 case VariablePre::V_ERROR:
		 {
			 return true;
		 }
		 case VariablePre::V_PRE_CREDITOS:  //  x_{i,d,u,s} 
		 {
			 int nCreditos = 0;

			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {
					 HorarioAula *hi = vSol->getHorarioAulaInicial();
					 HorarioAula *hf = vSol->getHorarioAulaFinal();
					 Calendario *sl = vSol->getDisciplina()->getCalendario();
					 int nCreds = sl->retornaNroCreditosEntreHorarios( hi, hf );
					 nCreditos += nCreds;
				 }				
			 }
			 return nCreditos;
		 }
		 case VariablePre::V_PRE_OFERECIMENTO:  //  o_{i,d,u,s}
		 {
			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
					  return 1;
			 }

			 return 0;
		 }
		case VariablePre::V_PRE_ABERTURA: // z_{i,d,cp}
		 {
			 // x_{i,d,u,s,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  problemData->retornaCampus( vSol->getUnidade()->getId() ) == v->getCampus() )
					  return 1;
			 }

			 return 0;
		 }
		 case VariablePre::V_PRE_ALUNOS:  //  a_{i,d,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 int nroDeAtendimentos = problemData->atendeTurmaDiscOferta( turma, discId, ofertaId );

			 if ( ! nroDeAtendimentos )
			 {
				return 0;
			 } 

			 // Procura na sala s, se o atendimento for nessa sala, retorna o nro de atendimentos
			 // e a variavel a_{i,d,s,oft} será criada com lowerBound igual a nroDeAtendimentos
			 // Se achar o atendimento feito em outra sala, retorna -1.
			 // x_{i,d,u,s,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					 vSol->getDisciplina()->getId() == v->getDisciplina()->getId() )
				 {					 
					if ( vSol->getUnidade()->getId() == v->getUnidade()->getId() &&
						 vSol->getSubCjtSala()->getId() == v->getSubCjtSala()->getId() )
					{
						return nroDeAtendimentos;
					}
					else
					{
						return -1; // há atendimento, mas em outra sala
					}
				 }
			 }

			 std::cout<<"\nError em SolverMIP::fixaLimiteInferiorVariavelPre_CjtAlunos: "
					  <<"Acho que nao deveria chegar ate aqui\n";
			 return 0;
		 }
		 case VariablePre::V_PRE_ALOC_ALUNO:  //  b_{i,d,c}
		 {
			 Curso *curso = v->getCurso();

			 ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
			 {
				 if ( itOft->curso == curso )
				 {
					 int ofertaId = itOft->getId();
					 int discId = v->getDisciplina()->getId();
					 int turma = v->getTurma();

					 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					 {
						return 1;
					 } 					
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_DEMANDA: // fd_{d,a}
		 {
			 return 0;
		 } 		 
		 case VariablePre::V_PRE_SLACK_COMPARTILHAMENTO:  // fc_{i,d,c1,c2}
		 {
			 Curso* curso1 = v->getParCursos().first;
			 Curso* curso2 = v->getParCursos().second;
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 ITERA_GGROUP_LESSPTR( itOft1, problemData->ofertas, Oferta )
			 {
				 if ( itOft1->curso == curso1 )
				 {
					int ofertaId = itOft1->getId();

					if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
					{
						 ITERA_GGROUP_INIC_LESSPTR( itOft2, itOft1, problemData->ofertas, Oferta )
						 {
							 if ( itOft2->curso == curso2 )
							 {
								 int ofertaId = itOft2->getId();

								 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
								 {
									return 1;
								 } 
							 }
						 }
					} 
				 }
			 }

			 return 0;
		 }		 
		 case VariablePre::V_PRE_SLACK_SALA:  //  fs_{d,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int n = 0;

			 GGroup<int> turmas;

			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {			
					 int turma = vSol->getTurma();
					 if ( turmas.find( turma ) == turmas.end() ) // evita somar alocações que diferenciam-se só pelo dia e horário
					 {
						 if ( problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
						 {
							n++;
							turmas.add( turma );
						 }
					 }
				 }
			 }

 			 if ( n <= 1 )
				return 0;
			 else
				 return n-1;
		 }
		 case VariablePre::V_PRE_SLACK_DISC_SALA:  //  fs_{d,s}
		 {
			 int n = 0;
			 GGroup<int> turmas;

			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {			
					 int turma = vSol->getTurma();
					 if ( turmas.find( turma ) == turmas.end() ) // evita somar alocações que diferenciam-se só pelo dia e horário
					 {
						n++;
						turmas.add( turma );						
					 }
				 }
			 }

 			 if ( n <= 1 )
				return 0;
			 else
				 return n-1;
		 }
		 case VariablePre::V_PRE_LIM_SUP_CREDS_SALA:  //  Hs_{cp}
		 {
			  return 0;
		 }
		 case VariablePre::V_PRE_ALOC_ALUNO_OFT:  //  c_{i,d,u,s,oft}
		 {
			 int ofertaId = v->getOferta()->getId();
			 int discId = v->getDisciplina()->getId();
			 int turma = v->getTurma();

			 if ( ! problemData->atendeTurmaDiscOferta( turma, discId, ofertaId ) )
			 {
				return 0;
			 } 

			 // x_{i,d,u,s,hi,hf,t}
			 ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
			 {
				 VariableTatico *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() )
				 {					 
					return 1;
				 }
			 }
			 return 0;
		 }
		 case VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC:  // s_{a,i,d,cp}
		 {
			 Aluno* aluno = v->getAluno();
			 int campusId = v->getCampus()->getId();
			 Disciplina *disciplina = v->getDisciplina();
			 int turma = v->getTurma();

		 	 std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator 
				 itMap = problemData->mapAluno_CampusTurmaDisc.find( aluno );
			 
			 if ( itMap == problemData->mapAluno_CampusTurmaDisc.end() )
				 return 0;

			 Trio< int, int, Disciplina* > trio;
			 trio.set( campusId, turma, disciplina );

			 GGroup< Trio< int , int, Disciplina* > >::iterator itGGroup =
				 itMap->second.find( trio );
			 
			 if ( itGGroup != itMap->second.end() )
			 {
				  return 1;
			 }

			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_PRIOR_INF:	// fpi_{a}
		 {
			 return 0;
		 }
		 case VariablePre::V_PRE_SLACK_PRIOR_SUP: 	// fps_{a}
		 {
			 return 0;		 
		 }	 
		 case VariablePre::V_PRE_FORMANDOS_NA_TURMA: // f_{i,d,cp}
		 {
			 int campusId = v->getCampus()->getId();
			 Disciplina *disciplina = v->getDisciplina();
			 int turma = v->getTurma();

			 Trio< int, int, Disciplina* > trio;
			 trio.set( campusId, turma, disciplina );

			 std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, 
				 GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
				 itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
			 		 	 
			 if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
				 return 0;
			 
			 ITERA_GGROUP_LESSPTR( itAlDem, itMap->second, AlunoDemanda )
			 {
				 Aluno *aluno = problemData->retornaAluno( (*itAlDem)->getAlunoId() );
				 if ( aluno->ehFormando() )
				 {
					return 1;
				 }
			 }

			 return 0;		 
		 }		 

		 default:
		 {
			return 0;
			break;
		 }
	}

#endif

}

/*
	Recebe uma Variavel v correspondente a um conjunto de alunos anterior
	(isto é, diferente do cjtAluno da iteração atual).

	Verifica qual o valor atribuido à variavel v na iteração do tatico
	anterior, e retorna esse valor, que será o valor dos limites
	inferior e superior fixados para v.
*/
double SolverMIP::fixaLimitesVariavelTaticoCjtAlunosAnterior( Variable *v )
{

	if ( v->getType() == Variable::V_CREDITOS )
	{
		// A variavel x adquire o campo "sala" em solVars, mas v ainda não o tem,
		// por isso x tem que ser comparada separada, por atributo
		ITERA_GGROUP_LESSPTR ( itVar, solVars, Variable )
		{
			if((*itVar)->getType() == Variable::V_CREDITOS)
			{
				Variable vSol = **itVar;		

				if ( vSol.getTurma() == v->getTurma() &&
					vSol.getDisciplina() == v->getDisciplina() &&
					vSol.getUnidade() == v->getUnidade() &&
					vSol.getSubCjtSala() == v->getSubCjtSala() &&
					vSol.getDia() == v->getDia() /*&&
					vSol.getType() == Variable::V_CREDITOS*/ )
				{
					return vSol.getValue();
				}
			}
		}
	}
	else
	{
		GGroup< Variable *, LessPtr<Variable> >::iterator itVar = solVars.find( v );
		if ( itVar != solVars.end() )
		{
			return (*itVar)->getValue();
		}
		/*
		ITERA_GGROUP ( itVar, solVars, Variable )
		{
			Variable vSol = **itVar;
		
			if ( vSol == *v )
				return vSol.getValue();
		}*/
	}

	return 0;

	// O trecho abaixo só é necessário se não tivermos o vetor com a solução da iteração-tatica anterior (solVars)
	/*
	switch( v->getType() )
	{
		
		 case Variable::V_ERROR:
		 {
			 return true;
		 }
		 case Variable::V_CREDITOS:  //  x_{i,d,u,s,t} 
		 {
			 int nCreditos = 0;

			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() &&
					  vSol->getDia() == v->getDia() )
				 {
					 nCreditos = vSol->getValue();
					 return nCreditos;
				 }				
			 }
			 return nCreditos;
		 }
		 case Variable::V_OFERECIMENTO:  //  o_{i,d,u,s,t}
		 {
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  vSol->getUnidade() == v->getUnidade() &&
					  vSol->getSubCjtSala() == v->getSubCjtSala() &&
					  vSol->getDia() == v->getDia() )
					  return 1;
			 }

			 return 0;
		 }
		 case Variable::V_ABERTURA: // z_{i,d,cp}
		 {
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  problemData->retornaCampus( vSol->getUnidade()->getId() ) == v->getCampus() )
					  return 1;
			 }

			 return 0;
		 }
		 case Variable::V_DIAS_CONSECUTIVOS: // c_{i,d,t}
		 {	
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it1_Vars_x, vars_x, Variable )
			 {
				 Variable *v1Sol = *it1_Vars_x;

				 if ( v1Sol->getTurma() == v->getTurma() &&
					  v1Sol->getDisciplina() == v->getDisciplina() &&
					  v1Sol->getDia() == v->getDia() )
				 {
					// x_{i,d,u,s,t-1}
					ITERA_VECTOR( it2_Vars_x, vars_x, Variable )
					{
						Variable *v2Sol = *it2_Vars_x;
						if ( v2Sol->getTurma() == v->getTurma() &&
							 v2Sol->getDisciplina() == v->getDisciplina() &&
							 v2Sol->getDia() == v->getDia() - 1 )
							return 1;
					}

					return 0;
				 }
			 }

			 return 0;
		 }
		 case Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR: // fcp_{i,d,tps,t}
		 {	
			 return ;// TODO!
		 } 
		 case Variable::V_SLACK_DIST_CRED_DIA_INFERIOR:	// fcm_{i,d,tps,t}
		 {	
			 return ;// TODO!
		 } 
		 case Variable::V_COMBINACAO_DIVISAO_CREDITO:   // m{i,d,k}
		 {	
			 return ;// TODO!
		 }
		 case Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M: // fkm{i,d,k}
		 {	
			 return ;// TODO!
		 } 
		 case Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P: // fkp{i,d,t}
		 {	
			 return ;// TODO!
		 }
		 case Variable::V_ABERTURA_COMPATIVEL:		 //zc_{d,t}
		 {	
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getDia() == v->getDia() &&
					  vSol->getDisciplina() == v->getDisciplina() )
					  return 1;
			 }

			 return 0;
		 }		 
		 case Variable::V_COMBINA_SL_SALA:			 // cs_{s,t,k}
		 {	
			 return ;// TODO!
		 }  
		 case Variable::V_COMBINA_SL_ALUNO:			 // ca_{a,t,k}
		 {	
			 return ;// TODO!
		 }
		 case Variable::V_MIN_CRED_SEMANA_ALUNO:	 // h_{a}
		 {	
			 return ;// TODO!
		 }  
		 case Variable::V_MAX_CRED_SEMANA_ALUNO:	 // H_{a}
		 {	
			 return ;// TODO!
		 }
		 case Variable::V_SLACK_DEMANDA_ALUNO:		// fd_{i,d,cp}
		 {	
			 // x_{i,d,u,s,t}
			 ITERA_VECTOR( it_Vars_x, vars_x, Variable )
			 {
				 Variable *vSol = *it_Vars_x;
				 if ( vSol->getTurma() == v->getTurma() &&
					  vSol->getDisciplina() == v->getDisciplina() &&
					  problemData->retornaCampus( vSol->getUnidade()->getId() ) == v->getCampus() )
				 {
					  return 0; // Supõe-se que a demanda tenha sido totalmente atendida, dado que existe turma em um dia.
				 }
			 }

			 return 1;
		 }
		 case Variable::V_SLACK_SLACKDEMANDA_PT:	// ffd_{i1,d,i2,-d,cp}
		 {	
			 // x_{i1,d1,u,s,t}
			 ITERA_VECTOR( it1_Vars_x, vars_x, Variable )
			 {
				 Variable *v1Sol = *it1_Vars_x;
				 if ( v1Sol->getTurma() == v->getTurma1() &&
					  v1Sol->getDisciplina() == v->getDisciplina1() &&
					  problemData->retornaCampus( v1Sol->getUnidade()->getId() ) == v->getCampus() )
				 {
					 // x_{i2,d2,u,s',t}
					 ITERA_VECTOR( it2_Vars_x, vars_x, Variable )
					 {
						 Variable *v2Sol = *it2_Vars_x;
						 if ( v2Sol->getTurma() == v->getTurma2() &&
							  v2Sol->getDisciplina() == v->getDisciplina2() &&
							  problemData->retornaCampus( v2Sol->getUnidade()->getId() ) == v->getCampus() )
							  return 0;
					 }

					 return 1;
				 }
			 }

			 return 1;
		 }
		 case Variable::V_SLACK_ALUNO_VARIAS_UNID_DIA: // fu_{i1,d1,i2,d2,t}
		 {
			 // x_{i1,d1,u,s,t}
			 ITERA_VECTOR( it1_Vars_x, vars_x, Variable )
			 {
				 Variable *v1Sol = *it1_Vars_x;
				 if ( v1Sol->getTurma() == v->getTurma1() &&
					  v1Sol->getDisciplina() == v->getDisciplina1() &&
					  v1Sol->getDia() == v->getDia() )
				 {
					 // x_{i2,d2,u,s',t}
					 ITERA_VECTOR( it2_Vars_x, vars_x, Variable )
					 {
						 Variable *v2Sol = *it2_Vars_x;
						 if ( v2Sol->getTurma() == v->getTurma2() &&
							  v2Sol->getDisciplina() == v->getDisciplina2() &&
							  v2Sol->getDia() == v->getDia() )
							  return 1;
					 }

					 return 0;
				 }
			 }

			 return 0;
		 }  

		 default:
		 {
			 std::cout << "\nEm SolverMIP::fixaLimitesVariavelTaticoCjtAlunosAnterior( Variable *v ):"
				 << "\nVariavel de tipo " << v->getType() << " desconhecido\n";
			return 0;
			break;
		 }
	}
	*/

}

/*
	Recebe uma Variavel v correspondente a um conjunto de alunos de P2.
	Procura v no conjunto solução de P1. Se encontrar retorna o seu valor.
	Se não, retorn 0 e marca FOUND = false.
*/
double SolverMIP::fixaLimitesVariavelTaticoPriorAnterior( Variable *v, bool &FOUND )
{
	// Verifica primeiro se a variavel procurada teve folga de demanda na prioridade anterior.
	// Se tiver tido, retorna que não encontrou v, para que esta não seja fixada com valores anteriores
	// e tenha a oportunidade de tentar ser alocada novamente.
	/* // Acho que não precisa disso mais pq o filtro de removeAtendimentosParciais() está mais completo
	if ( v->getDisciplina() != NULL && v->getTurma() != -1 )
	{
		Variable *vfd;
		vfd->reset();
		vfd->setType( Variable::V_SLACK_DEMANDA_ALUNO );
		vfd->setTurma( v->getTurma() );
		vfd->setDisciplina( v->getDisciplina() );
		vfd->setCampus( v->getCampus() );

		GGroup< Variable *, LessPtr<Variable> >::iterator itVar = solVars.find( vfd );
		if ( itVar != solVars.end() )
		{
			FOUND = false;
			return 0.0;
		}
	}*/
	
	if ( v->getType() == Variable::V_CREDITOS )
	{
		// A variavel x adquire o campo "sala" em solVars, mas v ainda não o tem,
		// por isso x tem que ser comparada separada, por atributo
		ITERA_GGROUP_LESSPTR ( itVar, solVars, Variable )
		{
			Variable vSol = **itVar;		

			if ( vSol.getTurma() == v->getTurma() &&
				 vSol.getDisciplina() == v->getDisciplina() &&
				 vSol.getUnidade() == v->getUnidade() &&
				 vSol.getSubCjtSala() == v->getSubCjtSala() &&
				 vSol.getDia() == v->getDia() &&
				 vSol.getType() == Variable::V_CREDITOS )
			{
				FOUND = true;
				return vSol.getValue();				
			}
		}
	}
	else
	{
		GGroup< Variable *, LessPtr<Variable> >::iterator itVar = solVars.find( v );
		if ( itVar != solVars.end() )
		{
			FOUND = true;
			return (*itVar)->getValue();
		}
	}
	
	FOUND = false;
	return 0.0;
}

double SolverMIP::fixaLimitesVariavelTaticoComHorAnterior( VariableTatico *v, bool &FOUND )
{
	if ( v->getType() == VariableTatico::V_SLACK_DEMANDA )
	{
		ITERA_GGROUP_LESSPTR ( itVar, solVarsTatico, VariableTatico )
		{
			VariableTatico vSol = **itVar;		

			if ( vSol.getType() == VariableTatico::V_ABERTURA &&
				 vSol.getTurma() == v->getTurma() &&
				 vSol.getDisciplina() == v->getDisciplina() &&		
				 vSol.getCampus() == v->getCampus() )
			{
				FOUND = true;
				return (0.0);				
			}
		}
	}
	else if ( v->getType() == VariableTatico::V_CREDITOS )
	{
		// A variavel x adquire o campo "sala" em solVars, mas v ainda não o tem,
		// por isso x tem que ser comparada separada, por atributo
		ITERA_GGROUP_LESSPTR ( itVar, solVarsTatico, VariableTatico )
		{
			VariableTatico vSol = **itVar;		

			if ( vSol.getTurma() == v->getTurma() &&
				 vSol.getDisciplina() == v->getDisciplina() &&
				 vSol.getUnidade() == v->getUnidade() &&
				 vSol.getSubCjtSala() == v->getSubCjtSala() &&
				 vSol.getDia() == v->getDia() &&
				 vSol.getHorarioAulaInicial() == v->getHorarioAulaInicial() &&
				 vSol.getHorarioAulaFinal() == v->getHorarioAulaFinal() &&
				 vSol.getType() == VariableTatico::V_CREDITOS )
			{
				FOUND = true;
				return (1.0);				
			}
		}
	}
	else
	{
		GGroup< VariableTatico *, LessPtr<VariableTatico> >::iterator itVar = solVarsTatico.find( v );
		if ( itVar != solVarsTatico.end() )
		{
			FOUND = true;
			int intValue = (int) ( (*itVar)->getValue() + 0.5 );
			return (double) intValue;
		}
	}
	
	FOUND = false;
	return 0.0;
}

void SolverMIP::carregaVariaveisSolucaoPreTatico_CjtAlunos( int campusId, int prioridade, int cjtAlunos, int r )
{
   double * xSol = NULL;
   VariablePreHash::iterator vit;
   map<ConjuntoSala *, int, LessPtr<ConjuntoSala>> mapCreditosSalas;

 //  SolutionLoader sLoader( problemData, problemSolution );
   lp->updateLP();
   int nroColsLP = lp->getNumCols();
   xSol = new double[ nroColsLP ];
   
   if ( this->CARREGA_SOLUCAO )
   {
	   int status = readSolBin( campusId, prioridade, cjtAlunos, r, 0, OutPutFileType::PRE_TAT_BIN, xSol );
	   if ( !status )
	   {
		   std::cout << "\nErro em SolverMIP::carregaVariaveisSolucaoPreTatico_CjtAlunos( int campusId, int prioridade, int cjtAlunos, int r ): arquivo nao encontrado.\n";
		   exit(0);
	   }
   }
   else
   {
	   lp->getX( xSol );
   }

   
   char solFilename[1024];
   strcpy( solFilename, getSolucaoPreTaticoFileName( campusId, prioridade, cjtAlunos, r ).c_str() );

   FILE * fout = fopen( solFilename, "wt" );

   if ( fout == NULL )
   {
	   std::cout << "\nErro em SolverMIP::carregaVariaveisSolucaoPreTatico_CjtAlunos( int campusAtualId, int prioridade, int cjtAlunos, int r )"
				 << "\nArquivo " << solFilename << " nao pode ser aberto\n";
	   fout = fopen( "solPreSubstituto.txt", "wt" );
	   if ( fout == NULL )
	   {
			std::cout <<"\nErro de novo. Finalizando execucao...\n";
			exit(0);
	   }
   }

   int nroNaoAtendimentoAlunoDemanda = 0;
   int nroAtendimentoAlunoDemanda = 0;

   vit = vHashPre.begin();
   while ( vit != vHashPre.end() )
   {
	  double value = xSol[ vit->second ];

      if ( value > 0.00001 )
      {
		  VariablePre * v = new VariablePre( vit->first );
		  int col = vit->second;
		  v->setValue( xSol[ col ] );
		           
		 char auxName[100];
         lp->getColName( auxName, col, 100 );
         fprintf( fout, "%s = %f\n", auxName, v->getValue() );

         switch( v->getType() )
         {
			 case VariablePre::V_ERROR:
				std::cout << "Variável inválida " << std::endl;
				break;
			 case VariablePre::V_PRE_CREDITOS:
				std::cout << "Oferta de " << v->getValue()
						  << " creditos da disciplina " << v->getDisciplina()->getCodigo()
						  << " para a turma " << v->getTurma()
						  << " para alguma de sala do conjunto de salas " << v->getSubCjtSala()->getId()
						  << std::endl << std::endl;
				mapCreditosSalas[v->getSubCjtSala()] += ((int)(xSol[ col ] + 0.5)) * ((int)(v->getDisciplina()->getTempoCredSemanaLetiva()+0.5));
				solVarsXPre.add( v );
				break;
			 case VariablePre::V_PRE_ALUNOS:
				std::cout << "Oferecimento de " << v->getValue()
						  << " vagas da disciplina " << v->getDisciplina()->getCodigo()
						  << " para a turma " << v->getTurma()
						  << " da oferta " << v->getOferta()->getId()
						  << " do curso " << v->getOferta()->curso->getCodigo()
						  << std::endl << std::endl;
				nroAtendimentoAlunoDemanda += v->getValue();				
				break;
			 case VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC: 
				 this->preencheMapAtendimentoAluno( v );
				 break;
			 case VariablePre::V_PRE_SLACK_DEMANDA:				 				 
				 // ------------ Preenche listSlackDemandaAluno ----------------
				 if ( problemData->parametros->otimizarPor == "ALUNO" )
				 {
					 Disciplina *d = v->getDisciplina();
					 Aluno *aluno = v->getAluno();

					 AlunoDemanda *ad = problemData->procuraAlunoDemanda( d->getId(), aluno->getAlunoId(), prioridade );

					 problemData->listSlackDemandaAluno.add( ad );		 
					 
					 nroNaoAtendimentoAlunoDemanda++;		 					 
				 }
				 // ------------------------------------------------------------
				 break; 
         }

		 if ( v->getType() != VariablePre::V_PRE_CREDITOS )
			 delete v;
      }

      vit++;
   }
   
   fprintf( fout, "\nAlunosDemanda nao atendidos = %d\n", nroNaoAtendimentoAlunoDemanda );
   fprintf( fout, "AlunosDemanda atendidos = %d", nroAtendimentoAlunoDemanda );

   if ( fout )
   {
      fclose( fout );
   }
      
   if ( vHashPre.size() > 0 )
   {
	   vHashPre.clear();
   }
   if ( cHashPre.size() > 0 )
   {
	   cHashPre.clear();
   }

   char solFilenameCreditosSala[1024];   
   strcpy( solFilenameCreditosSala, string("CreditosSala_"+getSolucaoPreTaticoFileName( campusId, prioridade, cjtAlunos, r )).c_str() );

   FILE * foutCS = fopen( solFilenameCreditosSala, "wt" );

   if ( foutCS )
   {
	   for(map<ConjuntoSala *, int, LessPtr<ConjuntoSala>>::iterator itCS = mapCreditosSalas.begin();
		   itCS != mapCreditosSalas.end();
		   itCS++)
	   {
		   fprintf( foutCS, "%i = %i (MAX = %i)\n", itCS->first->getId(), itCS->second,itCS->first->minLimiteTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor ) );
	   }
	   fclose( foutCS );
   }

   if ( xSol )
   {
      delete [] xSol;
   }
   						
   bool violou = problemData->violaMinTurma( campusId );
   
   return;
}

int SolverMIP::carregaVariaveisSolucaoTaticoPorAluno_CjtAlunos( int campusAtualId, int prioridade, int cjtAlunos, int r, int tatico )
{
	problemData->mapSlackCampusTurmaDisc_AlunosDemanda.clear();
	problemData->mapSlackAluno_CampusTurmaDisc.clear();

   double * xSol = NULL;
   
   SolutionLoader sLoader( problemData, problemSolution );
   lp->updateLP();

   int nroColsLP = lp->getNumCols();
   xSol = new double[ nroColsLP ];
	
	#pragma region Carrega solucao
	if ( this->CARREGA_SOLUCAO )
	{
		int status = readSolBin( campusAtualId, prioridade, cjtAlunos, r, tatico, OutPutFileType::TAT_HOR_BIN, xSol );
		if ( !status )
		{
		   std::cout << "\nErro em SolverMIP::carregaVariaveisSolucaoTaticoPorAluno_CjtAlunos( int campusId, int prioridade, int cjtAlunos, int r, int tatico ): arquivo "
					" nao encontrado.\n";
			exit(0);
		}
	}
	else
	{
		lp->getX( xSol );
	}
	#pragma endregion

   std::map< std::pair<Disciplina*, Oferta*>, int > mapSlackDemanda;
   std::map< std::pair<Disciplina*, Oferta*>, int >::iterator itMapSlackDemanda;
   

   char solFilename[1024];
   strcpy( solFilename, getSolucaoTaticoFileName( campusAtualId, prioridade, cjtAlunos, r, tatico ).c_str() );

   FILE * fout = fopen( solFilename, "wt" );
   if ( fout == NULL )
   {
	   std::cout << "\nErro em SolverMIP::carregaVariaveisSolucaoTaticoPorAluno_CjtAlunos( int campusAtualId, int prioridade, int cjtAlunos, int tatico )"
				 << "\nArquivo nao pode ser aberto\n";
	   fout = fopen( "solSubstituto.txt", "wt" );
	   if ( fout == NULL )
	   {
			std::cout <<"\nErro de novo. Finalizando execucao...\n";
			exit(0);
	   }
   }

   if ( tatico==2 && prioridade==1 )
	  teste( xSol, 1 );
      
   int nroNaoAtendimentoAlunoDemanda = 0;
   int nroAtendimentoAlunoDemanda = 0;
   Aluno *vAluno;
   AlunoDemanda *alunoDem;
   Disciplina *vDisc;
   HorarioAula *vhi;
   HorarioAula *vhf;
   Sala *vSala;
   int vDia;
   int vTurma;
   int vCampusId;

   #ifndef TATICO_COM_HORARIOS
   VariableHash::iterator vit = vHash.begin();
   while ( vit != vHash.end() )
   {
	  Variable* v = new Variable( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         //#ifdef DEBUG
         char auxName[100];
         lp->getColName( auxName, col, 100 );
         fprintf( fout, "%s = %f\n", auxName, v->getValue() );
         //#endif
		 		 
		 Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;

         switch( v->getType() )
         {
			 case Variable::V_ERROR:
				std::cout << "Variável inválida " << std::endl;
				break;
			 case Variable::V_CREDITOS:				 					 
				 vDisc = v->getDisciplina();
				 vTurma = v->getTurma();
				 vCampusId = v->getUnidade()->getIdCampus();

				 trio.set(vCampusId, vTurma, vDisc);
				 std::cout << problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size() << " vagas para a oferta"
					 << " de " << v->getValue()
						  << " creditos da disciplina " << v->getDisciplina()->getCodigo() << " id" << v->getDisciplina()->getId()
						  << " para a turma " << v->getTurma()
						  << " no dia " << v->getDia()
						  << " para a sala " << v->getSubCjtSala()->salas.begin()->first
						  << std::endl << std::endl;
				break;
			 case Variable::V_ABERTURA:
				 vDisc = v->getDisciplina();
				 vTurma = v->getTurma();
				 vCampusId = v->getCampus()->getId();

				 trio.set(vCampusId, vTurma, vDisc);
				 nroAtendimentoAlunoDemanda += problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size();
				 break;
			 case Variable::V_SLACK_DEMANDA_ALUNO:

				 // ------------ Preenche mapSlackDemanda ---------------------

				 vDisc = v->getDisciplina();
				 vTurma = v->getTurma();
				 vCampusId = v->getCampus()->getId();

				 trio.set(vCampusId, vTurma, vDisc);

				 std::map< Trio< int, int, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator 
					 itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
				 
				 if ( itMap != problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
				 {
					 GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = itMap->second;					
				 
					 ITERA_GGROUP_LESSPTR( itAlDem, alunosDemanda, AlunoDemanda )
					 {
						 nroNaoAtendimentoAlunoDemanda++;
						 problemData->listSlackDemandaAluno.add( *itAlDem );				 

						 itMapSlackDemanda = mapSlackDemanda.find( std::make_pair( vDisc, itAlDem->demanda->oferta ) );
						 if ( itMapSlackDemanda != mapSlackDemanda.end() )
							 itMapSlackDemanda->second = itMapSlackDemanda->second + 1;
						 else
							mapSlackDemanda[ std::make_pair( vDisc, itAlDem->demanda->oferta ) ] = 1;			 
					 }
				 }
				 // ------------------------------------------------------------

				 break;
         }
      }

	  delete v;
	 
      vit++;
   }
   #endif

   #ifdef TATICO_COM_HORARIOS
   VariableTaticoHash::iterator vit = vHashTatico.begin();
   while ( vit != vHashTatico.end() )
   {
	  VariableTatico* v = new VariableTatico( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         //#ifdef DEBUG
         char auxName[100];
         lp->getColName( auxName, col, 100 );
         fprintf( fout, "%s = %f\n", auxName, v->getValue() );
         //#endif
		 		 
		 Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;

         switch( v->getType() )
         {
			 case VariableTatico::V_ERROR:
				std::cout << "Variável inválida " << std::endl;
				break;
			 case VariableTatico::V_CREDITOS:				 					 
				break;
			 case VariableTatico::V_ABERTURA:
				 vDisc = v->getDisciplina();
				 vTurma = v->getTurma();
				 vCampusId = v->getCampus()->getId();

				 trio.set(vCampusId, vTurma, vDisc);
				 nroAtendimentoAlunoDemanda += problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size();
				 break;
			 case VariableTatico::V_DESALOCA_ALUNO:

				 vDisc = v->getDisciplina();
				 vTurma = v->getTurma();
				 vAluno = v->getAluno();
				 				 
				 alunoDem = vAluno->getAlunoDemanda( vDisc->getId() );

				 nroNaoAtendimentoAlunoDemanda++;
				 problemData->listSlackDemandaAluno.add( alunoDem );				 

				 itMapSlackDemanda = mapSlackDemanda.find( std::make_pair( vDisc, alunoDem->demanda->oferta ) );
				 if ( itMapSlackDemanda != mapSlackDemanda.end() )
				 	itMapSlackDemanda->second = itMapSlackDemanda->second + 1;
				 else
					mapSlackDemanda[ std::make_pair( vDisc, alunoDem->demanda->oferta ) ] = 1;			 
				
				 break;
			 case VariableTatico::V_SLACK_DEMANDA:

				 // ------------ Preenche mapSlackDemanda ---------------------

				 vDisc = v->getDisciplina();
				 vTurma = v->getTurma();
				 vCampusId = v->getCampus()->getId();

				 trio.set(vCampusId, vTurma, vDisc);

				 std::map< Trio< int, int, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator 
					 itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
				 
				 if ( itMap != problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
				 {
					 std::cout<<"\n\nFolga i"<<vTurma<<" Disc"<<vDisc->getId()<<":";

					 GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = itMap->second;					
				 
					 ITERA_GGROUP_LESSPTR( itAlDem, alunosDemanda, AlunoDemanda )
					 {
						 nroNaoAtendimentoAlunoDemanda++;
						 problemData->listSlackDemandaAluno.add( *itAlDem );				 
					 
						 std::cout<<"\n   Aluno"<<(*itAlDem)->getAlunoId()<<" AlunoDemanda"<<(*itAlDem)->getId()<<" Prior"<<(*itAlDem)->getPrioridade();
						 
						 itMapSlackDemanda = mapSlackDemanda.find( std::make_pair( vDisc, itAlDem->demanda->oferta ) );
						 if ( itMapSlackDemanda != mapSlackDemanda.end() )
							 itMapSlackDemanda->second = itMapSlackDemanda->second + 1;
						 else
							mapSlackDemanda[ std::make_pair( vDisc, itAlDem->demanda->oferta ) ] = 1;			 
					 }
				 }
				 // ------------------------------------------------------------

				 break;

           }
      }

	  delete v;
	 
      vit++;
   }
   #endif

	std::cout << std::endl;

   // Escreve um resumo do não-atendimento das demandas, juntando
   // as demandas não atendidas por oferta.
	itMapSlackDemanda = mapSlackDemanda.begin();
	for ( ; itMapSlackDemanda != mapSlackDemanda.end() ; itMapSlackDemanda++ )
	{
		fprintf( fout, "FD_{_Disc%d_Oft%d} = %d\n",
			itMapSlackDemanda->first.first->getId(), 
			itMapSlackDemanda->first.second->getId(), 
			itMapSlackDemanda->second );
	}
	fprintf( fout, "\nAlunosDemanda nao atendidos = %d\n", nroNaoAtendimentoAlunoDemanda );
	fprintf( fout, "AlunosDemanda atendidos = %d", nroAtendimentoAlunoDemanda );

	std::cout << std::endl;

    if ( fout )
    {
        fclose( fout );
    }	
    
	
   if ( tatico==2 && prioridade==1 )
	  teste( xSol, 2 );

	int nar = removeAtendimentosParciais( xSol, solFilename, prioridade );

#ifndef TATICO_COM_HORARIOS
   vit = vHash.begin();
   for (; vit != vHash.end(); ++vit )
   {
      Variable * v = new Variable( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         sLoader.setFolgas( v );
      }

      delete v;
   }
#endif

#ifdef TATICO_COM_HORARIOS
   vit = vHashTatico.begin();
   for (; vit != vHashTatico.end(); ++vit )
   {
      VariableTatico * v = new VariableTatico( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         sLoader.setFolgas( v );
      }

      delete v;
   }
#endif


   if ( tatico==2 && prioridade==1 )
	  teste( xSol, 3 );

  
   if ( tatico==2 ) // para a segunda rodada do tatico, aproveita-se as variaveis. Logo, não posso deletar o primeiro.
   {
	   if ( vHash.size() > 0 )
	   {
		   vHash.clear();
	   }
	   if ( vHashTatico.size() > 0 )
	   {
		   vHashTatico.clear();
	   }
   }    
   if ( cHash.size() > 0 )
   {
	   cHash.clear();
   }
   if ( cHashTatico.size() > 0 )
   {
	   cHashTatico.clear();
   }

   if ( xSol )
   {
      delete [] xSol;
   }
   
   bool violou = problemData->violaMinTurma( campusAtualId );

   return ( nar + nroNaoAtendimentoAlunoDemanda );
}

int SolverMIP::solveTaticoPorCampusCjtAlunos()
{
	int statusPre, statusTatico, status = 1;
		
#ifdef READ_SOLUTION
	this->CARREGA_SOLUCAO = true;
#endif
#ifndef READ_SOLUTION
	this->CARREGA_SOLUCAO = false;
#endif

    ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
    {		

		int campusId = ( *itCampus )->getId();

		this->campusAtualId = campusId;

		std::cout<<"\n\n--------------------------------------------------------------------------------";		
		std::cout<<"\n-------------------------- Campus " << campusId << "----------------------------\n";

		int n_prioridades = problemData->nPrioridadesDemanda[campusId];

		for( int P = 1; P <= n_prioridades; P++ )
		{			
			std::cout<<"\n-------------------------- Prioridade " << P << "---------------------------\n";
			
			// limpa o atendimento anterior, correspondente à prioridade anterior
			if ( !FIXAR_P1 )
				limpaMapAtendimentoAlunoPrioridadeAnterior( campusId );
			
			// Cria e ordena os conjuntos de alunos
			problemData->criaCjtAlunos( campusId, P, this->FIXAR_P1 );
			
			problemData->imprimeCjtAlunos( campusId );

			// Resolve pre-modelo e tatico para cada conjunto
			map< int, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
				itMapCjtAlunos = problemData->cjtAlunos.begin();
			
			for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
			{
				int grupoId = itMapCjtAlunos->first;
				GGroup< Aluno *, LessPtr< Aluno > > gruposAlunos = itMapCjtAlunos->second;

				int nRodadas;
				if ( problemData->parametros->min_alunos_abertura_turmas ) nRodadas = 2;
				else nRodadas = 1;

				for ( int r=1; r<=nRodadas ;r++ )
				{
					
					if ( P == 1 )
					{
						std::cout<<"\n---------------------Rodada "<< r <<" -----------------------\n";
						std::cout<<"\n------- Campus "<< campusId << " , Conjunto-Aluno "<< grupoId << ", Prior " << P << "----------\n";
						std::cout<<"\n------------------------------Pre-modelo------------------------------\n"; fflush(NULL);
				
						statusPre = solvePreTaticoCjtAlunos( campusId, P, grupoId, r );    

						carregaVariaveisSolucaoPreTatico_CjtAlunos( campusId, P, grupoId, r );								
						//imprimeSolVarsPre( campusId, P, grupoId );

						//preencheMapAtendimentoAluno( campusId );
					
						problemData->imprimeAlocacaoAlunos( campusId, P, grupoId, false, r, 0 );

					#ifndef TATICO_COM_HORARIOS
						encontraCliques(true);				
						imprimeCliques( campusId, P, grupoId );
					#endif
						int nTaticos=2;
						for ( int tatico=1; tatico<=nTaticos; tatico++ )
						{
							std::cout<<"\n---------------------Rodada "<< r <<" -----------------------\n";
							std::cout<<"\n------- Campus "<< campusId << " , Conjunto-Aluno "<< grupoId << ", Prior " << P << "----------\n";
							std::cout<<"\n------------------------------Tatico "<<tatico<<"------------------------------\n"; fflush(NULL);

							statusTatico = solveTaticoBasicoCjtAlunos( campusId, P, grupoId, r, tatico );

							int na = carregaVariaveisSolucaoTaticoPorAluno_CjtAlunos( campusId, P, grupoId, r, tatico );
						
							std::cout<<"\nCarregou solucao tatica\n";
				
							problemData->imprimeAlocacaoAlunos( campusId, P, grupoId, false, r, tatico );
						
							if ( na == 0 ) break;
						
							if (tatico < nTaticos) 
							{
								voltaComAlunosNaoAlocados();							
							}
						}
						   
						statusTatico = ( statusTatico && statusPre );
					
						vHash.clear();
						vHashTatico.clear();
					}												
					
					// ==================================
					// MODELO INTEGRADO	COM NOVAS TURMAS	
					bool NOVAS_TURMAS = true;
					if ( NOVAS_TURMAS )					
					if ( problemData->listSlackDemandaAluno.size() != 0 )
					{
						TaticoIntAlunoHor * solverTaticoInt = new TaticoIntAlunoHor( this->problemData, &(this->solVarsTatico), &(this->vars_xh),
																					&this->CARREGA_SOLUCAO, false, NOVAS_TURMAS );
						solverTaticoInt->solveTaticoIntegrado( campusId, P, r );
						delete solverTaticoInt;
					}
					// ==================================	
					
					if ( problemData->listSlackDemandaAluno.size() == 0 ) break;
					
					// ==================================
					// MODELO INTEGRADO COM EQUIVALENCIAS					
					if ( r==1 )
					if ( problemData->parametros->considerar_equivalencia_por_aluno )					
					if ( problemData->listSlackDemandaAluno.size() != 0 )
					{
						TaticoIntAlunoHor * solverTaticoInt = new TaticoIntAlunoHor( this->problemData, &(this->solVarsTatico), &(this->vars_xh), 
																					&this->CARREGA_SOLUCAO, true, false );
						solverTaticoInt->solveTaticoIntegrado( campusId, P, r );						
						delete solverTaticoInt;
					}
					// ==================================

					if ( problemData->listSlackDemandaAluno.size() == 0 ) break;

					// Faz rodadas duplas só para p1
					if (P>1) break;
					
					// Rodada dupla somente se estiverem sendo considerados formandos e minimo de alunos em turmas
					if ( !problemData->parametros->violar_min_alunos_turmas_formandos ||
						 !problemData->parametros->min_alunos_abertura_turmas ||
						 !(*itCampus)->getPossuiAlunoFormando() ) break;
					
					// Retira de listSlackDemandaAluno todos os AlunosDemanda de P que não foram atendidos
					if ( r<nRodadas )
					{
						GGroup< AlunoDemanda *, LessPtr< AlunoDemanda > >::iterator 
							itAlDem=problemData->listSlackDemandaAluno.begin();
						while ( itAlDem != problemData->listSlackDemandaAluno.end() )
						{
							AlunoDemanda *ad = *itAlDem;
							if ( ad->getPrioridade() == P )
							{
								itAlDem = problemData->listSlackDemandaAluno.remove( *itAlDem );								
							}
							else
								itAlDem++;
						}
					}
				}
			}

		#ifndef TATICO_COM_HORARIOS
			atualizaNroCredsPorDiaAlunos( campusAtualId, P );
		#endif		
			
			if ( ! problemData->parametros->utilizarDemandasP2 )
				break;

			if ( problemData->listSlackDemandaAluno.size() == 0 )
			{
				std::cout << "\nSem folga de demandas!\n"; fflush(NULL);
				break;
			}
			else if ( P + 1 <= n_prioridades )
			{
				std::cout << "\nAtualizacao de demandas de prioridade " << P + 1<<"..."; fflush(NULL);
				problemData->atualizaDemandas( P+1, campusId );
				std::cout << "  atualizadas!\n"; fflush(NULL);

				// ==================================
				// MODELO INTEGRADO	PARA SUBSTITUIR HEURISTICA DE P2
#ifdef MODELO_INTEGRADO_P2
				if ( problemData->listSlackDemandaAluno.size() != 0 )
				{
					TaticoIntAlunoHor * solverTaticoInt = new TaticoIntAlunoHor( this->problemData, &(this->solVarsTatico), &(this->vars_xh),
																				&this->CARREGA_SOLUCAO, false, false );
					solverTaticoInt->solveTaticoIntegrado( campusId, P+1, 1 );
					delete solverTaticoInt;
				}
#endif
				// ==================================

			}			
		}
		
		problemData->confereExcessoP2( campusId );
		
		problemData->listSlackDemandaAluno.clear(); // Caso seja util ter isso depois, entao tem que fazer um map com campus

		mudaCjtSalaParaSala();
		
		std::cout<<"\nPreenchendo a estrutura atendimento_campus com a saida.\n";        
		
#ifdef TATICO_COM_HORARIOS
		getSolutionTaticoPorAlunoComHorario();
#else
		getSolutionTaticoPorAluno();
#endif
		status = ( status && statusTatico );
	}
	
	return (status);
}

int SolverMIP::solvePreTaticoCjtAlunos( int campusId, int prioridade, int cjtAlunosId, int r )
{
	int status = 0;
	
	bool CARREGA_SOL_PARCIAL = this->CARREGA_SOLUCAO;

	bool CARREGOU_HEURISTICA = false;

   if ( this->CARREGA_SOLUCAO )
   {
#ifdef HEURISTICA_P2
		if ( leSolucaoHeuritica( campusId, prioridade, cjtAlunosId ) )
		{
			CARREGOU_HEURISTICA = true;		
			problemData->imprimeAlocacaoAlunos( campusId, prioridade, cjtAlunosId, true, r, 0 );
		}
#endif
	   char solName[1024];
	   strcpy( solName, getSolPreBinFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );
	   FILE* fin = fopen( solName,"rb");
	   if ( fin == NULL )
	   {
		   std::cout << "\nA partir de " << solName << " , nao foram lidas mais solucoes.\n"; fflush(NULL);
		   this->CARREGA_SOLUCAO = false;
	   }
	   else
	   {
		   fclose(fin);
	   }
   }

#ifdef HEURISTICA_P2
   // --------------------------------------------------------
   // HEURISTICA

   // Aloca alunos de prioridade 2 em turmas já existentes
   if ( !this->CARREGA_SOLUCAO && !CARREGOU_HEURISTICA && prioridade > 1 )
   {
#ifndef TATICO_COM_HORARIOS
	   this->heuristicaAlocaAlunos( campusId, prioridade, cjtAlunosId );
#else
	   this->heuristica2AlocaAlunos( campusId, prioridade, cjtAlunosId );
#endif
	   problemData->imprimeAlocacaoAlunos( campusId, prioridade, cjtAlunosId, true, r, 0 );
	   this->imprimeAlocacaoFinalHeuristica( campusId, prioridade, cjtAlunosId );

	   escreveSolucaoBinHeuristica( campusId, prioridade, cjtAlunosId );	   
   
	   CARREGA_SOL_PARCIAL=false;
   }
   // --------------------------------------------------------
#endif
      
   if ( prioridade>1 )
   {
	   problemData->removeDemandasEmExcesso( campusId, prioridade, cjtAlunosId );
	   problemData->reduzNroTurmasPorDisciplina( campusId, prioridade );
   }

   if ( lp != NULL )
   {
      lp->freeProb();
      delete lp;
#ifdef SOLVER_CPLEX
	   lp = new OPT_CPLEX; 
#endif
#ifdef SOLVER_GUROBI
	   lp = new OPT_GUROBI; 
#endif
   }
   
   if ( vHashPre.size() > 0 )
   {
	   vHashPre.clear();
   }
   if ( cHashPre.size() > 0 )
   {
	   cHashPre.clear();
   }

   int varNum = 0;
   int constNum = 0;

   char lpName[1024], id[100];
   strcpy( lpName, getPreLpFileName( campusId, prioridade, cjtAlunosId, r ).c_str() );

   if ( problemData->parametros->funcao_objetivo == 0
      || problemData->parametros->funcao_objetivo == 2 )
   {
      lp->createLP( lpName, OPTSENSE_MAXIMIZE, PROB_MIP );
   }
   else if( problemData->parametros->funcao_objetivo == 1 )
   {
      lp->createLP( lpName, OPTSENSE_MINIMIZE, PROB_MIP );
   }

#ifdef DEBUG
   printf( "Creating LP...\n" );
#endif

   std::cout<<"\nCriando modelo...\n";

   // Variable creation
   varNum = cria_preVariaveis( campusId, prioridade, cjtAlunosId, r );

   lp->updateLP();
      
#ifdef PRINT_cria_variaveis
   printf( "Total of Variables: %i\n\n", varNum );
#endif
      
	// -----------------------------------------------------
	// Deleta as variaveis em solVarsXPre 
	ITERA_GGROUP_LESSPTR ( it, solVarsXPre, VariablePre )
	{
		delete *it;    
	}
	solVarsXPre.clear();
    // --------------------------------------------

   if ( !this->CARREGA_SOLUCAO )
   {
	    ofstream outGaps;
		std::string gapFilename( "gap_input" );
		gapFilename += problemData->getInputFileName();
		gapFilename += ".txt";	

	    // Constraint creation
	    constNum = cria_preRestricoes( campusId, prioridade, cjtAlunosId, r );

	    lp->updateLP();

		#ifdef PRINT_cria_restricoes
	    printf( "Total of Constraints: %i\n\n", constNum );
		#endif   

		lp->writeProbLP( string( "1"+string(lpName) ).c_str() );
   
		// -------------------------------------------------------------------
		// Fixa o ub = 0 para todas as variaveis que possuem lb zero e são livres

		std::cout << "\n=========================================";
	    std::cout << "\nGarantindo solucao...\n"; fflush(NULL);

		std::map< int, double > vHashLivresOriginais;

		int *idxUB = new int[lp->getNumCols()*2];
		double *valUB = new double[lp->getNumCols()*2];
		BOUNDTYPE *bts = new BOUNDTYPE[lp->getNumCols()*2];

		int nChgUB = 0;
		
		VariablePreHash::iterator vit = vHashPre.begin();
		for ( ; vit != vHashPre.end(); vit++ )
		{
			VariablePre v = vit->first;

			if ( v.getType() != VariablePre::V_PRE_SLACK_DEMANDA &&					// fd
				v.getType() != VariablePre::V_PRE_SLACK_PRIOR_INF &&				// fpi
				v.getType() != VariablePre::V_PRE_SLACK_PRIOR_SUP &&				// fps
				v.getType() != VariablePre::V_PRE_FOLGA_ABRE_TURMA_SEQUENCIAL &&	// ft
				v.getType() != VariablePre::V_PRE_TURMAS_COMPART &&					// w
				v.getType() != VariablePre::V_PRE_LIM_SUP_CREDS_SALA &&
			    v.getType() != VariablePre::V_PRE_FOLGA_DISTR_ALUNOS &&		// fda_{}
			    v.getType() != VariablePre::V_PRE_CRED_SALA_F1 && // xcs1
			    v.getType() != VariablePre::V_PRE_CRED_SALA_F2 && // xcs2
			    v.getType() != VariablePre::V_PRE_CRED_SALA_F3 && // xcs3
				v.getType() != VariablePre::V_PRE_ALUNO_SALA ) // as
   			{
				int lb = (int)(lp->getLB(vit->second)+0.5);
				int ub = (int)(lp->getUB(vit->second)+0.5);
				
				if ( lb == 0 && ub != 0 )
				{
					vHashLivresOriginais[ vit->second ] = lp->getUB(vit->second);

					idxUB[nChgUB] = vit->second;
					valUB[nChgUB] = 0.0;
					bts[nChgUB] = BOUNDTYPE::BOUND_UPPER;
					nChgUB++;
				}
			}
		}

        lp->chgBds(nChgUB,idxUB,bts,valUB);
		// -------------------------------------------------------------------
			
		lp->updateLP();
	
		lp->setTimeLimit( 1e10 );
		lp->setMIPRelTol( 0.01 );
		lp->setPreSolve(OPT_TRUE);
		lp->setHeurFrequency(1.0);
		lp->setMIPEmphasis(0);
		lp->setSymetry(0);
		lp->setMIPScreenLog( 4 );
		lp->setNumIntSols(1);

		lp->updateLP();

		lp->writeProbLP( string( "2"+string(lpName) ).c_str() );
	
		double *xS = new double[lp->getNumCols()];

	    if ( CARREGA_SOL_PARCIAL )
		{
			// procura e carrega solucao parcial
			int statusReadBin = readSolBin( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN2, xS );
			if ( !statusReadBin )
			{
				CARREGA_SOL_PARCIAL=false;
			}
			else writeSolTxt( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN2, xS );
		}
		if ( !CARREGA_SOL_PARCIAL )
		{
			// GENERATES SOLUTION 		 
			this->nroPreSolAvaliadas = 0;
			status = lp->optimize( METHOD_MIP );
			lp->getX(xS);
		
			writeSolBin( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN2, xS );
			writeSolTxt( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN2, xS );
		}					

#pragma region Imprime Gap
	 	// Imprime Gap
		outGaps.open(gapFilename, ofstream::app);
		if ( !outGaps )
		{
			std::cerr<<"\nErro: Abertura do arquivo gaps.txt falhou em SolverMIP::solvePreTaticoCjtAlunos().\n";
		}
		else
		{
			outGaps << "Pre-modelo (Garante Solucao) - campus "<< campusId << ", cjtAlunos " << cjtAlunosId << ", prioridade " << prioridade;
			outGaps << "\nGap = " << lp->getMIPGap() * 100 << "%";
			outGaps << "\n\n";
			outGaps.close();
		} 
#pragma endregion

	    // -------------------------------------------------------------------
	    // Volta as variaveis que estavam livres
        nChgUB = 0;
         
		for ( std::map< int, double >::iterator it = vHashLivresOriginais.begin();
			  it != vHashLivresOriginais.end(); it++)
		{
			int col = (*it).first;
			double ub = (*it).second;
			idxUB[nChgUB] = col;
			valUB[nChgUB] = ub;
			bts[nChgUB] = BOUNDTYPE::BOUND_UPPER;
			nChgUB++;
		}
	 
        lp->chgBds(nChgUB,idxUB,bts,valUB);
		lp->updateLP();	   
		// -------------------------------------------------------------------

#ifdef SOLVER_CPLEX
	    lp->setNumIntSols(0);
		lp->setTimeLimit( 7200+3600 );
		lp->setPreSolve(OPT_TRUE);
		lp->setHeurFrequency(1.0);
		lp->setMIPEmphasis(0);
		lp->setSymetry(0);
		lp->setCuts(0);
		lp->setSolNPoolCapacity(20);
		lp->setPolishAfterTime(2400);
		lp->setNodeLimit(1000000);
		lp->setVarSel(4);
		lp->setHeur(10);
		lp->setRins(10);
		lp->setMIPRelTol( 0.0 );
		lp->setMIPScreenLog( 4 );
		lp->setPreSolve(OPT_TRUE);
#endif

#ifdef SOLVER_GUROBI
	    lp->setNumIntSols(0);
		lp->setTimeLimit( 7200 );
		lp->setPreSolve(OPT_TRUE);
		lp->setHeurFrequency(1.0);
		lp->setMIPEmphasis(0);
		lp->setSymetry(0);
		lp->setCuts(-1);
		lp->setNodeLimit(10000000);
		lp->setMIPScreenLog( 4 );
		lp->setMIPRelTol( 0.0 );
#endif

		lp->updateLP();

		std::cout << "\n=========================================";
	    std::cout << "\nGarantindo maximo atendimento...\n"; fflush(NULL);

		int *idxN = new int[lp->getNumCols()];
		double *objN = new double[lp->getNumCols()];
		lp->getObj(0,lp->getNumCols()-1,objN);
		
		int *idxFO = new int[lp->getNumCols()*2];
		double *valFO = new double[lp->getNumCols()*2];
        //nChgUB = 0;
		int nChgFO = 0;

		vit = vHashPre.begin();
		for ( ; vit != vHashPre.end(); vit++ )
		{
			VariablePre v = vit->first;

			idxN[vit->second] = vit->second;
						
			if ( v.getType() == VariablePre::V_PRE_SLACK_DEMANDA && prioridade==1 )
			{
				double coef = 100.0;
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = coef;
				nChgFO++;
			}
			else if ( v.getType() == VariablePre::V_PRE_SLACK_PRIOR_INF )
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 0.4;
				nChgFO++;
			}
			else if ( v.getType() == VariablePre::V_PRE_SLACK_PRIOR_SUP )
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 0.45;
				nChgFO++;
			}
			else if ( v.getType() == VariablePre::V_PRE_ABERTURA )
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 1.0;
				nChgFO++;
			}
			else if ( v.getType() == VariablePre::V_PRE_FOLGA_ABRE_TURMA_SEQUENCIAL )
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 0.1;
				nChgFO++;
			}
			else
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 0.0;
				nChgFO++;
			}
       }
		
	  lp->chgObj(nChgFO,idxFO,valFO);
      lp->updateLP();

	  lp->writeProbLP( string( "3"+string(lpName) ).c_str() );

      lp->copyMIPStartSol(lp->getNumCols(),idxN,xS);
	  lp->updateLP();
		
	  if ( CARREGA_SOL_PARCIAL )
	  {
			// procura e carrega solucao parcial
			int statusReadBin = readSolBin( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN3, xS );
			if ( !statusReadBin )
			{
				CARREGA_SOL_PARCIAL=false;
			}
			else writeSolTxt( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN3, xS );
	  }
	  if ( !CARREGA_SOL_PARCIAL )
	  {
			// GENERATES SOLUTION 		 
			this->nroPreSolAvaliadas = 0;
			status = lp->optimize( METHOD_MIP );
			lp->getX(xS);
		
			writeSolBin( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN3, xS );
			writeSolTxt( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN3, xS );
	  }		

#pragma region Imprime Gap
	 	  // Imprime Gap
		outGaps.open(gapFilename, ofstream::app);
		if ( !outGaps )
		{
			std::cerr<<"\nErro: Abertura do arquivo gaps.txt falhou em SolverMIP::solvePreTaticoCjtAlunos().\n";
		}
		else
		{
			outGaps << "Pre-modelo (Max atendimento) - campus "<< campusId << ", cjtAlunos " << cjtAlunosId << ", prioridade " << prioridade;
			outGaps << "\nGap = " << lp->getMIPGap() * 100 << "%";
			outGaps << "\n\n";
			outGaps.close();
		} 
#pragma endregion

		std::cout << "\n=========================================";
		std::cout << "\nFixando maximo atendimento (sem fixar COMO) e min 'w' e 'as'...\n"; fflush(NULL);

		vit = vHashPre.begin();
		nChgUB = 0;
		for ( ; vit != vHashPre.end(); vit++ )
		{
			VariablePre v = vit->first;

			if ( v.getType() == VariablePre::V_PRE_SLACK_DEMANDA && xS[vit->second] < 0.1 )
			{
				idxUB[nChgUB] = vit->second;
				valUB[nChgUB] = 0.0;
				bts[nChgUB] = BOUNDTYPE::BOUND_UPPER;	
				nChgUB++;
			}
			else if ( v.getType() == VariablePre::V_PRE_ABERTURA && xS[vit->second] > 0.9 )
			{
				idxUB[nChgUB] = vit->second;
				valUB[nChgUB] = 1.0;
				bts[nChgUB] = BOUNDTYPE::BOUND_LOWER;	
				nChgUB++;
			}			
		}

      lp->chgBds(nChgUB,idxUB,bts,valUB);
      lp->updateLP();

      // ----------------------------------------
	  // Função Obj só com variaveis w, as, fpi, fps, ft
      vit = vHashPre.begin();
      nChgFO = 0;
	  for ( ; vit != vHashPre.end(); vit++ )
	  {
			VariablePre v = vit->first;
						
			if ( v.getType() == VariablePre::V_PRE_ALUNO_SALA  ) // as
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 2.0;     
				nChgFO++;
			}
			else if ( v.getType() == VariablePre::V_PRE_TURMAS_COMPART  ) // w
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 5.0;		
				nChgFO++;
			}
			else if ( v.getType() == VariablePre::V_PRE_SLACK_PRIOR_INF )
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 0.2;
				nChgFO++;
			}
			else if ( v.getType() == VariablePre::V_PRE_SLACK_PRIOR_SUP )
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 0.25;
				nChgFO++;
			}
			else if ( v.getType() == VariablePre::V_PRE_FOLGA_ABRE_TURMA_SEQUENCIAL )
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 0.1;
				nChgFO++;
			}
			else
			{
				idxFO[nChgFO] = vit->second;
				valFO[nChgFO] = 0.0;
				nChgFO++;
			}			
	  }
      lp->chgObj(nChgFO,idxFO,valFO);
      lp->updateLP();
	  // ----------------------------------------
      
      lp->copyMIPStartSol(lp->getNumCols(),idxN,xS);
 

#ifdef SOLVER_CPLEX
//	lp->setPolishAfterIntSol(10000000);
//	lp->setPolishAfterNode(1);
	lp->setNumIntSols(1);
	if ( prioridade==1 ) lp->setTimeLimit( 7200+7200+3600 );
	else lp->setTimeLimit(7200);
	lp->setPreSolve(OPT_TRUE);
	lp->setHeurFrequency(1.0);
	lp->setMIPEmphasis(0);
	lp->setSymetry(0);
//	lp->setPolishAfterNode(10000000000);
	lp->setPolishAfterTime(7200);
	lp->setNodeLimit(10000000);
	lp->setNoCuts();
	//lp->setCuts(0);
	lp->setMIPScreenLog( 4 );
	lp->setMIPRelTol(0.0);
#endif
#ifdef SOLVER_GUROBI
      lp->setNumIntSols(0);
      lp->setTimeLimit(3600);
      lp->setPreSolve(OPT_TRUE);
      lp->setHeurFrequency(1.0);
      lp->setMIPEmphasis(0);
      lp->setSymetry(0);
      lp->setNodeLimit(10000000);
      lp->setCuts(-1);
      lp->setMIPScreenLog( 4 );
      lp->setMIPRelTol(0.0);
#endif
	 
	  lp->writeProbLP( string( "4"+string(lpName) ).c_str() );
	  		
	  if ( CARREGA_SOL_PARCIAL )
	  {
			// procura e carrega solucao parcial
			int statusReadBin = readSolBin( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN4, xS );
			if ( !statusReadBin )
			{
				CARREGA_SOL_PARCIAL=false;
			}
			else writeSolTxt( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN4, xS );
	  }
	  if ( !CARREGA_SOL_PARCIAL )
	  {
			// GENERATES SOLUTION 		 
			this->nroPreSolAvaliadas = 0;
			status = lp->optimize( METHOD_MIP );
			lp->getX(xS);

			writeSolBin( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN4, xS );
			writeSolTxt( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN4, xS );
	  }	

#pragma region Imprime Gap
	 	  // Imprime Gap
		outGaps.open(gapFilename, ofstream::app);
		if ( !outGaps )
		{
			std::cerr<<"\nErro: Abertura do arquivo gaps.txt falhou em SolverMIP::solvePreTaticoCjtAlunos().\n";
		}
		else
		{
			outGaps << "Pre-modelo (Min Conflitos) - campus "<< campusId << ", cjtAlunos " << cjtAlunosId << ", prioridade " << prioridade;
			outGaps << "\nGap = " << lp->getMIPGap() * 100 << "%";
			outGaps << "\n\n";
			outGaps.close();
		} 
#pragma endregion
			  
		std::cout << "\n=========================================";
		std::cout << "\nFixando 'w' e 'as' e garantindo o resto...\n"; fflush(NULL);

	  // ------------------------------------------------------
	  // Fixa w e as, e volta com todo o restante na FO
      vit = vHashPre.begin();
      nChgUB = 0;
	  for ( ; vit != vHashPre.end(); vit++ )
	  {
			VariablePre v = vit->first;

			if ( v.getType() == VariablePre::V_PRE_TURMAS_COMPART && xS[vit->second] > 0.1 )
			{
				idxUB[nChgUB] = vit->second;
				valUB[nChgUB] = 1.0;
				bts[nChgUB] = BOUNDTYPE::BOUND_LOWER;				
				nChgUB++;
			}
			else if ( v.getType() == VariablePre::V_PRE_ALUNO_SALA && xS[vit->second] > 0.1 )
			{
				idxUB[nChgUB] = vit->second;
				valUB[nChgUB] = 1.0;
				bts[nChgUB] = BOUNDTYPE::BOUND_LOWER;				
				nChgUB++;
			}			
	  }
      lp->chgBds(nChgUB,idxUB,bts,valUB);
      lp->updateLP();
	  
	  // Volta com a FO original
	  lp->chgObj(lp->getNumCols(),idxN,objN);
      lp->updateLP();  

      // -------------------------------------------------------------------

      int tempoDeExecucao = retornaTempoDeExecucaoPreModelo( campusId, cjtAlunosId, prioridade );

#ifdef SOLVER_CPLEX
      lp->setNumIntSols(0);
      lp->setTimeLimit(7200);
      lp->setPreSolve(OPT_TRUE);
      lp->setHeurFrequency(1.0);
      lp->setMIPEmphasis(0);
      lp->setSymetry(0);
      lp->setPolishAfterNode(10000000000);
      lp->setPolishAfterTime(2400);
      lp->setNodeLimit(10000000);
      lp->setCuts(0);
      lp->setMIPScreenLog( 4 );
#endif
#ifdef SOLVER_GUROBI
      lp->setNumIntSols(0);
      lp->setTimeLimit(3600);
      lp->setPreSolve(OPT_TRUE);
      lp->setHeurFrequency(1.0);
      lp->setMIPEmphasis(0);
      lp->setSymetry(0);
      lp->setNodeLimit(10000000);
      lp->setCuts(-1);
      lp->setMIPScreenLog( 4 );
#endif

      lp->updateLP();

	  lp->writeProbLP( lpName );

	  lp->copyMIPStartSol(lp->getNumCols(),idxN,xS);
	  		
	  if ( CARREGA_SOL_PARCIAL )
	  {
			// procura e carrega solucao parcial
			int statusReadBin = readSolBin( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN, xS );
			if ( !statusReadBin )
			{
				CARREGA_SOL_PARCIAL=false;
			}
	  }
	  if ( !CARREGA_SOL_PARCIAL )
	  {
			// GENERATES SOLUTION 		 
			this->nroPreSolAvaliadas = 0;
			status = lp->optimize( METHOD_MIP );
			lp->getX(xS);
	  
			writeSolBin( campusId, prioridade, cjtAlunosId, r, 0, OutPutFileType::PRE_TAT_BIN, xS );
	  }      

	  std::cout<<"\n\nOtimizado!\n\n"; fflush(NULL);
      
	  delete[] xS;
	  delete[] objN;
	  delete[] idxN;
      delete[] idxUB;
      delete[] bts;
      delete[] valUB;
      delete[] valFO;
      delete[] idxFO;

	  // Imprime Gap
		outGaps.open(gapFilename, ofstream::app);
		if ( !outGaps )
		{
			std::cerr<<"\nErro: Abertura do arquivo gaps.txt falhou em SolverMIP::solvePreTaticoCjtAlunos().\n";
		}
		else
		{
			outGaps << "Pre-modelo final - campus "<< campusId << ", cjtAlunos " << cjtAlunosId << ", prioridade " << prioridade;
			outGaps << "\nGap = " << lp->getMIPGap() * 100 << "%" << "\tTempo de execucao = " << tempoDeExecucao;
			outGaps << "\n\n";
			outGaps.close();
		}		
   }

   return status;
}

int SolverMIP::solveTaticoBasicoCjtAlunos( int campusId, int prioridade, int cjtAlunosId, int r, int tatico )
{
	int status = 0;

	bool CARREGA_SOL_PARCIAL = this->CARREGA_SOLUCAO;
	bool CARREGA_TESTE = false;

	//if ( tatico==2 && prioridade==1 ) 
	//	CARREGA_TESTE = true;

	if ( CARREGA_TESTE ) CARREGA_SOLUCAO = false;

   if ( this->CARREGA_SOLUCAO )
   {
	   char solName[1024];
	   strcpy( solName, getSolBinFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );
	   FILE* fin = fopen( solName,"rb");
	   if ( fin == NULL )
	   {
		   std::cout << "\nA partir de " << solName << " , nao foram lidas mais solucoes.\n";
		   CARREGA_SOLUCAO = false;
	   }
	   else
	   {
		  fclose(fin);
	   }
   }

   int varNum = 0;
   int constNum = 0;
   
   if ( lp != NULL && tatico==1 )
   {
      lp->freeProb();
      delete lp;
#ifdef SOLVER_CPLEX
	   lp = new OPT_CPLEX; 
#endif
#ifdef SOLVER_GUROBI
	   lp = new OPT_GUROBI; 
#endif
   }
   else if ( tatico!=1 )
   {
	   lp->delRows( 0, lp->getNumRows()-1 );
	   std::cout<<"\nNumero de restricoes apos remocao: "<<lp->getNumRows()<<endl; fflush(NULL);
   }

   if ( tatico==1 ) // para a segunda rodada do tatico, aproveita-se as variaveis
   {
	   if ( vHash.size() > 0 )
	   {
		   vHash.clear();
	   }
	   if ( vHashTatico.size() > 0 )
	   {
		   vHashTatico.clear();
	   }
   }
   
   if ( cHash.size() > 0 )
   {
	   cHash.clear();
   }
   if ( cHashTatico.size() > 0 )
   {
	   cHashTatico.clear();
   }

   char lpName[1024], id[100];
   strcpy( lpName, getTaticoLpFileName( campusId, prioridade, cjtAlunosId, r, tatico ).c_str() );

   if ( tatico==1 )
   {
	   if ( problemData->parametros->funcao_objetivo == 0
		  || problemData->parametros->funcao_objetivo == 2 )
	   {
		  lp->createLP( lpName, OPTSENSE_MAXIMIZE, PROB_MIP );
	   }
	   else if( problemData->parametros->funcao_objetivo == 1 )
	   {
		  lp->createLP( lpName, OPTSENSE_MINIMIZE, PROB_MIP );
	   }
   }
#ifdef DEBUG
   printf( "Creating LP...\n" );
#endif


// ---------------------------------------------------------------
// Tatico por aluno sem horarios:
#ifndef TATICO_COM_HORARIOS
   if ( problemData->parametros->otimizarPor == "ALUNO" )
   {
	   // Variable creation
	   varNum = cria_variaveis_aluno_sh( campusId, cjtAlunosId, prioridade );

	   lp->updateLP();

		#ifdef PRINT_cria_variaveis
	   printf( "Total of Variables: %i\n\n", varNum );
		#endif

	    // -----------------------------------------------------
		// Deleta todas as variaveis referenciadas em solVars (e em vars_x)
		ITERA_GGROUP_LESSPTR ( it, solVars, Variable )
		{
			delete *it;    
		}

		vars_x.clear();
		solVars.clear();
		// -----------------------------------------------------
		
		if ( ! this->CARREGA_SOLUCAO )
		{
		   // Constraint creation
		   constNum = cria_restricoes_aluno_sh( campusId, cjtAlunosId, prioridade );

		   lp->updateLP();

			#ifdef PRINT_cria_restricoes
		   printf( "Total of Constraints: %i\n\n", constNum );
			#endif
		}
   }
#endif

// ---------------------------------------------------------------
// Tatico por aluno com horarios:
#ifdef TATICO_COM_HORARIOS   
   if ( problemData->parametros->otimizarPor == "ALUNO" )
   {
	    // Variable creation
	    varNum = criaVariaveisTatico( campusId, prioridade, r, tatico );
		
	    lp->updateLP();

		if ( tatico==2 && prioridade==1 ) teste( 0 );

		#ifdef PRINT_cria_variaveis
	    printf( "Total of Variables: %i\n\n", varNum );
		#endif

		// -----------------------------------------------------
		// Deleta as variaveis em solVarsXPre 
		ITERA_GGROUP_LESSPTR ( it, solVarsXPre, VariablePre )
		{
			delete *it;    
		}
		solVarsXPre.clear();
		// -----------------------------------------------------
		// Deleta todas as variaveis referenciadas em solVarsTatico (e em vars_xh)
		ITERA_GGROUP_LESSPTR ( it, solVarsTatico, VariableTatico )
		{
			delete *it;    
		}
		vars_xh.clear();
		solVarsTatico.clear();
		// -----------------------------------------------------
		
		if ( ! this->CARREGA_SOLUCAO )
		{
		   // Constraint creation
		   constNum = criaRestricoesTatico( campusId, prioridade, r, tatico );

		   lp->updateLP();

			#ifdef PRINT_cria_restricoes
		   printf( "Total of Constraints: %i\n\n", constNum );
			#endif
		   		   
			if ( CARREGA_TESTE ) testeCarregaSol( campusId, prioridade, cjtAlunosId, r, tatico );

		}
   }
#endif
// ---------------------------------------------------------------

   else
   {
		std::cerr<<"\nErro: Parametro otimizarPor deve ser ALUNO!\n";
		exit(0);
   }  

   if ( ! this->CARREGA_SOLUCAO )
   {   
		ofstream outGaps;
		std::string gapFilename( "gap_input" );
		gapFilename += problemData->getInputFileName();
		gapFilename += ".txt";

	   std::set< int > vHashLivresOriginais;

		#ifndef TATICO_COM_HORARIOS
		VariableHash::iterator vit = vHash.begin();
		for ( ; vit != vHash.end(); vit++ )
		{
			Variable v = vit->first;
	   
			if ( v.getType() == Variable::V_ABERTURA )
			{
				int lb = (int)(lp->getLB(vit->second) + 0.5);
				int ub = (int)(lp->getUB(vit->second) + 0.5);

				if ( lb != ub ) // se for variavel livre
				{
					vHashLivresOriginais.insert( vit->second );

					lp->chgUB(vit->second, 0.0);
				}
			}
		}
		#endif

		int *idxs = new int[lp->getNumCols()*2];
		double *vals = new double[lp->getNumCols()*2];
		BOUNDTYPE *bds = new BOUNDTYPE[lp->getNumCols()*2];
		int nBds = 0;

		std::cout << "\n=========================================";
	    std::cout << "\nGarantindo solucao...\n"; fflush(NULL);

		#ifdef TATICO_COM_HORARIOS
		VariableTaticoHash::iterator vit = vHashTatico.begin();
		for ( ; vit != vHashTatico.end(); vit++ )
		{
			VariableTatico v = vit->first;
	   
			if ( v.getType() == VariableTatico::V_ABERTURA )
			{
				int lb = (int)(lp->getLB(vit->second) + 0.5);
				int ub = (int)(lp->getUB(vit->second) + 0.5);

				if ( lb != ub ) // se for variavel livre
				{
					vHashLivresOriginais.insert( vit->second );

				   idxs[nBds] = vit->second;
				   vals[nBds] = 0.0;
				   bds[nBds] = BOUNDTYPE::BOUND_UPPER;
				   nBds++;
				}
			}
		}
		lp->chgBds(nBds,idxs,bds,vals);
	    
		#endif

		lp->updateLP();
		lp->setTimeLimit( 1e10 );
		lp->setPreSolve(OPT_TRUE);
		lp->setHeurFrequency(1.0);
		lp->setMIPScreenLog( 4 );
		lp->setMIPEmphasis(0);
		lp->setSymetry(0);
		lp->setCuts(3);
		lp->setNumIntSols(1);	
		lp->updateLP();
		lp->writeProbLP( string("1"+ string(lpName) ).c_str() );
		
	    double *xS = new double[lp->getNumCols()];

		if ( CARREGA_SOL_PARCIAL )
		{
			// procura e carrega solucao parcial
			int statusReadBin = readSolBin( campusId, prioridade, cjtAlunosId, r, tatico, OutPutFileType::TAT_HOR_BIN1, xS );
			if ( !statusReadBin )
			{
				CARREGA_SOL_PARCIAL=false;
			}
		}
		if ( !CARREGA_SOL_PARCIAL )
		{			
			if (tatico==2) lp->setAdvance(0);

			// GENERATES SOLUTION 
			status = lp->optimize( METHOD_MIP );
			lp->getX(xS);
	  	
			if (tatico==2) lp->setAdvance(1);

			writeSolBin( campusId, prioridade, cjtAlunosId, r, tatico, OutPutFileType::TAT_HOR_BIN1, xS );
		}				

#pragma region Imprime Gap
	 	  // Imprime Gap
		outGaps.open(gapFilename, ofstream::app);
		if ( !outGaps )
		{
			std::cerr<<"\nErro: Abertura do arquivo gaps.txt falhou em SolverMIP::solveTaticoBasicoCjtAlunos().\n";
		}
		else
		{
			outGaps << "Tatico (Garante solucao) - campus "<< campusId << ", cjtAlunos " << cjtAlunosId << ", prioridade " << prioridade;
			outGaps << "\nGap = " << lp->getMIPGap() * 100 << "%";
			outGaps << "\n\n";
			outGaps.close();
		} 
#pragma endregion

		fflush(NULL);
			
		// -------------------------------------------------------------------
		// Volta as variaveis z_{i,d,cp} que estavam livres
         
		nBds = 0;

		for ( std::set< int >::iterator it = vHashLivresOriginais.begin();
			  it != vHashLivresOriginais.end(); it++)
		{
			idxs[nBds] = *it;
			vals[nBds] = 1.0;
			bds[nBds] = BOUNDTYPE::BOUND_UPPER;
			nBds++;
		}

		lp->chgBds(nBds,idxs,bds,vals);
		lp->updateLP();

		int tempoDeExecucao = retornaTempoDeExecucaoTatico( campusId, cjtAlunosId, prioridade );   

#ifdef SOLVER_CPLEX
		lp->setNumIntSols(0);
		lp->setTimeLimit( 7200+7200+3600 );
		lp->setPreSolve(OPT_TRUE);
		lp->setHeurFrequency(1.0);
		lp->setMIPScreenLog( 4 );
		lp->setMIPEmphasis(4);
	    //lp->setPolishAfterNode(1);
		lp->setPolishAfterTime(900);
		lp->setSymetry(0);
		lp->setCuts(2);
		lp->updateLP();
#endif
#ifdef SOLVER_GUROBI
		lp->setNumIntSols(0);
		lp->setTimeLimit( 10800 );
		lp->setPreSolve(OPT_TRUE);
		lp->setHeurFrequency(1.0);
		lp->setMIPScreenLog( 4 );
		lp->setMIPEmphasis(0);
		lp->setSymetry(0);
		lp->setCuts(-1);
		lp->updateLP();
#endif

		lp->updateLP();

		int *idxN = new int[lp->getNumCols()];

	    // -------------------------------------------------------------------
	    
		std::cout << "\n=========================================";
	    std::cout << "\nGarantindo maximo atendimento...\n"; fflush(NULL);

		double *objN = new double[lp->getNumCols()];
		lp->getObj(0,lp->getNumCols()-1,objN);

		#ifndef TATICO_COM_HORARIOS
		vit = vHash.begin();
		for ( ; vit != vHash.end(); vit++ )
		{
			idxN[vit->second] = vit->second;

			Variable v = vit->first;

			if ( v.getType() != Variable::V_SLACK_DEMANDA_ALUNO )
			{            
				lp->chgObj(vit->second,0.0); 
			}
			else
			{
				int nroAlunos = problemData->existeTurmaDiscCampus( v.getTurma(), v.getDisciplina()->getId(), campusId );
				lp->chgObj(vit->second,nroAlunos);
			}
		}
		#endif

        nBds = 0;
		#ifdef TATICO_COM_HORARIOS
		vit = vHashTatico.begin();
		for ( ; vit != vHashTatico.end(); vit++ )
		{
			idxN[vit->second] = vit->second;

			VariableTatico v = vit->first;
			
			if ( v.getType() != VariableTatico::V_SLACK_DEMANDA &&
				 v.getType() != VariableTatico::V_SLACK_SLACKDEMANDA_PT &&
				 v.getType() != VariableTatico::V_DESALOCA_ALUNO )
			{            
				idxs[nBds] = vit->second;
				vals[nBds] = 0.0;
				nBds++;
			}
			else if ( v.getType() == VariableTatico::V_SLACK_DEMANDA )
			{
				idxs[nBds] = vit->second;
				int nroAlunos = problemData->existeTurmaDiscCampus( v.getTurma(), v.getDisciplina()->getId(), v.getCampus()->getId() );
				vals[nBds] = nroAlunos;
				nBds++;
			}
			else if ( v.getType() == VariableTatico::V_SLACK_SLACKDEMANDA_PT )
			{
				idxs[nBds] = vit->second;
				GGroup<Aluno*> alunosEmComum = problemData->alunosEmComum( v.getTurma1(), v.getDisciplina1(),
																		   v.getTurma2(), v.getDisciplina2(), v.getCampus() );
				vals[nBds] = alunosEmComum.size();
				nBds++;
			}
			else if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO )
			{
				idxs[nBds] = vit->second;
				vals[nBds] = 1;
				nBds++;
			}
		}
		#endif

        lp->chgObj(nBds,idxs,vals);
        lp->updateLP();
		lp->writeProbLP( string( "2"+ string(lpName) ).c_str() );
				
		lp->copyMIPStartSol(lp->getNumCols(),idxN,xS);

		if ( CARREGA_SOL_PARCIAL )
		{
			// procura e carrega solucao parcial
			int statusReadBin = readSolBin( campusId, prioridade, cjtAlunosId, r, tatico, OutPutFileType::TAT_HOR_BIN2, xS );
			if ( !statusReadBin )
			{
				CARREGA_SOL_PARCIAL=false;
			}
		}
		if ( !CARREGA_SOL_PARCIAL )
		{
			// GENERATES SOLUTION 		 
			status = lp->optimize( METHOD_MIP );
			lp->getX(xS);
	  
			writeSolBin( campusId, prioridade, cjtAlunosId, r, tatico, OutPutFileType::TAT_HOR_BIN2, xS );
		}      
		
#pragma region Imprime Gap
	 	  // Imprime Gap
		outGaps.open(gapFilename, ofstream::app);
		if ( !outGaps )
		{
			std::cerr<<"\nErro: Abertura do arquivo gaps.txt falhou em SolverMIP::solveTaticoBasicoCjtAlunos().\n";
		}
		else
		{
			outGaps << "Tatico (Max Atend) - campus "<< campusId << ", cjtAlunos " << cjtAlunosId << ", prioridade " << prioridade;
			outGaps << "\nGap = " << lp->getMIPGap() * 100 << "%";
			outGaps << "\n\n";
			outGaps.close();
		} 
#pragma endregion

	    fflush(NULL);

		std::cout << "\n=========================================";
	    std::cout << "\nGarantindo o resto dos parametros...\n"; fflush(NULL);

		#ifndef TATICO_COM_HORARIOS
		vit = vHash.begin();
		for ( ; vit != vHash.end(); vit++ )
		{
			Variable v = vit->first;

			if (  v.getType() == Variable::V_SLACK_DEMANDA_ALUNO && xS[vit->second] < 0.1 )
			{
				lp->chgUB(vit->second,0.0); 
			}
		}
		#endif

        nBds = 0;
		#ifdef TATICO_COM_HORARIOS
		vit = vHashTatico.begin();
		for ( ; vit != vHashTatico.end(); vit++ )
		{
			VariableTatico v = vit->first;

			if (  v.getType() == VariableTatico::V_SLACK_DEMANDA && xS[vit->second] < 0.1 ) // atendido
			{
				int discId = v.getDisciplina()->getId();
				int turma = v.getTurma();
				bool ffdUsada=false;

				VariableTaticoHash::iterator vit2 = vHashTatico.begin();
				for ( ; vit2 != vHashTatico.end(); vit2++ )
				{
					VariableTatico v_ffd = vit2->first;
					if ( v_ffd.getType() == VariableTatico::V_SLACK_SLACKDEMANDA_PT && xS[vit2->second] > 0.1 )
						if ( ( v_ffd.getDisciplina1()->getId() == discId && v_ffd.getTurma1() == turma ) ||
							 ( v_ffd.getDisciplina2()->getId() == discId && v_ffd.getTurma2() == turma ) )
					{
						ffdUsada = true; break;
					}
				}
				if (!ffdUsada) // Só fixa o atendimento de fd (fd=0) se NÃO existir ffd=1 com o mesmo par turma/disc
				{
					idxs[nBds] = vit->second;
					vals[nBds] = 0.0;
					bds[nBds] = BOUNDTYPE::BOUND_UPPER;
					nBds++;
				}
			}
			else if (  v.getType() == VariableTatico::V_SLACK_SLACKDEMANDA_PT && xS[vit->second] < 0.1 ) // atendido
			{
				idxs[nBds] = vit->second;
				vals[nBds] = 0.0;
				bds[nBds] = BOUNDTYPE::BOUND_UPPER;
				nBds++;
			}
			else if (  v.getType() == VariableTatico::V_DESALOCA_ALUNO && xS[vit->second] < 0.1 ) // atendido
			{
				int discId = v.getDisciplina()->getId();
				int turma = v.getTurma();
				int campusId = v.getAluno()->getOferta()->getCampusId();
				bool fdUsada=false;

				VariableTaticoHash::iterator vit2 = vHashTatico.begin();
				for ( ; vit2 != vHashTatico.end(); vit2++ )
				{
					VariableTatico v_fd = vit2->first;
					if ( v_fd.getType() == VariableTatico::V_SLACK_DEMANDA && xS[vit2->second] > 0.1 )
						if ( v_fd.getDisciplina()->getId() == discId &&
							 v_fd.getTurma() == turma &&
							 v_fd.getCampus()->getId() == campusId )
					{
						fdUsada = true; break;
					}
				}
				if (!fdUsada) // Só fixa o atendimento de fa (fa=0) se NÃO existir fd=1 com o mesmo par turma/disc
				{
					idxs[nBds] = vit->second;
					vals[nBds] = 0.0;
					bds[nBds] = BOUNDTYPE::BOUND_UPPER;
					nBds++;
				}
			}
		}
		#endif

        lp->chgBds(nBds,idxs,bds,vals);
		lp->chgObj(lp->getNumCols(),idxN,objN);

		lp->updateLP();
		lp->writeProbLP( lpName );
		
		lp->copyMIPStartSol(lp->getNumCols(),idxN,xS);

		delete[] objN;
		delete[] idxN;
		delete[] idxs;
		delete[] bds;
		delete[] vals;

#ifdef SOLVER_CPLEX
		lp->setNumIntSols(0);
		//lp->setTimeLimit( tempoDeExecucao );
		lp->setTimeLimit(7200+7200);
		//lp->setMIPRelTol( 0.01 );
		lp->setPreSolve(OPT_TRUE);
		lp->setHeurFrequency(1.0);
		lp->setMIPScreenLog( 4 );
		lp->setPolishAfterTime(100000000);
		lp->setPolishAfterIntSol(100000000);
		lp->setMIPEmphasis(0);
		lp->setPolishAfterNode(1);
		lp->setSymetry(0);
		lp->setCuts(1);
		lp->setPreSolve(OPT_TRUE);
		lp->updateLP();
#endif
#ifdef SOLVER_GUROBI
		lp->setNumIntSols(0);
		lp->setTimeLimit(7200);
		lp->setPreSolve(OPT_TRUE);
		lp->setHeurFrequency(1.0);
		lp->setMIPScreenLog( 4 );
		lp->setPolishAfterTime(100000000);
		lp->setPolishAfterIntSol(100000000);
		lp->setMIPEmphasis(0);
		lp->setSymetry(0);
		lp->setCuts(1);
		lp->updateLP();
#endif
				
		//polishTaticoHor(xS, 3600, 50, 25);

		if ( CARREGA_SOL_PARCIAL )
		{
			// procura e carrega solucao parcial
			int statusReadBin = readSolBin( campusId, prioridade, cjtAlunosId, r, tatico, OutPutFileType::TAT_HOR_BIN, xS );
			if ( !statusReadBin )
			{
				CARREGA_SOL_PARCIAL=false;
			}
		}
		if ( !CARREGA_SOL_PARCIAL )
		{
			// GENERATES SOLUTION 		 
			status = lp->optimize( METHOD_MIP );
			lp->getX(xS);
	  
			writeSolBin( campusId, prioridade, cjtAlunosId, r, tatico, OutPutFileType::TAT_HOR_BIN, xS );

			if (tatico==2 && prioridade==1) teste( xS, 0 );

		}      
			  		
		fflush(NULL);

		delete[] xS;	
						
	    // Imprime Gap
		outGaps.open(gapFilename, ofstream::app);
		if ( !outGaps )
		{
			std::cerr<<"\nErro: Abertura do arquivo gaps.txt falhou em SolverMIP::solveTaticoBasicoCjtAlunos().\n";
		}
		else
		{
			outGaps << "Tatico - campus "<< campusId << ", cjtAlunos " << cjtAlunosId << ", prioridade " << prioridade;
			outGaps << ", r "<< r << ", tatico " << tatico;
			outGaps << "\nGap = " << lp->getMIPGap() * 100 << "%" << "\tTempo de execucao = " << tempoDeExecucao;
			outGaps << "\n\n\n";
			outGaps.close();
		}
			
		lp->updateLP();
   }

   return status;
}

void SolverMIP::atualizaNroCredsPorDiaAlunos( int campusAtualId, int prioridade )
{
	ITERA_VECTOR( itVarX, vars_x, Variable )
	{
		Variable *v = *itVarX;

		if ( v->getUnidade()->getIdCampus() != campusAtualId )
		{
			continue;
		}

		// ---------------------------------------------------
		// Atualiza addNCredsAlocados de cada Aluno alocado na turma
		int nCreds = (int) ( v->getValue() + 0.5 );
		int dia = v->getDia();
		int campusId =  v->getUnidade()->getIdCampus();
		int turma = v->getTurma();
		Disciplina *disciplina = v->getDisciplina();		
		Calendario* sl = disciplina->getCalendario();

		Trio< int, int, Disciplina* > trio;
		trio.set( campusId, turma, disciplina );
									
		GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = 
			problemData->mapCampusTurmaDisc_AlunosDemanda[trio];
		ITERA_GGROUP_LESSPTR( itAlDem, alunosDemanda, AlunoDemanda )
		{
			// Pula os que já foram contabilizados
			if ( itAlDem->getPrioridade() != prioridade )
				continue;
			if ( alunoDemandaAtendsHeuristica.find(*itAlDem) != 
				 alunoDemandaAtendsHeuristica.end() )
				continue;

			int alunoId = (*itAlDem)->getAlunoId();
			Aluno *aluno = problemData->retornaAluno(alunoId);

			aluno->addNCredsAlocados( sl, dia, nCreds );
		}
		// --------------------------------------------------
	}
}

void SolverMIP::fixaAtendimentosVariaveisCreditosAnterior()
{
	int nBds=0;
	int *idxs = new int[lp->getNumCols()*2];
	double *vals = new double[lp->getNumCols()*2];
	BOUNDTYPE *bdsl = new BOUNDTYPE[lp->getNumCols()*2];
	BOUNDTYPE *bdsu = new BOUNDTYPE[lp->getNumCols()*2];

	VariableTaticoHash::iterator vit = vHashTatico.begin();
	for ( ; vit != vHashTatico.end(); vit++ )
	{
		VariableTatico v = vit->first;
	   
		if ( v.getType() == VariableTatico::V_CREDITOS )
		{
			int lb = (int)(lp->getLB(vit->second) + 0.5);
			int ub = (int)(lp->getUB(vit->second) + 0.5);

			if ( lb != ub ) // se for variavel livre
			{				
				bool FOUND=false;
				bool FOUND_ANOTHER=false;
				
				// Procura a variavel x nos atendimentos anteriores.
				// Se for encontrada, fixa-a igual a 1. Se ela não for encontrada, mas
				// outra para a mesma turma/disciplina for (logo, ja existe atendimento),
				// fixa-a igual a 0.
				ITERA_GGROUP_LESSPTR ( itVar, solVarsTatico, VariableTatico )
				{
					VariableTatico vSol = **itVar;		

					if ( vSol.getType() == VariableTatico::V_CREDITOS &&
						 vSol.getTurma() == v.getTurma() &&
						 vSol.getDisciplina() == v.getDisciplina() &&
						 vSol.getUnidade()->getIdCampus() == v.getUnidade()->getIdCampus() )
					{
						if ( vSol.getUnidade() == v.getUnidade() &&
							 vSol.getSubCjtSala() == v.getSubCjtSala() &&
							 vSol.getDia() == v.getDia() &&
							 vSol.getHorarioAulaInicial() == v.getHorarioAulaInicial() &&
							 vSol.getHorarioAulaFinal() == v.getHorarioAulaFinal() )
						{
							FOUND = true;
							break;
						}
						else FOUND_ANOTHER = true;
					}
				}

				if (FOUND || FOUND_ANOTHER)
				{
					idxs[nBds] = vit->second;
					if (FOUND) vals[nBds] = 1.0;
					else if (!FOUND && FOUND_ANOTHER) vals[nBds] = 0.0;
					bdsl[nBds] = BOUNDTYPE::BOUND_LOWER;
					bdsu[nBds] = BOUNDTYPE::BOUND_UPPER;
					nBds++;
				}
			}
		}
		else if ( v.getType() == VariableTatico::V_ABERTURA )
		{
			int lb = (int)(lp->getLB(vit->second) + 0.5);
			int ub = (int)(lp->getUB(vit->second) + 0.5);

			if ( lb != ub ) // se for variavel livre
			{
				bool found=false;
				double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );				
				if (found) 
				{
					idxs[nBds] = vit->second;
					vals[nBds] = 1.0;
					bdsl[nBds] = BOUNDTYPE::BOUND_LOWER;
					bdsu[nBds] = BOUNDTYPE::BOUND_UPPER;
					nBds++;
				}
			}
		}
	}
	
	lp->chgBds(nBds,idxs,bdsl,vals);
	lp->chgBds(nBds,idxs,bdsu,vals);
}

void SolverMIP::liberaAtendimentosVariaveisFFD()
{
	int nBds=0;
	int *idxs = new int[lp->getNumCols()*2];
	double *vall = new double[lp->getNumCols()*2];
	double *valu = new double[lp->getNumCols()*2];
	BOUNDTYPE *bdsl = new BOUNDTYPE[lp->getNumCols()*2];
	BOUNDTYPE *bdsu = new BOUNDTYPE[lp->getNumCols()*2];

	VariableTaticoHash::iterator vit = vHashTatico.begin();
	for ( ; vit != vHashTatico.end(); vit++ )
	{
		VariableTatico v = vit->first;

		if ( v.getType() == VariableTatico::V_SLACK_SLACKDEMANDA_PT )
		{
			int lb = 0.0;
			int ub = 1.0;
			idxs[nBds] = vit->second;
			vall[nBds] = lb;
			valu[nBds] = ub;
			bdsl[nBds] = BOUNDTYPE::BOUND_LOWER;
			bdsu[nBds] = BOUNDTYPE::BOUND_UPPER;
			nBds++;
		}
	}
	
	lp->chgBds(nBds,idxs,bdsl,vall);
	lp->chgBds(nBds,idxs,bdsu,valu);
}

void SolverMIP::voltaComAlunosNaoAlocados()
{	
	std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator
		it1 = problemData->mapSlackAluno_CampusTurmaDisc.begin();
    for ( ; it1 != problemData->mapSlackAluno_CampusTurmaDisc.end(); it1++ )
	{
		Aluno *aluno = it1->first;

		GGroup< Trio< int, int, Disciplina* > >::iterator
			itGGroup = it1->second.begin();
		for ( ; itGGroup!= it1->second.end(); itGGroup++ )
		{
			problemData->mapAluno_CampusTurmaDisc[aluno].add( *itGGroup );		
		}
	}

	std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
		it2 = problemData->mapSlackCampusTurmaDisc_AlunosDemanda.begin();
    for ( ; it2 != problemData->mapSlackCampusTurmaDisc_AlunosDemanda.end(); it2++ )
	{
		Trio< int, int, Disciplina* > trio = it2->first;

		GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > >::iterator
			itGGroup = it2->second.begin();
		for ( ; itGGroup!= it2->second.end(); itGGroup++ )
		{
			problemData->mapCampusTurmaDisc_AlunosDemanda[trio].add( *itGGroup );
			problemData->listSlackDemandaAluno.remove( *itGGroup );
		}
	}
					
}

#endif

#ifndef TATICO_CJT_ALUNOS

void SolverMIP::carregaVariaveisSolucaoTaticoPorAluno( int campusId, int prioridade )
{
   double * xSol = NULL;
   VariableHash::iterator vit;

   SolutionLoader sLoader( problemData, problemSolution );

   xSol = new double[ lp->getNumCols() ];

   if ( this->CARREGA_SOLUCAO ) // #ifdef READ_SOLUTION_TATICO_BIN
   {
	   char solName[1024];

	   strcpy( solName, getSolBinFileName( campusId, prioridade, 0 ).c_str() );

	   FILE* fin = fopen( solName,"rb");
   
	   if ( fin == NULL )
	   {
		   std::cout << "\nErro em carregaVariaveisSolucaoTaticoPorAluno(): arquivo " << solName << " nao encontrado.\n";
		   exit(0);
	   }

	   int nCols = 0;

	   fread(&nCols,sizeof(int),1,fin);

	   if ( nCols == lp->getNumCols() )
	   {
		  for (int i =0; i < nCols; i++)
		  {
			 double auxDbl;
			 fread(&auxDbl,sizeof(double),1,fin);
			 xSol[i] = auxDbl;
		  }
	   }

	   fclose(fin);
   }
   else
   {
		lp->getX( xSol );
   }


   std::map< std::pair<Disciplina*, Oferta*>, int > mapSlackDemanda;
   std::map< std::pair<Disciplina*, Oferta*>, int >::iterator itMapSlackDemanda;
   
   // Deleta variaveis --------
   ITERA_VECTOR ( it, vars_x, Variable )
   {
		delete *it;    
   }
   vars_x.clear();
   // -------------------------

   char solFilename[1024];
   strcpy( solFilename, getSolucaoTaticoFileName( campusId, prioridade, 0 ).c_str() );

   FILE * fout = fopen( solFilename, "wt" );
   
   vit = vHash.begin();

   while ( vit != vHash.end() )
   {
      Variable* v = new Variable( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         //#ifdef DEBUG
         char auxName[100];
         lp->getColName( auxName, col, 100 );
         fprintf( fout, "%s = %f\n", auxName, v->getValue() );
         //#endif

		 Trio< int, int, Disciplina* > trio;

         switch( v->getType() )
         {
			 case Variable::V_ERROR:
				std::cout << "Variável inválida " << std::endl;
				break;
			 case Variable::V_CREDITOS:				 					 
				 
				 trio.set( v->getUnidade()->getIdCampus(), v->getTurma(), v->getDisciplina() );

				 std::cout << problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size() << " vagas para a oferta"
					 << " de " << v->getValue()
						  << " creditos da disciplina " << v->getDisciplina()->getCodigo()
						  << " para a turma " << v->getTurma()
						  << " no dia " << v->getDia()
						  << " para a sala " << v->getSubCjtSala()->salas.begin()->first
						  << std::endl << std::endl;
				 vars_x.push_back(v);
				break;
			 case Variable::V_SLACK_DEMANDA_ALUNO:

				 // ------------ Preenche mapSlackDemanda ---------------------

				 Disciplina *d = v->getDisciplina();
				 int turma = v->getTurma();
				 int campusId = v->getCampus()->getId();

				 Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
				 trio.set(campusId, turma, d);

				 GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = problemData->mapCampusTurmaDisc_AlunosDemanda[trio];
				 ITERA_GGROUP_LESSPTR( itAlDem, alunosDemanda, AlunoDemanda )
				 {
					 problemData->listSlackDemandaAluno.add( *itAlDem );				 

					 itMapSlackDemanda = mapSlackDemanda.find( std::make_pair( d, itAlDem->demanda->oferta ) );
					 if ( itMapSlackDemanda != mapSlackDemanda.end() )
						 itMapSlackDemanda->second = itMapSlackDemanda->second + 1;
					 else
						mapSlackDemanda[ std::make_pair( d, itAlDem->demanda->oferta ) ] = 1;			 
				 }
				 // ------------------------------------------------------------

				 break;
         }
      }
	  else
	  {
		 delete v;
	  }

      vit++;
   }
	std::cout << std::endl;

   // Escreve um resumo do não-atendimento das demandas, juntando
   // as demandas não atendidas por oferta.
	itMapSlackDemanda = mapSlackDemanda.begin();
	for ( ; itMapSlackDemanda != mapSlackDemanda.end() ; itMapSlackDemanda++ )
	{
		fprintf( fout, "FD_{_Disc%d_Oft%d} = %d\n",
			itMapSlackDemanda->first.first->getId(), 
			itMapSlackDemanda->first.second->getId(), 
			itMapSlackDemanda->second );
	}

	std::cout << std::endl;

	
	// -----------------------------------------------------------------------------
	// Retira dos maps mapAluno_CampusTurmaDisc e mapCampusTurmaDisc_AlunosDemanda
	// os atendimentos incompletos ( atendeu só disc pratica ou só teorica ), e os
	// acrescenta em listSlackDemandaAluno.
	// Deleta os atendimentos em vars_xh que não tiverem nenhum aluno alocado.
	#pragma region Retira Atendimentos Incompletos
    ITERA_GGROUP_LESSPTR( itSlack, problemData->listSlackDemandaAluno, AlunoDemanda )
	{		
		Aluno *aluno = problemData->retornaAluno( itSlack->getAlunoId() );
		int campusId = itSlack->demanda->oferta->getCampusId();
		int discId = itSlack->demanda->getDisciplinaId();

		// Se existir a disciplina teorica/pratica correspondente
		if ( problemData->refDisciplinas.find( discId ) != 
			 problemData->refDisciplinas.end() )
		{
			Disciplina *disciplina = problemData->refDisciplinas[ discId ];

			// Se o aluno estiver alocado em alguma turma da disciplina
			// retira-o, eliminando atendimento parcial
			int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );
			if ( turma != -1 )
			{
				AlunoDemanda *ad = problemData->procuraAlunoDemanda( discId, aluno->getAlunoId() );

				if ( ad == NULL )
				{
					std::cout<<"\nErro em carregaVariaveisSolucaoTaticoPorAluno: AlunoDemanda nao encontrado.\n";
					std::cout<<"Aluno"<<aluno->getAlunoId()<<" Disc"<<discId<<"\n";
				}

				Trio< int, int, Disciplina* > trio;
				trio.set( campusId, turma, disciplina );
				
				problemData->mapAluno_CampusTurmaDisc[aluno].remove( trio );
				
				problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].remove( ad );
				 
				problemData->listSlackDemandaAluno.add( ad );

				int nroAlunos = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].size();

				if ( nroAlunos == 0 )
				{
					GGroup< Variable *> remover;
					GGroup< Variable *> todos;

					
					ITERA_VECTOR( itVarX, vars_x, Variable )
					{
						Variable *v = *itVarX;
						
						todos.add( v );

						if ( v->getTurma() == turma &&
							 v->getDisciplina() == disciplina &&
							 problemData->retornaCampus( v->getUnidade()->getId() )->getId() == campusId )
						{
							remover.add( v );
						}
					}

					vars_x.clear();
					
					ITERA_GGROUP( itVarX, todos, Variable )
					{
						bool inserir = true;
						ITERA_GGROUP( itRemover, remover, Variable )
						{
							if ( *itRemover == *itVarX )
								inserir = false;
						}
						if ( inserir )
							vars_x.push_back( *itVarX );
					}
					
					problemData->mapCampusTurmaDisc_AlunosDemanda.erase( trio );
				}
			}
		}

		discId = - itSlack->demanda->getDisciplinaId();

		// Se existir a disciplina teorica/pratica correspondente
		if ( problemData->refDisciplinas.find( discId ) != 
			 problemData->refDisciplinas.end() )
		{
			Disciplina *disciplina = problemData->refDisciplinas[ discId ];

			// Se o aluno estiver alocado em alguma turma da disciplina
			// retira-o, eliminando atendimento parcial
			int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );
			if ( turma != -1 )
			{
				AlunoDemanda *ad = problemData->procuraAlunoDemanda( discId, aluno->getAlunoId() );

				if ( ad == NULL )
				{
					std::cout<<"\nErro em carregaVariaveisSolucaoTaticoPorAluno: AlunoDemanda nao encontrado.\n";
					std::cout<<"Aluno"<<aluno->getAlunoId()<<" Disc"<<discId<<"\n";
				}

				Trio< int, int, Disciplina* > trio;
				trio.set( campusId, turma, disciplina );
				
				problemData->mapAluno_CampusTurmaDisc[aluno].remove( trio );
				
				problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].remove( ad );
				 
				problemData->listSlackDemandaAluno.add( ad );

				int nroAlunos = problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ].size();

				if ( nroAlunos == 0 )
				{
					GGroup< Variable *> remover;
					GGroup< Variable *> todos;
										
					ITERA_VECTOR( itVarX, vars_x, Variable )
					{
						Variable *v = *itVarX;
						
						todos.add( v );

						if ( v->getTurma() == turma &&
							 v->getDisciplina() == disciplina &&
							 problemData->retornaCampus( v->getUnidade()->getId() )->getId() == campusId )
						{
							remover.add( v );
						}
					}
					vars_x.clear();
					
					ITERA_GGROUP( itVarX, todos, Variable )
					{
						bool inserir = true;
						ITERA_GGROUP( itRemover, remover, Variable )
						{
							if ( *itRemover == *itVarX )
								inserir = false;
						}
						if ( inserir )
							vars_x.push_back( *itVarX );
					}
					
					problemData->mapCampusTurmaDisc_AlunosDemanda.erase( trio );
				}
			}
		}
	}
	
	#pragma endregion
	// -----------------------------------------------------------------------------


   vit = vHash.begin();
   for (; vit != vHash.end(); ++vit )
   {
      Variable * v = new Variable( vit->first );
      int col = vit->second;
      v->setValue( xSol[ col ] );

      if ( v->getValue() > 0.00001 )
      {
         sLoader.setFolgas( v );
      }

      delete v;
   }

   //#ifdef DEBUG
   if ( fout )
   {
      fclose( fout );
   }
   //#endif

   if ( xSol )
   {
      delete [] xSol;
   }

}

int SolverMIP::solveTaticoPorCampus()
{
	int statusPre, statusTatico, status = 1;

    ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
    {		

		int campusId = ( *itCampus )->getId();

		std::cout<<"\n\n--------------------------------------------------------------------------------";		
		std::cout<<"\n-------------------------- Campus " << campusId << "----------------------------\n";

		int n_prioridades = problemData->nPrioridadesDemanda[campusId];

		for( int P = 1; P <= n_prioridades; P++ )
		{
			std::cout<<"\n-------------------------- Prioridade " << P << "---------------------------\n";

			std::cout<<"\n------------------------------Pre-modelo------------------------------\n";

			statusPre = solvePreTatico( campusId, P );    
			carregaVariaveisSolucaoPreTatico( campusId, P );
			preencheMapAtendimentoAluno( campusId );

			std::cout<<"\n------------------------------Tatico------------------------------\n";

			statusTatico = solveTaticoBasico( campusId, P );

			if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
				carregaVariaveisSolucaoTatico( campusId );
			if ( problemData->parametros->otimizarPor == "ALUNO" )		
				carregaVariaveisSolucaoTaticoPorAluno( campusId, P );

			std::cout<<"\nCarregou solucao tatica\n";

			mudaCjtSalaParaSala();

			//problemData->imprimeAlocacaoAlunos( campusId, P, false, tatico );
			
			statusTatico = ( statusTatico && statusPre );

			if ( problemData->listSlackDemandaAluno.size() == 0 )
			{
				break;
			}
			else if ( P + 1 <= n_prioridades )
			{
				std::cout << "\nAtualizacao de demandas de prioridade " << P + 1 << "...\n";

				problemData->atualizaDemandas( P+1, campusId );
			}
		}

		problemData->listSlackDemandaAluno.clear(); // Caso seja util ter isso depois, entao tem que fazer um map com campus

		std::cout<<"\nPreenchendo a estrutura atendimento_campus com a saida.\n";        
		
		// Preenchendo a estrutura "atendimento_campus" com a saída.
		if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
			 getSolutionTatico();
		else if ( problemData->parametros->otimizarPor == "ALUNO" )
			 getSolutionTaticoPorAluno();


		status = ( status && statusTatico );
	}

	return (status);
}

int SolverMIP::solvePreTatico( int campusId, int prioridade )
{   
   if ( this->CARREGA_SOLUCAO )
   {
	   char solName[1024];
	   strcpy( solName, getSolPreBinFileName( campusId, prioridade, 0 ).c_str() );
	   FILE* fin = fopen( solName,"rb");
	   if ( fin == NULL )
	   {
		   std::cout << "\nA partir de " << solName << " , nao foram lidas mais solucoes.\n";
		   CARREGA_SOLUCAO = false;
	   }
   }

   if ( lp != NULL )
   {
      lp->freeProb();
      delete lp;
#ifdef SOLVER_CPLEX
	   lp = new OPT_CPLEX; 
#endif
#ifdef SOLVER_GUROBI
	   lp = new OPT_GUROBI; 
#endif
   }
   
   if ( vHashPre.size() > 0 )
   {
	   vHashPre.clear();
   }
   if ( cHashPre.size() > 0 )
   {
	   cHashPre.clear();
   }

   int varNum = 0;
   int constNum = 0;

   char lpName[1024], id[100];
   strcpy( lpName, getPreLpFileName( campusId, prioridade, 0 ).c_str() );

   if ( problemData->parametros->funcao_objetivo == 0
      || problemData->parametros->funcao_objetivo == 2 )
   {
      lp->createLP( lpName, OPTSENSE_MAXIMIZE, PROB_MIP );
   }
   else if( problemData->parametros->funcao_objetivo == 1 )
   {
      lp->createLP( lpName, OPTSENSE_MINIMIZE, PROB_MIP );
   }

#ifdef DEBUG
   printf( "Creating LP...\n" );
#endif

   // Variable creation
   varNum = cria_preVariaveis( campusId, prioridade );

   limpaMapAtendimentoAlunoPrioridadeAnterior( campusId );

   lp->updateLP();

#ifdef PRINT_cria_variaveis
   printf( "Total of Variables: %i\n\n", varNum );
#endif

   if ( ! this->CARREGA_SOLUCAO )
   {
	   // Constraint creation
	   constNum = cria_preRestricoes( campusId, prioridade );

	   lp->updateLP();

	#ifdef PRINT_cria_restricoes
	   printf( "Total of Constraints: %i\n\n", constNum );
	#endif
   }
   printf( "\nEscrevendo o lp..." );

   lp->writeProbLP( lpName );
#ifdef DEBUG
  // lp->writeProbLP( lpName );
#endif

   printf( " Escreveu o lp." );

   int status = 0;
   lp->setTimeLimit( 9000 );
   lp->setMIPRelTol( 0.01 );
   lp->setPreSolve(OPT_TRUE);
   lp->setHeurFrequency(1.0);
   lp->setMIPEmphasis(0);
   lp->setSymetry(0);
   lp->setPolishAfterTime(7200);
   //lp->setNoCuts();
   lp->setMIPScreenLog( 4 );

   lp->setPreSolve(OPT_TRUE);

	
    if ( ! this->CARREGA_SOLUCAO ) // #ifndef READ_SOLUTION_PRETATICO_BIN
	{
		// GENERATES SOLUTION 
		status = lp->optimize( METHOD_MIP );

		// WRITES SOLUTION
		double * xSol = NULL;
		xSol = new double[ lp->getNumCols() ];
		lp->getX( xSol );

		char solName[1024];

		strcpy( solName, getSolPreBinFileName( campusId, prioridade, 0 ).c_str() );

		FILE * fout = fopen( solName, "wb" );

		int nCols = lp->getNumCols();

		fwrite( &nCols, sizeof( int ), 1, fout );
		for ( int i = 0; i < lp->getNumCols(); i++ )
		{
			fwrite( &( xSol[ i ] ), sizeof( double ), 1, fout );
		}

		fclose( fout );

		delete [] xSol;
	}

   printf( "\nTerminou solvePreTatico\n" );

   return status;
}

int SolverMIP::solveTaticoBasico( int campusId, int prioridade  )
{
   if ( this->CARREGA_SOLUCAO )
   {
	   char solName[1024];
	   strcpy( solName, getSolPreBinFileName( campusId, prioridade, 0 ).c_str() );
	   FILE* fin = fopen( solName,"rb");
	   if ( fin == NULL )
	   {
		   std::cout << "\nA partir de " << solName << " , nao foram lidas mais solucoes.\n";
		   CARREGA_SOLUCAO = false;
	   }
   }

   int varNum = 0;
   int constNum = 0;
   
   if ( lp != NULL )
   {
      lp->freeProb();
      delete lp;
#ifdef SOLVER_CPLEX
	   lp = new OPT_CPLEX; 
#endif
#ifdef SOLVER_GUROBI
	   lp = new OPT_GUROBI; 
#endif
   }

   if ( vHash.size() > 0 )
   {
	   vHash.clear();
   }
   if ( cHash.size() > 0 )
   {
	   cHash.clear();
   }
   if ( vHashTatico.size() > 0 )
   {
	   vHashTatico.clear();
   }
   if ( cHashTatico.size() > 0 )
   {
	   cHashTatico.clear();
   }

   char lpName[1024];
   strcpy( lpName, getTaticoLpFileName( campusId, prioridade, 0 ).c_str() );

   if ( problemData->parametros->funcao_objetivo == 0
      || problemData->parametros->funcao_objetivo == 2 )
   {
      lp->createLP( lpName, OPTSENSE_MAXIMIZE, PROB_MIP );
   }
   else if( problemData->parametros->funcao_objetivo == 1 )
   {
      lp->createLP( lpName, OPTSENSE_MINIMIZE, PROB_MIP );
   }

#ifdef DEBUG
   printf( "Creating LP...\n" );
#endif

// ---------------------------------------------------------------
// Tatico por bloco curricular:

   if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
   {
	   // Variable creation
	   varNum = cria_variaveis( campusId );

	   lp->updateLP();

		#ifdef PRINT_cria_variaveis
	   printf( "Total of Variables: %i\n\n", varNum );
		#endif

	   // Constraint creation
	   constNum = cria_restricoes( campusId );
		
	   lp->updateLP();

		#ifdef PRINT_cria_restricoes
	   printf( "Total of Constraints: %i\n\n", constNum );
		#endif

   }
// ---------------------------------------------------------------
// Tatico por aluno sem horarios:
#ifndef TATICO_COM_HORARIOS
   if ( problemData->parametros->otimizarPor == "ALUNO" )
   {
	   // Variable creation
	   varNum = cria_variaveis_aluno_sh( campusId );

	   lp->updateLP();

		#ifdef PRINT_cria_variaveis
	   printf( "Total of Variables: %i\n\n", varNum );
		#endif

	   if ( ! this->CARREGA_SOLUCAO )
		{
			// Constraint creation
			constNum = cria_restricoes_aluno_sh( campusId );
		
			lp->updateLP();

			#ifdef PRINT_cria_restricoes
			printf( "Total of Constraints: %i\n\n", constNum );
			#endif
	   }

   }
#endif

// ---------------------------------------------------------------
// Tatico por aluno com horarios:
#ifdef TATICO_COM_HORARIOS
   
   if ( problemData->parametros->otimizarPor == "ALUNO" )
   {
	   // Variable creation
	   varNum = criaVariaveisTatico( campusId );

	   lp->updateLP();

		#ifdef PRINT_cria_variaveis
	   printf( "Total of Variables: %i\n\n", varNum );
		#endif

	   // Constraint creation
	   constNum = criaRestricoesTatico( campusId );

	   lp->updateLP();

		#ifdef PRINT_cria_restricoes
	   printf( "Total of Constraints: %i\n\n", constNum );
		#endif	
   }
#endif
// ---------------------------------------------------------------

   else
   {
		std::cerr<<"\nErro: Parametro otimizarPor deve ser ALUNO ou BLOCOCURRICULAR!\n";
		exit(0);
   }  
   

   lp->writeProbLP( lpName );
#ifdef DEBUG
  // lp->writeProbLP( lpName );
#endif

   int status = 0;
   lp->setTimeLimit( 86400 + 43200 );
   //lp->setTimeLimit( 3600 );
   //lp->setMIPRelTol( 0.01 );
   lp->setPreSolve(OPT_TRUE);
   lp->setHeurFrequency(1.0);
   lp->setMIPScreenLog( 4 );
   lp->setMIPEmphasis(0);
   lp->setPolishAfterNode(1);
   lp->setSymetry(0);
   //lp->setNoCuts();
   lp->setCuts(3);
   lp->writeProbLP( lpName );
   
   lp->setPreSolve(OPT_TRUE);

   lp->updateLP();

   if ( ! this->CARREGA_SOLUCAO )
   {
	   // GENERATES SOLUTION
	   status = lp->optimize( METHOD_MIP );
	   
	   // WRITES SOLUTION
	   double * xSol = NULL;
	   xSol = new double[ lp->getNumCols() ];
	   lp->getX( xSol );

	   char solName[1024];

	   strcpy( solName, getSolBinFileName( campusId, prioridade, 0 ).c_str() );

	   FILE * fout = fopen( solName, "wb" );
	   int nCols = lp->getNumCols();

	   fwrite( &nCols, sizeof( int ), 1, fout );
	   for ( int i = 0; i < lp->getNumCols(); i++ )
	   {
		  fwrite( &( xSol[ i ] ), sizeof( double ), 1, fout );
	   }

	   fclose( fout );

	   delete [] xSol;
   }

   return status;
}


int SolverMIP::solveTatico( int campusId )
{
   int varNum = 0;
   int constNum = 0;

   if ( problemData->parametros->funcao_objetivo == 0
      || problemData->parametros->funcao_objetivo == 2 )
   {
      lp->createLP( "Solver Trieda", OPTSENSE_MAXIMIZE, PROB_MIP );
   }
   else if( problemData->parametros->funcao_objetivo == 1 )
   {
      lp->createLP( "Solver Trieda", OPTSENSE_MINIMIZE, PROB_MIP );
   }

#ifdef DEBUG
   printf( "Creating LP...\n" );
#endif

   // Variable creation
   varNum = cria_variaveis( campusId );

   lp->updateLP();

#ifdef PRINT_cria_variaveis
   printf( "Total of Variables: %i\n\n", varNum );
#endif

   // Constraint creation
   constNum = cria_restricoes( campusId );

   lp->updateLP();

#ifdef PRINT_cria_restricoes
   printf( "Total of Constraints: %i\n\n", constNum );
#endif

    lp->writeProbLP( "Solver Trieda" );
#ifdef DEBUG
   //lp->writeProbLP( "Solver Trieda" );
#endif

   int status = 0;

#ifndef READ_SOLUTION_TATICO_BIN

   // Muda FO para considerar somente atendimento
   double * objOrig = new double[ lp->getNumCols() ];

   lp->getObj( 0, lp->getNumCols()-1, objOrig );
   double * objNova = new double[ lp->getNumCols() ];
   int * idxNova = new int[ lp->getNumCols() ];

   for ( int i = 0; i < lp->getNumCols(); i++ )
   {
      objNova[ i ] = 0;
      idxNova[ i ] = i;
   }

   VariableHash::iterator vit = vHash.begin();

   for (; vit != vHash.end(); vit++ )
   {
      if ( vit->first.getType() == Variable::V_SLACK_DEMANDA )
      {
         objNova[ vit->second ] = 1.0;
      }
      
   }

   lp->chgObj( lp->getNumCols(), idxNova, objNova );

   //lp->setHeurFrequency( 1.0 );

#ifdef DEBUG
   lp->setTimeLimit( 3600 );
#else
   lp->setTimeLimit( 600 );
#endif

   lp->setMIPRelTol( 0.02 );
   //lp->setMIPStartAlg( METHOD_PRIMAL );
   lp->setMIPEmphasis( 0 );
   lp->setMIPScreenLog( 4 );
   // lp->setNoCuts();
   // lp->setNodeLimit( 1 );
   lp->setPreSolve( OPT_TRUE );

   // Resolve problema olhando somente atendimento
   status = lp->optimize( METHOD_MIP );

   // Passa solucao inicial obtida e fixa atendimento
   double * xSolInic = new double[ lp->getNumCols() ];
   lp->getX( xSolInic );

   double lbAtend = lp->getBestObj();
   double ubAtend = lp->getObjVal();

   OPT_ROW rowLB( 100, OPT_ROW::GREATER , lbAtend , "LBATEND" );
   OPT_ROW rowUB( 100, OPT_ROW::LESS , ubAtend , "UBATEND" );

   vit = vHash.begin();

   for (; vit != vHash.end(); vit++ )
   {
      if ( vit->first.getType() == Variable::V_SLACK_DEMANDA )
      {
         rowLB.insert( vit->second, 1.0 );
         rowUB.insert( vit->second, 1.0 );
      }

#ifdef SOLVER_GUROBI
      if ( vit->first.getType() == Variable::V_N_SUBBLOCOS )
      {
         xSolInic[ vit->second ] = GRB_UNDEFINED;
      }
#endif
   }

   lp->addRow( rowLB );
   lp->addRow( rowUB );
   lp->updateLP();

   lp->setHeurFrequency( 1.0 );
   lp->setTimeLimit( 600 );
   lp->setMIPRelTol( 0.02 );
   // lp->setMIPStartAlg( METHOD_PRIMAL );
   lp->setMIPEmphasis( 1 );
   lp->setMIPScreenLog( 4 );
   // lp->setNoCuts();
   // lp->setNodeLimit( 1 );
   lp->setPreSolve( OPT_TRUE );
   lp->copyMIPStartSol( lp->getNumCols(), idxNova, xSolInic );
   lp->chgObj( lp->getNumCols(), idxNova, objOrig );

   status = localBranching( xSolInic, 1200.0 );

   delete [] objNova;
   delete [] objOrig;
   delete [] idxNova;
   delete [] xSolInic;
#endif

#ifdef WRITE_SOLUTION_TATICO_BIN
   double * xSol = NULL;
   xSol = new double[ lp->getNumCols() ];
   lp->getX( xSol );

   char solName[1024];

   strcpy( solName, getSolBinFileName( campusId, 0, 0 ).c_str() );

   FILE * fout = fopen( solName, "wb" );
   int nCols = lp->getNumCols();

   fwrite( &nCols, sizeof( int ), 1, fout );
   for ( int i = 0; i < lp->getNumCols(); i++ )
   {
      fwrite( &( xSol[i] ), sizeof( double ), 1, fout );
   }

   fclose( fout );

   delete [] xSol;
#endif

   return status;
}

#endif


void SolverMIP::mudaCjtSalaParaSala()
{
	std::cout<<"\nMudando de CjtSala para Sala...\n";

	if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
	{		
		   ITERA_VECTOR( it_Vars_x, vars_x, Variable )
		   {
			  if ( ( *it_Vars_x )->getSubCjtSala()->salas.size() > 0 )
			  {
				 Sala *auxSala = (( *it_Vars_x )->getSubCjtSala()->salas.begin())->second;
				 ( *it_Vars_x )->setSala(auxSala);
			  }
		   }
		   // Imprimindo as variáveis x_{i,d,u,s,t} convertidas.

		   std::cout << "\n\n\n";
		   std::cout << "x\t\ti\td\tu\ts\tt\n";

		   ITERA_VECTOR( it_Vars_x, vars_x, Variable )
		   {
			  if ( ( *it_Vars_x )->getSala() == NULL )
			  {
				 printf( "\nOPA. Variavel x (x_i(%d)_d(%d)_u(%d)_tps(%d)_t(%d))nao convertida.\n\n",
						 ( *it_Vars_x )->getTurma(),
						 ( *it_Vars_x )->getDisciplina()->getId(),
						 ( *it_Vars_x )->getUnidade()->getId(),
						 ( *it_Vars_x )->getSubCjtSala()->getId(),
						 ( *it_Vars_x )->getDia() );

				 exit( 1 );
			  }

			  std::cout << (*it_Vars_x)->getValue() << "\t\t"
						<< ( *it_Vars_x )->getTurma() << "\t"
						<< ( *it_Vars_x )->getDisciplina()->getCodigo() << "\t"
						<< ( *it_Vars_x )->getUnidade()->getCodigo() << "\t"
						<< ( *it_Vars_x )->getSala()->getCodigo() << "\t"
						<< ( *it_Vars_x )->getDia() << "\n";
			  fflush(NULL);
		   }

	}
	else if ( problemData->parametros->otimizarPor == "ALUNO" )
	{
		#ifndef TATICO_COM_HORARIOS

		   ITERA_VECTOR( it_Vars_x, vars_x, Variable )
		   {
			  if ( ( *it_Vars_x )->getSubCjtSala()->salas.size() > 0 )
			  {
				 Sala *auxSala = (( *it_Vars_x )->getSubCjtSala()->salas.begin())->second;
				 ( *it_Vars_x )->setSala(auxSala);
			  }
		   }

		   // Imprimindo as variáveis x_{i,d,u,s,t} convertidas.

		   std::cout << "\n\n\n";
		   std::cout << "x\t\ti\td\t\t\tu\ts\t\tt\n";

		   ITERA_VECTOR( it_Vars_x, vars_x, Variable )
		   {
			  if ( ( *it_Vars_x )->getSala() == NULL )
			  {
				 printf( "\nOPA. Variavel x (x_i(%d)_d(%d)_u(%d)_tps(%d)_t(%d))nao convertida.\n\n",
						 ( *it_Vars_x )->getTurma(),
						 ( *it_Vars_x )->getDisciplina()->getId(),
						 ( *it_Vars_x )->getUnidade()->getId(),
						 ( *it_Vars_x )->getSubCjtSala()->getId(),
						 ( *it_Vars_x )->getDia() );

				 exit( 1 );
			  }

			  std::cout << (*it_Vars_x)->getValue() << "\n\t\t"
						<< ( *it_Vars_x )->getTurma() << "\t"
						<< ( *it_Vars_x )->getDisciplina()->getCodigo() << " - id"
						<< ( *it_Vars_x )->getDisciplina()->getId() << "\t"
						<< ( *it_Vars_x )->getUnidade()->getCodigo() << "\t"
						<< ( *it_Vars_x )->getSala()->getCodigo() << "\t"
						<< ( *it_Vars_x )->getDia() << "\n\n";
		   }
		#endif

		#ifdef TATICO_COM_HORARIOS
		   		   
		   ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
		   {
			  if ( ( *it_Vars_x )->getSubCjtSala()->salas.size() > 0 )
			  {
				 Sala *auxSala = (( *it_Vars_x )->getSubCjtSala()->salas.begin())->second;
				 ( *it_Vars_x )->setSala(auxSala);
			  }
		   }

		   std::cout<<"\nSolucao:";

		   // Imprimindo as variáveis x_{i,d,u,s,hi,hf,t} convertidas.
		   std::cout << "\n\n\n";
		   std::cout << "x\t\ti\td\tu\ts\t\thi\thf\tt\n\n";

		   ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
		   {
			  if ( ( *it_Vars_x )->getSala() == NULL )
			  {
				 printf( "\nOPA. Variavel x (x_i(%d)_d(%d)_u(%d)_tps(%d)_t(%d))nao convertida.\n\n",
						 ( *it_Vars_x )->getTurma(),
						 ( *it_Vars_x )->getDisciplina()->getId(),
						 ( *it_Vars_x )->getUnidade()->getId(),
						 ( *it_Vars_x )->getSubCjtSala()->getId(),
						 ( *it_Vars_x )->getHorarioAulaInicial()->getId(),
						 ( *it_Vars_x )->getHorarioAulaFinal()->getId(),
						 ( *it_Vars_x )->getDia() );

				 exit( 1 );
			  }

			  std::cout << (*it_Vars_x)->getValue() << "\t\t"
						<< ( *it_Vars_x )->getTurma() << "\t"
						<< ( *it_Vars_x )->getDisciplina()->getCodigo() << "\t"
						<< ( *it_Vars_x )->getUnidade()->getCodigo() << "\t"
						<< ( *it_Vars_x )->getSala()->getCodigo() << "\t"
						<< ( *it_Vars_x )->getHorarioAulaInicial()->getId() << "\t"
						<< ( *it_Vars_x )->getHorarioAulaFinal()->getId() << "\t"
						<< ( *it_Vars_x )->getDia() << "\n\n";
			  fflush(NULL);
		   }
		#endif
	}
}


void SolverMIP::converteCjtSalaEmSala()
{
   // ---------------------------------------

   // POS PROCESSAMENTO
   // Convertendo as variáveis x_{i,d,u,tps,t} para x_{i,d,u,s,t}.

   // PASSO 1: Criando uma estrutura que irá gerenciar o tempo livre para cada sala.
   std::map< Sala *, std::vector< std::pair< int /*dia*/, int/*minutos Livres*/ > > > tempo_Livre_Sala;

   // Inicializando a estrutura criada acima
   ITERA_GGROUP_LESSPTR( it_Campus, problemData->campi, Campus )
   {
      ITERA_GGROUP_LESSPTR( it_Unidade, it_Campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_Sala, it_Unidade->salas, Sala )
         {
            ITERA_GGROUP_N_PT( it_Dia, it_Sala->diasLetivos, int )
			{
				int dia = *it_Dia;
				int minutosLivres = it_Sala->getTempoDispPorDia(dia);
                
				tempo_Livre_Sala[ *it_Sala ].push_back( std::make_pair( dia, minutosLivres ) );
            }
         }
      }
   }

   // PASSO 2: Ordenando os vetores de Salas para cada disciplina da estrutura <disc_Salas_Pref>.

   // As disciplinas que possuem o menor número de
   // preferências, acima de 0, serão consideradas primeiro.
   // Em seguida, a ordem das demais disciplinas será mantida.

   // Vetor de disciplinas responsável por informar a ordem em que a 
   // heurística irá alocar as disicplinas.
   std::vector< std::pair< int/*Disc id*/, int/*Qtd salas associadas*/ > > disc_Salas_Cont;

   // Adicionando as disciplinas que possuem alguma associação.
   std::map< Disciplina *, GGroup< Sala *, LessPtr< Sala > >, LessPtr< Disciplina > >::iterator 
      it_Disc_Salas_Pref = problemData->disc_Salas_Pref.begin();

   for(; it_Disc_Salas_Pref != problemData->disc_Salas_Pref.end();
         it_Disc_Salas_Pref++ )
   {
      disc_Salas_Cont.push_back(
         std::make_pair( it_Disc_Salas_Pref->first->getId(),
                         it_Disc_Salas_Pref->second.size() ) );
   }

   // Ordenando.
#ifndef WIN32
   ordenaDiscSalas comparador;
   std::sort( disc_Salas_Cont.begin(), disc_Salas_Cont.end(), comparador );
#else
   std::sort( disc_Salas_Cont.begin(), disc_Salas_Cont.end(), ordenaDiscSalas );
#endif

   // Adicionando as demais disciplinas (as que não possuem nenhuma associação).
   std::vector< std::pair< int /*Disc id*/, int /*Qtd salas associadas*/ > > disc_Salas_TEMP;
   ITERA_GGROUP_LESSPTR( it_Disciplina, problemData->disciplinas, Disciplina )
   {
      // Estrutura: Dado o 'id' de uma disciplina,
      // retorna-se quantas salas estão associadas a essa disciplina
      std::pair< int, int > chave( it_Disciplina->getId(),
         problemData->disc_Salas_Pref[ *it_Disciplina ].size() );

      // Verificando para disciplina não adicionar a mesma disciplina várias vezes.
      // Estrutura dos itens do vector: Dado o 'id' de uma disciplina,
      // retorna-se quantas salas estão associadas a essa disciplina
      std::vector< std::pair< int, int > >::iterator it_Disc_Salas
         = std::find( disc_Salas_Cont.begin(), disc_Salas_Cont.end(), chave );

      if ( it_Disc_Salas == disc_Salas_Cont.end() )
      {
         disc_Salas_TEMP.push_back( chave );
      }
   }

   // Concatenando os 2 vetores.
   disc_Salas_Cont.insert( disc_Salas_Cont.end(),
      disc_Salas_TEMP.begin(), disc_Salas_TEMP.end() );

   // Para cada disciplina da estrutura <disc_Salas> realiza-se alguma alocação
   std::vector< std::pair< int /*Disc id*/, int /*Qtd salas associadas*/ > >::iterator
      it_Disc_Salas = disc_Salas_Cont.begin();

   for (; it_Disc_Salas != disc_Salas_Cont.end(); ++it_Disc_Salas )
   {
      // Obtendo uma referencia para a disciplina em questão.
      std::map< int /*Id Disc*/, Disciplina * >::iterator 
         it_Ref_Disciplinas = problemData->refDisciplinas.find( it_Disc_Salas->first );

      if ( it_Ref_Disciplinas == problemData->refDisciplinas.end() )
      {
         std::cout << "\nOpa. Disciplina inexistente."
                   << "\n(SolverMIP::converteCjtSalaEmSala()) !!!"
                   << "\n\nSaindo." << std::endl;

         exit( 1 );
      }

      Disciplina * disciplina = it_Ref_Disciplinas->second;

      // Estrutura responsável por armazenar as
      // variaveis "x" para a disciplina em questão.
      std::vector< Variable * > vars_x_Disc;

      // Listando todas as variaveis "x" para a disciplina em questão.
      ITERA_VECTOR( it_Vars_x, vars_x, Variable )
      {
         if ( ( *it_Vars_x )->getDisciplina() == disciplina )
         {
            vars_x_Disc.push_back( *it_Vars_x );
         }
      }

      // Ordenando as variaveis coletadas segundo
      // a ordem dos critérios estabelecidos:
      // 1 - unidade
      // 2 - turma
      // 3 - dia
      std::sort( vars_x_Disc.begin(),
                 vars_x_Disc.end(), ordenaVarsX );

      // Estrutura que armazena separadamente, por unidade,
      // turma e tipo de sala, as variaveis x coletadas.
      // --> Unidade, TPS, Turma
      std::map< std::vector< int >,
         std::vector< Variable * > > vars_x_Disc_Und_TPS_Turma;

      ITERA_VECTOR( it_Vars_x_Disc, vars_x_Disc, Variable )
      {
         // Unidade, TPS, Turma
         std::vector< int > chave;

         chave.push_back( ( *it_Vars_x_Disc )->getUnidade()->getId() );
         chave.push_back( ( *it_Vars_x_Disc )->getSubCjtSala()->getId() );
         chave.push_back( ( *it_Vars_x_Disc )->getTurma() );

         vars_x_Disc_Und_TPS_Turma[ chave ].push_back( *it_Vars_x_Disc );
      }

      // Estrutura que armazena as salas na ordem em
      // que se deve tentar alocar a disciplina em questão.

      std::vector< Sala * > salas_Ordenadas;

      // Ordenando a estrutura <discSalas> do problemData
      // de acordo com os seguintes critérios:
      // 1 - Salas preferenciais sugeridas pelo usuário.
      // 2 - Outras salas da mesma unidade em que todas,
      // ou a maioria, das salas estavam associadas.
      // 3 - Qualquer outra sala.
      // OBS.: Por eqto tento fazer o passo 1 e depois o 3.
      // O 2 talvez nem precise pq agt ja esta convertendo
      // a lista de cursos predios para associacoes de disciplinas a salas.

      // Adicionando as salas que foram associadas pelo usuario.
      std::map< Disciplina *, GGroup< Sala *, LessPtr< Sala > >, LessPtr< Disciplina > >::iterator
         it_Disc_Salas_Pref = problemData->disc_Salas_Pref.find( disciplina );

      if ( it_Disc_Salas_Pref != problemData->disc_Salas_Pref.end() )
      {
         // Iterando sobre as salas preferenciais para a disciplina em questão.
         ITERA_GGROUP_LESSPTR( it_Sala, it_Disc_Salas_Pref->second, Sala )
         {
            salas_Ordenadas.push_back( *it_Sala );
         }
      }

      // Adicionando as demais salas associadas à disciplina em questão.
      std::map< Disciplina *, std::vector< Sala * >, LessPtr< Disciplina > >::iterator
         it_Disc_Demais_Salas = problemData->discSalas.find( disciplina );

      if ( it_Disc_Demais_Salas != problemData->discSalas.end() )
      {
         ITERA_VECTOR( it_Sala, it_Disc_Demais_Salas->second, Sala )
         {
            // Para não adicionar repetidas
            if ( std::find( salas_Ordenadas.begin(),
               salas_Ordenadas.end(), ( *it_Sala ) ) == salas_Ordenadas.end() )
            {
               salas_Ordenadas.push_back( *it_Sala );
            }
         }
      }

      // Estrutura do vector: Unidade, TPS, Turma
      std::map< std::vector< int >, std::vector< Variable * > >::iterator
         it_Vars_x_Disc_Und_TPS_Turma = vars_x_Disc_Und_TPS_Turma.begin();

      // Iterando em cada conjunto de variaveis
      // da estrutura <vars_x_Disc_Und_TPS_Turma>
      for(; it_Vars_x_Disc_Und_TPS_Turma != vars_x_Disc_Und_TPS_Turma.end();
            it_Vars_x_Disc_Und_TPS_Turma++ )
      {
         bool alocou = false;

         // Iterando sobre as salas ordenadas para a disciplina em questão.
         ITERA_VECTOR( it_Salas_Ordenadas, salas_Ordenadas, Sala )
         {
            // Checando se a sala em questão pertence ao TPS especificado pelo solver
            if ( it_Vars_x_Disc_Und_TPS_Turma->second.front()->getSubCjtSala()->salas.find(
               ( *it_Salas_Ordenadas )->getId() ) != 
               it_Vars_x_Disc_Und_TPS_Turma->second.front()->getSubCjtSala()->salas.end() )
            {
               std::map< Sala *, std::vector< std::pair< int /*dia*/, int /*creds. Livres*/ > > >::iterator
                  it_Tempo_Livre_Sala = tempo_Livre_Sala.find( *it_Salas_Ordenadas );

               if ( it_Tempo_Livre_Sala == tempo_Livre_Sala.end() )
               {
                  std::cout << "Opa. Sala nao encontrada na estrutura\n"
                            << "<tempo_Livre_Sala> (SolverMIP::converteCjtSalaEmSala()) !!!"
                            << "\n\nSaindo." << std::endl;

                  exit( 1 );
               }

               // Indica se os dias demandados pelas vars x são
               // compatíveis com os dias disponíveis da sala.
               bool dias_Sala_Compativeis = true;

               // Iterando em cada variavel X armazenada para o conjunto em questão
               ITERA_VECTOR( it_Dias_Demandados_Vars_x, it_Vars_x_Disc_Und_TPS_Turma->second, Variable )
               {
                  // Iterando nos dias disponiveis da sala
                  std::vector< std::pair< int /*dia*/, int /*creds. Livres*/ > >::iterator
                     it_Dia = it_Tempo_Livre_Sala->second.begin();

                  for (; it_Dia != it_Tempo_Livre_Sala->second.end(); ++it_Dia )
                  {
                     // Se encontrei o dia, testo se tem o tempo livre necessario. Caso
                     // nao possua, posso parar de tentar alocar nessa sala.
                     if ( it_Dia->first == ( *it_Dias_Demandados_Vars_x )->getDia() )
                     {
						int tempoCredSL = ( *it_Dias_Demandados_Vars_x )->getDisciplina()->getTempoCredSemanaLetiva();
						int nCreds = (int) ( *it_Dias_Demandados_Vars_x )->getValue();

                        if ( it_Dia->second >= nCreds*tempoCredSL )
                        {
                           // Nao faço nada aqui. A busca pelos outros dias continua.
                           // Apenas dou um break por eficiência
                           break;
                        }
                        else
                        {
                           dias_Sala_Compativeis = false;

                           // Já que o dia é inviável, não
                           // faz sentido buscar os outros dias.
                           break;
                        }
                     }
                  }

                  if ( !dias_Sala_Compativeis )
                  {
                     // Parando o iterador <it_Dias_Demandados_Vars_x>.
                     // Já se sabe que a sala não é compatível para o dia em questão. Portanto
                     // paro a busca pelos demais dias livres que a sala pode ter.
                     break;
                  }
               }

               // Teste para saber se posso alocar na sala em questão.
               if ( dias_Sala_Compativeis )
               {
                  // Iterando em cada variavel X armazenada
                  ITERA_VECTOR( it_Dias_Demandados_Vars_x,
                     it_Vars_x_Disc_Und_TPS_Turma->second, Variable )
                  {
                     if ( ( *it_Dias_Demandados_Vars_x )->getSala() != NULL )
                     {
                        std::cout << "Opa. Fui setar a sala para uma\n"
                                  << "var x__i_u_tps_t e ja estava setada.\n"
                                  << "(// Já que o dia e inviável, não faz sentido\n"
                                  << "buscar os outros dias.) !!!"
                                  << "\n\nSaindo." << std::endl;

                        exit( 1 );
                     }

                     // Setando a sala na(s) variavel(eis)
                     ( *it_Dias_Demandados_Vars_x )->setSala( *it_Salas_Ordenadas );

                     // Iterando nos dias disponiveis da sala
                     std::vector< std::pair< int /*dia*/, int /*creds. Livres*/ > >::iterator
                        it_Dia = it_Tempo_Livre_Sala->second.begin();

                     for (; it_Dia != it_Tempo_Livre_Sala->second.end(); it_Dia++ )
                     {
                        // Quando encontro o dia correto, atualizo
                        // a estrutura que armazena os créditos livres.
                        if ( it_Dia->first == ( *it_Dias_Demandados_Vars_x )->getDia() )
                        {
							int tempoCredSL = ( *it_Dias_Demandados_Vars_x )->getDisciplina()->getTempoCredSemanaLetiva();
							int nCreds = (int) ( *it_Dias_Demandados_Vars_x )->getValue();

                           it_Dia->second -= (tempoCredSL*nCreds);

                           // Apenas por eficiência
                           break;
                        }
                     }
                  }

                  // Setando a FLAG que indica se alocou ou não
                  alocou = true;

                  // Parando a busca de salas.
                  break;
               }
               else
               {
                  // Nao faço nada. Deixo continuar
                  // tentando alocar nas outras salas associadas.
               }
            }
            else
            {
               // Nao faço nada. Deixo continuar
               // tentando alocar nas outras salas associadas.
            }
         }

         // Checando se a alocação foi realizada.
         // Abaixo, devemos tratar da possível causa da alocação da turma da disciplina em questão
         // não ter sido realizada.
         // 1 - Quando a disciplina foi dividida em mais de 1 dia letivo para realizar um atendimento,
         // pode ser que não se tenha mais nenhuma sala com os dias letivos demandados com créditos livres
         // o suficiente.
         // Solução: Por eqto, atendo em quantas salas diferentes forem necessárias, sem um padrão de
         // escolha das salas.
         // Tinha outras causas, mas como mudei a heurística pra poder rodar pra todas as salas
         // associadas (pelo usuário e pelo solver), acredito que este seja o único erro.

         if ( !alocou )
         {
            // Estrutura que armazena separadamente, por unidade,
            // turma, tipo de sala e DIA, as variaveis x coletadas.

            std::map< std::vector< int /*Unidade, TPS, Turma, dia*/ >, Variable * > 
               vars_x_Disc_Und_TPS_Turma_DIA;

            // Armazenando os dados na estrutura
            ITERA_VECTOR( it_Dias_Demandados_Vars_x,
               it_Vars_x_Disc_Und_TPS_Turma->second, Variable )
            {
               std::vector< int /*Unidade, TPS, Turma, Dia*/ > chave;

               chave.push_back( ( *it_Dias_Demandados_Vars_x )->getUnidade()->getId() );
               chave.push_back( ( *it_Dias_Demandados_Vars_x )->getSubCjtSala()->getId() );
               chave.push_back( ( *it_Dias_Demandados_Vars_x )->getTurma() );
               chave.push_back( ( *it_Dias_Demandados_Vars_x )->getDia() );

               if ( vars_x_Disc_Und_TPS_Turma_DIA.find( chave )
                  != vars_x_Disc_Und_TPS_Turma_DIA.end() )
               {
                  std::cout << "Opa. Fui add um dado na estrutura\n"
                            << "<vars_x_Disc_Und_TPS_Turma_DIA> e iria\n"
                            << "sobrescrever um existente. VOLTAR PARA VECTOR.\n"
                            << "(SolverMIP::converteCjtSalaEmSala()) !!!"
                            << "\n\nSaindo." << std::endl;

                  exit( 1 );
               }

               vars_x_Disc_Und_TPS_Turma_DIA[ chave ] = ( *it_Dias_Demandados_Vars_x );
            }

            std::map< std::vector< int /*Unidade, TPS, Turma, Dia */ >, Variable * >::iterator
               it_Vars_x_Disc_Und_TPS_Turma_DIA = vars_x_Disc_Und_TPS_Turma_DIA.begin();

            // Iterando em cada variavel da estrutura <vars_x_Disc_Und_TPS_Turma_DIA>
            for(; it_Vars_x_Disc_Und_TPS_Turma_DIA != vars_x_Disc_Und_TPS_Turma_DIA.end(); 
                  it_Vars_x_Disc_Und_TPS_Turma_DIA++ )
            {
               bool continuaBusca = false;

               // Iterando sobre as salas ordenadas para a disciplina em questão.
               ITERA_VECTOR( it_Salas_Ordenadas, salas_Ordenadas, Sala )
               {
                  // Checando se a sala em questão pertence ao TPS especificado pelo solver
                  if ( it_Vars_x_Disc_Und_TPS_Turma_DIA->second->getSubCjtSala()->salas.find(
                     ( *it_Salas_Ordenadas )->getId() ) != 
                     it_Vars_x_Disc_Und_TPS_Turma_DIA->second->getSubCjtSala()->salas.end() )
                  {
                     std::map< Sala *, std::vector< std::pair< int /*dia*/, int /*minutos Livres*/ > > >::iterator
                        it_Tempo_Livre_Sala = tempo_Livre_Sala.find( *it_Salas_Ordenadas );

                     if ( it_Tempo_Livre_Sala == tempo_Livre_Sala.end() )
                     {
                        std::cout << "Opa. Sala nao encontrada na estrutura <tempo_Livre_Sala>\n"
                                  << "(SolverMIP::converteCjtSalaEmSala()) !!!\n"
                                  << "\n\nSaindo." << std::endl;

                        exit( 1 );
                     }

                     // Indica se o dia demandado pela var x em
                     // questão é compatível com o dia disponível da sala.

                     // Iterando nos dias disponiveis da sala
                     std::vector< std::pair< int /*dia*/, int /*minutos Livres*/ > >::iterator
                        it_Dia = it_Tempo_Livre_Sala->second.begin();

                     for (; it_Dia != it_Tempo_Livre_Sala->second.end(); it_Dia++ )
                     {
                        // Se encontrei o dia, testo se tem o tempo livre necessario. Caso
                        // nao possua, posso parar de tentar alocar nessa sala.

                        if ( it_Dia->first == it_Vars_x_Disc_Und_TPS_Turma_DIA->second->getDia() )
                        {
							int tempoCredSL = it_Vars_x_Disc_Und_TPS_Turma_DIA->second->getDisciplina()->getTempoCredSemanaLetiva();
							int nCreds = (int) it_Vars_x_Disc_Und_TPS_Turma_DIA->second->getValue();

                           if ( it_Dia->second >= tempoCredSL*nCreds )
                           {
                              // Já posso alocar. Pois trata-se de apenas um dia.

                              // Setando a sala na variavel
                              it_Vars_x_Disc_Und_TPS_Turma_DIA->second->setSala( *it_Salas_Ordenadas );

                              // Atualizo a estrutura que armazena o tempo livre.
                              it_Dia->second -= tempoCredSL*nCreds;
                              it_Salas_Ordenadas = salas_Ordenadas.begin();

                              alocou = true;

                              // Apenas dou um break por eficiência
                              break;
                           }
                           else
                           {
                              // Continuo a busca em outras salas.
                              continuaBusca = true;

                              // Dia é inviável.
                              break;
                           }
                        }
                     }

                     if ( alocou )
                     {
                        alocou = false;
                        break;
                     }
                  }
                  else
                  {
                     // Nao faço nada. Deixo continuar
                     // tentando alocar nas outras salas associadas.
                  }
               }

               // TRIEDA-715
               // Ainda assim, a variável x em questão pode não ter sido convertida.
               // Pode acontecer o caso em que a variável x tem valor maior que 1 e todas as salas
               // do TPS especificado pela variável em questão possuem apenas 1 cred livre. Desse modo,
               // deve-se dividir os créditos da disciplina, alocando-os separadamente por sala.

               if ( continuaBusca && !alocou )
               {
                  // Referenciando a variável em questão.
                  Variable * pt_Var_x = ( it_Vars_x_Disc_Und_TPS_Turma_DIA->second );

                  // A ideia aqui é pegar a variável em questão e sair tentando alocar os créditos
                  // separadamente. Eles serão separados de acordo com a disponibilidade de cada
                  // sala.
                  // Quando a variável for totalmente alocada, aponta-se para NULL e finaliza a alocação da mesma.
                  // IMPORTANTE: Como estou dividindo os créditos, tenho que criar novas variáveis. Lembrar de adiciona-las
                  // à estrutura <vars_x> que armazena todas as variáveis do tipo x.

                  while ( pt_Var_x )
                  {
                     // Iterando sobre as salas ordenadas para a disciplina em questão.
                     ITERA_VECTOR( it_Salas_Ordenadas, salas_Ordenadas, Sala )
                     {
                        // Checando se a sala em questão pertence ao TPS especificado pelo solver
                        if ( pt_Var_x->getSubCjtSala()->salas.find( ( *it_Salas_Ordenadas )->getId() ) != 
                             pt_Var_x->getSubCjtSala()->salas.end() )
                        {
                           std::map< Sala *, std::vector< std::pair< int /*dia*/, int /*minutos Livres*/ > > >::iterator
                              it_Tempo_Livre_Sala = tempo_Livre_Sala.find( *it_Salas_Ordenadas );

                           if ( it_Tempo_Livre_Sala == tempo_Livre_Sala.end() )
                           {
                              std::cout << "Opa. Sala nao encontrada na estrutura\n"
                                        << "<tempo_Livre_Sala>\n"
                                        << "(SolverMIP::converteCjtSalaEmSala()) !!!"
                                        << "\n\nSaindo." << std::endl;

                              exit( 1 );
                           }

                           // Iterando nos dias disponiveis da sala
                           std::vector< std::pair< int /*dia*/, int /*minutos Livres*/ > >::iterator
                              it_Dia = ( it_Tempo_Livre_Sala->second.begin() );

                           for (; it_Dia != it_Tempo_Livre_Sala->second.end(); it_Dia++ )
                           {
                              // Se encontrei o dia, testo se tem tempo
                              // livre necessario. Caso nao possua, posso parar de tentar alocar nessa sala.
                              if ( it_Dia->first == pt_Var_x->getDia() )
                              {
                                 if ( it_Dia->second > 0 )
                                 {
                                    // Já posso alocar. Pois trata-se de apenas um dia.
							
									int tempoCredSL = pt_Var_x->getDisciplina()->getTempoCredSemanaLetiva();
									int nCreds = (int) pt_Var_x->getValue();

                                    // Cálculo do total de tempo a ser alocado.
                                    int tempo_Alocar = (int)( tempoCredSL*nCreds - it_Dia->second );

                                    // Criando uma nova variável para uma divisão da variável em questão.
                                    Variable * var_x_NAO_ALOCADA = NULL;

                                    // Se o total de créditos a serem alocados for maior do que a 
                                    // o total de crédtios livres da sala (tempo_Alocar > 0), devo
                                    // criar uma cópia da variável 'x' em questão e atualizar o seu
                                    // valor com a diferença entre o total de créditos da var subtraido
                                    // do total de cred. livre da sala. Já no caso em que o total de
                                    // créditos alocados é menor ou igual ao total de créditos livres
                                    // da sala em questão (tempo_Alocar <= 0), devo apenas alocar.

                                    if ( tempo_Alocar > 0 )
                                    {
									   // Numero de creditos em excesso, que nao poderao ser alocados
									   int excessoCreds = (int) ceil( (double) tempo_Alocar/tempoCredSL );

                                       // Criando uma nova variável para a divisão da variável em questão.
                                       var_x_NAO_ALOCADA = new Variable( *pt_Var_x );

                                       // Atualizando a quantidade de créditos não alocada.
                                       var_x_NAO_ALOCADA->setValue( excessoCreds ); //TODO: conferir o valor, originalmente estava diferente

                                       // Adicionando a nova variável à estrutura <vars_x>
                                       vars_x.push_back( var_x_NAO_ALOCADA );

                                       // Atualizando o valor da variável a ser atendida.
                                       pt_Var_x->setValue( nCreds - excessoCreds ); //TODO: conferir o valor, originalmente estava diferente
                                    }

                                    // Setando a sala na variavel
                                    pt_Var_x->setSala( *it_Salas_Ordenadas );

                                    // Atualizo a estrutura que armazena o tempo livre.
                                    it_Dia->second -= (int) nCreds;

                                    // Checando se ainda existe algum crédito para alocar.
                                    if ( var_x_NAO_ALOCADA )
                                    {
                                       pt_Var_x = var_x_NAO_ALOCADA;
                                    }
                                    else
                                    {
                                       // Condição para sair do loop.
                                       pt_Var_x = NULL;
                                    }

                                    alocou = true;

                                    // Apenas dou um break por eficiência
                                    break;
                                 }
                                 else
                                 {
                                    // Dia é inviável.
                                    break;
                                 }
                              }
                           }

                           if ( alocou )
                           {
                              alocou = false;
                              break;
                           }
                        }
                        else
                        {
                           // Nao faço nada. Deixo continuar tentando
                           // alocar nas outras salas associadas.
                        }
                     }
                  }
               }
            }
         }
      }
   }

   // ---------------------------------------
   // Imprimindo as variáveis x_{i,d,u,s,t} convertidas.

   std::cout << "\n\n\n";
   std::cout << "x\t\ti\td\tu\ts\tt\n";

   ITERA_VECTOR( it_Vars_x, vars_x, Variable )
   {
      if ( ( *it_Vars_x )->getSala() == NULL )
      {
         printf( "\nOPA. Variavel x (x_i(%d)_d(%d)_u(%d)_tps(%d)_t(%d))nao convertida.\n\n",
                 ( *it_Vars_x )->getTurma(),
                 ( *it_Vars_x )->getDisciplina()->getId(),
                 ( *it_Vars_x )->getUnidade()->getId(),
                 ( *it_Vars_x )->getSubCjtSala()->getId(),
                 ( *it_Vars_x )->getDia() );

         exit( 1 );
      }

      std::cout << (*it_Vars_x)->getValue() << "\t\t"
                << ( *it_Vars_x )->getTurma() << "\t"
                << ( *it_Vars_x )->getDisciplina()->getCodigo() << "\t"
                << ( *it_Vars_x )->getUnidade()->getCodigo() << "\t"
                << ( *it_Vars_x )->getSala()->getCodigo() << "\t"
                << ( *it_Vars_x )->getDia() << "\n";
   }
}


// Função usada para Tatico - Aluno - Com Horario
void SolverMIP::getSolutionTaticoPorAlunoComHorario()
{
   // POVOANDO AS CLASSES DE SAIDA

   int at_Tatico_Counter = 0;

   // Iterando sobre as variáveis do tipo x.
   ITERA_GGROUP_LESSPTR( it_Vars_x, vars_xh, VariableTatico )
   {
	  int dia = ( *it_Vars_x )->getDia();
	  Disciplina *d = ( *it_Vars_x )->getDisciplina();
	  int turma = ( *it_Vars_x )->getTurma();
	  HorarioAula *hi = ( *it_Vars_x )->getHorarioAulaInicial();
	  HorarioAula *hf = ( *it_Vars_x )->getHorarioAulaFinal();
  	  int nCreds = d->getCalendario()->retornaNroCreditosEntreHorarios( hi, hf );
	  Sala *sala = ( *it_Vars_x )->getSala();
      Unidade * unidade = ( *it_Vars_x )->getUnidade();

      // Descobrindo qual Campus a variável x em questão pertence.
      Campus * campus = problemData->refCampus[ ( *it_Vars_x )->getUnidade()->getIdCampus() ];
	
      bool novo_Campus = true;
      ITERA_GGROUP( it_At_Campus, ( *problemSolution->atendimento_campus ), AtendimentoCampus )
      {
         if ( it_At_Campus->getId() == campus->getId() )
         {
            if ( it_At_Campus->atendimentos_unidades->size() == 0 )
            {
               std::cout << "Achei que nao era pra cair aqui <dbg1>" << std::endl;

               // NOVA UNIDADE
               // exit( 1 );
            }
            else
            {
               bool nova_Unidade = true;
               ITERA_GGROUP( it_At_Unidade, ( *it_At_Campus->atendimentos_unidades ), AtendimentoUnidade )
               {
                  if ( it_At_Unidade->getId() == unidade->getId() )
                  {
                     if ( it_At_Unidade->atendimentos_salas->size() == 0 )
                     {
                        std::cout << "Achei que nao era pra cair aqui <dbg2>" << std::endl;

                        // NOVA SALA
                        // exit( 1 );
                     }
                     else
                     {
                        bool nova_Sala = true;
                        ITERA_GGROUP( it_At_Sala, ( *it_At_Unidade->atendimentos_salas ), AtendimentoSala )
                        {
                           if ( it_At_Sala->getId() == sala->getId() )
                           {
							    AtendimentoDiaSemana *at_Dia_Semana = NULL;
								bool novo_Dia = false;

                                if ( it_At_Sala->atendimentos_dias_semana->size() == 0 )
                                {
                                   std::cout << "Achei que nao era pra cair aqui <dbg3>" << std::endl;

                                   // NOVO DIA SEMANA
                                   // exit( 1 );
                                }
                                else
                                {
									// Verifica se o AtendimentoDiaSemana já existe
									ITERA_GGROUP( it_At_Dia, ( *it_At_Sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
									{
										if ( it_At_Dia->getDiaSemana() == dia )
										{
											if ( it_At_Dia->atendimentos_tatico->size() == 0 )
											{
												std::cout << "Achei que nao era pra cair aqui <dbg4>" << std::endl;
												// NOVO ATENDIMENTO
												// exit( 1 );
											}

											at_Dia_Semana = *it_At_Dia;
											break;
										}
									}

									if ( at_Dia_Semana == NULL )
									{
										novo_Dia = true;

										// Cadastrando o dia da semana
										at_Dia_Semana = new AtendimentoDiaSemana(
											this->problemSolution->getIdAtendimentos() );

										at_Dia_Semana->setDiaSemana( dia );
									}

									#pragma region CADASTRO DE ATENDIMENTO TATICO

									Trio<int,int,Disciplina*> trio;
									trio.set(campus->getId(), turma, d );

									std::map< Trio<int,int,Disciplina*>, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
										itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
							
									if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
									{
										std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
										std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
										std::cout << "\nNao encontrado AlunosDemanda em: Disciplina: " << d->getId();
										std::cout << "\tTurma: " << turma;
										continue;
									}

									// Todas as ofertas atendidas
									GGroup< Oferta*, LessPtr<Oferta> > ofertas;
									ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
									{
										ofertas.add( itAlunoDemanda->demanda->oferta );									
									}

									ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
									{										
										Oferta *oferta = *itOferta;

										AtendimentoTatico * at_Tatico = new AtendimentoTatico(
										this->problemSolution->getIdAtendimentos(),
										this->problemSolution->getIdAtendimentos() );

										// Verificando se a disciplina é de carater prático ou teórico.
										if ( d->getId() > 0 && d->getCredTeoricos() > 0 )
										{
											at_Tatico->setQtdCreditosTeoricos( nCreds );
										}
										else
										{
											at_Tatico->setQtdCreditosPraticos( nCreds );
										}

										AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );
										
										ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
										{
											if ( itAlunoDemanda->demanda->oferta != oferta )
												continue;

											if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
											{
												int alunoId = itAlunoDemanda->getAlunoId();
												int discId = - itAlunoDemanda->demanda->getDisciplinaId();
												Aluno* aluno = problemData->retornaAluno( alunoId );

												// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
												// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
												AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
												if ( alunoDemanda != NULL )
												{
													at_Oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
												}
											}
											else
											{
												at_Oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
											}
										}
																																	 
										stringstream str;
										str << oferta->getId();
										at_Oferta->setOfertaCursoCampiId( str.str() );

										int id_disc = d->getId();
											 
										std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
										Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
										if ( discOriginal != NULL )
										{
											at_Oferta->setDisciplinaSubstitutaId( id_disc );
											at_Oferta->setDisciplinaId( discOriginal->getId() );
											at_Oferta->disciplina = d;
										}
										else
										{
											at_Oferta->setDisciplinaId( id_disc );
											at_Oferta->disciplina = d;
										}

										at_Oferta->setQuantidade( at_Oferta->alunosDemandasAtendidas.size() );
										at_Oferta->setTurma( turma );
										at_Oferta->oferta = oferta;

										at_Tatico->atendimento_oferta = at_Oferta;

										at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

										++at_Tatico_Counter;

									}

									#pragma endregion
                                }

                                if ( novo_Dia )
                                {
                                    it_At_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                                }
                               
								nova_Sala = false;
                                break;
                           }
                        }

                        if ( nova_Sala )
                        {
                            // Cadastrando a Sala
                            AtendimentoSala * at_Sala = new AtendimentoSala(
                              this->problemSolution->getIdAtendimentos() );

                            at_Sala->setId( sala->getId() );
                            at_Sala->setSalaId( sala->getCodigo() );
                            at_Sala->sala = sala;

                            // Cadastrando o dia da semana
                            AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
                              this->problemSolution->getIdAtendimentos() );

                            at_Dia_Semana->setDiaSemana( dia );
							
							#pragma region CADASTRO DE ATENDIMENTO TATICO PARA NOVA SALA

							Trio<int,int,Disciplina*> trio;
							trio.set(campus->getId(), turma, d );

							std::map< Trio<int,int,Disciplina*>, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
								itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
							
							if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
							{
								std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
								std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
								std::cout << "\nNao encontrado AlunosDemanda em: Disciplina: " << d->getId();
								std::cout << "\tTurma: " << turma;
								continue;
							}

							// Todas as ofertas atendidas
							GGroup< Oferta*, LessPtr<Oferta> > ofertas;
							ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
							{
								ofertas.add( itAlunoDemanda->demanda->oferta );									
							}

							ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
							{										
								Oferta *oferta = *itOferta;

								AtendimentoTatico * at_Tatico = new AtendimentoTatico(
								this->problemSolution->getIdAtendimentos(),
								this->problemSolution->getIdAtendimentos() );

								// Verificando se a disciplina é de carater prático ou teórico.
								if ( d->getId() > 0 && d->getCredTeoricos() > 0 )
								{
									at_Tatico->setQtdCreditosTeoricos( nCreds );
								}
								else
								{
									at_Tatico->setQtdCreditosPraticos( nCreds );
								}

								AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );
											
								ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
								{
									if ( itAlunoDemanda->demanda->oferta != oferta )
										continue;

									if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
									{
										int alunoId = itAlunoDemanda->getAlunoId();
										int discId = - itAlunoDemanda->demanda->getDisciplinaId();
										Aluno* aluno = problemData->retornaAluno( alunoId );

										// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
										// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
										AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
										if ( alunoDemanda != NULL )
										{
											at_Oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
										}
									}
									else
									{
										at_Oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
									}
								}
																																	 
								stringstream str;
								str << oferta->getId();
								at_Oferta->setOfertaCursoCampiId( str.str() );

								int id_disc = d->getId();
											 
								std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
								Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
								if ( discOriginal != NULL )
								{
									at_Oferta->setDisciplinaSubstitutaId( id_disc );
									at_Oferta->setDisciplinaId( discOriginal->getId() );
									at_Oferta->disciplina = d;
								}
								else
								{
									at_Oferta->setDisciplinaId( id_disc );
									at_Oferta->disciplina = d;
								}

								at_Oferta->setQuantidade( at_Oferta->alunosDemandasAtendidas.size() );
								at_Oferta->setTurma( turma );
								at_Oferta->oferta = oferta;

								at_Tatico->atendimento_oferta = at_Oferta;

								at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

								++at_Tatico_Counter;
							
							}

							#pragma endregion

                           at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                           it_At_Unidade->atendimentos_salas->add( at_Sala );
                        }
                     }

                     nova_Unidade = false;
                     break;

                  }
               }

               if ( nova_Unidade )
               {
				   // Cadastrando a Unidade
                   AtendimentoUnidade * at_Unidade = new AtendimentoUnidade(
                     this->problemSolution->getIdAtendimentos() );

                   at_Unidade->setId( unidade->getId() );
                   at_Unidade->setCodigoUnidade( unidade->getCodigo() );
                   at_Unidade->unidade = unidade;

                   // Cadastrando a Sala
                   AtendimentoSala * at_Sala = new AtendimentoSala(
                     this->problemSolution->getIdAtendimentos() );

                   at_Sala->setId( sala->getId() );
                   at_Sala->setSalaId( sala->getCodigo() );
                   at_Sala->sala = sala;

                   // Cadastrando o dia da semana
                   AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
                     this->problemSolution->getIdAtendimentos() );

                   at_Dia_Semana->setDiaSemana( dia );
 					
					#pragma region CADASTRO DE ATENDIMENTO TATICO PARA NOVA UNIDADE
				   
					Trio<int,int,Disciplina*> trio;
					trio.set(campus->getId(), turma, d );

					std::map< Trio<int,int,Disciplina*>, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
						itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
							
					if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
					{
						std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
						std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
						std::cout << "\nNao encontrado AlunosDemanda em: Disciplina: " << d->getId();
						std::cout << "\tTurma: " << turma;
						continue;
					}

					// Todas as ofertas atendidas
					GGroup< Oferta*, LessPtr<Oferta> > ofertas;
					ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
					{
						ofertas.add( itAlunoDemanda->demanda->oferta );									
					}

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{										
						Oferta *oferta = *itOferta;

						AtendimentoTatico * at_Tatico = new AtendimentoTatico(
						this->problemSolution->getIdAtendimentos(),
						this->problemSolution->getIdAtendimentos() );

						// Verificando se a disciplina é de carater prático ou teórico.
						if ( d->getId() > 0 && d->getCredTeoricos() > 0 )
						{
							at_Tatico->setQtdCreditosTeoricos( nCreds );
						}
						else
						{
							at_Tatico->setQtdCreditosPraticos( nCreds );
						}

						AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );
									
						ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
						{
							if ( itAlunoDemanda->demanda->oferta != oferta )
								continue;

							if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
							{
								int alunoId = itAlunoDemanda->getAlunoId();
								int discId = - itAlunoDemanda->demanda->getDisciplinaId();
								Aluno* aluno = problemData->retornaAluno( alunoId );
								
								// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
								// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
								AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
								if ( alunoDemanda != NULL )
								{
									at_Oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
								}
							}
							else
							{
								at_Oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
							}
						}
																																	 
						stringstream str;
						str << oferta->getId();
						at_Oferta->setOfertaCursoCampiId( str.str() );

						int id_disc = d->getId();
											 
						std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
						Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
						if ( discOriginal != NULL )
						{
							at_Oferta->setDisciplinaSubstitutaId( id_disc );
							at_Oferta->setDisciplinaId( discOriginal->getId() );
							at_Oferta->disciplina = d;
						}
						else
						{
							at_Oferta->setDisciplinaId( id_disc );
							at_Oferta->disciplina = d;
						}

						at_Oferta->setQuantidade( at_Oferta->alunosDemandasAtendidas.size() );
						at_Oferta->setTurma( turma );
						at_Oferta->oferta = oferta;

						at_Tatico->atendimento_oferta = at_Oferta;

						at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

						++at_Tatico_Counter;
					}
					#pragma endregion

                    at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                    at_Unidade->atendimentos_salas->add( at_Sala );
                    it_At_Campus->atendimentos_unidades->add( at_Unidade );
               }
            }

            novo_Campus = false;
            break;
         }
      }

      if ( novo_Campus )
      {
			AtendimentoCampus * at_Campus = new AtendimentoCampus(
			this->problemSolution->getIdAtendimentos() );

			at_Campus->setId( campus->getId() );
			at_Campus->setCampusId( campus->getCodigo() );
			at_Campus->campus = campus;

			// Cadastrando a Unidade
			AtendimentoUnidade * at_Unidade = new AtendimentoUnidade(
			this->problemSolution->getIdAtendimentos() );

			at_Unidade->setId( unidade->getId() );
			at_Unidade->setCodigoUnidade( unidade->getCodigo() );
			at_Unidade->unidade = unidade;

			// Cadastrando a Sala
			AtendimentoSala * at_Sala = new AtendimentoSala(
			this->problemSolution->getIdAtendimentos() );

			at_Sala->setId( sala->getId() );
			at_Sala->setSalaId( sala->getCodigo() );
			at_Sala->sala = sala;

			// Cadastrando o dia da semana
			AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
			this->problemSolution->getIdAtendimentos() );

			at_Dia_Semana->setDiaSemana( dia );

			#pragma region CADASTRO DE ATENDIMENTO TATICO PARA NOVO CAMPUS

			Trio<int,int,Disciplina*> trio;
			trio.set(campus->getId(), turma, d );

			std::map< Trio<int,int,Disciplina*>, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
				itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
							
			if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
			{
				std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
				std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
				std::cout << "\nNao encontrado AlunosDemanda em: Disciplina: " << d->getId();
				std::cout << "\tTurma: " << turma;
				continue;
			}

			// Todas as ofertas atendidas
			GGroup< Oferta*, LessPtr<Oferta> > ofertas;
			ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
			{
				ofertas.add( itAlunoDemanda->demanda->oferta );									
			}

			ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
			{										
				Oferta *oferta = *itOferta;
				
				AtendimentoTatico * at_Tatico = new AtendimentoTatico(
				this->problemSolution->getIdAtendimentos(),
				this->problemSolution->getIdAtendimentos() );

				// Verificando se a disciplina é de carater prático ou teórico.
				if ( d->getId() > 0 && d->getCredTeoricos() > 0 )
				{
					at_Tatico->setQtdCreditosTeoricos( nCreds );
				}
				else
				{
					at_Tatico->setQtdCreditosPraticos( nCreds );
				}

				AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );
								
				ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
				{
					if ( itAlunoDemanda->demanda->oferta != oferta )
						continue;

					if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
					{
						int alunoId = itAlunoDemanda->getAlunoId();
						int discId = - itAlunoDemanda->demanda->getDisciplinaId();
						Aluno* aluno = problemData->retornaAluno( alunoId );

						// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
						// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
						AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
						if ( alunoDemanda != NULL )
						{
							at_Oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
						}
					}
					else
					{
						at_Oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
					}
				}
																																	 
				stringstream str;
				str << oferta->getId();
				at_Oferta->setOfertaCursoCampiId( str.str() );

				int id_disc = d->getId();
											 
				std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
				Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
				if ( discOriginal != NULL )
				{
					at_Oferta->setDisciplinaSubstitutaId( id_disc );
					at_Oferta->setDisciplinaId( discOriginal->getId() );
					at_Oferta->disciplina = d;
				}
				else
				{
					at_Oferta->setDisciplinaId( id_disc );
					at_Oferta->disciplina = d;
				}

				at_Oferta->setQuantidade( at_Oferta->alunosDemandasAtendidas.size() );
				at_Oferta->setTurma( turma );
				at_Oferta->oferta = oferta;

				at_Tatico->atendimento_oferta = at_Oferta;

				at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

				++at_Tatico_Counter;
			}
			#pragma endregion
         
			at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
			at_Unidade->atendimentos_salas->add( at_Sala );
			at_Campus->atendimentos_unidades->add( at_Unidade );

			problemSolution->atendimento_campus->add( at_Campus );
      }
   }
}


void SolverMIP::getSolutionTaticoPorAluno()
{
   // POVOANDO AS CLASSES DE SAIDA

   int at_Tatico_Counter = 0;

   // Iterando sobre as variáveis do tipo x.
   ITERA_VECTOR( it_Vars_x, vars_x, Variable )
   {
	  int dia = ( *it_Vars_x )->getDia();
	  Disciplina *d = ( *it_Vars_x )->getDisciplina();
	  int turma = ( *it_Vars_x )->getTurma();
	  int nCreds = ( *it_Vars_x )->getValue();
	  Sala *sala = ( *it_Vars_x )->getSala();
      Unidade * unidade = ( *it_Vars_x )->getUnidade();

      // Descobrindo qual Campus a variável x em questão pertence.
      Campus * campus = problemData->refCampus[ ( *it_Vars_x )->getUnidade()->getIdCampus() ];
	
      bool novo_Campus = true;
      ITERA_GGROUP( it_At_Campus, ( *problemSolution->atendimento_campus ), AtendimentoCampus )
      {
         if ( it_At_Campus->getId() == campus->getId() )
         {
            if ( it_At_Campus->atendimentos_unidades->size() == 0 )
            {
               std::cout << "Achei que nao era pra cair aqui <dbg1>" << std::endl;

               // NOVA UNIDADE
               // exit( 1 );
            }
            else
            {
               bool nova_Unidade = true;
               ITERA_GGROUP( it_At_Unidade, ( *it_At_Campus->atendimentos_unidades ), AtendimentoUnidade )
               {
                  if ( it_At_Unidade->getId() == unidade->getId() )
                  {
                     if ( it_At_Unidade->atendimentos_salas->size() == 0 )
                     {
                        std::cout << "Achei que nao era pra cair aqui <dbg2>" << std::endl;

                        // NOVA SALA
                        // exit( 1 );
                     }
                     else
                     {
                        bool nova_Sala = true;
                        ITERA_GGROUP( it_At_Sala, ( *it_At_Unidade->atendimentos_salas ), AtendimentoSala )
                        {
                           if ( it_At_Sala->getId() == sala->getId() )
                           {
							    AtendimentoDiaSemana *at_Dia_Semana = NULL;
								bool novo_Dia = false;

                                if ( it_At_Sala->atendimentos_dias_semana->size() == 0 )
                                {
                                   std::cout << "Achei que nao era pra cair aqui <dbg3>" << std::endl;

                                   // NOVO DIA SEMANA
                                   // exit( 1 );
                                }
                                else
                                {
									// Verifica se o AtendimentoDiaSemana já existe
									ITERA_GGROUP( it_At_Dia, ( *it_At_Sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
									{
										if ( it_At_Dia->getDiaSemana() == dia )
										{
											if ( it_At_Dia->atendimentos_tatico->size() == 0 )
											{
												std::cout << "Achei que nao era pra cair aqui <dbg4>" << std::endl;
												// NOVO ATENDIMENTO
												// exit( 1 );
											}

											at_Dia_Semana = *it_At_Dia;
											break;
										}
									}

									if ( at_Dia_Semana == NULL )
									{
										novo_Dia = true;

										// Cadastrando o dia da semana
										at_Dia_Semana = new AtendimentoDiaSemana(
											this->problemSolution->getIdAtendimentos() );

										at_Dia_Semana->setDiaSemana( dia );
									}

									#pragma region CADASTRO DE ATENDIMENTO TATICO

									Trio<int,int,Disciplina*> trio;
									trio.set(campus->getId(), turma, d );

									std::map< Trio<int,int,Disciplina*>, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
										itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
							
									if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
									{
										std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
										std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
										std::cout << "\nNao encontrado AlunosDemanda em: Disciplina: " << d->getId();
										std::cout << "\tTurma: " << turma;
										continue;
									}

									// Todas as ofertas atendidas
									GGroup< Oferta* > ofertas;
									ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
									{
										ofertas.add( itAlunoDemanda->demanda->oferta );									
									}

									ITERA_GGROUP( itOferta, ofertas, Oferta )
									{										
										Oferta *oferta = *itOferta;

										AtendimentoTatico * at_Tatico = new AtendimentoTatico(
										this->problemSolution->getIdAtendimentos(),
										this->problemSolution->getIdAtendimentos() );

										// Verificando se a disciplina é de carater prático ou teórico.
										if ( d->getId() > 0 && d->getCredTeoricos() > 0 )
										{
											at_Tatico->setQtdCreditosTeoricos( nCreds );
										}
										else
										{
											at_Tatico->setQtdCreditosPraticos( nCreds );
										}

										AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );
										
										ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
										{
											if ( itAlunoDemanda->demanda->oferta != oferta )
												continue;

											if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
											{
												int alunoId = itAlunoDemanda->getAlunoId();
												int discId = - itAlunoDemanda->demanda->getDisciplinaId();
												Aluno* aluno = problemData->retornaAluno( alunoId );

												// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
												// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
												AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
												if ( alunoDemanda != NULL )
												{
													at_Oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
												}
											}
											else
											{
												at_Oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
											}
										}
																																	 
										stringstream str;
										str << oferta->getId();
										at_Oferta->setOfertaCursoCampiId( str.str() );

										int id_disc = d->getId();
											 
										std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
										Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
										if ( discOriginal != NULL )
										{
											at_Oferta->setDisciplinaSubstitutaId( id_disc );
											at_Oferta->setDisciplinaId( discOriginal->getId() );
											at_Oferta->disciplina = d;
										}
										else
										{
											at_Oferta->setDisciplinaId( id_disc );
											at_Oferta->disciplina = d;
										}

										at_Oferta->setQuantidade( at_Oferta->alunosDemandasAtendidas.size() );
										at_Oferta->setTurma( turma );
										at_Oferta->oferta = oferta;

										at_Tatico->atendimento_oferta = at_Oferta;

										at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

										++at_Tatico_Counter;

									}

									#pragma endregion
                                }

                                if ( novo_Dia )
                                {
                                    it_At_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                                }
                               
								nova_Sala = false;
                                break;
                           }
                        }

                        if ( nova_Sala )
                        {
                            // Cadastrando a Sala
                            AtendimentoSala * at_Sala = new AtendimentoSala(
                              this->problemSolution->getIdAtendimentos() );

                            at_Sala->setId( sala->getId() );
                            at_Sala->setSalaId( sala->getCodigo() );
                            at_Sala->sala = sala;

                            // Cadastrando o dia da semana
                            AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
                              this->problemSolution->getIdAtendimentos() );

                            at_Dia_Semana->setDiaSemana( dia );
							
							#pragma region CADASTRO DE ATENDIMENTO TATICO PARA NOVA SALA

							Trio<int,int,Disciplina*> trio;
							trio.set(campus->getId(), turma, d );

							std::map< Trio<int,int,Disciplina*>, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
								itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
							
							if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
							{
								std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
								std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
								std::cout << "\nNao encontrado AlunosDemanda em: Disciplina: " << d->getId();
								std::cout << "\tTurma: " << turma;
								continue;
							}

							// Todas as ofertas atendidas
							GGroup< Oferta* > ofertas;
							ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
							{
								ofertas.add( itAlunoDemanda->demanda->oferta );									
							}

							ITERA_GGROUP( itOferta, ofertas, Oferta )
							{										
								Oferta *oferta = *itOferta;

								AtendimentoTatico * at_Tatico = new AtendimentoTatico(
								this->problemSolution->getIdAtendimentos(),
								this->problemSolution->getIdAtendimentos() );

								// Verificando se a disciplina é de carater prático ou teórico.
								if ( d->getId() > 0 && d->getCredTeoricos() > 0 )
								{
									at_Tatico->setQtdCreditosTeoricos( nCreds );
								}
								else
								{
									at_Tatico->setQtdCreditosPraticos( nCreds );
								}

								AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );
											
								ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
								{
									if ( itAlunoDemanda->demanda->oferta != oferta )
										continue;

									if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
									{
										int alunoId = itAlunoDemanda->getAlunoId();
										int discId = - itAlunoDemanda->demanda->getDisciplinaId();
										Aluno* aluno = problemData->retornaAluno( alunoId );

										// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
										// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
										AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
										if ( alunoDemanda != NULL )
										{
											at_Oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
										}
									}
									else
									{
										at_Oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
									}
								}
																																	 
								stringstream str;
								str << oferta->getId();
								at_Oferta->setOfertaCursoCampiId( str.str() );

								int id_disc = d->getId();
											 
								std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
								Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
								if ( discOriginal != NULL )
								{
									at_Oferta->setDisciplinaSubstitutaId( id_disc );
									at_Oferta->setDisciplinaId( discOriginal->getId() );
									at_Oferta->disciplina = d;
								}
								else
								{
									at_Oferta->setDisciplinaId( id_disc );
									at_Oferta->disciplina = d;
								}

								at_Oferta->setQuantidade( at_Oferta->alunosDemandasAtendidas.size() );
								at_Oferta->setTurma( turma );
								at_Oferta->oferta = oferta;

								at_Tatico->atendimento_oferta = at_Oferta;

								at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

								++at_Tatico_Counter;
							
							}

							#pragma endregion

                           at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                           it_At_Unidade->atendimentos_salas->add( at_Sala );
                        }
                     }

                     nova_Unidade = false;
                     break;

                  }
               }

               if ( nova_Unidade )
               {
				   // Cadastrando a Unidade
                   AtendimentoUnidade * at_Unidade = new AtendimentoUnidade(
                     this->problemSolution->getIdAtendimentos() );

                   at_Unidade->setId( unidade->getId() );
                   at_Unidade->setCodigoUnidade( unidade->getCodigo() );
                   at_Unidade->unidade = unidade;

                   // Cadastrando a Sala
                   AtendimentoSala * at_Sala = new AtendimentoSala(
                     this->problemSolution->getIdAtendimentos() );

                   at_Sala->setId( sala->getId() );
                   at_Sala->setSalaId( sala->getCodigo() );
                   at_Sala->sala = sala;

                   // Cadastrando o dia da semana
                   AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
                     this->problemSolution->getIdAtendimentos() );

                   at_Dia_Semana->setDiaSemana( dia );
 					
					#pragma region CADASTRO DE ATENDIMENTO TATICO PARA NOVA UNIDADE
				   
					Trio<int,int,Disciplina*> trio;
					trio.set(campus->getId(), turma, d );

					std::map< Trio<int,int,Disciplina*>, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
						itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
							
					if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
					{
						std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
						std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
						std::cout << "\nNao encontrado AlunosDemanda em: Disciplina: " << d->getId();
						std::cout << "\tTurma: " << turma;
						continue;
					}

					// Todas as ofertas atendidas
					GGroup< Oferta* > ofertas;
					ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
					{
						ofertas.add( itAlunoDemanda->demanda->oferta );									
					}

					ITERA_GGROUP( itOferta, ofertas, Oferta )
					{										
						Oferta *oferta = *itOferta;

						AtendimentoTatico * at_Tatico = new AtendimentoTatico(
						this->problemSolution->getIdAtendimentos(),
						this->problemSolution->getIdAtendimentos() );

						// Verificando se a disciplina é de carater prático ou teórico.
						if ( d->getId() > 0 && d->getCredTeoricos() > 0 )
						{
							at_Tatico->setQtdCreditosTeoricos( nCreds );
						}
						else
						{
							at_Tatico->setQtdCreditosPraticos( nCreds );
						}

						AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );
									
						ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
						{
							if ( itAlunoDemanda->demanda->oferta != oferta )
								continue;

							if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
							{
								int alunoId = itAlunoDemanda->getAlunoId();
								int discId = - itAlunoDemanda->demanda->getDisciplinaId();
								Aluno* aluno = problemData->retornaAluno( alunoId );

								// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
								// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
								AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
								if ( alunoDemanda != NULL )
								{
									at_Oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
								}
							}
							else
							{
								at_Oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
							}
						}
																																	 
						stringstream str;
						str << oferta->getId();
						at_Oferta->setOfertaCursoCampiId( str.str() );

						int id_disc = d->getId();
											 
						std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
						Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
						if ( discOriginal != NULL )
						{
							at_Oferta->setDisciplinaSubstitutaId( id_disc );
							at_Oferta->setDisciplinaId( discOriginal->getId() );
							at_Oferta->disciplina = d;
						}
						else
						{
							at_Oferta->setDisciplinaId( id_disc );
							at_Oferta->disciplina = d;
						}

						at_Oferta->setQuantidade( at_Oferta->alunosDemandasAtendidas.size() );
						at_Oferta->setTurma( turma );
						at_Oferta->oferta = oferta;

						at_Tatico->atendimento_oferta = at_Oferta;

						at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

						++at_Tatico_Counter;
					}
					#pragma endregion

                    at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                    at_Unidade->atendimentos_salas->add( at_Sala );
                    it_At_Campus->atendimentos_unidades->add( at_Unidade );
               }
            }

            novo_Campus = false;
            break;
         }
      }

      if ( novo_Campus )
      {
			AtendimentoCampus * at_Campus = new AtendimentoCampus(
			this->problemSolution->getIdAtendimentos() );

			at_Campus->setId( campus->getId() );
			at_Campus->setCampusId( campus->getCodigo() );
			at_Campus->campus = campus;

			// Cadastrando a Unidade
			AtendimentoUnidade * at_Unidade = new AtendimentoUnidade(
			this->problemSolution->getIdAtendimentos() );

			at_Unidade->setId( unidade->getId() );
			at_Unidade->setCodigoUnidade( unidade->getCodigo() );
			at_Unidade->unidade = unidade;

			// Cadastrando a Sala
			AtendimentoSala * at_Sala = new AtendimentoSala(
			this->problemSolution->getIdAtendimentos() );

			at_Sala->setId( sala->getId() );
			at_Sala->setSalaId( sala->getCodigo() );
			at_Sala->sala = sala;

			// Cadastrando o dia da semana
			AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
			this->problemSolution->getIdAtendimentos() );

			at_Dia_Semana->setDiaSemana( dia );

			#pragma region CADASTRO DE ATENDIMENTO TATICO PARA NOVO CAMPUS

			Trio<int,int,Disciplina*> trio;
			trio.set(campus->getId(), turma, d );

			std::map< Trio<int,int,Disciplina*>, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
				itMap = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
							
			if ( itMap == problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
			{
				std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
				std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
				std::cout << "\nNao encontrado AlunosDemanda em: Disciplina: " << d->getId();
				std::cout << "\tTurma: " << turma;
				continue;
			}

			// Todas as ofertas atendidas
			GGroup< Oferta* > ofertas;
			ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
			{
				ofertas.add( itAlunoDemanda->demanda->oferta );									
			}

			ITERA_GGROUP( itOferta, ofertas, Oferta )
			{										
				Oferta *oferta = *itOferta;
				
				AtendimentoTatico * at_Tatico = new AtendimentoTatico(
				this->problemSolution->getIdAtendimentos(),
				this->problemSolution->getIdAtendimentos() );

				// Verificando se a disciplina é de carater prático ou teórico.
				if ( d->getId() > 0 && d->getCredTeoricos() > 0 )
				{
					at_Tatico->setQtdCreditosTeoricos( nCreds );
				}
				else
				{
					at_Tatico->setQtdCreditosPraticos( nCreds );
				}

				AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );
								
				ITERA_GGROUP_LESSPTR( itAlunoDemanda, itMap->second, AlunoDemanda )
				{
					if ( itAlunoDemanda->demanda->oferta != oferta )
						continue;

					if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
					{
						int alunoId = itAlunoDemanda->getAlunoId();
						int discId = - itAlunoDemanda->demanda->getDisciplinaId();
						Aluno* aluno = problemData->retornaAluno( alunoId );

						// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
						// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
						AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
						if ( alunoDemanda != NULL )
						{
							at_Oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
						}
					}
					else
					{
						at_Oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
					}
				}
																																	 
				stringstream str;
				str << oferta->getId();
				at_Oferta->setOfertaCursoCampiId( str.str() );

				int id_disc = d->getId();
											 
				std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
				Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
				if ( discOriginal != NULL )
				{
					at_Oferta->setDisciplinaSubstitutaId( id_disc );
					at_Oferta->setDisciplinaId( discOriginal->getId() );
					at_Oferta->disciplina = d;
				}
				else
				{
					at_Oferta->setDisciplinaId( id_disc );
					at_Oferta->disciplina = d;
				}

				at_Oferta->setQuantidade( at_Oferta->alunosDemandasAtendidas.size() );
				at_Oferta->setTurma( turma );
				at_Oferta->oferta = oferta;

				at_Tatico->atendimento_oferta = at_Oferta;

				at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

				++at_Tatico_Counter;
			}
			#pragma endregion
         
			at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
			at_Unidade->atendimentos_salas->add( at_Sala );
			at_Campus->atendimentos_unidades->add( at_Unidade );

			problemSolution->atendimento_campus->add( at_Campus );
      }
   }
}


void SolverMIP::getSolutionTatico()
{
   // POVOANDO AS CLASSES DE SAIDA

   int at_Tatico_Counter = 0;

   // Iterando sobre as variáveis do tipo x.
   ITERA_VECTOR( it_Vars_x, vars_x, Variable )
   {
      // Descobrindo qual Campus a variável x em questão pertence.
      Campus * campus = problemData->refCampus[ ( *it_Vars_x )->getUnidade()->getIdCampus() ];
	
      bool novo_Campus = true;
      ITERA_GGROUP( it_At_Campus, ( *problemSolution->atendimento_campus ),
                    AtendimentoCampus )
      {
         if ( it_At_Campus->getId() == campus->getId() )
         {
            if ( it_At_Campus->atendimentos_unidades->size() == 0 )
            {
               std::cout << "Achei que nao era pra cair aqui <dbg1>" << std::endl;

               // NOVA UNIDADE
               // exit( 1 );
            }
            else
            {
               Unidade * unidade = ( *it_Vars_x )->getUnidade();

               bool nova_Unidade = true;
               ITERA_GGROUP( it_At_Unidade, ( *it_At_Campus->atendimentos_unidades ),
                             AtendimentoUnidade )
               {
                  if ( it_At_Unidade->getId() == unidade->getId() )
                  {
                     if ( it_At_Unidade->atendimentos_salas->size() == 0 )
                     {
                        std::cout << "Achei que nao era pra cair aqui <dbg2>" << std::endl;

                        // NOVA SALA
                        // exit( 1 );
                     }
                     else
                     {
                        Sala * sala = ( *it_Vars_x )->getSala();

                        bool nova_Sala = true;
                        ITERA_GGROUP( it_At_Sala, ( *it_At_Unidade->atendimentos_salas ),
                                      AtendimentoSala )
                        {
                           if ( it_At_Sala->getId() == sala->getId() )
                           {
                              if ( it_At_Sala->atendimentos_dias_semana->size() == 0 )
                              {
                                 std::cout << "Achei que nao era pra cair aqui <dbg3>" << std::endl;

                                 // NOVO DIA SEMANA
                                 // exit( 1 );
                              }
                              else
                              {
                                 int dia = ( *it_Vars_x )->getDia();
								 Disciplina *d = ( *it_Vars_x )->getDisciplina();
								 int turma = ( *it_Vars_x )->getTurma();

                                 bool novo_Dia = true;
                                 ITERA_GGROUP( it_At_Dia, ( *it_At_Sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
                                 {
                                    if ( it_At_Dia->getDiaSemana() == dia )
                                    {
                                       if ( it_At_Dia->atendimentos_tatico->size() == 0 )
                                       {
                                          std::cout << "Achei que nao era pra cair aqui <dbg4>" << std::endl;

                                          // NOVO ATENDIMENTO
                                          // exit( 1 );
                                       }
                                       else
                                       {
                                          // CADASTRO DE ATENDIMENTO TATICO

                                          // Para cada variavel a__i_d_o existem para a variavel x__i_d_u_s_t em questão.
										  std::map< std::pair< int /*turma*/, Disciplina * >,
													std::vector< Variable * > >::iterator
													itMap = vars_a.find( std::make_pair( turma, d ) );
							
										  if ( itMap == vars_a.end() )
										  {
											std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
											std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
											std::cout << "\nNao encontrada variavel 'a' com: Disciplina: " << d->getId();
											std::cout << "\tTurma: " << turma;
											continue;
										  }

										  for ( std::vector< Variable* >::iterator it_Vars_a = itMap->second.begin();
												it_Vars_a != itMap->second.end(); ++it_Vars_a )
										  {
                                             AtendimentoTatico * at_Tatico = new AtendimentoTatico(
                                                this->problemSolution->getIdAtendimentos(),
                                                this->problemSolution->getIdAtendimentos() );

                                             // Verificando se a disciplina é de carater prático ou teórico.
                                             if ( ( *it_Vars_x )->getDisciplina()->getId() > 0
                                                && ( *it_Vars_x )->getDisciplina()->getCredTeoricos() > 0 )
                                             {
                                                at_Tatico->setQtdCreditosTeoricos( (int)( ( *it_Vars_x )->getValue() ) );
                                             }
                                             else
                                             {
                                                at_Tatico->setQtdCreditosPraticos( (int)( ( *it_Vars_x )->getValue() ) );
                                             }

                                             AtendimentoOferta * at_Oferta = new AtendimentoOferta( this->problemSolution->getIdAtendimentos() );

											 Oferta *oferta = ( *it_Vars_a )->getOferta();
											 
                                             stringstream str;
                                             str << oferta->getId();
                                             at_Oferta->setOfertaCursoCampiId( str.str() );

                                             int id_disc = d->getId();
											 
											 std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
											 Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
											 if ( discOriginal != NULL )
											 {
												 at_Oferta->setDisciplinaSubstitutaId( id_disc );
												 at_Oferta->setDisciplinaId( discOriginal->getId() );
												 at_Oferta->disciplina = d;
											 }
											 else
											 {
												at_Oferta->setDisciplinaId( id_disc );
												at_Oferta->disciplina = d;
											 }

                                             at_Oferta->setQuantidade( (int)( ( *it_Vars_a )->getValue() ) );
                                             at_Oferta->setTurma( turma );
                                             at_Oferta->oferta = ( *it_Vars_a )->getOferta();

											 at_Tatico->atendimento_oferta = at_Oferta;

                                             it_At_Dia->atendimentos_tatico->add( at_Tatico );

                                             ++at_Tatico_Counter;
                                          }
                                       }
                                       novo_Dia = false;
                                       break;
                                    }
                                 }

                                 if ( novo_Dia )
                                 {
									//Disciplina *d = ( *it_Vars_x )->getDisciplina();
									//int turma = ( *it_Vars_x )->getTurma();

                                    // Cadastrando o dia da semana
                                    AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
                                       this->problemSolution->getIdAtendimentos() );

                                    at_Dia_Semana->setDiaSemana( ( *it_Vars_x )->getDia() );

                                    // Para cada variavel x__i_d_u_s_t existe uma variavel a__i_d_o em questão.

									std::map< std::pair< int /*turma*/, Disciplina * >,
											  std::vector< Variable * > >::iterator
											  itMap = vars_a.find( std::make_pair( turma, d ) );
							
									if ( itMap == vars_a.end() )
									{
										std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
										std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
										std::cout << "\nNao encontrada variavel 'a' com: Disciplina: " << d->getId();
										std::cout << "\tTurma: " << turma;
										continue;
									}

									for ( std::vector< Variable* >::iterator it_Vars_a = itMap->second.begin();
										  it_Vars_a != itMap->second.end(); ++it_Vars_a )
                                    {
                                       AtendimentoTatico * at_Tatico = new AtendimentoTatico(
                                          this->problemSolution->getIdAtendimentos(),
                                          this->problemSolution->getIdAtendimentos() );

                                       // Verificando se a disicplina é de carater prático ou teórico.
                                       if (  ( *it_Vars_x )->getDisciplina()->getId() > 0
                                          && ( *it_Vars_x )->getDisciplina()->getCredTeoricos() > 0 )
                                       {
                                          at_Tatico->setQtdCreditosTeoricos( (int)( ( *it_Vars_x )->getValue() ) );
                                       }
                                       else
                                       {
                                          at_Tatico->setQtdCreditosPraticos( (int)( ( *it_Vars_x )->getValue() ) );
                                       }
											 
									   Oferta *oferta = ( *it_Vars_a )->getOferta();
									   
                                       AtendimentoOferta * at_Oferta = new AtendimentoOferta(
                                          this->problemSolution->getIdAtendimentos() );

                                       stringstream str;
                                       str << oferta->getId();
                                       at_Oferta->setOfertaCursoCampiId( str.str() );

                                       int id_disc = d->getId();
											 
										std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
										Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
										if ( discOriginal != NULL )
										{
											at_Oferta->setDisciplinaSubstitutaId( id_disc );
											at_Oferta->setDisciplinaId( discOriginal->getId() );
											at_Oferta->disciplina = d;
										}
										else
										{
											at_Oferta->setDisciplinaId( id_disc );
											at_Oferta->disciplina = d;
										}

                                       at_Oferta->setQuantidade( (int)( ( *it_Vars_a )->getValue() ) );
                                       at_Oferta->setTurma( ( *it_Vars_a )->getTurma() );
                                       at_Oferta->oferta = oferta;
                                       at_Tatico->atendimento_oferta = at_Oferta;

                                       at_Dia_Semana->atendimentos_tatico->add( at_Tatico );

                                       ++at_Tatico_Counter;
                                    }

                                    it_At_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                                 }
                              }
                              nova_Sala = false;
                              break;
                           }
                        }

                        if ( nova_Sala )
                        {
							Sala *s = ( *it_Vars_x )->getSala();
							Disciplina *d = ( *it_Vars_x )->getDisciplina();
							int turma = ( *it_Vars_x )->getTurma();

                           // Cadastrando a Sala
                           AtendimentoSala * at_Sala = new AtendimentoSala(
                              this->problemSolution->getIdAtendimentos() );

                           at_Sala->setId( s->getId() );
                           at_Sala->setSalaId( s->getCodigo() );
                           at_Sala->sala = s;

                           // Cadastrando o dia da semana
                           AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
                              this->problemSolution->getIdAtendimentos() );

                           at_Dia_Semana->setDiaSemana( ( *it_Vars_x )->getDia() );

                           // Para cada variavel x__i_d_u_s_t existe uma variavel a__i_d_o em questão.
							std::map< std::pair< int /*turma*/, Disciplina * >,
									  std::vector< Variable * > >::iterator
									  itMap = vars_a.find( std::make_pair( turma, d ) );
							
							if ( itMap == vars_a.end() )
							{
								std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg5>" << std::endl;
								std::cout << "\nNao era pra cair aqui <dbg5>" << std::endl;
								std::cout << "\nNao encontrada variavel 'a' com: Disciplina: " << d->getId();
								std::cout << "\tTurma: " << turma;
								continue;
							}

							for ( std::vector< Variable* >::iterator it_Vars_a = itMap->second.begin();
								  it_Vars_a != itMap->second.end(); ++it_Vars_a )
                            {
                              AtendimentoTatico * at_Tatico = new AtendimentoTatico(
                                 this->problemSolution->getIdAtendimentos(),
                                 this->problemSolution->getIdAtendimentos() );

                              // Verificando se a disicplina é de carater prático ou teórico.
                              if (  d->getId() > 0 && d->getCredTeoricos() > 0 )
                              {
                                 at_Tatico->setQtdCreditosTeoricos( (int)( ( *it_Vars_x )->getValue() ) );
                              }
                              else
                              {
                                 at_Tatico->setQtdCreditosPraticos( (int)( ( *it_Vars_x )->getValue() ) );
                              }
							  
							  Oferta *oferta = ( *it_Vars_a )->getOferta();

                              AtendimentoOferta * at_Oferta = new AtendimentoOferta(
                                 this->problemSolution->getIdAtendimentos() );

                              stringstream str;
                              str << oferta->getId();
                              at_Oferta->setOfertaCursoCampiId( str.str() );

                              int id_disc = d->getId();
								
							  std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
							  Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
							  if ( discOriginal != NULL )
							  {
									at_Oferta->setDisciplinaSubstitutaId( id_disc );	// substituta
									at_Oferta->setDisciplinaId( discOriginal->getId() );// original
									at_Oferta->disciplina = d;							// substituta
							  }
							  else
						      {
									at_Oferta->setDisciplinaId( id_disc );  // original
									at_Oferta->disciplina = d;				// original
							  }

                              at_Oferta->setQuantidade( (int)( ( *it_Vars_a )->getValue() ) );
                              at_Oferta->setTurma( (*it_Vars_a)->getTurma() );
                              at_Oferta->oferta = oferta;
                              at_Tatico->atendimento_oferta = at_Oferta;

                              at_Dia_Semana->atendimentos_tatico->add( at_Tatico );
                              ++at_Tatico_Counter;
                           }
                           at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                           it_At_Unidade->atendimentos_salas->add( at_Sala );
                        }
                     }

                     nova_Unidade = false;
                     break;
                  }
               }

               if ( nova_Unidade )
               {
				   Disciplina *d = ( *it_Vars_x )->getDisciplina();
				   int turma = ( *it_Vars_x )->getTurma();

				   // Cadastrando a Unidade
                  AtendimentoUnidade * at_Unidade = new AtendimentoUnidade(
                     this->problemSolution->getIdAtendimentos() );

                  at_Unidade->setId( ( *it_Vars_x )->getUnidade()->getId() );
                  at_Unidade->setCodigoUnidade( ( *it_Vars_x )->getUnidade()->getCodigo() );
                  at_Unidade->unidade = ( *it_Vars_x )->getUnidade();

                  // Cadastrando a Sala
                  AtendimentoSala * at_Sala = new AtendimentoSala(
                     this->problemSolution->getIdAtendimentos() );

                  at_Sala->setId( ( *it_Vars_x )->getSala()->getId() );
                  at_Sala->setSalaId( ( *it_Vars_x )->getSala()->getCodigo() );
                  at_Sala->sala = ( *it_Vars_x )->getSala();

                  // Cadastrando o dia da semana
                  AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
                     this->problemSolution->getIdAtendimentos() );

                  at_Dia_Semana->setDiaSemana( ( *it_Vars_x )->getDia() );

                  // Para cada variavel a__i_d_o existem para a variavel x__i_d_u_s_t em questão.

				  std::map< std::pair< int /*turma*/, Disciplina * >,
							std::vector< Variable * > >::iterator
							itMap = vars_a.find( std::make_pair( turma, d ) );
							
				  if ( itMap == vars_a.end() )
				  {
					std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg6>" << std::endl;
					std::cout << "\nNao era pra cair aqui <dbg6>" << std::endl;
					std::cout << "\nNao encontrada variavel 'a' com: Disciplina: " << d->getId();
					std::cout << "\tTurma: " << turma;
					continue;
				  }

				  for ( std::vector< Variable* >::iterator it_Vars_a = itMap->second.begin();
						it_Vars_a != itMap->second.end(); ++it_Vars_a )
				  {
                     AtendimentoTatico * at_Tatico = new AtendimentoTatico(
                        this->problemSolution->getIdAtendimentos(),
                        this->problemSolution->getIdAtendimentos() );

                     // Verificando se a disciplina é de carater prático ou teórico.
                     if (  ( *it_Vars_x )->getDisciplina()->getId() > 0
                        && ( *it_Vars_x )->getDisciplina()->getCredTeoricos() > 0 )
                     {
                        at_Tatico->setQtdCreditosTeoricos( (int)( ( *it_Vars_x )->getValue() ) );
                     }
                     else
                     {
                        at_Tatico->setQtdCreditosPraticos( (int)( ( *it_Vars_x )->getValue() ) );
                     }
					 
					 Oferta *oferta = ( *it_Vars_a )->getOferta();

                     AtendimentoOferta * at_Oferta = new AtendimentoOferta(
                        this->problemSolution->getIdAtendimentos() );

                     stringstream str;
                     str << ( *it_Vars_a )->getOferta()->getId();
                     at_Oferta->setOfertaCursoCampiId( str.str() );

                     int id_disc = ( *it_Vars_a )->getDisciplina()->getId();

 					 std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
					 Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
					 if ( discOriginal != NULL )
					 {
						at_Oferta->setDisciplinaSubstitutaId( id_disc );
						at_Oferta->setDisciplinaId( discOriginal->getId() );
						at_Oferta->disciplina = d;
					 }
					 else
					 {
						at_Oferta->setDisciplinaId( id_disc );
						at_Oferta->disciplina = d;
					 }

                     at_Oferta->setQuantidade( (int)( ( *it_Vars_a )->getValue() ) );
                     at_Oferta->setTurma( ( *it_Vars_a )->getTurma() );
                     at_Oferta->oferta = ( *it_Vars_a )->getOferta();
                     at_Tatico->atendimento_oferta = at_Oferta;

                     at_Dia_Semana->atendimentos_tatico->add( at_Tatico );
                     ++at_Tatico_Counter;
                  }

                  at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
                  at_Unidade->atendimentos_salas->add( at_Sala );
                  it_At_Campus->atendimentos_unidades->add( at_Unidade );
               }
            }

            novo_Campus = false;
            break;
         }
      }

      if ( novo_Campus )
      {
		 Disciplina *d = ( *it_Vars_x )->getDisciplina();
		 int turma = ( *it_Vars_x )->getTurma();

         AtendimentoCampus * at_Campus = new AtendimentoCampus(
            this->problemSolution->getIdAtendimentos() );

         at_Campus->setId( campus->getId() );
         at_Campus->setCampusId( campus->getCodigo() );
         at_Campus->campus = campus;

         // Cadastrando a Unidade
         AtendimentoUnidade * at_Unidade = new AtendimentoUnidade(
            this->problemSolution->getIdAtendimentos() );

         at_Unidade->setId( ( *it_Vars_x )->getUnidade()->getId() );
         at_Unidade->setCodigoUnidade( ( *it_Vars_x )->getUnidade()->getCodigo() );
         at_Unidade->unidade = ( *it_Vars_x )->getUnidade();

         // Cadastrando a Sala
         AtendimentoSala * at_Sala = new AtendimentoSala(
            this->problemSolution->getIdAtendimentos() );

         at_Sala->setId( ( *it_Vars_x )->getSala()->getId() );
         at_Sala->setSalaId( ( *it_Vars_x )->getSala()->getCodigo() );
         at_Sala->sala = ( *it_Vars_x )->getSala();

         // Cadastrando o dia da semana
         AtendimentoDiaSemana * at_Dia_Semana = new AtendimentoDiaSemana(
            this->problemSolution->getIdAtendimentos() );

         at_Dia_Semana->setDiaSemana( ( *it_Vars_x )->getDia() );

         // Para cada variavel a__i_d_o existem para a variavel x__i_d_u_s_t em questão.
		std::map< std::pair< int /*turma*/, Disciplina * >,
					std::vector< Variable * > >::iterator
					itMap = vars_a.find( std::make_pair( turma, d ) );
							
		if ( itMap == vars_a.end() )
		{
			std::cout << "\nvoid SolverMIP::getSolutionTatico() <dbg7>" << std::endl;
			std::cout << "\nNao era pra cair aqui <dbg7>" << std::endl;
			std::cout << "\nNao encontrada variavel 'a' com: Disciplina: " << d->getId();
			std::cout << "\tTurma: " << turma;
			continue;
		}

		for ( std::vector< Variable* >::iterator it_Vars_a = itMap->second.begin();
				it_Vars_a != itMap->second.end(); ++it_Vars_a )
        {
            AtendimentoTatico * at_Tatico = new AtendimentoTatico(
               this->problemSolution->getIdAtendimentos(),
			   this->problemSolution->getIdAtendimentos() );

            // Verificando se a disciplina é de carater prático ou teórico.
            if ( ( *it_Vars_x )->getDisciplina()->getId() > 0
               && ( *it_Vars_x )->getDisciplina()->getCredTeoricos() > 0 )
            {
               at_Tatico->setQtdCreditosTeoricos( (int)( ( *it_Vars_x )->getValue() ) );
            }
            else
            {
               at_Tatico->setQtdCreditosPraticos( (int)( ( *it_Vars_x )->getValue() ) );
            }
					 
			Oferta *oferta = ( *it_Vars_a )->getOferta();

            AtendimentoOferta * at_Oferta = new AtendimentoOferta(
            this->problemSolution->getIdAtendimentos() );

            stringstream str;
            str << ( *it_Vars_a )->getOferta()->getId();
            at_Oferta->setOfertaCursoCampiId( str.str() );

            int id_disc = ( *it_Vars_a )->getDisciplina()->getId();

 			std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
			Disciplina *discOriginal = problemData->ehSubstitutaDe( d, parCursoCurr );
			if ( discOriginal != NULL )
			{
				at_Oferta->setDisciplinaSubstitutaId( id_disc );
				at_Oferta->setDisciplinaId( discOriginal->getId() );
				at_Oferta->disciplina = d;
			}
			else
			{
				at_Oferta->setDisciplinaId( id_disc );
				at_Oferta->disciplina = d;
			}

            at_Oferta->setQuantidade( (int)( ( *it_Vars_a )->getValue() ) );
            at_Oferta->setTurma( ( *it_Vars_a )->getTurma() );
            at_Oferta->oferta = ( *it_Vars_a )->getOferta();
            at_Tatico->atendimento_oferta = at_Oferta;

            at_Dia_Semana->atendimentos_tatico->add( at_Tatico );
            ++at_Tatico_Counter;
         }
         at_Sala->atendimentos_dias_semana->add( at_Dia_Semana );
         at_Unidade->atendimentos_salas->add( at_Sala );
         at_Campus->atendimentos_unidades->add( at_Unidade );

         problemSolution->atendimento_campus->add( at_Campus );
      }
   }
}

int SolverMIP::solveOperacional()
{
   solveOperacionalMIP();
   // Criando uma solução inicial
   SolucaoInicialOperacional solIni( *problemData );

   std::cout << "Gerando uma solucao inicial para o modelo operacional" << std::endl;
   SolucaoOperacional & solucaoOperacional = solIni.geraSolucaoInicial();

   std::cout << "Solucao inicial gerada." << std::endl;

   /*bool solucao_valida = solucaoOperacional.validaSolucao( "Validando a solucao inicial gerada" );
   if ( solucao_valida )
   {
      std::cout << "Solucao Inicial VALIDA gerada." << std::endl;
   }
   else
   {
      std::cout << "Solucao Inicial NAO-VALIDA gerada." << std::endl;
   }*/

   solucaoOperacional.toString2();

   // Avaliador
   Avaliador avaliador;
   std::cout << "Avaliando solucao" << std::endl;
   avaliador.avaliaSolucao( solucaoOperacional, true );
   std::cout << "Solucao avaliada." << std::endl;

   // Estruturas de Vizinhança
   //NSSeqSwapEqBlocks nsSeqSwapEqBlocks ( *problemData );
   //NSSwapEqSchedulesBlocks nsSwapEqSchedulesBlocks ( *problemData );
   //NSSwapEqTeachersBlocks nsSwapEqTeachersBlocks ( *problemData );
   NSShift nsShift( *problemData );

   // Heurísticas de Busca Local - Descida Randômica
   //RandomDescentMethod rdmSeqSwapEqBlocks ( avaliador, nsSeqSwapEqBlocks, 300 );
   //RandomDescentMethod rdmSwapEqSchedulesBlocks ( avaliador, nsSwapEqSchedulesBlocks, 300 );
   //RandomDescentMethod rdmSwapEqTeachersBlocks ( avaliador, nsSwapEqTeachersBlocks, 300 );
   RandomDescentMethod rdmShift ( avaliador, nsShift, 300 );

   //rdmSeqSwapEqBlocks.exec( solucaoOperacional, 30, 0 );
   //rdmSwapEqSchedulesBlocks.exec( solucaoOperacional, 30, 0 );
   //rdmSwapEqTeachersBlocks.exec( solucaoOperacional, 30, 0 );
   rdmShift.exec( solucaoOperacional, 30, 0 );

   // Mecanismo de perturbação
   //ILSLPerturbationLPlus2 ilslPerturbationPlus2 ( avaliador, -1, nsSeqSwapEqBlocks );
   //ilslPerturbationPlus2.add_ns( nsSeqSwapEqBlocks );
   //ilslPerturbationPlus2.add_ns( nsSwapEqSchedulesBlocks );
   //ilslPerturbationPlus2.add_ns( nsSwapEqTeachersBlocks );
   //ilslPerturbationPlus2.add_ns( nsShift );

   // RVND
   std::vector< Heuristic * > heuristicasBuscaLocal;
   //heuristicasBuscaLocal.push_back( &rdmSeqSwapEqBlocks );
   //heuristicasBuscaLocal.push_back( &rdmSwapEqSchedulesBlocks );
   //heuristicasBuscaLocal.push_back( &rdmSwapEqTeachersBlocks );
   heuristicasBuscaLocal.push_back( &rdmShift );

   RVND rvnd( avaliador, heuristicasBuscaLocal );

   // Busca Local Iterada por Níveis
   //IteratedLocalSearchLevels ilsl ( avaliador, rvnd, ilslPerturbationPlus2, 20 , 4 );

   // Parâmetro 2 : tempo ( em segundos )
   //ilsl.exec( solucaoOperacional, 30, 0 );

   // Avaliação final
   avaliador.avaliaSolucao( solucaoOperacional, true );
   /*solucao_valida = solucaoOperacional.validaSolucao( "Validando a solucao final" );
   if ( solucao_valida )
   {
      std::cout << "Solucao final viavel." << std::endl;
   }
   else
   {
      std::cout << "A solucao final NAO ALOCOU todas as aulas." << std::endl;
   }*/

   // Armazena a solução operacional no problem solution
   problemSolution->solucao_operacional = &( solucaoOperacional );
   return 1;
}

int SolverMIP::solveOperacionalMIP()
{
   int varNum = 0;
   int constNum = 0;

   if ( lp != NULL )
   {
      lp->freeProb();
      delete lp;
#ifdef SOLVER_CPLEX
	   lp = new OPT_CPLEX; 
#endif
#ifdef SOLVER_GUROBI
	   lp = new OPT_GUROBI; 
#endif
   }

   lp->createLP( "SolverOperacional",
      OPTSENSE_MINIMIZE, PROB_MIP );

#ifdef DEBUG
   printf( "Creating LP...\n" );
#endif

   relacionaProfessoresDisciplinas();

   // Variable creation
   varNum = criaVariaveisOperacional();

#ifdef PRINT_cria_variaveis
   printf( "Total of Variables: %i\n\n", varNum );
#endif

   // Constraint creation
   constNum = criaRestricoesOperacional();

#ifdef PRINT_cria_restricoes
   printf( "Total of Constraints: %i\n\n", constNum );
#endif

#ifdef DEBUG
 //  lp->writeProbLP( "SolverOperacional" );
#endif

   VariableOpHash::iterator vit;

   // ------------------------------------
   // Garantia de solucao
   std::cout<<"\n------------------------------------";
   std::cout<<"\nGarantia de solucao\n\n"; fflush(NULL);

   vit = vHashOp.begin();
   for (; vit != vHashOp.end(); vit++ )
   {
	   VariableOp v = vit->first;
	   if(v.getType() == VariableOp::V_X_PROF_AULA_HOR)
	   {
         lp->chgUB(vit->second,0.0);
	   }
   }

   lp->setMIPScreenLog( 4 );
   lp->setNumIntSols(1);

   lp->writeProbLP( "SolverOperacional1" );

   lp->optimize(METHOD_MIP);
    
   fflush(NULL);
   
   double *x = new double[ lp->getNumCols() ];
   lp->getX( x );

   int *idxN = new int[ lp->getNumCols() ];

   vit = vHashOp.begin();
   for (; vit != vHashOp.end(); vit++ )
   {
	   idxN[vit->second] = vit->second;

	   VariableOp v = vit->first;
	   if(v.getType() == VariableOp::V_X_PROF_AULA_HOR)
	   {
           lp->chgUB(vit->second,1.0);
	   }
   }
   // ------------------------------------

   int maxTitulId = 5;
   if ( !problemData->parametros->min_doutores )
   {
	   maxTitulId = 4;
	   if ( !problemData->parametros->min_mestres )
		   maxTitulId = 1;
   }

   map<int, double> cost;

   // ------------------------------------
   // Garantia de máximo atendimento
   std::cout<<"\n------------------------------------";
   std::cout<<"\nGarantia de máximo atendimento usando profs só virtuais de alta titulação\n\n"; fflush(NULL);

   vit = vHashOp.begin();
   for (; vit != vHashOp.end(); vit++ )
   {
		VariableOp v = vit->first;
		if(v.getType() != VariableOp::V_FOLGA_DEMANDA)
		{
			cost[vit->second] = lp->getObj(vit->second);
			lp->chgObj(vit->second, 0.0);
		}
		else
		{
			cost[vit->second] = lp->getObj(vit->second);
			lp->chgObj(vit->second, cost[vit->second]/100000.0);
		}

		if(v.getType() == VariableOp::V_X_PROF_AULA_HOR && !v.getProfessor()->eVirtual() )
			lp->chgUB(vit->second, 0.0);
		else if(v.getType() == VariableOp::V_X_PROF_AULA_HOR && v.getProfessor()->eVirtual() && v.getProfessor()->getTitulacaoId() != maxTitulId )
		{
			lp->chgUB(vit->second, 0.0);
		}
   }
   
   int status = 0;

   //lp->setMIPRelTol( 0.01 );
   lp->setMIPEmphasis(4);
   lp->setVarSel(4);
   lp->setNumIntSols(0);
   //lp->setCuts(0);
   lp->setNoCuts();
   lp->setMIPScreenLog( 4 );
   lp->setTimeLimit( 3600 );
   lp->setNodeLimit(3100);
   lp->setPolishAfterNode( 1 );
   lp->setPreSolve(OPT_TRUE);
   
   lp->copyMIPStartSol(lp->getNumCols(),idxN,x);

   lp->writeProbLP( "SolverOperacional2" );

   status = lp->optimize( METHOD_MIP );
   
   // ------------------------------------

   lp->getX( x );

   /*FILE * fin = fopen( "solOpAtual.bin", "rb" );
   if ( fin == NULL )
   {
      std::cout << "\nErro em SolverMIP::solveTaticoBasicoCjtAlunos( int campusId, int prioridade, int cjtAlunosId ):"
         << "\nArquivo " << "solLBAtual.bin" << " nao pode ser aberto.\n";
   }
   else
   {
      int nCols = 0;

      fread( &nCols, sizeof( int ), 1, fin );

      for ( int i = 0; i < nCols; i++ )
      {
         double auxR;
         fread( &auxR, sizeof( double ), 1, fin );

         x[ i ] = auxR;
      }

      fclose( fin );
   }*/

   /*FILE * fout2 = fopen( "solOpAtual.bin", "wb" );
   if ( fout2 == NULL )
   {
      std::cout << "\nErro em SolverMIP::solveTaticoBasicoCjtAlunos( int campusId, int prioridade, int cjtAlunosId ):"
         << "\nArquivo " << "solLBAtual.bin" << " nao pode ser aberto.\n";
   }
   else
   {
      int nCols = lp->getNumCols();

      fwrite( &nCols, sizeof( int ), 1, fout2 );
      for ( int i = 0; i < lp->getNumCols(); i++ )
      {
         fwrite( &( x[ i ] ), sizeof( double ), 1, fout2 );
      }

      fclose( fout2 );
   }*/

   std::cout<<"\n------------------------------------";
   std::cout<<"\nFixa máximo atendimento e volta pesos originais\n\n"; fflush(NULL);

   std::list<VariableOpHash::iterator> usedVars;
   vit = vHashOp.begin();
   for (; vit != vHashOp.end(); vit++ )
   {
		VariableOp v = vit->first;
		if(v.getType() == VariableOp::V_FOLGA_DEMANDA  && x[vit->second] < 0.1)
			lp->chgUB(vit->second, 0.0);
		else if(v.getType() == VariableOp::V_FOLGA_DEMANDA)
			lp->chgLB(vit->second, 1.0);

		if(v.getType() == VariableOp::V_X_PROF_AULA_HOR && x[vit->second] >= 0.1 )
			usedVars.push_back(vit);
		else if (v.getType() == VariableOp::V_X_PROF_AULA_HOR)
			lp->chgUB(vit->second,0.0);
		if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR )
			lp->chgObj(vit->second, cost[vit->second]);
   }

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
	  VariableOp v = vit->first;
      if(v.getType() == VariableOp::V_X_PROF_AULA_HOR)
      {
         for (std::list<VariableOpHash::iterator>::iterator itL = usedVars.begin();
            itL != usedVars.end();
            itL++)
         {
            VariableOpHash::iterator vit2 = *itL;

            if ( vit2->first.getAula() == v.getAula() &&
               vit2->first.getCampus() == v.getCampus() &&
               vit2->first.getCurso() == v.getCurso() &&
               vit2->first.getDia() == v.getDia() &&
               vit2->first.getDisciplina() == v.getDisciplina() &&
               vit2->first.getH1() == v.getH1() &&
               vit2->first.getH2() == v.getH2() &&
               vit2->first.getHorario() == v.getHorario() &&
               vit2->first.getHorarioAula() == v.getHorarioAula() &&
               vit2->first.getHorarioDiaD() == v.getHorarioDiaD() &&
               vit2->first.getHorarioDiaD1() == v.getHorarioDiaD1() &&
               vit2->first.getSala() == v.getSala() &&
               vit2->first.getTurma() == v.getTurma() &&
               vit2->first.getUnidade() == v.getUnidade() ) // Só não compara o prof
            {
               lp->chgUB(vit->second,1.0);
            }
         }
      }
	  
	  lp->chgObj(vit->second, cost[vit->second]);
   }

   usedVars.clear();
   
   lp->setMIPEmphasis(0);
   lp->setCuts(5);
   lp->setNodeLimit(10000000000);
   lp->setPolishAfterNode(1);
   lp->setTimeLimit(6*3600);

   lp->copyMIPStartSol(lp->getNumCols(),idxN,x);

   lp->writeProbLP( "SolverOperacional3" );

   status = lp->optimize( METHOD_MIP );

   lp->getX( x );

   std::cout<<"\n------------------------------------";
   std::cout<<"\Maximo atendimento fixado e profs livres\n\n"; fflush(NULL);

   vit = vHashOp.begin();
   for (; vit != vHashOp.end(); vit++ )
   {
	  VariableOp v = vit->first;

	  if(v.getType() == VariableOp::V_X_PROF_AULA_HOR )
		  lp->chgUB(vit->second, 1.0);

	  // fixa cada prof para cada turma, deixando portanto so o horario livre para decidir
      //if ( v.getType() == VariableOp::V_Y_PROF_DISCIPLINA )
      //{
      //   if ( x[vit->second] > 0.1 )
      //      lp->chgLB(vit->second,1.0);
      //   else
      //      lp->chgUB(vit->second,0.0);
      //}

      lp->chgObj(vit->second, cost[vit->second]);
   }
      
   lp->writeProbLP( "SolverOperacional" );

   lp->setMIPEmphasis(0);
   lp->setNoCuts();
   lp->setTimeLimit(3*3600);
   lp->setVarSel(4);
   lp->setPolishAfterIntSol(1);
   lp->setNumIntSols(0);
   lp->setNodeLimit(1000000000);
   
   lp->copyMIPStartSol(lp->getNumCols(),idxN,x);

   status = lp->optimize( METHOD_MIP );
    
   lp->getX( x );

   fflush(NULL);

   FILE * fout = fopen( "solucaoOp.txt", "wt" );
   solVarsOp.clear();

   vit = vHashOp.begin();
   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( x[ vit->second ] > 0.01 )
      {
         VariableOp * newVar = new VariableOp( v );

         newVar->setValue( x[ vit->second ] );
         fprintf( fout, "%s = %f\n", v.toString().c_str(), x[ vit->second ] );

         solVarsOp.push_back( newVar );
      }
   }

   fclose( fout );
   delete [] x;

   geraProfessoresVirtuaisMIP();

   return status;
}

void SolverMIP::relacionaProfessoresDisciplinas()
{
   problemData->mapProfessorDisciplinas.clear();

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->campi.begin()->professores;

   // Informa as aulas alocadas para cada professor
   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
      {
         Aula * aula = ( *it_aula );
         Disciplina * disciplina = aula->getDisciplina();

         // TODO -- como recuperar o professor que foi alocado à aula ???
         std::pair< int, int > professor_disciplina(
            professor->getId(), disciplina->getId() );

         // Se o professor e a disciplina da aula em questão se relacionarem
         if ( problemData->prof_Disc_Dias.find( professor_disciplina )
               == problemData->prof_Disc_Dias.end() )
         {
            continue;
         }

         std::pair< Aula *, Disciplina * > aula_disciplina
            = std::make_pair( aula, disciplina );

         problemData->mapProfessorDisciplinas[ professor ].add( aula_disciplina );
      }
   }
}

void SolverMIP::getSolutionOperacional()
{
   int i = 0, j = 0, id_operacional = 0;

   Aula * aula = NULL;
   Professor * professor = NULL;
   ProfessorVirtualOutput * professor_virtual = NULL;

   // Preenche a lista de professores virtuais do output
   MatrizSolucao * matriz_solucao
      = problemSolution->solucao_operacional->getMatrizAulas();

   for (; i < (int)this->problemData->professores_virtuais.size(); i++ )
   {
      // Devo apenas analisar os professores virtuais
      professor = this->problemData->professores_virtuais.at( i );

      // Inclui um novo professor na
      // lista de professores virtuais
      professor_virtual = new ProfessorVirtualOutput();

      professor_virtual->setId( professor->getId() );
      professor_virtual->setChMin( professor->getChMin() );
      professor_virtual->setChMax( professor->getChMax() );
      professor_virtual->setTitulacaoId( professor->getTitulacaoId() );
      professor_virtual->setAreaTitulacaoId( professor->getAreaId() );

      // Procura pelas disciplinas que o professor deverá ministrar
      id_operacional = professor->getIdOperacional();
      for (; j < (int)matriz_solucao->at( id_operacional )->size(); j++ )
      {
         aula = matriz_solucao->at( id_operacional )->at( j );

         if ( aula != NULL && aula->eVirtual() == false )
         {
            // Adiciona uma disciplina a mais ao professor virtual
            professor_virtual->disciplinas.add(
               aula->getDisciplina()->getId() );
         }
      }

      this->problemSolution->professores_virtuais->add( professor_virtual );
   }
}

Professor * SolverMIP::criaProfessorVirtual( Professor *professor, HorarioDia * horario, int cred,
   std::set< std::pair< Professor *, HorarioDia * > > & profVirtualList )
{
   // Procura primeiro professor virtual livre no horario
   Professor * prof = NULL;
   TipoTitulacao *titulacao = professor->titulacao;
   int nCreds;
   int dia = horario->getDia();

   for ( int i = 0; i < (int)problemData->professores_virtuais.size(); i++ )
   {
	   if ( problemData->professores_virtuais[ i ]->getTitulacaoId() != titulacao->getId() )
		   continue;

      std::pair< Professor *, HorarioDia * > auxPair;
	  
      // Tenta professor livre para todos os creditos
      bool profOK = true;
	  
	  nCreds = 1;
	  Calendario* c = horario->getHorarioAula()->getCalendario();
	  HorarioAula* h = horario->getHorarioAula();
	 
	  while ( h != NULL && nCreds <= cred )
      {
		  std::set< std::pair< Professor *, HorarioDia * > >::iterator itProfV = profVirtualList.begin();
		  for ( ; itProfV != profVirtualList.end(); itProfV++ )
		  {
			  // Verifica todos os horários já alocados para o professor i no dia
			  // e marca profOK=false caso este já possua aula em algum horario que
			  // sobreponha h

			  if ( itProfV->first != problemData->professores_virtuais[ i ] ||
				   itProfV->second->getDia() != dia )
			  {
				  continue;
			  }

			  HorarioAula* ha = itProfV->second->getHorarioAula();
			  
			  if ( ha == h || h->sobrepoe( *ha ) )
			  {
				  profOK = false; // prof já possui horario que sobrepõe h no dia
				  break;
			  }
		  }

		  if ( !profOK )
			  break;

		  // itera
		  nCreds++;
		  h = c->getProximoHorario( h );
      }

      if ( profOK )
      {
         prof = problemData->professores_virtuais[ i ];

		 nCreds = 1;
		 Calendario* c = horario->getHorarioAula()->getCalendario();
		 HorarioAula* h = horario->getHorarioAula();
	     		 
		 while ( h!=NULL && nCreds <= cred )
		 {
            auxPair.first = prof;
            auxPair.second = problemData->getHorarioDiaCorrespondente( h, dia );

            profVirtualList.insert( auxPair );

			// itera
			nCreds++;
			h = c->getProximoHorario( h );
         }

         break;
      }
   }

   if ( prof != NULL )
   {
      return prof;
   }

   // Criando um professor virtual.
   prof = new Professor( true );
   int idProf = -1 * (int)( problemData->professores_virtuais.size() );
   idProf--;
   prof->setId( idProf );

	prof->setTitulacaoId( titulacao->getId() );
	prof->titulacao = titulacao;
	std::string nome = prof->getNome();
	stringstream ss; ss << idProf;
	nome += ss.str();
	prof->setNome( nome );

   // Setando alguns dados para o novo professor
   prof->tipo_contrato = ( *problemData->tipos_contrato.begin() );

   // Temporariamente vou setar os ids
   // dos magistérios com valores negativos.
   int idMag = 0;

   ITERA_GGROUP_LESSPTR( itDisciplina,
      problemData->disciplinas, Disciplina )
   {
	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( *itDisciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( *itDisciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion

      Magisterio * mag = new Magisterio();

      mag->setId( --idMag );
      mag->disciplina = ( *itDisciplina );
      mag->setDisciplinaId( itDisciplina->getId() );
      mag->setNota( 10 );
      mag->setPreferencia( 1 );

      prof->magisterio.add( mag );
   }

   problemData->campi.begin()->professores.add( prof );
   prof->horarios = problemData->campi.begin()->horarios;

   problemData->professores_virtuais.push_back( prof );

   std::pair< Professor *, HorarioDia * > auxPair;
   
	nCreds = 1;
	Calendario* c = horario->getHorarioAula()->getCalendario();
	HorarioAula* h = horario->getHorarioAula();

	while ( h!=NULL && nCreds <= cred )
	{
       auxPair.first = prof;
       auxPair.second = problemData->getHorarioDiaCorrespondente( h, dia );

       profVirtualList.insert( auxPair );

	   // itera
	   nCreds++;
	   h = c->getProximoHorario( h );
    }

   return prof;
}

void SolverMIP::geraProfessoresVirtuaisMIP()
{
	std::set<std::pair< Professor *, HorarioDia * > > profVirtualList;

   // Procura variaveis que usem professor virtual
   for ( int i = 0; i < (int) solVarsOp.size(); i++ )
   {
      VariableOp * v = solVarsOp[ i ];

      if ( v->getType() != VariableOp::V_X_PROF_AULA_HOR )
      {
         continue;
      }

	  if ( ! v->getProfessor()->eVirtual() )
      {
         continue;
      }

      int nCred = v->getAula()->getTotalCreditos();

	  Professor * profVirtual = criaProfessorVirtual( v->getProfessor(), v->getHorario(), nCred, profVirtualList );

      v->setProfessor( profVirtual );
   }
}

void SolverMIP::getSolutionOperacionalMIP()
{
   // Procura variaveis que usem professor virtual
   for ( int i = 0; i < (int) solVarsOp.size(); i++ )
   {
      VariableOp * v = solVarsOp[ i ];

      if ( v->getType() != VariableOp::V_X_PROF_AULA_HOR )
      {
         continue;
      }

      if ( !v->getProfessor()->eVirtual() )
      {
         continue;
      }

      // Procura virtual
      bool achou = false;
      ITERA_GGROUP( itProf, ( *problemSolution->professores_virtuais ), ProfessorVirtualOutput )
      {
         ProfessorVirtualOutput * professor_virtual = ( *itProf );

         if ( professor_virtual->getId() == v->getProfessor()->getId() )
         {
            achou = true;

            professor_virtual->disciplinas.add(
               v->getAula()->getDisciplina()->getId() );

            break;
         }
      }

      if ( !achou )
      {
         ProfessorVirtualOutput * professor_virtual = new ProfessorVirtualOutput();

         professor_virtual->setId( v->getProfessor()->getId() );
         professor_virtual->setChMin( v->getProfessor()->getChMin() );
         professor_virtual->setChMax( v->getProfessor()->getChMax() );
         professor_virtual->setTitulacaoId( v->getProfessor()->getTitulacaoId() );
         professor_virtual->setAreaTitulacaoId( v->getProfessor()->getAreaId() );

         professor_virtual->disciplinas.add( v->getAula()->getDisciplina()->getId() );

         problemSolution->professores_virtuais->add( professor_virtual );
      }
   }
}


void SolverMIP::imprimeSolVarsPre( int campusId, int prioridade, int cjtAlunosId )
{

   // teste
   char solPosFilename[1024];
   strcpy( solPosFilename, getSolVarsPreFileName( campusId, prioridade, cjtAlunosId ).c_str() );
   FILE * fout = fopen( solPosFilename, "wt" );
   
   ITERA_GGROUP_LESSPTR ( itSolX, solVarsXPre, VariablePre )
   {      
	   VariablePre *v = *itSolX;
	   
	   fprintf( fout, "%s = %f\n", v->toString().c_str(), v->getValue() );
		   
   }
   fclose( fout );

}

int SolverMIP::solve()
{
   int status = 0;

   if ( problemData->parametros->modo_otimizacao == "TATICO"
         && problemData->atendimentosTatico == NULL )
   {
	   if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
	   {
			std::cout<<"\nAjustar!!!!!!!! Saindo...\n";
			exit(1);
		   //status = solveTaticoPorCampus();
	   }
	   else if ( problemData->parametros->otimizarPor == "ALUNO" )
	   {
			#ifndef TATICO_CJT_ALUNOS
			  status = solveTaticoPorCampus();
			#endif

			#ifdef TATICO_CJT_ALUNOS
			  status = solveTaticoPorCampusCjtAlunos();
			#endif	   
	   }

   }
   else if ( problemData->parametros->modo_otimizacao == "OPERACIONAL" )
   {
	  std::cout<<"\n------------------------------Operacional------------------------------\n";

      problemSolution->atendimento_campus;

      if ( problemData->atendimentosTatico != NULL
            && problemData->atendimentosTatico->size() > 0 )
      {
		  ITERA_GGROUP_LESSPTR( itAtTat, ( *problemData->atendimentosTatico ), AtendimentoCampusSolucao )
         { 
            Campus * campus = problemData->refCampus[ itAtTat->getCampusId() ];

            AtendimentoCampus * atCampus = new AtendimentoCampus( this->problemSolution->getIdAtendimentos() );

            atCampus->setId( campus->getId() );
            atCampus->setCampusId( campus->getCodigo() );
            atCampus->campus = campus;

            ITERA_GGROUP( itAtUnd, itAtTat->atendimentosUnidades, AtendimentoUnidadeSolucao )
            {
               Unidade * unidade = problemData->refUnidade[ itAtUnd->getUnidadeId() ];

               AtendimentoUnidade * atUnidade = new AtendimentoUnidade(
                  this->problemSolution->getIdAtendimentos() );

               atUnidade->setId( unidade->getId() );
               atUnidade->setCodigoUnidade( unidade->getCodigo() );
               atUnidade->unidade = unidade;

               ITERA_GGROUP( itAtSala,
                  itAtUnd->atendimentosSalas, AtendimentoSalaSolucao )
               {
                  Sala * sala = problemData->refSala[ itAtSala->getSalaId() ];

                  AtendimentoSala * atSala = new AtendimentoSala(
                     this->problemSolution->getIdAtendimentos() );

                  atSala->setId( sala->getId() );
                  atSala->setSalaId( sala->getCodigo() );
                  atSala->sala = sala;

                  ITERA_GGROUP( itAtDiaSemana,
                     itAtSala->atendimentosDiasSemana, AtendimentoDiaSemanaSolucao )
                  {
                     AtendimentoDiaSemana * atDiaSemana = new AtendimentoDiaSemana(
                        this->problemSolution->getIdAtendimentos() );

                     atDiaSemana->setDiaSemana( itAtDiaSemana->getDiaSemana() );

                     atSala->atendimentos_dias_semana->add( atDiaSemana );
                  }

                  atUnidade->atendimentos_salas->add( atSala );
               }

               atCampus->atendimentos_unidades->add( atUnidade );
            }

            problemSolution->atendimento_campus->add( atCampus );
         }

         // Resolvendo o modelo operacional
         status = solveOperacionalMIP();

         // Preenche as classes do output operacional
         preencheOutputOperacionalMIP( problemSolution );
      }
      else
      {
         // Neste caso, primeiro deve-se gerar uma saída para
         // o modelo tático. Em seguida, deve-se resolver o
         // modelo operacional com base na saída do modelo tático gerada.
		if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
		{
			std::cout<<"\nAjustar!!!!!!!! Saindo...\n";
			exit(1);
			//status = solveTaticoPorCampus();
		}
		else if ( problemData->parametros->otimizarPor == "ALUNO" )
		{
			#ifndef TATICO_CJT_ALUNOS
				status = solveTaticoPorCampus();
			#endif

			#ifdef TATICO_CJT_ALUNOS
				status = solveTaticoPorCampusCjtAlunos();
			#endif
		}
         // Preenchendo a estrutura "atendimentosTatico".
         problemData->atendimentosTatico
               = new GGroup< AtendimentoCampusSolucao *, LessPtr< AtendimentoCampusSolucao > >();

         ITERA_GGROUP( it_At_Campus,
            ( *problemSolution->atendimento_campus ), AtendimentoCampus )
         {
            problemData->atendimentosTatico->add(
               new AtendimentoCampusSolucao( **it_At_Campus ) );
         }

         // Remove a referência para os atendimentos tático (que pertencem ao output tático)
         ITERA_GGROUP( it_At_Campus,
            ( *problemSolution->atendimento_campus ), AtendimentoCampus )
         {
            ITERA_GGROUP( it_At_Unidade,
               ( *it_At_Campus->atendimentos_unidades ), AtendimentoUnidade )
            {
               ITERA_GGROUP( it_At_Sala,
                  ( *it_At_Unidade->atendimentos_salas ), AtendimentoSala )
               {
                  ITERA_GGROUP( it_At_DiaSemana,
                     ( *it_At_Sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
                  {
                     GGroup< AtendimentoTatico * > * atendimentos_tatico
                           = it_At_DiaSemana->atendimentos_tatico;

                     atendimentos_tatico->clear();
                  }
               }
            }
         }
	    
		 std::cout<<"\n------------------------------Operacional------------------------------\n";

         // Criando as aulas que serão utilizadas
         // para resolver o modelo operacional
         problemDataLoader->criaAulas();

         // Resolvendo o modelo operacional
         status = solveOperacionalMIP();

         // Preenche as classes do output operacional
         preencheOutputOperacionalMIP( problemSolution );
      }
	   
	  getSolutionOperacionalMIP();

   }
   
	std::cout<<"\nRelacionando alunos\n";

   relacionaAlunosDemandas();

   //buscaLocalTempoDeslocamentoSolucao();

   return status;
}

// Método que relaciona cada demanda atendida aos
// correspondentes alunos que assistirão as aulas 
void SolverMIP::relacionaAlunosDemandas()
{
   Campus * campus = NULL;
   Unidade * unidade = NULL;
   Sala * sala = NULL;
   int dia_semana = 0;

   // Lendo os atendimentos oferta da solução
   GGroup< AtendimentoOferta * > atendimentosOferta;

   ITERA_GGROUP( it_At_Campus,
      ( *problemSolution->atendimento_campus ), AtendimentoCampus )
   {
      // Campus do atendimento
      campus = it_At_Campus->campus;

      ITERA_GGROUP( it_At_Unidade,
         ( *it_At_Campus->atendimentos_unidades ), AtendimentoUnidade )
      {
         // Unidade do atendimento
         unidade = problemData->refUnidade[ it_At_Unidade->getId() ];

         ITERA_GGROUP( it_At_Sala,
            ( *it_At_Unidade->atendimentos_salas ), AtendimentoSala )
         {
            // Sala do atendimento
            sala = problemData->refSala[ it_At_Sala->getId() ];

            ITERA_GGROUP( it_At_DiaSemana,
               ( *it_At_Sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
            {
               // Dia da semana do atendimento
               dia_semana = it_At_DiaSemana->getDiaSemana();

               // Modelo Tático
               if ( it_At_DiaSemana->atendimentos_tatico != NULL
                  && it_At_DiaSemana->atendimentos_tatico->size() > 0 )
               {
                  ITERA_GGROUP( it_at_tatico,
                     ( *it_At_DiaSemana->atendimentos_tatico ), AtendimentoTatico )
                  {
                     AtendimentoTatico * at_tatico = ( *it_at_tatico );

                     atendimentosOferta.add( at_tatico->atendimento_oferta );
                  }
               }
               // Modelo Operacional
               else if ( it_At_DiaSemana->atendimentos_turno != NULL
                  && it_At_DiaSemana->atendimentos_turno->size() > 0 )
               {
                  ITERA_GGROUP( it_at_turno,
                     ( *it_At_DiaSemana->atendimentos_turno ), AtendimentoTurno )
                  {
                     AtendimentoTurno * at_turno = ( *it_at_turno );

                     ITERA_GGROUP( it_horario_aula,
                        ( *at_turno->atendimentos_horarios_aula ), AtendimentoHorarioAula )
                     {
                        AtendimentoHorarioAula * horario_aula = ( *it_horario_aula );

                        ITERA_GGROUP( it_oferta,
                           ( *it_horario_aula->atendimentos_ofertas ), AtendimentoOferta )
                        {
                           AtendimentoOferta * oferta = ( *it_oferta );

                           atendimentosOferta.add( oferta );
                        }
                     }
                  }
               }
            }
         }
      }
   }
   // Fim da leitura dos atendimentos oferta

   // Armazenando a informação de quantos alunos
   // de cada demanda foram atendidos pela solução
   std::map< Demanda *, int > quantidadeAlunosAtendidosDemanda;

   ITERA_GGROUP( it_at_oferta, atendimentosOferta, AtendimentoOferta )
   {
      AtendimentoOferta * at_oferta = ( *it_at_oferta );

      int id_oferta = atoi( at_oferta->getOfertaCursoCampiId().c_str() );
      int id_disciplina = at_oferta->getDisciplinaId();

      Demanda * demanda = this->problemData->buscaDemanda( id_oferta, id_disciplina );

      quantidadeAlunosAtendidosDemanda[ demanda ] += at_oferta->getQuantidade();
   }

   // Preenchendo alunosDemanda com cada demanda atendida de cada aluno
   if ( problemData->parametros->otimizarPor == "ALUNO" )
   {
	   ITERA_GGROUP_LESSPTR( it_alunosDemanda, problemData->alunosDemanda, AlunoDemanda )
	   {
		   AlunoDemanda * aluno_demanda = ( *it_alunosDemanda );

		   Disciplina * disc = aluno_demanda->demanda->disciplina;
		   int alunoId = aluno_demanda->getAlunoId();

		   Aluno* a = problemData->retornaAluno( alunoId );

		   GGroup< Trio<int, int, Disciplina*> > campusTurmaDiscAluno = problemData->mapAluno_CampusTurmaDisc[a];
		   for ( GGroup< Trio<int, int, Disciplina*> >::iterator it_at_aluno = campusTurmaDiscAluno.begin();
				 it_at_aluno != campusTurmaDiscAluno.end(); it_at_aluno++ )
		   {
			   if ( (*it_at_aluno).third == disc )
			   {
					this->problemSolution->alunosDemanda->add( aluno_demanda );
			   }
		   }
	   }
   }

   // Preenchendo alunosDemanda de acordo com o numero de demandas atendidas
   // (Escolhe os alunos que foram atendidos 'aleatoriamente' )
   else if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
   {
	   // De acordo com o total de alunos de cada demanda que foram atendidos,
	   // adicionamos os alunos na lista de atendidos da solução
	   std::map< Demanda *, int >::iterator it_alunos_atendidos =
		  quantidadeAlunosAtendidosDemanda.begin();

	   for (; it_alunos_atendidos != quantidadeAlunosAtendidosDemanda.end();
			  it_alunos_atendidos++ )
	   {
		  Demanda * demanda = it_alunos_atendidos->first;
		  int alunos_atendidos = it_alunos_atendidos->second;

		  GGroup< AlunoDemanda *, LessPtr< AlunoDemanda > > alunosDemanda =
			 this->problemData->mapDemandaAlunos[ demanda ];

		  int cont = 0;

		  ITERA_GGROUP_LESSPTR( it_atendidos, alunosDemanda, AlunoDemanda )
		  {
			 // Mais um aluno dessa demanda foi atendido
			 cont++;

			 AlunoDemanda * aluno_demanda = ( *it_atendidos );
			 this->problemSolution->alunosDemanda->add( aluno_demanda );

			 if ( cont == alunos_atendidos )
			 {
				break;
			 }
		  }
	   }
   }
}

void SolverMIP::preencheOutputOperacionalMIP( ProblemSolution * solution )
{
   Campus * campus = NULL;
   Unidade * unidade = NULL;
   Sala * sala = NULL;
   int dia_semana = 0;

   ITERA_GGROUP( it_At_Campus,
      ( *problemSolution->atendimento_campus ), AtendimentoCampus )
   {
      // Campus do atendimento
      campus = it_At_Campus->campus;

      ITERA_GGROUP( it_At_Unidade,
         ( *it_At_Campus->atendimentos_unidades ), AtendimentoUnidade )
      {
         // Unidade do atendimento
         unidade = problemData->refUnidade[ it_At_Unidade->getId() ];

         ITERA_GGROUP( it_At_Sala,
            ( *it_At_Unidade->atendimentos_salas ), AtendimentoSala )
         {
            // Sala do atendimento
            sala = problemData->refSala[ it_At_Sala->getId() ];

            ITERA_GGROUP( it_At_DiaSemana,
               ( *it_At_Sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
            {
               // Dia da semana do atendimento
               dia_semana = it_At_DiaSemana->getDiaSemana();

               it_At_DiaSemana->atendimentos_turno = new GGroup< AtendimentoTurno * >();

               for ( int i = 0; i < (int)solVarsOp.size(); i++ )
               {
                  VariableOp * v = solVarsOp[ i ];

                  if ( v->getType() != VariableOp::V_X_PROF_AULA_HOR )
                  {
                     continue;
                  }

                  if ( v->getAula()->getSala() != sala )
                  {
                     continue;
                  }

                  if ( v->getAula()->getDiaSemana() != dia_semana )
                  {
                     continue;
                  }

                  Aula * aula = v->getAula();

                  // Procura o turno da aula
                  Oferta * temp = ( *( aula->ofertas.begin() ) );
                  int turno = temp->getTurnoId();

                  AtendimentoTurno * atendimento_turno = NULL;
                  ITERA_GGROUP( it, ( *it_At_DiaSemana->atendimentos_turno ), AtendimentoTurno )
                  {
                     if ( it->getTurnoId() == turno )
                     {
                        atendimento_turno = ( *it );
                        break;
                     }
                  }

                  if ( atendimento_turno == NULL )
                  {
                     atendimento_turno = new AtendimentoTurno(
                        this->problemSolution->getIdAtendimentos() );

                     atendimento_turno->setId( turno );
                     atendimento_turno->setTurnoId( turno );
                     atendimento_turno->turno = temp->turno;

                     it_At_DiaSemana->atendimentos_turno->add( atendimento_turno );
                  }
				  
				  HorarioAula * h = v->getHorarioAula();
				  Calendario * c = v->getDisciplina()->getCalendario();
				  int nCreds = 1;

				  while ( h!=NULL && nCreds <= aula->getTotalCreditos() )
				  {
                     AtendimentoHorarioAula * atendimento_horario_aula = new AtendimentoHorarioAula(
                        this->problemSolution->getIdAtendimentos() );
					                      
					 Professor * professor = v->getProfessor();

                     atendimento_horario_aula->setId( h->getId() );
                     atendimento_horario_aula->setHorarioAulaId( h->getId() );
                     atendimento_horario_aula->setProfessorId( professor->getId() );
                     atendimento_horario_aula->setProfVirtual( professor->eVirtual() );
                     atendimento_horario_aula->setCreditoTeorico( aula->getCreditosTeoricos() > 0 );
                     atendimento_horario_aula->horario_aula = h;
                     atendimento_horario_aula->professor = professor;

                     GGroup< Oferta *, LessPtr< Oferta > >::iterator 
                        it_oferta = aula->ofertas.begin();

                     for (; it_oferta != aula->ofertas.end(); ++it_oferta )
                     {
                        Oferta * oferta = ( *it_oferta );
                        AtendimentoOferta * atendimento_oferta = new AtendimentoOferta(
                           this->problemSolution->getIdAtendimentos() );

 						std::pair< Curso *, Curriculo * > parCursoCurr = std::make_pair( oferta->curso, oferta->curriculo );
						Disciplina *discOriginal = problemData->ehSubstitutaDe( aula->getDisciplina(), parCursoCurr );
						if ( discOriginal != NULL )
						{
							atendimento_oferta->setDisciplinaSubstitutaId( aula->getDisciplina()->getId() );
							atendimento_oferta->setDisciplinaId( discOriginal->getId() );
							atendimento_oferta->disciplina = discOriginal;
						}
						else
						{
							atendimento_oferta->setDisciplinaId( aula->getDisciplina()->getId() );
							atendimento_oferta->disciplina = aula->getDisciplina();
						}
						
                        atendimento_oferta->setId( oferta->getId() );
                        atendimento_oferta->setTurma( aula->getTurma() );
                        atendimento_oferta->setQuantidade( aula->getQuantidadePorOft(oferta) );

						// ----- alunosDemandasAtendidas -----
						Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
						trio.set( campus->getId(), aula->getTurma(), aula->getDisciplina() );

						GGroup<AlunoDemanda*, LessPtr< AlunoDemanda >> alunosDemanda =
							problemData->mapCampusTurmaDisc_AlunosDemanda[ trio ];

						ITERA_GGROUP_LESSPTR( itAlunoDemanda, alunosDemanda, AlunoDemanda )
						{
							if ( itAlunoDemanda->demanda->oferta != oferta )
								continue;

							if ( itAlunoDemanda->demanda->getDisciplinaId() < 0 )
							{
								int alunoId = itAlunoDemanda->getAlunoId();
								int discId = - itAlunoDemanda->demanda->getDisciplinaId();
								Aluno* aluno = problemData->retornaAluno( alunoId );

								// Disciplina pratica que teve seu AlunoDemanda criado internamente, pelo solver.
								// Deve-se passar o AlunoDemanda original, que corresponde ao da disciplina teorica.
								AlunoDemanda* alunoDemanda = aluno->getAlunoDemanda( discId );
								if ( alunoDemanda != NULL )
								{
									atendimento_oferta->alunosDemandasAtendidas.add( alunoDemanda->getId() );
								}
							}
							else
							{
								atendimento_oferta->alunosDemandasAtendidas.add( itAlunoDemanda->getId() );
							}
						}
						// -----
						
						stringstream str;
                        str << oferta->getId();
                        atendimento_oferta->setOfertaCursoCampiId( str.str() );
                        atendimento_oferta->oferta = oferta;

                        atendimento_horario_aula->atendimentos_ofertas->add( atendimento_oferta );                        
                     }

                     atendimento_turno->atendimentos_horarios_aula->add( atendimento_horario_aula );

					 // itera
					 h = c->getProximoHorario( h );
					 nCreds++;
                  }
               }
            }
         }
      }
   }
}

void SolverMIP::preencheOutputOperacional( ProblemSolution * solution )
{
   /*
   Campus * campus = NULL;
   Unidade * unidade = NULL;
   Sala * sala = NULL;
   int dia_semana = 0;

   int total_horarios = solution->solucao_operacional->getTotalHorarios();
   MatrizSolucao * matriz_aulas = solution->solucao_operacional->getMatrizAulas();

   ITERA_GGROUP( it_At_Campus, ( *problemSolution->atendimento_campus ), AtendimentoCampus )
   {
      // Campus do atendimento
      campus = it_At_Campus->campus;

      ITERA_GGROUP( it_At_Unidade, ( *it_At_Campus->atendimentos_unidades ), AtendimentoUnidade )
      {
         // Unidade do atendimento
         unidade = problemData->refUnidade[ it_At_Unidade->getId() ];

         ITERA_GGROUP( it_At_Sala, ( *it_At_Unidade->atendimentos_salas ), AtendimentoSala )
         {
            // Sala do atendimento
            sala = problemData->refSala[ it_At_Sala->getId() ];

            ITERA_GGROUP( it_At_DiaSemana, ( *it_At_Sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
            {
               // Dia da semana do atendimento
               dia_semana = it_At_DiaSemana->getDiaSemana();

               it_At_DiaSemana->atendimentos_turno = new GGroup< AtendimentoTurno * >();

               std::vector< std::vector< Aula * > * >::iterator
                  it_matriz_aulas = matriz_aulas->begin();

               for (; it_matriz_aulas != matriz_aulas->end(); it_matriz_aulas++ )
               {
                  int linha_professor = std::distance( matriz_aulas->begin(), it_matriz_aulas );

                  std::vector< Aula * > * aulas = ( *it_matriz_aulas );
                  std::vector< Aula * >::iterator it_aula = aulas->begin();

                  for (; it_aula != aulas->end(); it_aula++ )
                  {
                     Aula * aula = ( *it_aula );
                     if ( aula == NULL || aula->eVirtual() == true )
                     {
                        continue;
                     }

                     // Verifica se a aula está alocada na sala e dia da semana atuais
                     if ( !aulaAlocada( aula, campus, unidade, sala, dia_semana ) )
                     {
                        continue;
                     }

                     int horario_aula_id = ( std::distance( aulas->begin(), it_aula ) % total_horarios );

                     // Procura o turno da aula
                     Oferta * temp = ( *( aula->ofertas.begin() ) );
                     int turno = temp->getTurnoId();

                     //-------------------------------------------------------------------------------------
                     AtendimentoTurno * atendimento_turno = NULL;
                     ITERA_GGROUP( it, ( *it_At_DiaSemana->atendimentos_turno ), AtendimentoTurno )
                     {
                        if ( it->getTurnoId() == turno )
                        {
                           atendimento_turno = ( *it );
                           break;
                        }
                     }

                     if ( atendimento_turno == NULL )
                     {
                        atendimento_turno = new AtendimentoTurno();

                        atendimento_turno->setId( turno );
                        atendimento_turno->setTurnoId( turno );
                        atendimento_turno->turno = temp->turno;

                        it_At_DiaSemana->atendimentos_turno->add( atendimento_turno );
                     }
                     //-------------------------------------------------------------------------------------

                     //-------------------------------------------------------------------------------------
                     AtendimentoHorarioAula * atendimento_horario_aula = new AtendimentoHorarioAula();

                     HorarioAula * horario_aula = problemData->horarios_aula_ordenados[ horario_aula_id ];
                     Professor * professor = solution->solucao_operacional->getProfessorMatriz( linha_professor );

                     atendimento_horario_aula->setId( horario_aula->getId() );
                     atendimento_horario_aula->setHorarioAulaId( horario_aula->getId() );
                     atendimento_horario_aula->setProfessorId( professor->getId() );
                     atendimento_horario_aula->setProfVirtual( professor->eVirtual() );
                     atendimento_horario_aula->setCreditoTeorico( aula->getCreditosTeoricos() > 0 );
                     atendimento_horario_aula->horario_aula = horario_aula;
                     atendimento_horario_aula->professor = professor;

                     GGroup< Oferta *, LessPtr< Oferta > >::iterator 
                        it_oferta = aula->ofertas.begin();

                     for (; it_oferta != aula->ofertas.end(); ++it_oferta )
                     {
                        Oferta * oferta = ( *it_oferta );
                        AtendimentoOferta * atendimento_oferta = new AtendimentoOferta();

                        atendimento_oferta->setId( oferta->getId() );
                        atendimento_oferta->disciplina = aula->getDisciplina();
                        atendimento_oferta->setDisciplinaId( aula->getDisciplina()->getId() );
                        atendimento_oferta->setTurma( aula->getTurma() );
                        atendimento_oferta->setQuantidade( aula->getQuantidade() );

                        char id_oferta_char[ 200 ];
                        sprintf( id_oferta_char, "%d", oferta->getId() );
                        std::string id_oferta_str = std::string( id_oferta_char );
                        atendimento_oferta->setOfertaCursoCampiId( id_oferta_str );
                        atendimento_oferta->oferta = oferta;

                        atendimento_horario_aula->atendimentos_ofertas->add( atendimento_oferta );                        
                     }

                     atendimento_turno->atendimentos_horarios_aula->add( atendimento_horario_aula );
                     //-------------------------------------------------------------------------------------
                  }
               }
            }
         }
      }
   }
   */
}

bool SolverMIP::aulaAlocada( Aula * aula, Campus * campus,
   Unidade * unidade, Sala * sala, int dia_semana ) 
{
   if ( aula == NULL || aula->eVirtual() )
   {
      return false;
   }

   bool aula_alocada = true;

   int id_unidade_aula = aula->getSala()->getIdUnidade();
   int id_campus_aula = problemData->refUnidade[ id_unidade_aula ]->getIdCampus();
   int id_sala_aula = aula->getSala()->getId();
   int dia_semana_aula = aula->getDiaSemana();

   if ( id_campus_aula != campus->getId() || id_unidade_aula != unidade->getId()
      || id_sala_aula != sala->getId() || dia_semana_aula != dia_semana )
   {
      aula_alocada = false;
   }

   return aula_alocada;
}

void SolverMIP::separaDisciplinasEquivalentes()
{
   // Primeiramente, devo criar as variáveis de alocação de alunos ( variáveis 'a' )
   // para as disciplinas que foram substituídas. A alocação é feita utilizando o total
   // de alunos que foram alocados para a disciplina que as substituiu
   criaVariaveisAlunosDisciplinasSubstituidas();

   // Após criadas as variáveis de alocação de alunos, então devo criar
   // as variáveis de créditos ( variáveis 'x' )para as disciplinas substituídas
   criaVariaveisCreditosDisciplinasSubstituidas();
}

void SolverMIP::criaVariaveisAlunosDisciplinasSubstituidas()
{
   Curso * curso = NULL;
   Curriculo * curriculo = NULL;
   Disciplina * disciplina_substituta = NULL;
   Disciplina * disciplina_equivalente = NULL;

   std::map< std::pair< Curso *, Curriculo * >,
             std::map< Disciplina *, GGroup< Disciplina *, LessPtr< Disciplina > >, LessPtr< Disciplina > > >::iterator
             it_disc_substituidas = problemData->mapGroupDisciplinasSubstituidas.begin();

   // Procura criar variáveis 'a' para as disciplinas que foram substituídas
   for (; it_disc_substituidas != problemData->mapGroupDisciplinasSubstituidas.end();
          it_disc_substituidas++ )
   {
      curso = it_disc_substituidas->first.first;
      curriculo = it_disc_substituidas->first.second;

		// Cria variáveis para cada uma das disciplinas substituídas
      std::map< Disciplina *, GGroup< Disciplina *, LessPtr< Disciplina > >, LessPtr< Disciplina > >::iterator
         it_conjunto_disc = it_disc_substituidas->second.begin();

      for (; it_conjunto_disc != it_disc_substituidas->second.end();
             it_conjunto_disc++ )
      {
         // Disciplina para a qual as variáveis foram criadas
         disciplina_substituta = ( it_conjunto_disc->first );

         // Variáveis criadas para 'disciplina_substituta' em cursos compatíveis
         // com os cursos das disciplinas que foram substituídas por ela
         std::vector< Variable * > variaveis_alunos
            = variaveisAlunosAtendidos( curso, disciplina_substituta );

         // Total de alunos que foram atendidos
         int alunos_atendidos = 0;

         for ( int i = 0; i < (int)variaveis_alunos.size(); i++ )
         {
            Variable * v = variaveis_alunos[i];

            alunos_atendidos += (int)( v->getValue() );
         }

         // Primeiramente, devo atender toda a demanda da disciplina
         // 'disciplina_substituta', e em seguida alocar a demanda de
         // alunos das suas disciplinas equivalentes, enquanto for possível
         Demanda * demanda_substituta
            = problemData->buscaDemanda( curso, disciplina_substituta );

         // Demanda da disciplina que substituiu as demais
         int alunos_disciplina_substituta = demanda_substituta->getQuantidade();

         Variable * v_disc_substituta = NULL;
         if ( alunos_disciplina_substituta <= alunos_atendidos )
         {
            // Atende a disciplina 'disciplina_substituta'
            ITERA_VECTOR( it_v_substituta, variaveis_alunos, Variable )
            {
               v_disc_substituta = ( *it_v_substituta );

               // Atende ESPECIFICAMENTE à disciplina 'disciplina_substituta'
               if ( v_disc_substituta->getOferta()->curso == curso
                  && v_disc_substituta->getOferta()->curriculo == curriculo )
               {
                  if ( v_disc_substituta->getValue() <= alunos_disciplina_substituta )
                  {
                     alunos_atendidos -= (int)( v_disc_substituta->getValue() );
                     alunos_disciplina_substituta -= (int)( v_disc_substituta->getValue() );
                  }
                  else
                  {
                     v_disc_substituta->setValue( alunos_disciplina_substituta );
                     alunos_atendidos -= alunos_disciplina_substituta;
                     break;
                  }
               }

               // Já atendi à demanda de disciplina 'disciplina_substituta'
               if ( alunos_disciplina_substituta <= 0 )
               {
                  alunos_disciplina_substituta = 0;
                  break;
               }
            }
         }
         else
         {
            // Assim, temos que só a disciplina 'disciplina_substituta' será
            // atendida, não sendo criada nenhuma nova variável para as suas
            // disciplinas equivalentes, pois as mesmas não foram atendidas
            continue;
         }

         // Enquanto for possível, criamos variáveis referentes ao atendimento da demanda
         // das disciplinas substituídas. OBS.: Partimos do princípio qu\e a escolha de qual
         // disciplina deve ser atendida prioritariamente é INDIFERENTE para a solução
         ITERA_GGROUP_LESSPTR( it_disc_equi, it_conjunto_disc->second, Disciplina )
         {
            // Não pode atender mais disciplinas
            if ( alunos_atendidos == 0 )
            {
               break;
            }

            disciplina_equivalente = ( *it_disc_equi );

            // Variáveis criadas para 'disciplina_equivalente'
            std::vector< Variable > variaveis_alunos_equivalente
               = filtraVariaveisAlunos( mapVariaveisDisciplinasEquivalentes[ disciplina_equivalente ] );

            // Alunos atendidos da disciplina
            std::vector< Variable >::iterator it_variable
               = variaveis_alunos_equivalente.begin();
            for (; it_variable != variaveis_alunos_equivalente.end(); it_variable++ )
            {
               // 'v_temp' representa a variável do modelo que estava
               // associada à disciplina 'disciplina_substituta', mas que
               // na verdade foi criada para representar a disciplina 'disciplina_equivalente'
               Variable v_temp = ( *it_variable );

               // Criando uma nova  variável 'a' (alunos)
               Campus * campus_alunos = v_temp.getCampus();
               Unidade * unidade_alunos = v_temp.getUnidade();
               ConjuntoSala * cjtSala_alunos = v_temp.getSubCjtSala();
               Sala * sala_alunos = v_temp.getSala();
               int dia_alunos = v_temp.getDia();
               Oferta * oferta_alunos = v_temp.getOferta();
               Curso * curso_alunos = v_temp.getCurso();
               Disciplina * disc_alunos = v_temp.getDisciplina();
				   int turma_alunos = v_temp.getTurma();

               Variable * v = criaVariavelAlunos( campus_alunos, unidade_alunos, cjtSala_alunos, sala_alunos,
                                                  dia_alunos, oferta_alunos, curso_alunos, disc_alunos, turma_alunos );

               v->setValue( v_temp.getValue() );

					std::pair< int, Disciplina * > turma_disciplina
                  = std::make_pair( v->getTurma(), v->getDisciplina() );

					// Adiciono uma variável 'a' a mais para o getSolutionTatico()
               vars_a[ turma_disciplina ].push_back( v );

               alunos_atendidos -= (int)( v_temp.getValue() );

               // Remove a variável anterior da lista de variáveis
               // a serem utilizadas no método getSolutionTatico()
               for ( int i = 0; i < (int)( vars_a[ turma_disciplina ].size() ); i++ )                  
               {
                  if ( ( *vars_a[ turma_disciplina ][i] ) == v_temp )
                  {
                     vars_a[ turma_disciplina ].erase( vars_a[ turma_disciplina ].begin() + i );
                     break;
                  }
               }
            }

            // Diz que a disciplina equivalente foi atendida, ou seja,
            // posso posteriormente criar variável de créditos para essa disciplina
            problemData->disciplinasSubstituidasAtendidas[ disciplina_equivalente ] = true;
         }
      }
   }
}

void SolverMIP::criaVariaveisCreditosDisciplinasSubstituidas()
{
   Curso * curso = NULL;
   Curriculo * curriculo = NULL;
   Disciplina * disciplina_substituta = NULL;
   Disciplina * disciplina_equivalente = NULL;

   std::map< std::pair< Curso *, Curriculo * >,
             std::map< Disciplina *, GGroup< Disciplina *, LessPtr< Disciplina > >, LessPtr< Disciplina > > >::iterator
             it_disc_substituidas = problemData->mapGroupDisciplinasSubstituidas.begin();

	// Procura criar variáveis 'x' para as disciplinas que foram substituídas
   for (; it_disc_substituidas != problemData->mapGroupDisciplinasSubstituidas.end();
          it_disc_substituidas++ )
   {
      curso = it_disc_substituidas->first.first;
      curriculo = it_disc_substituidas->first.second;

		// Cria variáveis para cada uma das disciplinas substituídas
      std::map< Disciplina *, GGroup< Disciplina *, LessPtr< Disciplina > >, LessPtr< Disciplina > >::iterator
         it_conjunto_disc = it_disc_substituidas->second.begin();

      for (; it_conjunto_disc != it_disc_substituidas->second.end();
             it_conjunto_disc++ )
      {
         disciplina_substituta = ( it_conjunto_disc->first );

		 // Busca pelas ofertas da disciplina 'disciplina_substituta'
		 // GGroup< Oferta *, LessPtr< Oferta > > ofertas_disc
		 // 	= problemData->ofertasDisc[ disciplina_substituta->getId() ];

		 // Procura pelas variáveis créditos que foram
		 // criadas para atender a 'disciplina_substituta'
         std::vector< Variable * > variaveis_creditos
            = variaveisCreditosAtendidos( disciplina_substituta );

         // Enquanto for possível, criamos variáveis referentes
         // ao atendimento da demanda das disciplinas substituídas.
         // OBS.: Partimos do princípio que a escolha de qual disciplina
         // deve ser atendida prioritariamente é INDIFERENTE para a solução
         ITERA_GGROUP_LESSPTR( it_disc_equi, it_conjunto_disc->second, Disciplina )
         {
            disciplina_equivalente = ( *it_disc_equi );

            // Verifica se a disciplina equivalente
				// teve pelo menos um aluno atendido na solução
            bool disciplina_atendida = false;

			std::map< Disciplina *, bool, LessPtr< Disciplina > >::iterator it_find_disciplina
            = problemData->disciplinasSubstituidasAtendidas.find( disciplina_equivalente );

			if ( it_find_disciplina != problemData->disciplinasSubstituidasAtendidas.end() )
			{
				disciplina_atendida = it_find_disciplina->second;
			}

            if ( disciplina_atendida )
            {
			   // Procura pelas variáveis créditos que foram
			   // criadas para atender a 'disciplina_substituta'
               std::vector< Variable > variaveis_creditos_equivalente
                  = filtraVariaveisCreditos( mapVariaveisDisciplinasEquivalentes[ disciplina_equivalente ] );

               std::vector< Variable >::iterator it_variable
                  = variaveis_creditos_equivalente.begin();
               for (; it_variable != variaveis_creditos_equivalente.end(); it_variable++ )
               {
                  // 'v_temp' representa a variável do modelo que estava
                  // associada à disciplina 'disciplina_substituta', mas que
                  // na verdade foi criada para representar a disciplina 'disciplina_equivalente'
                  Variable v_temp = ( *it_variable );

                  // Criando uma nova variável 'x' (créditos) para a disciplina equivalente
                  Campus * campus_creditos = v_temp.getCampus();
                  Unidade * unidade_creditos = v_temp.getUnidade();
                  ConjuntoSala * cjtSala_creditos = v_temp.getSubCjtSala();
                  Sala * sala_creditos = v_temp.getSala();
                  int dia_creditos = v_temp.getDia();
                  Oferta * oferta_creditos = v_temp.getOferta();
                  Curso * curso_creditos = v_temp.getCurso();
					   Disciplina * disc_creditos = v_temp.getDisciplina();
                  int turma_creditos = v_temp.getTurma();
                  BlocoCurricular * bloco_curricular = v_temp.getBloco();

                  Variable * v = criaVariavelCreditos( campus_creditos, unidade_creditos, cjtSala_creditos,
                                                       sala_creditos, dia_creditos, oferta_creditos, curso_creditos,
                                                       disc_creditos, turma_creditos, bloco_curricular );

                  v->setValue( v_temp.getValue() );
                  vars_x.push_back( v );

                  // Remove a variável anterior da lista de variáveis
                  // a serem utilizadas no método getSolutionTatico()
                  for ( int i = 0; i < (int)( vars_x.size() ); i++ )                  
                  {
                     if ( ( *vars_x[i] ) == v_temp )
                     {
                        vars_x.erase( vars_x.begin() + i );
                        break;
                     }
                  }
               }
            }
         }
      }
   }
}

std::vector< Variable > SolverMIP::filtraVariaveisAlunos(
   std::vector< Variable > variables )
{
   std::vector< Variable > result;

   std::vector< Variable >::iterator
      it_variable = variables.begin();

   for (; it_variable != variables.end(); it_variable++ )
   {
      Variable v = ( *it_variable );

      if ( v.getType() == Variable::V_ALUNOS )
      {
         result.push_back( v );
      }
   }

   return result;
}

std::vector< Variable > SolverMIP::filtraVariaveisCreditos(
   std::vector< Variable > variables )
{
   std::vector< Variable > result;
   
   std::vector< Variable >::iterator
      it_variable = variables.begin();

   for (; it_variable != variables.end(); it_variable++ )
   {
      Variable v = ( *it_variable );

      if ( v.getType() == Variable::V_CREDITOS
            || v.getType() == Variable::V_CREDITOS_MODF )
      {
         result.push_back( v );
      }
   }

   return result;
}

// Retorna as variáveis de alunos referentes à essa disciplina,
// em qualquer dos cursos que sejam compatíveis com o curso dessa da disciplina
std::vector< Variable * > SolverMIP::variaveisAlunosAtendidos(
   Curso * curso, Disciplina * disciplina )
{
   std::vector< Variable * > variaveis;

   vars__A___i_d_o::iterator it_a = vars_a.begin();

   for (; it_a != vars_a.end(); it_a++ )
   {
      std::vector< Variable * >::iterator it_variable = it_a->second.begin();

      for (; it_variable != it_a->second.end(); it_variable++ )
      {
         Variable * v = ( *it_variable );

         if ( abs( v->getDisciplina()->getId() ) == abs( disciplina->getId() )
            && problemData->cursosCompativeis( v->getOferta()->curso, curso ) )
         {
            variaveis.push_back( v );
         }
      }
   }

   return variaveis;
}

// Retorna as variáveis de alunos referentes à essa disciplina
std::vector< Variable * > SolverMIP::variaveisCreditosAtendidos( Disciplina * disciplina )
{
   std::vector< Variable * > variaveis;

   for ( int i = 0; i < (int)vars_x.size(); i++ )
   {
      Variable * v = vars_x[ i ];

      if ( abs( v->getDisciplina()->getId() ) == abs( disciplina->getId() ) )
      {
         variaveis.push_back( v );
      }
   }

   return variaveis;
}

Variable * SolverMIP::criaVariavelAlunos(
   Campus * campus, Unidade * unidade, ConjuntoSala * cjtSala,
   Sala * sala, int dia_semana, Oferta * oferta, Curso * curso,
   Disciplina * disciplina, int turma )
{
   Variable * v = new Variable();

   v->reset();
   v->setType( Variable::V_ALUNOS );
   v->setCampus( campus );
   v->setUnidade( unidade );
   v->setSubCjtSala( cjtSala );
   v->setSala( sala );
   v->setDia( dia_semana );
   v->setOferta( oferta );
   v->setCurso( curso );
   v->setDisciplina( disciplina );
   v->setTurma( turma );

   return v;
}

Variable * SolverMIP::criaVariavelCreditos(
   Campus * campus, Unidade * unidade, ConjuntoSala * cjtSala,
   Sala * sala, int dia_semana, Oferta * oferta, Curso * curso,
   Disciplina * disciplina, int turma, BlocoCurricular * bloco_curricular )
{
   Variable * v = new Variable();

   v->reset();
   v->setType( Variable::V_CREDITOS_MODF );
   v->setCampus( campus );
   v->setUnidade( unidade );
   v->setSubCjtSala( cjtSala );
   v->setSala( sala );
   v->setDia( dia_semana );
   v->setOferta( oferta );
   v->setCurso( curso );
   v->setDisciplina( disciplina );
   v->setTurma( turma );
   v->setBloco( bloco_curricular );

   return v;
}

int SolverMIP::localBranching( double * xSol, double maxTime )
{
   // Adiciona restrição de local branching
   int status = 0;
   int nIter = 0;
   int * idxSol = new int[ lp->getNumCols() ];

   for ( int i = 0; i < lp->getNumCols(); i++ )
   {
      idxSol[ i ] = i;
   }

   double objAtual = 100000000000.0;
   double okIter = true;

   int k = -10;

   /*FILE * fin = fopen( "solLBAtual.bin", "rb" );
   if ( fin == NULL )
   {
      std::cout << "\nErro em SolverMIP::solveTaticoBasicoCjtAlunos( int campusId, int prioridade, int cjtAlunosId ):"
         << "\nArquivo " << "solLBAtual.bin" << " nao pode ser aberto.\n";
   }
   else
   {
      int nCols = 0;

      fread( &nCols, sizeof( int ), 1, fin );

      for ( int i = 0; i < nCols; i++ )
      {
         double auxR;
         fread( &auxR, sizeof( double ), 1, fin );

         xSol[ i ] = auxR;
      }

      fclose( fin );
   }*/

   int tempoIter = 300;
   k = -50;

   while (okIter)
   {
      VariableHash::iterator vit = vHash.begin();

      OPT_ROW nR( 50, OPT_ROW::GREATER, 0.0, "LOCBRANCH" );
      double rhsLB = k;

      while ( vit != vHash.end() )
      {
         if ( vit->first.getType() == Variable::V_OFERECIMENTO )
         {
            if ( xSol[vit->second] > 0.1 )
            {
               rhsLB += 1.0;
               nR.insert( vit->second,1.0 );
            }
            else
            {
               nR.insert( vit->second, -1.0 );
            }
         }

         vit++;
      }

      nR.setRhs( rhsLB );

      lp->addRow( nR );
      lp->updateLP();
      lp->setNodeLimit( 100000000 );
      lp->setTimeLimit( tempoIter );
      //lp->setMIPRelTol( 0.02 );
      lp->setNodeLimit( 100000000 );
      lp->setPolishAfterNode(1);
      lp->setPolishAfterTime(100000000);
      lp->setMIPEmphasis( 4 );
      lp->setCuts(4);
      //lp->setNoCuts();
      lp->setVarSel(4);
      lp->setHeurFrequency( 1.0 );
      lp->copyMIPStartSol( lp->getNumCols(), idxSol, xSol );

      status = lp->optimize( METHOD_MIP );

      double objN = lp->getObjVal();

      if ( fabs(objAtual-objN) < 100.0  )
      {
         lp->setNodeLimit(10000000);
         lp->setPolishAfterNode(1);
         lp->setTimeLimit( tempoIter );
         status = lp->optimize( METHOD_MIP );

         if ( k == -100 )
            k = -50;

         if ( k == -150 )
            k = -100;
      }

      lp->getX( xSol );

      FILE * fout = fopen( "solLBAtual.bin", "wb" );
		if ( fout == NULL )
		{
			std::cout << "\nErro em SolverMIP::solveTaticoBasicoCjtAlunos( int campusId, int prioridade, int cjtAlunosId ):"
					<< "\nArquivo " << "solLBAtual.bin" << " nao pode ser aberto.\n";
		}
		else
		{
			int nCols = lp->getNumCols();

			fwrite( &nCols, sizeof( int ), 1, fout );
			for ( int i = 0; i < lp->getNumCols(); i++ )
			{
				fwrite( &( xSol[ i ] ), sizeof( double ), 1, fout );
			}

			fclose( fout );
		}

      if ( fabs(objN-objAtual) < 0.0001 && k >= -10 )
      {
         okIter = false;
      }
      else if (fabs(objN-objAtual) < 0.0001 && k < -10 )
      {
         k += 10;
         tempoIter += 300;
      }

      objAtual = objN;

      int * idxs = new int[ 1 ];
      idxs[ 0 ] = lp->getNumRows() - 1;
      lp->delSetRows( 1, idxs );
      lp->updateLP();
      delete [] idxs;
   }

   delete [] idxSol;

   return status;
}

int SolverMIP::localBranchingHor( double * xSol, double maxTime )
{
   // Adiciona restrição de local branching
   int status = 0;
   int nIter = 0;
   int * idxSol = new int[ lp->getNumCols() ];

   for ( int i = 0; i < lp->getNumCols(); i++ )
   {
      idxSol[ i ] = i;
   }

   double objAtual = 100000000000.0;
   double okIter = true;

   int k = -10;

   FILE * fin = fopen( "solPolAtual.bin", "rb" );
   if ( fin == NULL )
   {
      std::cout << "\nErro em SolverMIP::solveTaticoBasicoCjtAlunos( int campusId, int prioridade, int cjtAlunosId ):"
         << "\nArquivo " << "solLBAtual.bin" << " nao pode ser aberto.\n";
   }
   else
   {
      int nCols = 0;

      fread( &nCols, sizeof( int ), 1, fin );

      for ( int i = 0; i < nCols; i++ )
      {
         double auxR;
         fread( &auxR, sizeof( double ), 1, fin );

         xSol[ i ] = auxR;
      }

      fclose( fin );
   }

   int tempoIter = 600;
   k = -3;

   while (okIter)
   {
      VariableTaticoHash::iterator vit = vHashTatico.begin();

      OPT_ROW nR( 50, OPT_ROW::GREATER, 0.0, "LOCBRANCH" );
      double rhsLB = k;

      while ( vit != vHashTatico.end() )
      {
         if ( vit->first.getType() == VariableTatico::V_ABERTURA )
         {
            if ( xSol[vit->second] > 0.1 )
            {
               rhsLB += 1.0;
               nR.insert( vit->second,1.0 );
            }
            else
            {
               nR.insert( vit->second, -1.0 );
            }
         }

         vit++;
      }

      nR.setRhs( rhsLB );

      lp->addRow( nR );
      lp->updateLP();
      lp->setNodeLimit( 100000000 );
      lp->setTimeLimit( tempoIter );
      //lp->setMIPRelTol( 0.02 );
      lp->setNodeLimit( 100000000 );
      lp->setPolishAfterNode(1);
      lp->setPolishAfterTime(100000000);
      lp->setMIPEmphasis( 4 );
      lp->setCuts(4);
      //lp->setNoCuts();
      lp->setVarSel(4);
      lp->setHeurFrequency( 1.0 );
      lp->copyMIPStartSol( lp->getNumCols(), idxSol, xSol );

      status = lp->optimize( METHOD_MIP );

      double objN = lp->getObjVal();

      if ( fabs(objAtual-objN) < 100.0  )
      {
         lp->setNodeLimit(10000000);
         lp->setPolishAfterNode(1);
         lp->setTimeLimit( tempoIter );
         status = lp->optimize( METHOD_MIP );

         if ( k == -100 )
            k = -50;

         if ( k == -150 )
            k = -100;
      }

      lp->getX( xSol );

      FILE * fout = fopen( "solLBAtual.bin", "wb" );
		if ( fout == NULL )
		{
			std::cout << "\nErro em SolverMIP::solveTaticoBasicoCjtAlunos( int campusId, int prioridade, int cjtAlunosId ):"
					<< "\nArquivo " << "solLBAtual.bin" << " nao pode ser aberto.\n";
		}
		else
		{
			int nCols = lp->getNumCols();

			fwrite( &nCols, sizeof( int ), 1, fout );
			for ( int i = 0; i < lp->getNumCols(); i++ )
			{
				fwrite( &( xSol[ i ] ), sizeof( double ), 1, fout );
			}

			fclose( fout );
		}

      if ( fabs(objN-objAtual) < 0.0001 && k >= -10 )
      {
         okIter = false;
      }
      else if (fabs(objN-objAtual) < 0.0001 && k < -10 )
      {
         k += 10;
         tempoIter += 300;
      }

      objAtual = objN;

      int * idxs = new int[ 1 ];
      idxs[ 0 ] = lp->getNumRows() - 1;
      lp->delSetRows( 1, idxs );
      lp->updateLP();
      delete [] idxs;
   }

   delete [] idxSol;

   return status;
}

void SolverMIP::polishTatico(double *xSol, double maxTime, int percIni, int percMin)
{
   // Adiciona restrição de local branching
   int status = 0;
   int nIter = 0;
   int * idxSol = new int[ lp->getNumCols() ];
   double *ubVars = new double[ lp->getNumCols() ];
   double *lbVars = new double[ lp->getNumCols() ];

   for ( int i = 0; i < lp->getNumCols(); i++ )
   {
      idxSol[ i ] = i;
   }

   double objAtual = 100000000000.0;
   double okIter = true;
   CPUTimer tempoPol;

   tempoPol.reset();
   tempoPol.start();

   srand(123);

   lp->getUB(0,lp->getNumCols()-1,ubVars);
   lp->getLB(0,lp->getNumCols()-1,lbVars);

   int tempoIter = 300;
   int perc = percIni;

   //bool primeiraIter = true;

   while (okIter)
   {
      VariableHash::iterator vit = vHash.begin();

      // Seleciona turmas e disciplinas para fixar
      std::set<std::pair<int,Disciplina*> > paraFixarUm;
      std::set<std::pair<int,Disciplina*> > paraFixarZero;

      while ( vit != vHash.end() )
      {
         if ( vit->first.getType() == Variable::V_ABERTURA )
         {
            if ( rand() % 100 >= perc  )
            {
               vit++;
               continue;
            }

            if (xSol[vit->second] > 0.1 )//|| primeiraIter )
            {
               lp->chgLB(vit->second,(int)(xSol[vit->second]+0.5));
               std::pair<int,Disciplina*> auxPair(vit->first.getTurma(),vit->first.getDisciplina());
               paraFixarUm.insert(auxPair);
            }
            else
            {
               lp->chgUB(vit->second,0.0);
               std::pair<int,Disciplina*> auxPair(vit->first.getTurma(),vit->first.getDisciplina());
               paraFixarZero.insert(auxPair);
            }
         }

         vit++;
      }

      //primeiraIter = false;

      vit = vHash.begin();

      while ( vit != vHash.end() )
      {
         if ( vit->first.getType() == Variable::V_CREDITOS )
         {
            /*if ( rand() % 100 >= perc  )
            {
               vit++;
               continue;
            }*/

            std::pair<int,Disciplina*> auxPair(vit->first.getTurma(),vit->first.getDisciplina());
            if ( paraFixarUm.find(auxPair) != paraFixarUm.end() )
            {
               if ( xSol[vit->second] > 0.1 )
               {
                  lp->chgLB(vit->second,(int)(xSol[vit->second]+0.5));
                  lp->chgUB(vit->second,(int)(xSol[vit->second]+0.5));
               }
               else
               {
                  lp->chgUB(vit->second,0.0);
               }
            }
            else if ( paraFixarZero.find(auxPair) != paraFixarZero.end() )
            {
               lp->chgUB(vit->second,0.0);
            }
         }

         vit++;
      }

      lp->updateLP();
      lp->setNodeLimit( 100000000 );
      lp->setTimeLimit( tempoIter );
      lp->setMIPRelTol( 0.01 );
      lp->setPolishAfterNode(1);
      lp->setPolishAfterTime(100000000);
      lp->setMIPEmphasis( 4 );
      lp->setCuts(0);
      if ( perc < percIni )
         lp->setCuts(1);
      //lp->setNoCuts();
      lp->setVarSel(4);
      lp->setHeurFrequency( 1.0 );
      lp->copyMIPStartSol( lp->getNumCols(), idxSol, xSol );

      status = lp->optimize( METHOD_MIP );

      double objN = lp->getObjVal();

      lp->getX( xSol );

      FILE * fout = fopen( "solLBAtual.bin", "wb" );
		if ( fout == NULL )
		{
			std::cout << "\nErro em SolverMIP::polishTatico():"
					<< "\nArquivo " << "solLBAtual.bin" << " nao pode ser aberto.\n";
		}
		else
		{
			int nCols = lp->getNumCols();

			fwrite( &nCols, sizeof( int ), 1, fout );
			for ( int i = 0; i < lp->getNumCols(); i++ )
			{
				fwrite( &( xSol[ i ] ), sizeof( double ), 1, fout );
			}

			fclose( fout );
		}

      if ( fabs(objN-objAtual) < 0.0001 && perc < percMin )
      {
         okIter = false;
         perc -= 5;
      }

      if ( fabs(objN-objAtual) < 0.0001 && perc >= percMin)
      {
         perc -= 5;
         lp->setCuts(1);
         tempoIter += 10;
      }

      objAtual = objN;

      tempoPol.stop();
      double tempoAtual = tempoPol.getCronoTotalSecs();
      tempoPol.start();
      if ( tempoAtual >= maxTime )
      {
         okIter = false;
         tempoPol.stop();
      }

      // Volta bounds
      vit = vHash.begin();

      while ( vit != vHash.end() )
      {
         if ( vit->first.getType() == Variable::V_CREDITOS || vit->first.getType() == Variable::V_ABERTURA )
         {
            lp->chgLB(vit->second,lbVars[vit->second]);
            lp->chgUB(vit->second,ubVars[vit->second]);
         }
         vit++;
      }

      lp->setPolishAfterNode(1);
      lp->setMIPRelTol( 0.0 );
   }

   delete [] idxSol;
   delete [] ubVars;
   delete [] lbVars;
}

void SolverMIP::polishTaticoHor(double *xSol, double maxTime, int percIni, int percMin)
{
   // Adiciona restrição de local branching
   int status = 0;
   int nIter = 0;
   int * idxSol = new int[ lp->getNumCols() ];
   double *ubVars = new double[ lp->getNumCols() ];
   double *lbVars = new double[ lp->getNumCols() ];

   for ( int i = 0; i < lp->getNumCols(); i++ )
   {
      idxSol[ i ] = i;
   }

   double objAtual = 100000000000.0;
   double okIter = true;
   CPUTimer tempoPol;

   tempoPol.reset();
   tempoPol.start();

   srand(123);

   lp->getUB(0,lp->getNumCols()-1,ubVars);
   lp->getLB(0,lp->getNumCols()-1,lbVars);

   int tempoIter = 100;
   int perc = percIni;
   int *idxs = new int[lp->getNumCols()*2];
   double *vals = new double[lp->getNumCols()*2];
   BOUNDTYPE *bds = new BOUNDTYPE[lp->getNumCols()*2];
   int nBds = 0;

   int fixType = 1;

   while (okIter)
   {
      VariableTaticoHash::iterator vit = vHashTatico.begin();

      // Seleciona turmas e disciplinas para fixar
      std::set<std::pair<int,Disciplina*> > paraFixarUm;
      std::set<std::pair<int,Disciplina*> > paraFixarZero;
      std::map<Trio<int,Disciplina*,int>,int > paraFixarDia;

      if ( fixType == 1 )
      {
         nBds = 0;
         while ( vit != vHashTatico.end() )
         {
            if ( vit->first.getType() == VariableTatico::V_ABERTURA )
            {
               if ( rand() % 100 >= perc  )
               {
                  vit++;
                  continue;
               }

               if (xSol[vit->second] > 0.1 )
               {
                  idxs[nBds] = vit->second;
                  vals[nBds] = (int)(xSol[vit->second]+0.5);
                  bds[nBds] = BOUNDTYPE::BOUND_LOWER;
                  nBds++;
                  std::pair<int,Disciplina*> auxPair(vit->first.getTurma(),vit->first.getDisciplina());
                  paraFixarUm.insert(auxPair);
               }
               else
               {
                  idxs[nBds] = vit->second;
                  vals[nBds] = 0.0;
                  bds[nBds] = BOUNDTYPE::BOUND_UPPER;
                  nBds++;
                  std::pair<int,Disciplina*> auxPair(vit->first.getTurma(),vit->first.getDisciplina());
                  paraFixarZero.insert(auxPair);
               }
            }

            vit++;
         }
         lp->chgBds(nBds,idxs,bds,vals);
         lp->updateLP();
      }

      vit = vHashTatico.begin();

      nBds = 0;
      while ( vit != vHashTatico.end() )
      {
         if ( vit->first.getType() == VariableTatico::V_CREDITOS )
         {
            if ( fixType == 1 )
            {
               std::pair<int,Disciplina*> auxPair(vit->first.getTurma(),vit->first.getDisciplina());
               if ( paraFixarUm.find(auxPair) != paraFixarUm.end() )
               {
                  if ( xSol[vit->second] > 0.1 )
                  {
                     //lp->chgLB(vit->second,(int)(xSol[vit->second]+0.5));
                     //lp->chgUB(vit->second,(int)(xSol[vit->second]+0.5));
                     idxs[nBds] = vit->second;
                     vals[nBds] = (int)(xSol[vit->second]+0.5);
                     bds[nBds] = BOUNDTYPE::BOUND_UPPER;
                     nBds++;
                     idxs[nBds] = vit->second;
                     vals[nBds] = (int)(xSol[vit->second]+0.5);
                     bds[nBds] = BOUNDTYPE::BOUND_LOWER;
                     nBds++;
                  }
                  else
                  {
                     idxs[nBds] = vit->second;
                     vals[nBds] = 0.0;
                     bds[nBds] = BOUNDTYPE::BOUND_UPPER;
                     nBds++;
                     //lp->chgUB(vit->second,0.0);
                  }
               }
               else if ( paraFixarZero.find(auxPair) != paraFixarZero.end() )
               {
                  idxs[nBds] = vit->second;
                  vals[nBds] = 0.0;
                  bds[nBds] = BOUNDTYPE::BOUND_UPPER;
                  nBds++;
                  //lp->chgUB(vit->second,0.0);
               }
            }
            else
            {
               if ( rand() % 100 >= perc  )
               {
                  vit++;
                  continue;
               }

               if ( xSol[vit->second] > 0.1 )
               {
                  idxs[nBds] = vit->second;
                  vals[nBds] = (int)(xSol[vit->second]+0.5);
                  bds[nBds] = BOUNDTYPE::BOUND_UPPER;
                  nBds++;
                  idxs[nBds] = vit->second;
                  vals[nBds] = (int)(xSol[vit->second]+0.5);
                  bds[nBds] = BOUNDTYPE::BOUND_LOWER;
                  nBds++;
                  //lp->chgLB(vit->second,(int)(xSol[vit->second]+0.5));
                  //lp->chgUB(vit->second,(int)(xSol[vit->second]+0.5));
               }
               else
               {
                  idxs[nBds] = vit->second;
                  vals[nBds] = 0.0;
                  bds[nBds] = BOUNDTYPE::BOUND_UPPER;
                  nBds++;
                  lp->chgUB(vit->second,0.0);
               }
            }
         }

         vit++;
      }

      lp->chgBds(nBds,idxs,bds,vals);
      lp->updateLP();

#ifdef SOLVER_CPLEX
      lp->updateLP();
      lp->setNodeLimit( 100000000 );
      lp->setTimeLimit( tempoIter );
      lp->setMIPRelTol( 0.01 );
      lp->setPolishAfterNode(1);
      lp->setPolishAfterTime(100000000);
      lp->setMIPEmphasis( 4 );
      lp->setCuts(0);
      if ( perc < percIni )
         lp->setCuts(1);
      lp->setNoCuts();
      //lp->setNoCuts();
      lp->setVarSel(4);
      lp->setNodeLimit(200);
      lp->setHeurFrequency( 1.0 );
#endif
#ifdef SOLVER_GUROBI
      lp->updateLP();
      lp->setNodeLimit( 100000000 );
      lp->setTimeLimit( tempoIter );
      lp->setMIPRelTol( 0.0 );
      lp->setMIPEmphasis( 0 );
      lp->setCuts(4);
      lp->setVarSel(4);
      lp->setNodeLimit(1000000000);
      lp->setHeurFrequency( 1.0 );
      lp->updateLP();
#endif
      lp->copyMIPStartSol( lp->getNumCols(), idxSol, xSol );
      lp->updateLP();

      status = lp->optimize( METHOD_MIP );

      double objN = lp->getObjVal();

      lp->getX( xSol );

      if ( fabs(objN-objAtual) < 0.0001 && perc < percMin )
      {
         if ( fixType == 2 )
         {
            okIter = false;
            perc -= 5;
            fixType = 1;
         }
         else
         {
            fixType = 2;
         }
      }

      if ( fabs(objN-objAtual) < 0.0001 && perc >= percMin)
      {
         if ( fixType == 2 )
         {
            perc -= 5;
            lp->setCuts(1);
            tempoIter += 20;
            fixType = 1;
         }
         else
         {
            fixType = 2;
         }
      }

      objAtual = objN;

      tempoPol.stop();
      double tempoAtual = tempoPol.getCronoTotalSecs();
      tempoPol.start();
      if ( tempoAtual >= maxTime )
      {
         okIter = false;
         tempoPol.stop();
      }

      // Volta bounds
      vit = vHashTatico.begin();

      nBds = 0;
      while ( vit != vHashTatico.end() )
      {
         if ( vit->first.getType() == VariableTatico::V_CREDITOS || vit->first.getType() == VariableTatico::V_ABERTURA )
         {
            idxs[nBds] = vit->second;
            vals[nBds] = ubVars[vit->second];
            bds[nBds] = BOUNDTYPE::BOUND_UPPER;
            nBds++;
            idxs[nBds] = vit->second;
            vals[nBds] = lbVars[vit->second];
            bds[nBds] = BOUNDTYPE::BOUND_LOWER;
            nBds++;
            //lp->chgLB(vit->second,lbVars[vit->second]);
            //lp->chgUB(vit->second,ubVars[vit->second]);
         }
         vit++;
      }
      lp->chgBds(nBds,idxs,bds,vals);
      lp->updateLP();

#ifdef SOLVER_CPLEX
      lp->setPolishAfterNode(1);
      lp->setMIPRelTol( 0.0 );
#endif
   }

   delete [] idxSol;
   delete [] ubVars;
   delete [] lbVars;
   delete [] idxs;
   delete [] vals;
   delete [] bds;
}

int SolverMIP::localBranchingPre( double * xSol, double maxTime )
{
   // Adiciona restrição de local branching
   int status = 0;
   int nIter = 0;
   int * idxSol = new int[ lp->getNumCols() ];
   CPUTimer tempoLB;

   for ( int i = 0; i < lp->getNumCols(); i++ )
   {
      idxSol[ i ] = i;
   }



   /*FILE * fin = fopen( "solLBAtualPre.bin", "rb" );
   if ( fin == NULL )
   {
      std::cout << "\nErro em SolverMIP::solvePreTaticoCjtAlunos( int campusId, int prioridade, int cjtAlunosId ):"
         << "\nArquivo " << "solLBAtualPre.bin" << " nao pode ser aberto.\n";
   }
   else
   {
      int nCols = 0;

      fread( &nCols, sizeof( int ), 1, fin );

      for ( int i = 0; i < nCols; i++ )
      {
         double auxR;
         fread( &auxR, sizeof( double ), 1, fin );

         xSol[ i ] = auxR;
      }

      fclose( fin );
   }

   lp->copyMIPStartSol(lp->getNumCols(),idxSol,xSol);*/

   double objAtual = 100000000000.0;
   double okIter = true;

   int k = -100;

   tempoLB.reset();
   tempoLB.start();

   int tempoIter = 600;

   while (okIter)
   {
      VariablePreHash::iterator vit = vHashPre.begin();

      OPT_ROW nR( 50, OPT_ROW::GREATER, 0.0, "LOCBRANCH" );
      double rhsLB = k;

      while ( vit != vHashPre.end() )
      {
         if ( vit->first.getType() == VariablePre::V_PRE_OFERECIMENTO )
         {
            if ( xSol[vit->second] > 0.1 )
            {
               rhsLB += 1.0;
               nR.insert( vit->second,1.0 );
            }
            else
            {
               nR.insert( vit->second, -1.0 );
            }
         }

         vit++;
      }

      nR.setRhs( rhsLB );

      lp->addRow( nR );
      lp->updateLP();
      lp->setNodeLimit( 100000000 );
      lp->setTimeLimit( tempoIter );
      //lp->setMIPRelTol( 0.02 );
      //lp->setNodeLimit( 1 );
      lp->setPolishAfterNode(101);
      lp->setPolishAfterTime(100000000);
      lp->setMIPEmphasis( 4 );
      lp->setCuts(4);
      //lp->setNoCuts();
      lp->setVarSel(4);
      lp->setHeurFrequency( 1.0 );
      lp->copyMIPStartSol( lp->getNumCols(), idxSol, xSol );

      status = lp->optimize( METHOD_MIP );

      lp->getX( xSol );

      FILE * fout = fopen( "solLBAtualPre.bin", "wb" );
		if ( fout == NULL )
		{
			std::cout << "\nErro em SolverMIP::localBranchingPre( ):"
					<< "\nArquivo " << "solLBAtualPre.bin" << " nao pode ser aberto.\n";
		}
		else
		{
			int nCols = lp->getNumCols();

			fwrite( &nCols, sizeof( int ), 1, fout );
			for ( int i = 0; i < lp->getNumCols(); i++ )
			{
				fwrite( &( xSol[ i ] ), sizeof( double ), 1, fout );
			}

			fclose( fout );
		}

      double objN = lp->getObjVal();

      if ( fabs(objN-objAtual) < 0.0001 && k <= -1000 )
      {
         okIter = false;
      }
      else if (fabs(objN-objAtual) < 0.0001 )
      {
         k -= 50;
         tempoIter += 300;
      }

      if ( k == -50 )
      {
          tempoIter += 300;
          k+=30;
      }

      if ( k == -100 )
          k += 50;

      objAtual = objN;

      if ( objAtual < 0.001 )
         okIter = false;

      tempoLB.stop();
      double tempoAtual = tempoLB.getCronoTotalSecs();
      tempoLB.start();
      if ( tempoAtual >= maxTime )
      {
         okIter = false;
         tempoLB.stop();
      }

      int * idxs = new int[ 1 ];
      idxs[ 0 ] = lp->getNumRows() - 1;
      lp->delSetRows( 1, idxs );
      lp->updateLP();
      delete [] idxs;
   }

   delete [] idxSol;

   return status;
}

void SolverMIP::polishPreTatico(double *xSol, double maxTime, int percIni, int percMin)
{
   int status = 0;
   int * idxSol = new int[ lp->getNumCols() ];
   double *ubVars = new double[ lp->getNumCols() ];
   double *lbVars = new double[ lp->getNumCols() ];

   for ( int i = 0; i < lp->getNumCols(); i++ )
   {
      idxSol[ i ] = i;
   }

   double objAtual = 100000000000.0;
   double okIter = true;
   CPUTimer tempoPol;

   tempoPol.reset();
   tempoPol.start();

   srand(123);

   lp->getUB(0,lp->getNumCols()-1,ubVars);
   lp->getLB(0,lp->getNumCols()-1,lbVars);

   int tempoIter = 300;
   int perc = percIni;

   int nIter = 1;

   int *idxBds = new int[lp->getNumCols()*2];
   double *valBds = new double[lp->getNumCols()*2];
   BOUNDTYPE *bts = new BOUNDTYPE[lp->getNumCols()*2];
   int nChgBds = 0;

   while (okIter)
   {
      VariablePreHash::iterator vit = vHashPre.begin();

      vit = vHashPre.begin();

      nChgBds = 0;
      while ( vit != vHashPre.end() )
      {
         if ( vit->first.getType() == VariablePre::V_PRE_OFERECIMENTO )
         {
            if ( rand() % 100 >= perc  )
            {
               vit++;
               continue;
            }

            if ( xSol[vit->second] > 0.1 )
            {
               idxBds[nChgBds] = vit->second;
               valBds[nChgBds] = (int)(xSol[vit->second]+0.5);
               bts[nChgBds] = BOUNDTYPE::BOUND_LOWER;
               nChgBds++;
               //lp->chgLB(vit->second,(int)(xSol[vit->second]+0.5));
            }
            else
            {
               idxBds[nChgBds] = vit->second;
               valBds[nChgBds] = 0.0;
               bts[nChgBds] = BOUNDTYPE::BOUND_UPPER;
               nChgBds++;
               //lp->chgUB(vit->second,0.0);
            }
         }

         vit++;
      }

      lp->chgBds(nChgBds,idxBds,bts,valBds);

#ifdef SOLVER_CPLEX
      lp->updateLP();
      lp->setNodeLimit( 100000000 );
      lp->setTimeLimit( tempoIter );
      lp->setPolishAfterNode(1);
      lp->setPolishAfterTime(100000000);
      lp->setMIPEmphasis( 4 );
      lp->setCuts(4);
      lp->setVarSel(4);
      lp->setHeurFrequency( 1.0 );
      lp->copyMIPStartSol( lp->getNumCols(), idxSol, xSol );
      lp->updateLP();
#endif

#ifdef SOLVER_GUROBI
      lp->updateLP();
      lp->setNodeLimit( 100000000 );
      lp->setTimeLimit( tempoIter );
      lp->setPolishAfterTime(100000000);
      lp->setMIPEmphasis( 0 );
      lp->setCuts(4);
      lp->setHeurFrequency( 1.0 );
      lp->copyMIPStartSol( lp->getNumCols(), idxSol, xSol );
      lp->updateLP();
#endif

      status = lp->optimize( METHOD_MIP );

      double objN = lp->getObjVal();

      lp->getX( xSol );

      if ( fabs(objN-objAtual) < 0.0001 && perc < percMin )
      {
         if ( nIter == 2 )
         {
            okIter = false;
            perc -= 5;
         }
         else
         {
            perc -= 5;
         }
      }

      if ( fabs(objN-objAtual) < 0.0001 && perc >= percMin)
      {
         perc -= 5;
      }

      if ( perc < percMin && nIter == 1 )
      {
         nIter++;
      }

      if ( objN < 0.0001 )
         okIter = false;

      objAtual = objN;

      tempoPol.stop();
      double tempoAtual = tempoPol.getCronoTotalSecs();
      tempoPol.start();
      if ( tempoAtual >= maxTime )
      {
         okIter = false;
         tempoPol.stop();
      }

      // Volta bounds
      vit = vHashPre.begin();
      nChgBds = 0;

      while ( vit != vHashPre.end() )
      {
         if ( vit->first.getType() == VariablePre::V_PRE_OFERECIMENTO )
         {
            idxBds[nChgBds] = vit->second;
            valBds[nChgBds] = lbVars[vit->second];
            bts[nChgBds] = BOUNDTYPE::BOUND_LOWER;
            nChgBds++;
            idxBds[nChgBds] = vit->second;
            valBds[nChgBds] = ubVars[vit->second];
            bts[nChgBds] = BOUNDTYPE::BOUND_UPPER;
            nChgBds++;
            //lp->chgLB(vit->second,lbVars[vit->second]);
            //lp->chgUB(vit->second,ubVars[vit->second]);
         }
         vit++;
      }
      lp->chgBds(nChgBds,idxBds,bts,valBds);
      lp->updateLP();
   }

   delete [] idxSol;
   delete [] ubVars;
   delete [] lbVars;
   delete [] idxBds;
   delete [] valBds;
   delete [] bts;
}

void SolverMIP::getSolution( ProblemSolution * problem_solution )
{
   // Input TATICO
   if ( problemData->parametros->modo_otimizacao == "TATICO"
      && problemData->atendimentosTatico == NULL )
   {
	   if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
	   {
			getSolutionTatico();
	   }
	   else if ( problemData->parametros->otimizarPor == "ALUNO" )
	   {
			getSolutionTaticoPorAluno();
	   }
   }
   // Input OPERACIONAL
   else if ( problemData->parametros->modo_otimizacao == "OPERACIONAL" )
   {
      if ( problemData->atendimentosTatico == NULL )
      {
		   if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
		   {
				getSolutionTatico();
		   }
		   else if ( problemData->parametros->otimizarPor == "ALUNO" )
		   {
				getSolutionTaticoPorAluno();
		   }
      }

      getSolutionOperacionalMIP();
   }

   relacionaAlunosDemandas();
}



#ifdef TATICO_CJT_ALUNOS

/*----------------------------------------------------------------------------------
**							PRE-MODELO					  				          **
----------------------------------------------------------------------------------*/


/********************************************************************
**                      Variaveis do pre-tatico                    **
*********************************************************************/

int SolverMIP::cria_preVariaveis(  int campusId, int prioridade, int grupoAlunosId, int r )
{
	int num_vars = 0;
	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_variaveis
	int numVarsAnterior = 0;
#endif


	timer.start();
	num_vars += cria_preVariavel_alunos( campusId, grupoAlunosId, prioridade, r );  // a_{i,d,oft,s}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"a\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_preVariavel_creditos( campusId, grupoAlunosId, prioridade, r );   // x_{i,d,s}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"x\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_oferecimentos( campusId, grupoAlunosId, prioridade, r ); // o_{i,d,s}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"o\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_abertura( campusId, grupoAlunosId, prioridade, r );   // z_{i,d}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"z\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_aloc_alunos( campusId, grupoAlunosId, prioridade, r );   // b_{i,d,c}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"b\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	/*
	timer.start();
	num_vars += cria_preVariavel_folga_compartilhamento_incomp( campusId, grupoAlunosId, prioridade ); // bs_{d,oft}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"bs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	*/

	timer.start();
	num_vars += cria_preVariavel_folga_proibe_compartilhamento( campusId, grupoAlunosId, prioridade, r ); // fc_{d,oft}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fc\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	
	timer.start();
	num_vars += cria_preVariavel_limite_sup_creds_sala( campusId ); // Hs
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"Hs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

   timer.start();
   num_vars += cria_preVariavel_soma_cred_sala( campusId ); // xcs
   timer.stop();
   dif = timer.getCronoCurrSecs();
#ifdef PRINT_cria_variaveis
   std::cout << "numVars \"xcs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
   numVarsAnterior = num_vars;
#endif

	// Exclusivas para modelo por aluno:

	if ( problemData->parametros->otimizarPor == "ALUNO" )
	{
		timer.start();
		num_vars += cria_preVariavel_folga_demanda_disciplina_aluno( campusId, grupoAlunosId, prioridade ); // fd_{d,a}
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif

		timer.start();
		num_vars += cria_preVariavel_aloca_aluno_turma_disc( campusId, grupoAlunosId, prioridade, r ); // s
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"s\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif

		timer.start();
		num_vars += cria_preVariavel_folga_prioridade_inf( campusId, prioridade, grupoAlunosId ); // fpi
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fpi\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif
		

		timer.start();
		num_vars += cria_preVariavel_folga_prioridade_sup( campusId, prioridade, grupoAlunosId ); // fps
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fps\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif
		

		timer.start();
		num_vars += cria_preVariavel_folga_abre_turma_sequencial( campusId, grupoAlunosId, prioridade, r ); // ft
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"ft\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif

		/*timer.start();
		num_vars += cria_preVariavel_folga_distribuicao_aluno( campusId, grupoAlunosId, prioridade ); // fda
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fda\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif*/
		
	
		timer.start();
		num_vars += cria_preVariavel_turmas_compartilhadas( campusId, grupoAlunosId, prioridade ); // w_{i,d,i',d'}
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_variaveis
			std::cout << "numVars \"w\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
			numVarsAnterior = num_vars;
		#endif

		timer.start();
		num_vars += cria_preVariavel_folga_turma_mesma_disc_sala_dif( campusId, grupoAlunosId, prioridade, r ); // fs_{d,s}
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
		#endif	


		timer.start();

		if ( campusId==19 )
			num_vars += cria_preVariavel_aluno_sala( campusId, grupoAlunosId, prioridade ); // as_{a,s}
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"as\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
		#endif	


		timer.start();
		num_vars += cria_preVariavel_formandosNaTurma( campusId, grupoAlunosId, prioridade, r ); // f_{i,d,cp}
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"f\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
		#endif	
		
	}
	else if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
	{
		timer.start();
	//	num_vars += cria_preVariavel_folga_turma_mesma_disc_oft_sala_dif( campusId, grupoAlunosId, prioridade, r ); // fs_{d,s,oft}
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
		#endif

		timer.start();
		num_vars += cria_preVariavel_aloca_alunos_oferta( campusId, grupoAlunosId, prioridade, r ); // c_{i,d,s,oft}
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"c\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
		#endif
	}

	return num_vars;
}

// x_{i,d,u,s}
int SolverMIP::cria_preVariavel_creditos( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  Campus *cp = *itCampus;

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disc );

			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
			   {
				   continue;
			   }
			   #pragma endregion

				int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );

 				if ( discGrupoAlunosId > grupoAlunosId || 
					 discGrupoAlunosId == 0 )
				{
					continue;
				}

                for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                {
                     VariablePre v;
                     v.reset();
                     v.setType( VariablePre::V_PRE_CREDITOS );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setUnidade( *itUnidade );     // u
                     v.setSubCjtSala( *itCjtSala );  // tps

                     if ( vHashPre.find( v ) == vHashPre.end() )
                     {
						 double coef = 0.0;

						 int upperBound = disciplina->getCredTeoricos() + disciplina->getCredPraticos();						 
						 double lowerBound = 0.0;

						 if ( upperBound == 0 )
						 {
							std::cout<<"\nAtencao em cria_preVariavel_creditos: disciplina "
								<<disciplina->getId()<<" possui 0 creditos associados.\n";
						 }

#ifdef TATICO_COM_HORARIOS
						 if ( FIXAR_P1 && P_ATUAL > 1 )
						 {
							int value = this->fixaLimitesVariavelPre( &v );
							if ( value > 0 ) // fixa!
							{
						 		lowerBound = value;
								upperBound = lowerBound;
							}
						 }
						 else if ( discGrupoAlunosId < grupoAlunosId )
						 {
							lowerBound = this->fixaLimitesVariavelPre( &v );
							upperBound = lowerBound;
						 }

						 if (r>1)
						 {
							int value = this->fixaLimitesVariavelPre( &v );
							if ( value > 0 ) // fixa!
							{
						 		lowerBound = value;
								upperBound = lowerBound;
							}
						 }

#else
						
						 if ( FIXAR_P1 && P_ATUAL > 1 )
						 {
							 int value = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							 if ( value > 0 ) // fixa!
							 {
						 		lowerBound = value;
								upperBound = lowerBound;
							 }
						 }
						 else if ( discGrupoAlunosId < grupoAlunosId )
						 {
							lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
						 }
#endif
                         vHashPre[ v ] = lp->getNumCols();

                         OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );
                          
						 lp->newCol( col );						 

						 num_vars++;						  
                     }
                 }
             }
         }
      }
   }

	return num_vars;
}

// o_{i,d,s}
int SolverMIP::cria_preVariavel_oferecimentos( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;

   Disciplina * disciplina = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  Campus *cp = *itCampus;

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disc );

			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
			   {
				   continue;
			   }
			   #pragma endregion

				int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );

 				if ( discGrupoAlunosId > grupoAlunosId || 
					discGrupoAlunosId == 0 )
				{
					continue;
				}

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                    // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                    GGroup< int > dias_letivos = itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                    GGroup< int >::iterator itDiscSala_Dias = dias_letivos.begin();

                     VariablePre v;
                     v.reset();
                     v.setType( VariablePre::V_PRE_OFERECIMENTO );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setUnidade( *itUnidade );     // u
                     v.setSubCjtSala( *itCjtSala );  // tps

                     if ( vHashPre.find( v ) == vHashPre.end() )
                     {
                        double custo = 0.0;

                        vHashPre[ v ] = lp->getNumCols();
						 
						double lowerBound = 0.0;
						double upperBound = 1.0;
						
#ifdef TATICO_COM_HORARIOS
						 if ( FIXAR_P1 && P_ATUAL > 1 )
						 {
							int value = this->fixaLimitesVariavelPre( &v );
							if ( value > 0 ) // fixa!
							{
						 		lowerBound = value;
								upperBound = lowerBound;
							}
						 }
						 else if ( discGrupoAlunosId < grupoAlunosId )
						 {
							lowerBound = this->fixaLimitesVariavelPre( &v );
							upperBound = lowerBound;
						 }

						 if (r>1)
						 {
							int value = this->fixaLimitesVariavelPre( &v );
							if ( value > 0 ) // fixa!
							{
						 		lowerBound = value;
								upperBound = lowerBound;
							}
						 }
#else

						if ( FIXAR_P1 && P_ATUAL > 1 )
						{
							int value = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							if ( value > 0 ) // fixa!
							{
						 		lowerBound = value;
								upperBound = lowerBound;
							}
						}
						else if ( discGrupoAlunosId < grupoAlunosId )
						{
							lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
						}
#endif
                        OPT_COL col( OPT_COL::VAR_BINARY, custo, lowerBound, upperBound, ( char* )v.toString().c_str() );
                          
						lp->newCol( col );

						num_vars++;						  
                     }
                }
            }
         }
      }
   }

	return num_vars;
}

// z_{i,d,cp}
int SolverMIP::cria_preVariavel_abertura( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;
	
   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_disciplina, it_CpDisc->second, int )
      {
		 Disciplina *disciplina = problemData->refDisciplinas[ *it_disciplina ];
		 		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
		 	continue;
		 }
		 #pragma endregion

		 int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );
		 
 		 if ( discGrupoAlunosId > grupoAlunosId || 
			  discGrupoAlunosId == 0 )
		 {
			 continue;
		 }
		 
         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            VariablePre v;
            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( cp );	    // cp

            if ( vHashPre.find(v) == vHashPre.end() )
            {
               lp->getNumCols();
               vHashPre[v] = lp->getNumCols();

			    double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					double custo = cp->getCusto();
							 
					coef = -10 * custo * disciplina->getTotalCreditos();
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					double custo = cp->getCusto();

					coef = custo/10.0 * disciplina->getTotalCreditos();
				}
						                
						 
				double lowerBound = 0.0;
				double upperBound = 1.0;

#ifdef TATICO_COM_HORARIOS
				if ( FIXAR_P1 && P_ATUAL > 1 )
				{
					int value = this->fixaLimitesVariavelPre( &v );
					if ( value > 0 ) // fixa!
					{
						lowerBound = value;
						upperBound = lowerBound;
					}
				}
				else if ( discGrupoAlunosId < grupoAlunosId )
				{
					lowerBound = this->fixaLimitesVariavelPre( &v );
					upperBound = lowerBound;
				}

				if (r>1)
				{
					int value = this->fixaLimitesVariavelPre( &v );
					if ( value > 0 ) // fixa!
					{
						lowerBound = value;
						upperBound = lowerBound;
					}
				}
#else
				if ( FIXAR_P1 && P_ATUAL > 1 )
				{
					int value = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
					if ( value > 0 ) // fixa!
					{
						lowerBound = value;
						upperBound = lowerBound;
					}
				}
				else if ( discGrupoAlunosId < grupoAlunosId )
				{
					lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
					upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
				}
#endif
				OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound,
                     ( char * )v.toString().c_str() );

                lp->newCol( col ); 
                
				num_vars++;
            }
         }
      }
   }

	return num_vars;
}

// a_{i,d,oft,s}
int SolverMIP::cria_preVariavel_alunos( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;
		
	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
	  
	    if ( cp->getId() != campusId )
	    {
		    continue;
	    }

		ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *it_disc;
					
				    #pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				    {
					    continue;
				    }
				    #pragma endregion

					int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );

					if ( discGrupoAlunosId > grupoAlunosId || 
						 discGrupoAlunosId == 0 )
					{
						continue;
					}

					// Listando todas as ofertas que contêm uma disciplina especificada.
					GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ it_disc->getId() ];

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{
							 Oferta* oft = *itOferta;

							 if ( oft->campus != cp )
								 continue;

							 int qtdDem = problemData->haDemandaDiscNoCjtAlunosPorOferta( disciplina->getId(), oft->getId(), discGrupoAlunosId );

							 if ( qtdDem == 0 )
							 {
								continue;
							 }

							 for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							 {
								VariablePre v;
								v.reset();
								v.setType( VariablePre::V_PRE_ALUNOS );

								v.setTurma( turma );               // i
								v.setDisciplina( disciplina );     // d
								v.setOferta( *itOferta );          // oft
								v.setUnidade( *itUnidade );		   // u
								v.setSubCjtSala( *itCjtSala );	   // s
								
								if ( vHashPre.find(v) == vHashPre.end() )
								{
									vHashPre[v] = lp->getNumCols();
									
									double coef = 0.0;

									if ( problemData->parametros->funcao_objetivo == 0 )
									{
										double valorCredito = itOferta->getReceita();
										int numCreditos = ( disciplina->getCredTeoricos() + disciplina->getCredPraticos() );
				
										coef = 100 * numCreditos * valorCredito;
									}
									else if ( problemData->parametros->funcao_objetivo == 1 )
									{
										coef = 0.0;
									}
						 
									int lowerBound = 0;
									int upperBound = qtdDem;
						
#ifdef TATICO_COM_HORARIOS
									 if ( FIXAR_P1 && P_ATUAL > 1 )
									 {
										int nAtend = this->fixaLimitesVariavelPre( &v );
										if ( nAtend == -1 ) // turma ja alocada em outra sala
										{
						 					lowerBound = 0;
											upperBound = lowerBound;
										}
										else
										{
											lowerBound = nAtend;
											if ( nAtend > 0 && !PERMITIR_INSERCAO_ALUNODEMANDAP2_EM_TURMAP1 )
											{
												upperBound = nAtend;
											}
											if ( discGrupoAlunosId < grupoAlunosId && nAtend == 0 )
											{
												upperBound = nAtend;
											}										
										}
									 }
									 else if ( discGrupoAlunosId < grupoAlunosId )
									 {
										int nAtend = this->fixaLimitesVariavelPre( &v );
										if ( nAtend == -1 ) // a turma já esta alocada em outra sala
										{
											lowerBound = 0.0;										
											upperBound = lowerBound;
										}
										else
										{
											lowerBound = nAtend;										
											upperBound = lowerBound;
										}
									 }

									 if (r>1)
									 {
										int value = this->fixaLimitesVariavelPre( &v );
										if ( value > 0 ) // fixa minimo!
										{
						 					lowerBound = value;
										}
									 }
#else									
									if ( FIXAR_P1 && P_ATUAL > 1 )
									{
										int nAtend = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
										if ( nAtend == -1 ) // a turma já esta alocada em outra sala
										{
											lowerBound = 0.0;										
											upperBound = lowerBound;
										}
										else
										{
											lowerBound = nAtend;
											if ( nAtend > 0 && !PERMITIR_INSERCAO_ALUNODEMANDAP2_EM_TURMAP1 )
											{
												upperBound = nAtend;
											}
											if ( discGrupoAlunosId < grupoAlunosId && nAtend == 0 )
											{
												upperBound = nAtend;
											}
										}
									}
									else if ( discGrupoAlunosId < grupoAlunosId )
									{
										int nAtend = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
										if ( nAtend == -1 ) // a turma já esta alocada em outra sala
										{
											lowerBound = 0.0;										
											upperBound = lowerBound;
										}
										else
										{
											lowerBound = nAtend;										
											upperBound = lowerBound;
										}
									}
#endif
									OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound,
										( char * )v.toString().c_str() );

									lp->newCol( col );

									num_vars += 1;
								}
							}
				      }
				}
			}
		}
   }

	return num_vars;
}

// b_{i,d,c}
int SolverMIP::cria_preVariavel_aloc_alunos( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;
		
	ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
	{		
		Disciplina* disciplina = *itDisc;

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion

		if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			 problemData->cp_discs[campusId].end() )
		{
			continue;
		}

		 int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );

 		 if ( discGrupoAlunosId > grupoAlunosId || 
			  discGrupoAlunosId == 0 )
		 {
			 continue;
		 }

		ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
		{
			Curso *curso = *itCurso;

			if ( !curso->possuiDisciplina( disciplina ) )
				continue;

			// Calculando P_{d,curso}
			int qtdDem = problemData->haDemandaDiscNoCjtAlunosPorCurso( disciplina->getId(), curso->getId(), discGrupoAlunosId );
			
			if ( qtdDem == 0 )
			{
				continue;
			}

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOC_ALUNO );

				v.setTurma( turma );               // i
				v.setDisciplina( disciplina );     // d
				v.setCurso( curso );			   // c
				
				if ( vHashPre.find(v) == vHashPre.end() )
				{
					double coef = 0.0;
					
					vHashPre[v] = lp->getNumCols();

					if ( problemData->parametros->funcao_objetivo == 0 )
					{
						coef = -1.0;
					}
					else if ( problemData->parametros->funcao_objetivo == 1 )
					{						
						coef = 1.0;
					}
						
					double lowerBound = 0.0;
					double upperBound = 1.0;
					
#ifdef TATICO_COM_HORARIOS
					if ( FIXAR_P1 && P_ATUAL > 1 )
					{
						int value = this->fixaLimitesVariavelPre( &v );
						if ( value > 0 ) // fixa!
						{
							lowerBound = value;
							upperBound = lowerBound;
						}
					}
					else if ( discGrupoAlunosId < grupoAlunosId )
					{
						lowerBound = this->fixaLimitesVariavelPre( &v );
						upperBound = lowerBound;
					}

					if (r>1)
					{
						int value = this->fixaLimitesVariavelPre( &v );
						if ( value > 0 ) // fixa!
						{
							lowerBound = value;
							upperBound = lowerBound;
						}
					}
#else
					if ( FIXAR_P1 && P_ATUAL > 1 )
					{
						int value = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
						if ( value > 0 ) // fixa!
						{
						 	lowerBound = value;
							upperBound = lowerBound;
						}
					}
					else if ( discGrupoAlunosId < grupoAlunosId )
					{
						lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
						upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
					}
#endif
					OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );
												
					lp->newCol( col );
					
					num_vars += 1;
				}
			}
		}
   }

	return num_vars;
}

// fd_{d,a}
int SolverMIP::cria_preVariavel_folga_demanda_disciplina_aluno( int campusId, int grupoAlunosAtualId, int P_ATUAL )
{
    int num_vars = 0;

	Campus *cp = problemData->refCampus[campusId];

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para cada conjunto de alunos cp com id menor ou igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;

		if ( grupoAlunosId > grupoAlunosAtualId )
		{
			break;
		}

		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];
	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;

				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_SLACK_DEMANDA );
				v.setAluno( aluno );
				v.setDisciplina( disciplina );

				// Evita criação da variavel caso o aluno já possua o total de creditos pedidos em P1 atendidos
				// e a disciplina corrente não for uma das já atendidas.
				if (P_ATUAL>1)
				{
					int turmaAlocada = problemData->retornaTurmaDiscAluno( aluno, disciplina );
					double tempoTotalP1 = problemData->cargaHorariaOriginalRequeridaPorPrioridade( 1, aluno );
					double tempoJaAtendido = problemData->cargaHorariaJaAtendida( aluno );
					if ( tempoJaAtendido >= tempoTotalP1 &&
						 turmaAlocada == -1 )
						continue;
				}

				// Coeficiente na funcao objetivo
				double coef = 0.0;
				if ( itAlDemanda->getPrioridade() > 1 )
				{
					coef = 0.0; // para P2, quem controla o custo da folga de demanda são fpi e fps
				}
				else
				{
					if ( problemData->parametros->funcao_objetivo == 0 )
					{
						coef = 0.0;
					}
					else if( problemData->parametros->funcao_objetivo == 1 )
					{
						//if ( aluno->ehFormando() )
						//	coef = 150.0 * cp->getCusto() * disciplina->getTotalCreditos();
						//else
							coef = 50.0 * cp->getCusto() * disciplina->getTotalCreditos();
					}
				}
				
				// Limites da variavel						 
				double lowerBound = 0.0;
				double ub = 1.0;

#ifdef TATICO_COM_HORARIOS
				if ( FIXAR_P1 )
				{
					int turmaAlocada = problemData->retornaTurmaDiscAluno( aluno, disciplina );
					if ( turmaAlocada != -1 ) // se o aluno esta alocado
					{
						ub = 0.0; // fixa atendimento
					}
					else if ( (*itAlDemanda)->getPrioridade() < P_ATUAL ||
							  grupoAlunosId < grupoAlunosAtualId ) // se o aluno não esta alocado e é de cjtAluno ou P anterior
					{
						lowerBound = 1.0; // fixa nao-atendimento
					}					
				}
				else
				{
					if ( grupoAlunosId < grupoAlunosAtualId ) // só fixa atendimento se for cjt anterior
					{
						int turmaAlocada = problemData->retornaTurmaDiscAluno( aluno, disciplina );
						if ( turmaAlocada != -1 ) ub = 0.0;	// se o aluno esta alocado												
						else lowerBound = 1.0;
					}
				}
#else
				if ( FIXAR_P1 )
				{
					int turmaAlocada = problemData->retornaTurmaDiscAluno( aluno, disciplina );
					if ( turmaAlocada != -1 ) // se o aluno esta alocado
					{
						ub = 0.0; // fixa atendimento
					}
					else if ( (*itAlDemanda)->getPrioridade() < P_ATUAL ||
							  grupoAlunosId < grupoAlunosAtualId ) // se o aluno não esta alocado e é de cjtAluno ou P anterior
					{
						lowerBound = 1.0; // fixa nao-atendimento
					}					
				}
				else
				{
					if ( grupoAlunosId < grupoAlunosAtualId ) // só fixa atendimento se for cjt anterior
					{
						int turmaAlocada = problemData->retornaTurmaDiscAluno( aluno, disciplina );
						if ( turmaAlocada != -1 ) ub = 0.0;	// se o aluno esta alocado												
						else lowerBound = 1.0;
					}
				}
#endif
				if ( vHashPre.find( v ) == vHashPre.end() )
				{
					vHashPre[v] = lp->getNumCols();

					OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, ub, ( char * )v.toString().c_str() );
					lp->newCol(col);
				
					num_vars++;
				}
			}
		}
	
	}

	return num_vars;
}

// Não esta sendo mais usada, a restrição é forte
// bs_{i,d,c1,c2}
int SolverMIP::cria_preVariavel_folga_compartilhamento_incomp( int campusId, int grupoAlunosId, int P_ATUAL )
{
	int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
		Campus* cp = *itCampus;
	  
	    if ( cp->getId() != campusId )
	    {
		    continue;
	    }

	   ITERA_GGROUP_LESSPTR( itCurso1, cp->cursos, Curso )
	   {
		   Curso* c1 = *itCurso1;
		   
		   ITERA_GGROUP_INIC_LESSPTR( itCurso2, itCurso1, cp->cursos, Curso )
		   {
				Curso* c2 = *itCurso2;
			    
			    if ( problemData->cursosCompativeis(c1, c2) || c1 == c2 )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion
					

					// A disciplina deve estar no conjunto de alunos atual ou anterior
					int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );
 					if ( discGrupoAlunosId > grupoAlunosId || 
						 discGrupoAlunosId == 0 )
					{
						continue;
					}

					// A disciplina deve ser ofertada no campus especificado
					if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
						 problemData->cp_discs[campusId].end() )
					{
						continue;
					}

					// A disciplina deve pertencer aos dois cursos c1 e c2
					if ( !c1->possuiDisciplina(disciplina) || !c2->possuiDisciplina(disciplina) )
						continue;

					// Calculando P_{d,curso}					
					if ( problemData->haDemandaDiscNoCjtAlunosPorCurso( disciplina->getId(), c1->getId(), discGrupoAlunosId ) == 0 ||
						 problemData->haDemandaDiscNoCjtAlunosPorCurso( disciplina->getId(), c2->getId(), discGrupoAlunosId ) == 0 )
					{
						continue;
					}

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
					   VariablePre v;
					   v.reset();
					   v.setType( VariablePre::V_PRE_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT );
					   v.setTurma( turma );							// i
					   v.setDisciplina( disciplina );   			// d
					   v.setParCursos( std::make_pair(c1, c2) );	// c1 c2

					   if ( vHashPre.find( v ) == vHashPre.end() )
					   {
						  vHashPre[v] = lp->getNumCols();
						  
						  double coef = 0.0;

						  if ( problemData->parametros->funcao_objetivo == 0 )
						  {
							  coef = -cp->getCusto();
						  }
						  else if( problemData->parametros->funcao_objetivo == 1 )
						  {
							  coef = cp->getCusto();
						  }
						 
						 
						  double lowerBound = 0.0;
						  double upperBound = 1.0;
					
#ifdef TATICO_COM_HORARIOS
						  if ( FIXAR_P1 && P_ATUAL > 1 )
						  {
							  int value = this->fixaLimitesVariavelPre( &v );
						  	  if ( value > 0 ) // fixa!
							  {
								  lowerBound = value;
								  upperBound = lowerBound;
							  }
						  }
						  else if ( discGrupoAlunosId < grupoAlunosId )
						  {
							  lowerBound = this->fixaLimitesVariavelPre( &v );
							  upperBound = lowerBound;
						  }
#else
						  if ( FIXAR_P1 && P_ATUAL > 1 )
						  {
								int value = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
								if ( value > 0 ) // fixa!
								{
									lowerBound = value;
									upperBound = lowerBound;
								}
						  }
						  else if ( discGrupoAlunosId < grupoAlunosId )
						  {
							  lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							  upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
						  }
#endif
						  OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

						  lp->newCol( col );
						  num_vars++;
					   }
					}
				}
		    }
		}
   }

	return num_vars;
}

// fc_{i,d,c1,c2}
int SolverMIP::cria_preVariavel_folga_proibe_compartilhamento( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;

   if ( problemData->parametros->permite_compartilhamento_turma_sel )
   {
		return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus* cp = *itCampus;
	  
	   if ( cp->getId() != campusId )
	   {
		   continue;
	   }

	   ITERA_GGROUP_LESSPTR( itCurso1, cp->cursos, Curso )
	   {
		   Curso* c1 = *itCurso1;
		   
		   ITERA_GGROUP_INIC_LESSPTR( itCurso2, itCurso1, cp->cursos, Curso )
		   {
				Curso* c2 = *itCurso2;
			    
				// A variavel de folga só é criada para cursos compativeis e diferentes entre si
				// Ofertas para mesmo curso sempre poderão compartilhar
				// Ofertas de cursos distintos só poderão compartilhar se forem compativeis e o compartilhamento estiver permitido
			    if ( c1 == c2 || !problemData->cursosCompativeis(c1, c2) )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						  !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion


					// A disciplina deve estar no conjunto de alunos atual ou anterior
					int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );
 					if ( discGrupoAlunosId > grupoAlunosId || 
						 discGrupoAlunosId == 0 )
					{
						continue;
					}
					
					// A disciplina deve ser ofertada no campus especificado
					if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
						 problemData->cp_discs[campusId].end() )
					{
						continue;
					}

					// A disciplina deve pertencer aos dois cursos c1 e c2
					if ( !c1->possuiDisciplina(disciplina) || !c2->possuiDisciplina(disciplina) )
						continue;

					// Calculando P_{d,curso}					
					if ( problemData->haDemandaDiscNoCjtAlunosPorCurso( disciplina->getId(), c1->getId(), discGrupoAlunosId ) == 0 ||
						 problemData->haDemandaDiscNoCjtAlunosPorCurso( disciplina->getId(), c2->getId(), discGrupoAlunosId ) == 0 )
					{
						continue;
					}

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
					   VariablePre v;
					   v.reset();
					   v.setType( VariablePre::V_PRE_SLACK_COMPARTILHAMENTO );
					   v.setTurma( turma );							// i
					   v.setDisciplina( disciplina );   			// d
					   v.setParCursos( std::make_pair(c1, c2) );	// c1 c2

					   if ( vHashPre.find( v ) == vHashPre.end() )
					   {
						  vHashPre[v] = lp->getNumCols();
						  
						  double coef = 0.0;

						  if ( problemData->parametros->funcao_objetivo == 0 )
						  {
							  coef = -200*cp->getCusto();
						  }
						  else if( problemData->parametros->funcao_objetivo == 1 )
						  {
							  coef = 200*cp->getCusto();
						  }
						  						 
						  double lowerBound = 0.0;
						  double upperBound = 1.0;
					
#ifdef TATICO_COM_HORARIOS
						  if ( FIXAR_P1 && P_ATUAL > 1 )
						  {
							  int value = this->fixaLimitesVariavelPre( &v );
							  if ( value > 0 ) // fixa!
							  {
							  	  lowerBound = value;
								  upperBound = lowerBound;
							  }
						  }
						  else if ( discGrupoAlunosId < grupoAlunosId )
						  {
							  lowerBound = this->fixaLimitesVariavelPre( &v );
							  upperBound = lowerBound;
						  }

						  if (r>1)
						  {
								int value = this->fixaLimitesVariavelPre( &v );
								if ( value > 0 ) // fixa!
								{
						 			lowerBound = value;
									upperBound = lowerBound;
								}
						  }
#else
						  if ( FIXAR_P1 && P_ATUAL > 1 )
						  {
								int value = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
								if ( value > 0 ) // fixa!
								{
									lowerBound = value;
									upperBound = lowerBound;
								}
						  }
						  else if ( discGrupoAlunosId < grupoAlunosId )
						  {
							  lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							  upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
						  }
#endif
						  OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

						  lp->newCol( col );
						  num_vars++;
					   }
					}
				}
		    }
		}
   }

	return num_vars;
}

// fs_{d,s,oft}
int SolverMIP::cria_preVariavel_folga_turma_mesma_disc_oft_sala_dif( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;

    Disciplina * disciplina_equivalente = NULL;

    Curso * curso = NULL;
    Curriculo * curriculo = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;

		if ( cp->getId() != campusId )
	    {
		    continue;
	    }
		
		ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *itDisc;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion


					// A disciplina deve estar no conjunto de alunos atual ou anterior
					int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );
 					if ( discGrupoAlunosId > grupoAlunosId || 
						 discGrupoAlunosId == 0 )
					{
						continue;
					}

					// Listando todas as ofertas que contem uma disciplina especificada.
					GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ itDisc->getId() ];

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{
						Oferta* oft = *itOferta;

						if ( oft->campus != cp )
							continue;

						// Calculando P_{d,oft}
						int qtdDem = problemData->haDemandaDiscNoCjtAlunosPorOferta( disciplina->getId(), oft->getId(), discGrupoAlunosId );

						if ( qtdDem == 0 )
						{
							continue;
						}
						
						if ( itDisc->getNumTurmas() > 1 )
						{
							VariablePre v;
							v.reset();
							v.setType( VariablePre::V_PRE_SLACK_SALA);
							v.setDisciplina( *itDisc );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setOferta( oft );

							if ( vHashPre.find( v ) == vHashPre.end() )
							{
								vHashPre[v] = lp->getNumCols();

								double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{
									coef = -10*cp->getCusto();
								}
								else if( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = 10*cp->getCusto();
								}
						  
								double upperBound = itDisc->getNumTurmas();						 
								double lowerBound = 0.0;
					
#ifdef TATICO_COM_HORARIOS
								if ( FIXAR_P1 && P_ATUAL > 1 )
								{
									lowerBound = this->fixaLimitesVariavelPre( &v );									
								}
								else if ( discGrupoAlunosId < grupoAlunosId )
								{
									lowerBound = this->fixaLimitesVariavelPre( &v );
									upperBound = lowerBound;
								}

								if (r>1)
								{
									int value = this->fixaLimitesVariavelPre( &v );
									if ( value > 0 ) // fixa!
									{
						 				lowerBound = value;
										upperBound = lowerBound;
									}
								}
#else
								if ( FIXAR_P1 && P_ATUAL > 1 )
								{
									// Só posso fixar o lowerBound!
									lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
								}
								else if ( discGrupoAlunosId < grupoAlunosId )
								{
									lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
									upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
								}
#endif
								OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

								lp->newCol( col );
								num_vars++;
							}
						}
					}
				}
			}
		}
	}
	return num_vars;
}

// fs_{d,s}
int SolverMIP::cria_preVariavel_folga_turma_mesma_disc_sala_dif( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;

    Disciplina * disciplina_equivalente = NULL;

    Curso * curso = NULL;
    Curriculo * curriculo = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;

		if ( cp->getId() != campusId )
	    {
		    continue;
	    }
		
		ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *itDisc;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion
					
					// A disciplina deve estar no conjunto de alunos atual ou anterior
					int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );
 					if ( discGrupoAlunosId > grupoAlunosId || 
						 discGrupoAlunosId == 0 )
					{
						continue;
					}
				
					// Verificando existencia de demanda					
					if ( !problemData->haDemandaDiscNoCampus( disciplina->getId(), cp->getId() ) )
					{
						continue;
					}
						
					if ( itDisc->getNumTurmas() > 1 )
					{
						VariablePre v;
						v.reset();
						v.setType( VariablePre::V_PRE_SLACK_DISC_SALA);
						v.setDisciplina( *itDisc );
						v.setUnidade( *itUnidade );
						v.setSubCjtSala( *itCjtSala );

						if ( vHashPre.find( v ) == vHashPre.end() )
						{
							vHashPre[v] = lp->getNumCols();

							double coef = 0.0;

							if ( problemData->parametros->funcao_objetivo == 0 )
							{
								coef = -5*cp->getCusto();
							}
							else if( problemData->parametros->funcao_objetivo == 1 )
							{
								coef = 5*cp->getCusto();
							}
						  
							double upperBound = itDisc->getNumTurmas()-1;						 
							double lowerBound = 0.0;
					
#ifdef TATICO_COM_HORARIOS
							if ( FIXAR_P1 && P_ATUAL > 1 )
							{
								lowerBound = this->fixaLimitesVariavelPre( &v );									
							}
							else if ( discGrupoAlunosId < grupoAlunosId )
							{
								lowerBound = this->fixaLimitesVariavelPre( &v );
								upperBound = lowerBound;
							}

							if (r>1)
							{
								int value = this->fixaLimitesVariavelPre( &v );
								if ( value > 0 ) // fixa!
								{
						 			lowerBound = value;
									upperBound = lowerBound;
								}
							}
#else
							if ( FIXAR_P1 && P_ATUAL > 1 )
							{
								// Só posso fixar o lowerBound!
								lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							}
							else if ( discGrupoAlunosId < grupoAlunosId )
							{
								lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
								upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
							}
#endif
							OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

							lp->newCol( col );
							num_vars++;
						}
					}
				}
			}
		}
	}
	return num_vars;
}

// Hs_{cp}
int SolverMIP::cria_preVariavel_limite_sup_creds_sala( int campusId )
{
	int num_vars = 0;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus *cp = *itCampus;

	    if ( cp->getId() != campusId )
	    {
		   continue;
	    }

		VariablePre v;
		v.reset();
		v.setType( VariablePre::V_PRE_LIM_SUP_CREDS_SALA);
		v.setCampus( cp );

		if ( vHashPre.find( v ) == vHashPre.end() )
		{
			vHashPre[v] = lp->getNumCols();

			double upperbound = 0;

			ITERA_GGROUP_N_PT( itDisc, problemData->cp_discs[ cp->getId() ], int )
			{
				Disciplina* disciplina = problemData->refDisciplinas[ *itDisc ];
			
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					  !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				int nCreds = disciplina->getCredTeoricos() + disciplina->getCredPraticos();

				upperbound += nCreds * disciplina->getNumTurmas();				
			}

			double coef = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				coef = -cp->getCusto();
			}
			else if( problemData->parametros->funcao_objetivo == 1 )
			{
				coef = cp->getCusto();
			}
			
			double lowerBound;		
#ifdef TATICO_COM_HORARIOS
			lowerBound = this->fixaLimitesVariavelPre( &v );
#else
			lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
#endif
			OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperbound, ( char * )v.toString().c_str() );

			lp->newCol( col );
			num_vars++;
		}
	}

	return num_vars;
}

// c_{i,d,s,oft}
int SolverMIP::cria_preVariavel_aloca_alunos_oferta( int campusId, int grupoAlunosAtualId, int P_ATUAL, int r )
{
	int num_vars = 0;
	
	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
	    
		if ( cp->getId() != campusId )
	    {
		   continue;
	    }

		ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *it_disc;
					
					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion


					// A disciplina deve estar no conjunto de alunos atual ou anterior
					int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );
 					if ( discGrupoAlunosId > grupoAlunosAtualId || 
						 discGrupoAlunosId == 0 )
					{
						continue;
					}

					// Listando todas as ofertas que contem uma disciplina especificada.
					GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ disciplina->getId() ];

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{
							 Oferta* oft = *itOferta;

							 if ( oft->campus != cp )
								 continue;

							 // Calculando P_{d,oft}
							 int qtdDem = problemData->haDemandaDiscNoCjtAlunosPorOferta( disciplina->getId(), oft->getId(), discGrupoAlunosId );

							 if ( qtdDem == 0 )
							 {
								 continue;
							 }

							 for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							 {
								VariablePre v;
								v.reset();
								v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT );

								v.setTurma( turma );               // i
								v.setDisciplina( disciplina );     // d
								v.setOferta( *itOferta );          // oft
								v.setUnidade( *itUnidade );		   // u
								v.setSubCjtSala( *itCjtSala );	   // s
								
								if ( vHashPre.find(v) == vHashPre.end() )
								{
									vHashPre[v] = lp->getNumCols();
									
									double coef = 0.0;
									if ( problemData->parametros->funcao_objetivo == 0 )
									{
										coef = -1.0;
									}
									else if ( problemData->parametros->funcao_objetivo == 1 )
									{
										coef = 1.0;
									}
																		
									double lowerBound = 0.0;
									double upperBound = 1.0;
					
#ifdef TATICO_COM_HORARIOS
									if ( FIXAR_P1 && P_ATUAL > 1 )
									{
										lowerBound = this->fixaLimitesVariavelPre( &v );										
									}
									else if ( discGrupoAlunosId < grupoAlunosAtualId )
									{
										lowerBound = this->fixaLimitesVariavelPre( &v );
										upperBound = lowerBound;
									}
									if (r>1)
									{
										int value = this->fixaLimitesVariavelPre( &v );
										if ( value > 0 ) // fixa!
										{
						 					lowerBound = value;
											upperBound = lowerBound;
										}
									}
#else
									if ( FIXAR_P1 && P_ATUAL > 1 )
									{
										lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
									}
									else if ( discGrupoAlunosId < grupoAlunosAtualId )
									{
										lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
										upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
									}
#endif
									OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound,
										( char * )v.toString().c_str() );

									lp->newCol( col );

									num_vars += 1;
								}
							}
				     }
				}
			}
		}
   }

	return num_vars;
}

// xcs1_{s}, xcs2_{s}, xcs3_{s}
int SolverMIP::cria_preVariavel_soma_cred_sala( int campusId )
{
	int num_vars = 0;
   double upperBound1 = 0;
   double upperBound2 = 0;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
		{
			continue;
		}

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            VariablePre v;
            v.reset();
            v.setType( VariablePre::V_PRE_CRED_SALA_F1 );
            v.setCampus( *itCampus );          // c
            v.setUnidade( *itUnidade );		   // u
            v.setSubCjtSala( *itCjtSala );	   // s

            if ( vHashPre.find(v) == vHashPre.end() )
            {
               vHashPre[v] = lp->getNumCols();

               double coef = 0.0;

               double lowerBound = 0.0;
  
               double htps = itCjtSala->maxTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor );//itCjtSala->minLimiteTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor );//itCjtSala->maxTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor );

               upperBound1 = (int)(htps / 2.0 + 0.5);

               /*if ( FIXAR_P1 && P_ATUAL > 1 )
               {
               lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
               }
               else if ( discGrupoAlunosId < grupoAlunosId )
               {
               lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
               upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
               }*/

               OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound1,
                  ( char * )v.toString().c_str() );

               lp->newCol( col );

               num_vars ++;
            }

            v.reset();
            v.setType( VariablePre::V_PRE_CRED_SALA_F2 );
            v.setCampus( *itCampus );          // c
            v.setUnidade( *itUnidade );		   // u
            v.setSubCjtSala( *itCjtSala );	   // s

            if ( vHashPre.find(v) == vHashPre.end() )
            {
               vHashPre[v] = lp->getNumCols();

               double coef = 50.0;

               double lowerBound = 0.0;

               double htps = itCjtSala->maxTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor );//itCjtSala->minLimiteTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor );//itCjtSala->maxTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor );

               upperBound2 = (int)(htps * 0.9 + 0.5);
               upperBound2 -= upperBound1;

               /*if ( FIXAR_P1 && P_ATUAL > 1 )
               {
               lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
               }
               else if ( discGrupoAlunosId < grupoAlunosId )
               {
               lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
               upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
               }*/

               OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound2,
                  ( char * )v.toString().c_str() );

               lp->newCol( col );

               num_vars ++;
            }

            v.reset();
            v.setType( VariablePre::V_PRE_CRED_SALA_F3 );
            v.setCampus( *itCampus );          // c
            v.setUnidade( *itUnidade );		   // u
            v.setSubCjtSala( *itCjtSala );	   // s

            if ( vHashPre.find(v) == vHashPre.end() )
            {
               vHashPre[v] = lp->getNumCols();

               double coef = 1000.0;

               double lowerBound = 0.0;
               double upperBound = 1.0;

               double htps = itCjtSala->maxTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor ); //itCjtSala->minLimiteTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor );

               upperBound = htps - upperBound1 - upperBound2;

               /*if ( FIXAR_P1 && P_ATUAL > 1 )
               {
               lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
               }
               else if ( discGrupoAlunosId < grupoAlunosId )
               {
               lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
               upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
               }*/

               OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound,
                  ( char * )v.toString().c_str() );

               lp->newCol( col );

               num_vars ++;
            }
         }
      }
   }

	return num_vars;
}

// s_{i,d,a,cp}
int SolverMIP::cria_preVariavel_aloca_aluno_turma_disc( int campusId, int grupoAlunosAtualId, int P_ATUAL, int r )
{
	int num_vars = 0;

	Campus *cp = problemData->refCampus[campusId];

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para cada conjunto de alunos com id menor ou igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;

		if ( grupoAlunosId > grupoAlunosAtualId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;

				int turmaAluno = problemData->retornaTurmaDiscAluno( aluno, disciplina );
				
				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
					VariablePre v;
					v.reset();
					v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
					v.setAluno( aluno );
					v.setDisciplina( disciplina );
					v.setTurma( turma );
					v.setCampus( cp );

					if ( vHashPre.find( v ) == vHashPre.end() )
					{						
						// Se o aluno já estiver alocado, evita a criação da variavel para outras turmas
						if ( turmaAluno != -1 && turmaAluno != turma )
						{
							continue;
						}

						// passou: aluno não alocado em nenhuma turma ou alocado nesse turma corrente

						// Se não for permitido ao modelo inserir aluno de prioridade 2 em turma de p1,
						// e o aluno não tiver sido alocado pela heuristica, não cria a variavel
						if ( FIXAR_P1 && P_ATUAL > 1 && itAlDemanda->getPrioridade()==P_ATUAL )
						{							
							if ( turmaAluno == -1 ) // se não foi alocado pela heuristica
							{							
								int nAlunosTurmaDeP1 = problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId );
								if ( nAlunosTurmaDeP1 > 0 && !PERMITIR_INSERCAO_ALUNODEMANDAP2_EM_TURMAP1 )
								{
									continue;
								}
							}
						}					

						// Evita criação da variavel caso o aluno já possua o total de creditos pedidos em P1 atendidos
						// e a disciplina corrente não for uma das já atendidas.
						if ( P_ATUAL>1 )
						{
							double tempoTotalP1 = problemData->cargaHorariaOriginalRequeridaPorPrioridade( 1, aluno );
							double tempoJaAtendido = problemData->cargaHorariaJaAtendida( aluno );
							if ( tempoJaAtendido >= tempoTotalP1 &&
								 turmaAluno != turma )
								continue;
						}

						vHashPre[v] = lp->getNumCols();

						double coef = 0.0;												 
						double lowerBound = 0.0;
						double upperBound = 1.0;
					
#ifdef TATICO_COM_HORARIOS
						if ( FIXAR_P1 && P_ATUAL > 1 )
						{
							lowerBound = this->fixaLimitesVariavelPre( &v );
							if ( grupoAlunosId < grupoAlunosAtualId )
							{
								upperBound = lowerBound;
							}
						}
						else if ( grupoAlunosId < grupoAlunosAtualId )
						{
							lowerBound = this->fixaLimitesVariavelPre( &v );
							upperBound = lowerBound;
						}

						if (r>1)
						{
							if ( turmaAluno != -1 ) // alocado, fixa
							{
								lowerBound = 1.0 - 1e-5;
								upperBound = 1.0 + 1e-5;
							}
							else // não alocado, deixa livre para novas turmas e fixa igual a 0 para turmas existentes
							{
								int nAlunosTurmaDeP1 = problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId );
								if ( nAlunosTurmaDeP1 > 0 )
								{	// turma existente
									lowerBound = 0.0 - 1e-5;
									upperBound = 0.0 + 1e-5;
								}							
							}
						}

#else
						if ( FIXAR_P1 && P_ATUAL > 1 )
						{
							lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							if ( grupoAlunosId < grupoAlunosAtualId )
							{
								upperBound = lowerBound;
							}
						}
						else if ( grupoAlunosId < grupoAlunosAtualId )
						{
							lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
							upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
						}
#endif

						OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

						lp->newCol( col );
						num_vars++;
					}
				}
			}
		}
	}

	return num_vars;
}

// fda_{}
int SolverMIP::cria_preVariavel_folga_distribuicao_aluno( int campusId, int grupoAlunosAtualId, int P_ATUAL )
{
	int num_vars = 0;

	Campus *cp = problemData->refCampus[campusId];

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();

	// Para cada conjunto de alunos cp com id menor ou igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;

		if ( grupoAlunosId > grupoAlunosAtualId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;

				GGroup< AlunoDemanda*, LessPtr<AlunoDemanda> >::iterator itAlDemanda2 = itAlDemanda;
				itAlDemanda2++;

				for(; itAlDemanda2 != aluno->demandas.end(); itAlDemanda2++)
				{
					Disciplina *disciplina2 = (*itAlDemanda2)->demanda->disciplina;

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
						{
							VariablePre v;
							v.reset();
							v.setType( VariablePre::V_PRE_FOLGA_DISTR_ALUNOS );
							v.setDisciplina( disciplina );
							v.setTurma( turma );
							v.setDisciplina2( disciplina2 );
							v.setTurma2( turma2 );
							//v.setCampus( cp );

							if ( vHashPre.find( v ) == vHashPre.end() )
							{
								vHashPre[v] = lp->getNumCols();

								double coef = 100.0;

								double lowerBound = 0.0;
								double upperBound = 1.0;

								/*if ( FIXAR_P1 && P_ATUAL > 1 )
								{
								lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
								}
								else if ( grupoAlunosId < grupoAlunosAtualId )
								{
								lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
								upperBound = this->fixaLimiteSuperiorVariavelPre_CjtAlunos( &v );
								}*/

								OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

								lp->newCol( col );
								num_vars++;
							}
						}
					}
				}
			}
		}
	}

	return num_vars;
}


// fpi_{a}
// Só para P2 em diante
int SolverMIP::cria_preVariavel_folga_prioridade_inf( int campusId, int prior, int grupoAlunosAtualId )
{
	int num_vars = 0;

	if ( prior < 2 )
	{
	   return num_vars;
	}

	Campus *cp = problemData->refCampus[campusId];

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para cada conjunto de alunos cp com id menor ou igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;

		if ( grupoAlunosId > grupoAlunosAtualId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			VariablePre v;
			v.reset();
			v.setType( VariablePre::V_PRE_SLACK_PRIOR_INF );
			v.setAluno( aluno );
			v.setCampus( cp );

			if ( vHashPre.find( v ) == vHashPre.end() )
			{
				vHashPre[v] = lp->getNumCols();					

				double upperBound = 0.0;						 
				double lowerBound = 0.0;

				if ( grupoAlunosId < grupoAlunosAtualId )
				{
#ifdef TATICO_COM_HORARIOS
					lowerBound = this->fixaLimitesVariavelPre( &v );
#else
					lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
#endif
				}
								
				double cargaHorariaNaoAtendida = problemData->cargaHorariaNaoAtendidaPorPrioridade( 1, aluno->getAlunoId() );	
				if ( cargaHorariaNaoAtendida == 0 ) // se não houver folga de demanda de P1
				{
					continue;
				}

				int tempoMaxCred=0;
				int totalCreditosP2 = 0;
				ITERA_GGROUP_LESSPTR( itAlunoDem, aluno->demandas, AlunoDemanda )
				{
					if ( itAlunoDem->getPrioridade() != prior )
						continue;

					int nCreds = itAlunoDem->demanda->disciplina->getTotalCreditos();
					int tempo = itAlunoDem->demanda->disciplina->getTempoCredSemanaLetiva();
					totalCreditosP2 += nCreds;

					if ( tempoMaxCred < tempo )
						tempoMaxCred=tempo;
				}							
				if ( totalCreditosP2 == 0 ) // se não houver demanda de P2 para o aluno
					continue;
				
				// Limita o tanto de carga horária do aluno que pode ser excedido em P2 em 2 créditos.
				upperBound = tempoMaxCred*2;

				double coef = 0.0;
				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					double custo = cp->getCusto();
							 
					coef = -50 * custo * totalCreditosP2;
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					double custo = cp->getCusto();

					coef = 5 * custo * totalCreditosP2;
				}	

				OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			}
		}
	}

	return num_vars;
}

// fps_{a}
// Só para P2 em diante
int SolverMIP::cria_preVariavel_folga_prioridade_sup( int campusId, int prior, int grupoAlunosAtualId )
{
	int num_vars = 0;
	
	if ( prior < 2 )
	{
	   return num_vars;
	}

	Campus *cp = problemData->refCampus[campusId];

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para cada conjunto de alunos cp com id menor ou igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;

		if ( grupoAlunosId > grupoAlunosAtualId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			VariablePre v;
			v.reset();
			v.setType( VariablePre::V_PRE_SLACK_PRIOR_SUP );
			v.setAluno( aluno );
			v.setCampus( cp );

			if ( vHashPre.find( v ) == vHashPre.end() )
			{
				vHashPre[v] = lp->getNumCols();
				
				double upperBound = 0.0;						 
				double lowerBound = 0.0;

				if ( grupoAlunosId < grupoAlunosAtualId )
				{
#ifdef TATICO_COM_HORARIOS
					lowerBound = this->fixaLimiteInferiorVariavelPre_CjtAlunos( &v );
#else
					lowerBound = this->fixaLimitesVariavelPre( &v );
#endif
				}

				int totalCreditos = problemData->creditosNaoAtendidosPorPrioridade( 1, aluno->getAlunoId() );
				double cargaHorariaNaoAtendida = problemData->cargaHorariaNaoAtendidaPorPrioridade( 1, aluno->getAlunoId() );	
				if ( cargaHorariaNaoAtendida == 0 ) // se não houver folga de demanda de P1
				{
					continue;
				}

				upperBound = cargaHorariaNaoAtendida;

				double coef = 0.0;
				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					double custo = cp->getCusto();
							 
					coef = -60 * custo * totalCreditos;
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					double custo = cp->getCusto();

					coef = 6 * custo * totalCreditos;
				}	

				OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			}
		}
	}

	return num_vars;
}


// ft_{i,d,cp}
// Só para P2 em diante
int SolverMIP::cria_preVariavel_folga_abre_turma_sequencial( int campusId, int cjtAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;
	
	if ( P_ATUAL < 2 && r==1 )
	{
	   return num_vars;
	}

   std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_disciplina, it_CpDisc->second, int )
      {
		 Disciplina *disciplina = problemData->refDisciplinas[ *it_disciplina ];
		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
		 	continue;
		 }
		 #pragma endregion
	 
		 int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );

 		 if ( discGrupoAlunosId > cjtAlunosId || 
			  discGrupoAlunosId == 0 )
		 {
			 continue;
		 }
		 
         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            VariablePre v;
            v.reset();
            v.setType( VariablePre::V_PRE_FOLGA_ABRE_TURMA_SEQUENCIAL );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( cp );				// cp

            if ( vHashPre.find(v) == vHashPre.end() )
            {
                lp->getNumCols();
                vHashPre[v] = lp->getNumCols();

			    double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{							 
					coef = -10 * (turma+1);
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{					
					coef = 10 * (turma+1);
				}						                
						 
				double lowerBound = 0.0;
				double upperBound = 1.0;

				OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound,
                     ( char * )v.toString().c_str() );

                lp->newCol( col ); 
                
				num_vars++;
            }
         }
      }
   }

	return num_vars;

}


// w_{i,d,i',d'}
/* // Usada só para p2
int SolverMIP::cria_preVariavel_turmas_compartilhadas( int campusId, int cjtAlunosId, int P_ATUAL )
{
	int num_vars = 0;
	
	if ( P_ATUAL < 2 )
	{
	   return num_vars;
	}

   std::map< int, GGroup< int > >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( itDisc1, it_CpDisc->second, int )
      {
		 Disciplina *disciplina1 = problemData->refDisciplinas[ *itDisc1 ];

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina1 ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina1 ) )
		 {
		 	continue;
		 }
		 #pragma endregion
	 
		 int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina1->getId() );

 		 if ( discGrupoAlunosId > cjtAlunosId || 
			  discGrupoAlunosId == 0 )
		 {
			 continue;
		 }
		 
		 bool haDemandaDisc1P2 = problemData->haDemandaP2DiscNoCampus( campusId, P_ATUAL, disciplina1 );

         for ( int turma1 = 0; turma1 < disciplina1->getNumTurmas(); turma1++ )
         {
			std::pair<ConjuntoSala*, GGroup<int> > atends1 = retornaSalaEDiasDeAtendimentoTaticoAnterior( turma1, disciplina1, cp );
						
			ConjuntoSala* cjtSala1 = atends1.first;
			GGroup<int> dias1 = atends1.second;

			ITERA_GGROUP_INIC_N_PT( itDisc2, itDisc1, it_CpDisc->second, int )
			{
				Disciplina *disciplina2 = problemData->refDisciplinas[ *itDisc2 ];
		 
				if ( disciplina2 == disciplina1 )
					continue;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina2 ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina2 ) )
				{
		 			continue;
				}
				#pragma endregion

				bool haDemandaDisc2P2 = problemData->haDemandaP2DiscNoCampus( campusId, P_ATUAL, disciplina2 );

				// Só cria a variavel se pelo menos 1 das disciplinas tiver demanda de prioridade 2
				if ( !haDemandaDisc1P2 && !haDemandaDisc2P2 )
				{
					continue;
				}

				discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina2->getId() );

 				if ( discGrupoAlunosId > cjtAlunosId || 
					discGrupoAlunosId == 0 )
				{
					continue;
				}
		 
				for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
				{
					std::pair<ConjuntoSala*, GGroup<int> > atends2 = retornaSalaEDiasDeAtendimentoTaticoAnterior( turma2, disciplina2, cp );
						
					ConjuntoSala* cjtSala2 = atends2.first;
					GGroup<int> dias2 = atends2.second;

					// Se os dois atendimentos já existirem: 
					// Esta variavel por enquanto só é usada para atendimentos em salas diferentes e no mesmo dia
					if ( cjtSala1 != NULL && cjtSala2 != NULL )
					{
						bool diaEmComum = false;
						ITERA_GGROUP_N_PT( itDia1, dias1, int )
						{
							if ( dias2.find( *itDia1 ) != dias2.end() )
							{
								diaEmComum = true;
							}
						}

						if ( cjtSala1 == cjtSala2 || !diaEmComum )
						{
							continue;
						}
					}

					// Esta variavel por enquanto só sera usada se pelo menos uma das turmas já existir de p1
					if ( cjtSala1 == NULL && cjtSala2 == NULL )
					{					
						continue;
					}										

					VariablePre v;
					v.reset();
					v.setType( VariablePre::V_PRE_TURMAS_COMPART );
					v.setTurma1( turma1 );            // i1
					v.setDisciplina1( disciplina1 );  // d1
					v.setTurma2( turma2 );            // i2
					v.setDisciplina2( disciplina2 );  // d2					


					if ( vHashPre.find(v) == vHashPre.end() )
					{			
						lp->getNumCols();
						vHashPre[v] = lp->getNumCols();

						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{							 
							coef = -1.0;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{					
							coef = 1.0;
						}						                
						 
						double lowerBound = 0.0;
						double upperBound = 1.0;

						// Se as turmas já estão alocadas com alunos em comum, já fixa a variavel
						if ( problemData->possuiAlunosEmComum( turma1, disciplina1, turma2, disciplina2, cp ) )						
						{
							lowerBound = 1.0 - 1e-8;
							upperBound = 1.0 + 1e-8;						
						}

						OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

						lp->newCol( col ); 
                
						num_vars++;
					}
				}
			}
         }
      }
   }

	return num_vars;
}
*/

// w_{i,d,i',d'}
int SolverMIP::cria_preVariavel_turmas_compartilhadas( int campusId, int cjtAlunosId, int P_ATUAL )
{
	int num_vars = 0;

   std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( itDisc1, it_CpDisc->second, int )
      {
		 Disciplina *disciplina1 = problemData->refDisciplinas[ *itDisc1 ];

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina1 ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina1 ) )
		 {
		 	continue;
		 }
		 #pragma endregion
	 
		 int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina1->getId() );

 		 if ( discGrupoAlunosId > cjtAlunosId || 
			  discGrupoAlunosId == 0 )
		 {
			 continue;
		 }

		 ITERA_GGROUP_INIC_N_PT( itDisc2, itDisc1, it_CpDisc->second, int )
		 {
			Disciplina *disciplina2 = problemData->refDisciplinas[ *itDisc2 ];
		 
			if ( disciplina2 == disciplina1 )
				continue;

			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( disciplina2 ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina2 ) )
			{
		 		continue;
			}
			#pragma endregion
								
			discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina2->getId() );

 			if ( discGrupoAlunosId > cjtAlunosId || 
				discGrupoAlunosId == 0 )
			{
				continue;
			}
		 	
			bool demandasAlunoEmComum = problemData->possuiDemandasAlunoEmComum( disciplina1, disciplina2, campusId, P_ATUAL );

			if ( !demandasAlunoEmComum )
			{
				continue;
			}

			for ( int turma1 = 0; turma1 < disciplina1->getNumTurmas(); turma1++ )
			{		 
				for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
				{
					VariablePre v;
					v.reset();
					v.setType( VariablePre::V_PRE_TURMAS_COMPART );
					v.setTurma1( turma1 );            // i1
					v.setDisciplina1( disciplina1 );  // d1
					v.setTurma2( turma2 );            // i2
					v.setDisciplina2( disciplina2 );  // d2					
					
					if ( vHashPre.find(v) == vHashPre.end() )
					{			
						lp->getNumCols();
						vHashPre[v] = lp->getNumCols();

						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{							 
							coef = -400.0;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{					
							coef = 400.0;
						}						                
						 
						double lowerBound = 0.0;
						double upperBound = 1.0;

						// Se as turmas já estão alocadas com alunos em comum, já fixa a variavel
						if ( problemData->possuiAlunosEmComum( turma1, disciplina1, turma2, disciplina2, cp ) )						
						{
							lowerBound = 1.0 - 1e-8;
							upperBound = 1.0 + 1e-8;						
						}

						OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

						lp->newCol( col ); 
                
						num_vars++;
					}
				}
			}
         }
      }
   }

	return num_vars;	
}

// as_{a,s}
int SolverMIP::cria_preVariavel_aluno_sala( int campusId, int grupoAlunosAtualId, int P_ATUAL )
{
	int num_vars = 0;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;

		if ( cp->getId() != campusId )
	    {
		    continue;
	    }
		
		ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
					itMapCjtAlunos = problemData->cjtAlunos.begin();
	
				// Para cada conjunto de alunos com id menor ou igual ao atual
				for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
				{
					int grupoAlunosId = itMapCjtAlunos->first;

					if ( grupoAlunosId > grupoAlunosAtualId )
					{
						break;
					}

					// Para cada aluno do conjunto
					GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
					ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
					{
						Aluno *aluno = *itAluno;

						if ( aluno->getOferta()->getCampusId() != campusId )
						{
							continue;
						}

						VariablePre v;
						v.reset();
						v.setType( VariablePre::V_PRE_ALUNO_SALA);
						v.setAluno( aluno );
						v.setUnidade( *itUnidade );
						v.setSubCjtSala( *itCjtSala );

						if ( vHashPre.find( v ) == vHashPre.end() )
						{
							vHashPre[v] = lp->getNumCols();

							double coef = 0.0;

							if ( problemData->parametros->funcao_objetivo == 0 )
							{
								coef = -cp->getCusto()*2;
							}
							else if( problemData->parametros->funcao_objetivo == 1 )
							{
								coef = cp->getCusto()*2;
							}
						  
							double upperBound = 1.0;						 
							double lowerBound = 0.0;
					
							OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

							lp->newCol( col );
							num_vars++;
						}
					}
				}
			}
		}
	}
	return num_vars;
}

// f_{i,d,cp} -> indica se há alunos formandos na turma
int SolverMIP::cria_preVariavel_formandosNaTurma( int campusId, int grupoAlunosId, int P_ATUAL, int r )
{
	int num_vars = 0;
	
	if ( !problemData->parametros->violar_min_alunos_turmas_formandos )
		return num_vars;

	if ( P_ATUAL==1 && r==1 ) // só considera formandos a partir da segunda rodada
		return num_vars;

	std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_disciplina, it_CpDisc->second, int )
      {
		 Disciplina *disciplina = problemData->refDisciplinas[ *it_disciplina ];
		 		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
		 	continue;
		 }
		 #pragma endregion

		 int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );
		 
 		 if ( discGrupoAlunosId > grupoAlunosId || 
			  discGrupoAlunosId == 0 )
		 {
			 continue;
		 }
		 
		 if ( ! problemData->haDemandaPorFormandos( disciplina, cp, P_ATUAL ) )
			 continue;

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
			 if ( !problemData->possuiAlunoFormando( turma, disciplina, cp ) &&
				  !problemData->haAlunoFormandoNaoAlocado( disciplina, campusId, P_ATUAL ) )
			 {
				 continue;
			 }

            VariablePre v;
            v.reset();
            v.setType( VariablePre::V_PRE_FORMANDOS_NA_TURMA );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( cp );				// cp

            if ( vHashPre.find(v) == vHashPre.end() )
            {
                lp->getNumCols();
                vHashPre[v] = lp->getNumCols();

			    double coef = 0.0;					                
						 
				double lowerBound = 0.0;
				double upperBound = 1.0;

				int value = this->fixaLimitesVariavelPre( &v );
				if ( value > 0 ) // fixa!
				{
					lowerBound = value;
					upperBound = lowerBound;
				}

				OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound,
                     ( char * )v.toString().c_str() );

                lp->newCol( col ); 
                
				num_vars++;
            }
         }
      }
   }

	return num_vars;
}


/********************************************************************
**                    Restrições do pre-Tatico                     **
*********************************************************************/

int SolverMIP::cria_preRestricoes( int campusId, int prioridade, int cjtAlunosId, int r )
{
	int restricoes = 0;
	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_restricoes
	int numRestAnterior = 0;
#endif

	timer.start();
	restricoes += cria_preRestricao_carga_horaria( campusId, cjtAlunosId );					// Restrição 1.1
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.1\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_max_cred_sala_sl( campusId, cjtAlunosId );				// Restrição 1.2
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_ativacao_var_o( campusId, cjtAlunosId );				// Restrição 1.3
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.3\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_evita_mudanca_de_sala( campusId, cjtAlunosId );			// Restrição 1.4
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.4\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_aluno_curso_disc( campusId, cjtAlunosId );				// Restrição 1.6
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.6\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_cap_sala( campusId, cjtAlunosId );						// Restrição 1.7
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.7\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_compartilhamento_incompat( campusId, cjtAlunosId );		// Restrição 1.8
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.8\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif    

	timer.start();
	restricoes += cria_preRestricao_proibe_compartilhamento( campusId, cjtAlunosId );		// Restrição 1.9
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.9\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_ativacao_var_z( campusId, cjtAlunosId );				// Restrição 1.10
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.10\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_evita_turma_disc_camp_d( campusId, cjtAlunosId );		// Restrição 1.11
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.11\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_limita_abertura_turmas( campusId, cjtAlunosId, prioridade, r );		// Restrição 1.12
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.12\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_abre_turmas_em_sequencia( campusId, cjtAlunosId, prioridade, r );		// Restrição 1.13
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.13\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   


	timer.start();
	restricoes += cria_preRestricao_limite_sup_creds_sala( campusId, cjtAlunosId );		// Restrição 1.15
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.15\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   


   timer.start();
   restricoes += cria_preRestricao_soma_cred_sala( campusId, cjtAlunosId );		// Restrição 1.26
   timer.stop();
   dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
   std::cout << "numRest \"1.26\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
   numRestAnterior = restricoes;
#endif


   if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
   {
		timer.start();
		restricoes += cria_preRestricao_turma_mesma_disc_oft_sala_dif( campusId, cjtAlunosId );		// Restrição 1.14
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.14\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
	#endif


		timer.start();
		restricoes += cria_preRestricao_cap_aloc_dem_disc_oft( campusId );				// Restrição 1.5
		timer.stop();
		dif = timer.getCronoCurrSecs();

	   #ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
	   #endif

		timer.start();
		restricoes += cria_preRestricao_ativa_var_aloc_aluno_oft( campusId, cjtAlunosId );		// Restrição 1.16
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.16\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
	#endif

		timer.start();
		restricoes += cria_preRestricao_fixa_nao_compartilhamento( campusId );				// Restrição 1.17
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.17\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif   
   }

   else if ( problemData->parametros->otimizarPor == "ALUNO" )
   {
		timer.start();
	//	restricoes += cria_preRestricao_turma_mesma_disc_sala_dif( campusId, cjtAlunosId );		// Restrição 1.14
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.14\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
	#endif


		timer.start();
		restricoes += cria_preRestricao_cap_aloc_dem_disc_aluno( campusId, cjtAlunosId );				// Restrição 1.5
		timer.stop();
		dif = timer.getCronoCurrSecs();

	   #ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
	   #endif

		timer.start();
		restricoes += cria_preRestricao_atendimento_aluno( campusId, cjtAlunosId );				// Restrição 1.18
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.18\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif   

      timer.start();
		restricoes += cria_preRestricao_limite_cred_aluno( campusId, cjtAlunosId, prioridade ); // Restrição 1.27
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.27\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif  

	   /* // Não precisa dessa restrição, caso a restrição de folga de demanda já
		  // garanta a soma dos "s" menor ou igual a 1

	   restricoes += cria_preRestricao_aluno_unica_turma_disc( campusId, cjtAlunosId );		// Restrição 1.19

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.19\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif
		*/

		timer.start();
		restricoes += cria_preRestricao_aluno_discPraticaTeorica( campusId, cjtAlunosId );		// Restrição 1.20
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.20\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif	   


		timer.start();
		restricoes += cria_preRestricao_prioridadesDemanda( campusId, prioridade, cjtAlunosId );		// Restrição 1.21
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.21\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif

		timer.start();
		restricoes += cria_preRestricao_ativa_var_compart_turma( campusId, cjtAlunosId, prioridade );		// Restrição 1.23
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.23\": " << (restricoes - numRestAnterior) << std::endl;
		numRestAnterior = restricoes;
		#endif
		   
		timer.start();
		if ( campusId==19 )
			restricoes += cria_preRestricao_aluno_sala( campusId, cjtAlunosId );		// Restrição 1.23
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.24\": " << (restricoes - numRestAnterior) << std::endl;
		numRestAnterior = restricoes;
		#endif
		   

		timer.start();
		restricoes += cria_preRestricao_formandos( campusId, cjtAlunosId, prioridade, r );
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.25\": " << (restricoes - numRestAnterior) << std::endl;
		numRestAnterior = restricoes;
		#endif
		   

	   if ( FIXAR_TATICO_P1 && prioridade > 1 )
	   {
		   /*
			timer.start();
			restricoes += cria_preRestricao_evita_sobrepos_turmas_mesmos_alunos( campusId, cjtAlunosId, prioridade );		// Restrição 1.22
			timer.stop();
			dif = timer.getCronoCurrSecs();

			#ifdef PRINT_cria_restricoes
		   std::cout << "numRest \"1.22\": " << (restricoes - numRestAnterior) << std::endl;
		   numRestAnterior = restricoes;
			#endif
			*/
		   
			timer.start();
			restricoes += cria_preRestricao_maxCredsAlunoDia( campusId, cjtAlunosId, prioridade );		// Restrição 1.24
			timer.stop();
			dif = timer.getCronoCurrSecs();

			#ifdef PRINT_cria_restricoes
		   std::cout << "numRest \"1.26\": " << (restricoes - numRestAnterior) << std::endl;	
		   numRestAnterior = restricoes;
			#endif
		   
	   }

	   /*timer.start();
	   restricoes += cria_preRestricao_distribuicao_aluno( campusId, cjtAlunosId );		// Restrição 1.25
	   timer.stop();
	   dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.26\": " << (restricoes - numRestAnterior) << std::endl;	
	   numRestAnterior = restricoes;
#endif*/

   }

	return restricoes;
}

// Restrição 1.1
int SolverMIP::cria_preRestricao_carga_horaria( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   int nnz;
   char name[ 100 ];

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );
		 		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			 continue;
		 }
		 #pragma endregion
		 
		  map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		    itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		  if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		  {
			  if ( itMapDiscCjt->second	!= cjtAlunosId &&
				   NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				  continue;
		  }
		  else
		  {
			  if ( problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
				std::cout<<"\nERROR: disciplina "<<disciplina->getId()<<"nao pertence a nenhum cjt\n";
			  continue;
		  }
		 
         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {	 

            c.reset();
            c.setType( ConstraintPre::C_PRE_CARGA_HORARIA );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHashPre.find( c ) != cHashPre.end() )
            {
               continue;
            }

			nnz = disciplina->getNSalasAptas();

            OPT_ROW row( nnz + 1, OPT_ROW::EQUAL , 0 , name );

            // ---

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
				    if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
					     itCjtSala->disciplinas_associadas.end() )
					{
						continue;
				    }

					v.reset();
					v.setType( VariablePre::V_PRE_CREDITOS );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );             

					it_v = vHashPre.find( v );
					if ( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
               }
            }

            // ---

            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );

            v.setCampus( *itCampus );
            v.setDisciplina( disciplina );
            v.setTurma( turma );

            it_v = vHashPre.find( v );
            if( it_v != vHashPre.end() )
            {
               row.insert( it_v->second, -( disciplina->getCredPraticos() + 
											disciplina->getCredTeoricos() ) );
            }

            // ---

            if ( row.getnnz() != 0 )
            {
               cHashPre[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

	return restricoes;
}

// Restrição 1.2
int SolverMIP::cria_preRestricao_max_cred_sala_sl( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   int nnz;
   char name[ 100 ];

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			ConstraintPre c;
			c.reset();
			c.setType( ConstraintPre::C_PRE_MAX_CRED_SALA );
			
			c.setUnidade( *itUnidade );
			c.setSubCjtSala( *itCjtSala );

			sprintf( name, "%s", c.toString().c_str() ); 
			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			double htps = itCjtSala->minLimiteTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor );//itCjtSala->maxTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor ); 

			nnz = itCjtSala->disciplinas_associadas.size() * 5; // estimando em media 5 turmas por disciplina

			OPT_ROW row( nnz, OPT_ROW::LESS , htps, name );

            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disc );
			   
			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
			   {
					continue;
			   }
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                     VariablePre v;
                     v.reset();
                     v.setType( VariablePre::V_PRE_CREDITOS );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setUnidade( *itUnidade );     // u
                     v.setSubCjtSala( *itCjtSala );  // tps

					 it_v = vHashPre.find( v );
					 if ( it_v != vHashPre.end() )
					 {
						 row.insert( it_v->second, disciplina->getTempoCredSemanaLetiva() );
					 }       
                }
            }

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}
         }
      }
   }

	return restricoes;
}

// Restrição 1.3
int SolverMIP::cria_preRestricao_ativacao_var_o( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disc );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
				itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

				if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
				{
					if ( itMapDiscCjt->second	!= cjtAlunosId &&
						NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
						continue;
				}
				else
				{
					continue;
				}

                for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                {
					c.reset();
					c.setType( ConstraintPre::C_PRE_VAR_O );

					c.setUnidade( *itUnidade );
					c.setSubCjtSala( *itCjtSala );
					c.setDisciplina( disciplina );
					c.setTurma( turma );

					sprintf( name, "%s", c.toString().c_str() ); 
					if ( cHashPre.find( c ) != cHashPre.end() )
					{
						continue;
					}

					nnz = 2;

					OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0, name );

					v.reset();
					v.setType( VariablePre::V_PRE_OFERECIMENTO );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );

					it_v = vHashPre.find( v );
					if( it_v != vHashPre.end() )
					{
                  row.insert( it_v->second, - ( disciplina->getCredPraticos() + 
													  disciplina->getCredTeoricos() ) );
					}

					v.reset();
					v.setType( VariablePre::V_PRE_CREDITOS );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );

					it_v = vHashPre.find( v );
					if ( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, 1.0 );
					}

					if ( row.getnnz() != 0 )
					{
						cHashPre[ c ] = lp->getNumRows();

						lp->addRow( row );
						restricoes++;
					}
				}
            }
         }
      }
   }

	return restricoes;
}

// Restrição 1.4
int SolverMIP::cria_preRestricao_evita_mudanca_de_sala( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   int nnz;
   char name[ 100 ];

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
		 	 continue;
		 }
		 #pragma endregion

		  map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		    itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		  if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		  {
			  if ( itMapDiscCjt->second	!= cjtAlunosId &&
				   NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				  continue;
		  }
		  else
		  {
			  continue;
		  }

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( ConstraintPre::C_EVITA_MUDANCA_DE_SALA );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHashPre.find( c ) != cHashPre.end() )
            {
               continue;
            }

			nnz = disciplina->getNSalasAptas();

            OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );
			
            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
				    if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
					     itCjtSala->disciplinas_associadas.end() )
					{
						continue;
				    }

					v.reset();
					v.setType( VariablePre::V_PRE_OFERECIMENTO );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );             

					it_v = vHashPre.find( v );
					if ( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
               }
            }
			
            if ( row.getnnz() != 0 )
            {
               cHashPre[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

// Restrição 1.5
/*
	Alocação de demanda por oferta
*/
int SolverMIP::cria_preRestricao_cap_aloc_dem_disc_oft( int campusId  )
{
    int restricoes = 0;
    char name[ 100 ];
    int nnz = 0;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itOferta, problemData->ofertas, Oferta )
   {
	   if ( itOferta->getCampusId() != campusId )
	   {
			continue;
	   }

      map < Disciplina*, int, LessPtr< Disciplina > >::iterator itPrdDisc = 
         itOferta->curriculo->disciplinas_periodo.begin();

      for (; itPrdDisc != itOferta->curriculo->disciplinas_periodo.end(); itPrdDisc++ )
      {
		  disciplina = itPrdDisc->first;

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
		 	 continue;
		 }
		 #pragma endregion

         c.reset();
         c.setType( ConstraintPre::C_PRE_CAP_ALOC_DEM_DISC );

         c.setOferta( *itOferta );
         c.setDisciplina( disciplina );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHashPre.find( c ) != cHashPre.end() )
         {
            continue;
         }

         if ( disciplina->getNumTurmas() <= 0 )
         {
            continue;
         }

         nnz = disciplina->getNumTurmas();
         int rhs = 0;

         // Calculando P_{d,o}
         ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
         {
            if ( itDem->disciplina->getId() == disciplina->getId()
               && itDem->getOfertaId() == itOferta->getId() )
            {
               rhs += itDem->getQuantidade();
            }
         }

         OPT_ROW row( nnz , OPT_ROW::EQUAL, rhs , name );

		 ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
		 {
			if ( itCampus->getId() != campusId )
			{
				continue;
			}

			Campus* cp = *itCampus;
		
			ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
			{
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{
				    if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
					     itCjtSala->disciplinas_associadas.end() )
					{
						continue;
				    }
					
					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						v.reset();
						v.setType( VariablePre::V_PRE_ALUNOS );

						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setOferta( *itOferta );
						v.setUnidade( *itUnidade );
						v.setSubCjtSala( *itCjtSala );

						it_v = vHashPre.find( v );
						if ( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1.0 );
						}
					}
				}
			}
		 }

         v.reset();
         v.setType( VariablePre::V_PRE_SLACK_DEMANDA );
         v.setDisciplina( disciplina );
         v.setOferta( *itOferta );

         it_v = vHashPre.find( v );
         if( it_v != vHashPre.end() )
         {
            row.insert( it_v->second, 1.0 );
         }

         if ( row.getnnz() != 0 )
         {
            cHashPre[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

	return restricoes;
}

/*
	Alocação de demanda por aluno
*/
int SolverMIP::cria_preRestricao_cap_aloc_dem_disc_aluno( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
      
   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;   

   Campus *campus = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = itAlDemanda->demanda->disciplina;

			// Pula a restrição caso a disciplina seja de conjuntoAluno anterior

			map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
			itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

			if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
			{
				if ( itMapDiscCjt->second != cjtAlunosId &&
					NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
					continue;
			}
			else
			{
				continue;
			}

			c.reset();
			c.setType( ConstraintPre::C_PRE_CAP_ALOC_DEM_DISC );
			c.setAluno( aluno );
			c.setDisciplina( disciplina );
			c.setCampus( campus );

			sprintf( name, "%s", c.toString().c_str() ); 

			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			nnz = disciplina->getNumTurmas() + 1;

			OPT_ROW row( nnz, OPT_ROW::EQUAL , 1.0 , name );

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( disciplina );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			}

			v.reset();
			v.setType( VariablePre::V_PRE_SLACK_DEMANDA );
			v.setDisciplina( disciplina );
			v.setAluno( aluno );

			it_v = vHashPre.find( v );
			if( it_v != vHashPre.end() )
			{
				row.insert( it_v->second, 1.0 );
			}

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
	}

	return restricoes;
}


// Restrição 1.6
int SolverMIP::cria_preRestricao_aluno_curso_disc( int campusId, int cjtAlunosId  )
{
	int restricoes = 0;

    char name[ 100 ];
    int nnz = 0;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
	{		
		Disciplina* disciplina = *itDisc;

		if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
			 problemData->cp_discs[ campusId ].end() )
		{
			continue;
		}

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion
		
		// Pula a restrição caso a disciplina seja de conjuntoAluno anterior

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second != cjtAlunosId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
		{
			Curso *curso = *itCurso;

			if ( !curso->possuiDisciplina( disciplina ) )
				continue;

			// Calculando P_{d,o}
			int qtdDem = 0;
			ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
			{
				if ( itDem->disciplina->getId() == disciplina->getId() &&
					 itDem->oferta->getCursoId() == curso->getId() &&
					 itDem->oferta->getCampusId() == campusId )
				{
					qtdDem += itDem->getQuantidade();
				}
			}

			if ( qtdDem <= 0 )
			{
				continue;
			}

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				// -------------------------------------------------
				c.reset();
				c.setType( ConstraintPre::C_ALUNO_OFT_DISC );

				c.setCurso( curso );
				c.setDisciplina( disciplina );
				c.setTurma( turma );

				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHashPre.find( c ) != cHashPre.end() )
				{
					continue;
				}
						 
				nnz = 100;

				OPT_ROW row( nnz , OPT_ROW::LESS, 0.0 , name );

				v.reset();
				v.setType( VariablePre::V_PRE_ALOC_ALUNO ); // b_{i,d,c}
				v.setTurma( turma );
				v.setDisciplina( disciplina );
				v.setCurso( curso );

				it_v = vHashPre.find(v);
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -qtdDem );
				}

				GGroup< Oferta*, LessPtr<Oferta> > ofertas = problemData->ofertasDisc[ disciplina->getId() ];

				ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
				{
					if ( itOferta->getCursoId() != curso->getId() )
						continue;

					if ( itOferta->campus->getId() != campusId )
						continue;

					ITERA_GGROUP_LESSPTR( itUnidade, itOferta->campus->unidades, Unidade )
					{
						ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
						{
							 if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
							 	  itCjtSala->disciplinas_associadas.end() )
							 {
								 continue;
							 }
						 
							 v.reset();
							 v.setType( VariablePre::V_PRE_ALUNOS ); // a_{i,d,oft,s}
							 v.setTurma( turma );
							 v.setDisciplina( disciplina );
							 v.setOferta( *itOferta );
							 v.setUnidade( *itUnidade );
							 v.setSubCjtSala( *itCjtSala );

							 it_v = vHashPre.find( v );
							 if ( it_v != vHashPre.end() )
							 {
						 		 row.insert( it_v->second, 1.0 );
							 }
						}
					}
				}

				if ( row.getnnz() != 0 )
				{
					cHashPre[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}				
				// -------------------------------------------------
		   }
       }
   }

	return restricoes;
}

// Restrição 1.7
int SolverMIP::cria_preRestricao_cap_sala( int campusId, int cjtAlunosId  )
{
	int restricoes = 0;

    char name[ 100 ];
    int nnz = 0;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
			
		if ( cp->getId() != campusId )
		{
			continue;
		}

		GGroup< int > disciplinas = problemData->cp_discs[ cp->getId() ];
		
		// Para cada disciplina do campus
		ITERA_GGROUP_N_PT( itDisc, disciplinas, int )
		{
			 Disciplina *disciplina = problemData->refDisciplinas[ *itDisc ];

			 #pragma region Equivalencias
			 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
			 {
			 	 continue;
			 }
			 #pragma endregion

			 // Pula a restrição caso a disciplina seja de conjuntoAluno anterior

			 map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
			 itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

			 if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
			 {
				if ( itMapDiscCjt->second != cjtAlunosId &&
					NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
					continue;
			 }
			 else
		 	 {
				continue;
			 }

			 ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
			 {
				// Para cada sala associada à disciplina
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{
					if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
						itCjtSala->disciplinas_associadas.end() )
					{
						continue;
					}

					// Para cada turma da disciplina
					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						c.reset();
						c.setType( ConstraintPre::C_CAP_SALA );

						c.setDisciplina( disciplina );
						c.setTurma( turma );
						c.setUnidade( *itUnidade );
						c.setSubCjtSala( *itCjtSala );

						sprintf( name, "%s", c.toString().c_str() ); 
						if ( cHashPre.find( c ) != cHashPre.end() )
						{
							continue;
						}
						 
						nnz = disciplina->getNumTurmas();

						OPT_ROW row( nnz , OPT_ROW::LESS, 0.0 , name );

						// Para cada oferta que contém a disciplina
						GGroup< Oferta*, LessPtr<Oferta> > ofertas = problemData->ofertasDisc[ disciplina->getId() ];

						ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
						{							
							 v.reset();
							 v.setType( VariablePre::V_PRE_ALUNOS );

							 v.setTurma( turma );
							 v.setDisciplina( disciplina );
							 v.setOferta( *itOferta );
							 v.setUnidade( *itUnidade );
							 v.setSubCjtSala( *itCjtSala );

							 it_v = vHashPre.find( v );
							 if ( it_v != vHashPre.end() )
							 {
						 		 row.insert( it_v->second, 1.0 );
							 }

						}						

						v.reset();
						v.setType( VariablePre::V_PRE_OFERECIMENTO );

						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setSubCjtSala( *itCjtSala );
						v.setUnidade( *itUnidade ); 

						it_v = vHashPre.find(v);
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, -itCjtSala->capTotalSalas() );
						}

						if ( row.getnnz() != 0 )
						{
							cHashPre[ c ] = lp->getNumRows();

							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}
   }

	return restricoes;
}

// Restrição 1.8
int SolverMIP::cria_preRestricao_compartilhamento_incompat( int campusId, int cjtAlunosId  )
{
       int restricoes = 0;
       char name[ 100 ];
       int nnz;

	   ConstraintPre c;
	   VariablePre v;
	   VariablePreHash::iterator it_v;	
	   Campus *cp = NULL;

	   cp = problemData->refCampus[ campusId ];

	   if ( cp==NULL )
	   {
		   std::cout<<"\nATENCAO: SolverMIP::cria_preRestricao_compartilhamento_incompat( int campusId ): ";
		   std::cout<<"\nCampus" << campusId << "nao encontrado.\n";
		   return restricoes;
	   }

	   ITERA_GGROUP_LESSPTR( itCurso1, cp->cursos, Curso )
	   {
		   Curso* c1 = *itCurso1;

		   ITERA_GGROUP_INIC_LESSPTR( itCurso2, itCurso1, cp->cursos, Curso )
		   {
				Curso* c2 = *itCurso2;
				
			    if ( problemData->cursosCompativeis(c1, c2) || c1 == c2 )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
						 problemData->cp_discs[ campusId ].end() )
					{
						continue;
					}

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						  !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion
								
					// Pula a restrição caso a disciplina seja de conjuntoAluno anterior

					map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
					itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

					if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
					{
						if ( itMapDiscCjt->second != cjtAlunosId &&
							NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
							continue;
					}
					else
					{
						continue;
					}


					if ( !c1->possuiDisciplina( disciplina ) ||
						 !c2->possuiDisciplina( disciplina ) )
						continue;

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						c.reset();
						c.setType( ConstraintPre::C_PRE_ALUNOS_CURSOS_INCOMP );
						c.setParCursos( std::make_pair( c1, c2 ) );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHashPre.find( c ) != cHashPre.end() )
						{
							continue;
						}

						nnz = 3;

						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

						v.reset();
						v.setType( VariablePre::V_PRE_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c1 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1 );
						}

						v.reset();
						v.setType( VariablePre::V_PRE_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c2 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert(it_v->second, 1);
						}

						if ( row.getnnz() != 0 )
						{
							cHashPre[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}

		return restricoes;
}

// Restrição 1.9
int SolverMIP::cria_preRestricao_proibe_compartilhamento( int campusId, int cjtAlunosId  )
{
	int restricoes = 0;

    if ( problemData->parametros->permite_compartilhamento_turma_sel )
    {
	 	return restricoes;
    }

    char name[ 100 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;
	   
	Campus *cp = NULL;

	cp = problemData->refCampus[ campusId ];

	if ( cp==NULL )
	{
		 std::cout<<"\nATENCAO: SolverMIP::cria_preRestricao_compartilhamento_incompat( int campusId ): ";
		 std::cout<<"\nCampus" << campusId << "nao encontrado.\n";
		 return restricoes;
	}
	
	   ITERA_GGROUP_LESSPTR( itCurso1, cp->cursos, Curso )
	   {
		   Curso* c1 = *itCurso1;
		   
		   ITERA_GGROUP_INIC_LESSPTR( itCurso2, itCurso1, cp->cursos, Curso )
		   {
				Curso* c2 = *itCurso2;
			    
			    if ( !problemData->cursosCompativeis(c1, c2) || c1 == c2 )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
						 problemData->cp_discs[ campusId ].end() )
					{
						continue;
					}

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						  !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion
										
					if ( !c1->possuiDisciplina( disciplina ) ||
						 !c2->possuiDisciplina( disciplina ) )
						continue;
							
					// Pula a restrição caso a disciplina seja de conjuntoAluno anterior

					map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
					itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

					if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
					{
						if ( itMapDiscCjt->second != cjtAlunosId &&
							NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
							continue;
					}
					else
					{
						continue;
					}

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						c.reset();
						c.setType( ConstraintPre::C_PRE_PROIBE_COMPARTILHAMENTO );
						c.setParCursos( std::make_pair( c1, c2 ) );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHashPre.find( c ) != cHashPre.end() )
						{
							continue;
						}

						nnz = 3;

						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

						v.reset();
						v.setType( VariablePre::V_PRE_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c1 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1 );
						}

						v.reset();
						v.setType( VariablePre::V_PRE_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c2 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert(it_v->second, 1);
						}

						VariablePre v;
						v.reset();
						v.setType( VariablePre::V_PRE_SLACK_COMPARTILHAMENTO );
						v.setTurma( turma );				
						v.setDisciplina( disciplina );  
						v.setParCursos( std::make_pair(c1, c2) );	

						it_v = vHashPre.find( v );
						if ( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, -1 );
						}

						if ( row.getnnz() != 0 )
						{
							cHashPre[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}

		return restricoes;
}

// Restricao 1.10
int SolverMIP::cria_preRestricao_ativacao_var_z( int campusId, int cjtAlunosId  )
{
	int restricoes = 0;
    char name[ 100 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

   std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_disciplina, it_CpDisc->second, int )
      {
		 Disciplina *disciplina = problemData->refDisciplinas[ *it_disciplina ];

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
		 	 continue;
		 }
		 #pragma endregion
		
		 // Pula a restrição caso a disciplina seja de conjuntoAluno anterior

 		 map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		 itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		 if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		 {
			if ( itMapDiscCjt->second != cjtAlunosId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		 }
		 else
		 {
			continue;
		 }

		 double bigM = disciplina->getNSalasAptas();

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
			c.reset();
			c.setType( ConstraintPre::C_PRE_ATIVA_Z );
			c.setCampus( cp );
			c.setDisciplina( disciplina );
			c.setTurma( turma );

			sprintf( name, "%s", c.toString().c_str() ); 

			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			nnz = disciplina->getNSalasAptas() + 1;

			OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

            VariablePre v;
            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );
            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( cp );				// cp

			it_v = vHashPre.find( v );
			if ( it_v != vHashPre.end() )
			{
				row.insert( it_v->second, -bigM );
			}
			
			ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
			{
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{							
					if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
						itCjtSala->disciplinas_associadas.end() )
					{
						continue;
					}

                    VariablePre v;
                    v.reset();
                    v.setType( VariablePre::V_PRE_OFERECIMENTO );
                    v.setTurma( turma );            // i
                    v.setDisciplina( disciplina );  // d
                    v.setUnidade( *itUnidade );     // u
                    v.setSubCjtSala( *itCjtSala );  // tps

					it_v = vHashPre.find( v );
					if ( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
            
         }
      }
   }

   return restricoes;

}
   

// Restricao 1.11
int SolverMIP::cria_preRestricao_evita_turma_disc_camp_d( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
		   problemData->cp_discs[ campusId ].end() )
	  {
		  continue;
 	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion

		// Pula a restrição caso a disciplina seja de conjuntoAluno anterior

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second != cjtAlunosId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue;
		}

      for ( int i = 0; i < disciplina->getNumTurmas(); ++i )
      {
         c.reset();
         c.setType( ConstraintPre::C_PRE_EVITA_TURMA_DISC_CAMP_D );

         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHashPre.find( c ) != cHashPre.end() )
         {
            continue;
         }

         nnz = problemData->totalSalas;
         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

         ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
         {
			if ( it_campus->getId() != campusId )
			{
				continue;
			}

            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );

            v.setTurma( i );
            v.setDisciplina( disciplina );
            v.setCampus( *it_campus );

            it_v = vHashPre.find( v );
            if( it_v != vHashPre.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         if ( row.getnnz() != 0 )
         {
            cHashPre[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}   
   
// Restricao 1.12
int SolverMIP::cria_preRestricao_limita_abertura_turmas( int campusId, int cjtAlunosId, int prioridade, int r )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;
   int min;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   if ( problemData->parametros->min_alunos_abertura_turmas )
   {
		min = problemData->parametros->min_alunos_abertura_turmas_value;
		if ( min <= 0 ) min = 1;
   }
   else
   {
	   min = 1;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  if ( itCampus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );
	  
		 if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
			  problemData->cp_discs[ campusId ].end() )
		 {
			 continue;
 		 }

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			  continue;
		 }
		 #pragma endregion

		 // Pula a restrição caso a disciplina seja de conjuntoAluno anterior

		 map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		 itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

	 	 if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	 	 {
			if ( itMapDiscCjt->second != cjtAlunosId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		 }
		 else
		 {
			continue;
		 }

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( ConstraintPre::C_PRE_LIMITA_ABERTURA_TURMAS );

            c.setCampus( *itCampus );
            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHashPre.find( c ) != cHashPre.end() )
            {
               continue;
            }

			nnz = 1 + disciplina->getNSalasAptas() * problemData->ofertasDisc[ disciplina->getId() ].size();
            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );
            v.setTurma( turma );
            v.setDisciplina( disciplina );
            v.setCampus( *itCampus );

            it_v = vHashPre.find( v );
            if ( it_v != vHashPre.end() )
            {
               row.insert( it_v->second, min );
            }

            // ------
			if ( prioridade!=1 || r!=1 )
			{
				v.reset();
				v.setType( VariablePre::V_PRE_FORMANDOS_NA_TURMA );
				v.setTurma( turma );
				v.setDisciplina( disciplina );
				v.setCampus( *itCampus );

				it_v = vHashPre.find( v );
				if ( it_v != vHashPre.end() )
				{
				   row.insert( it_v->second, -min );
				}
			}
			// ------
			
			ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
			{
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{							
					if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
						itCjtSala->disciplinas_associadas.end() )
					{
						continue;
					}

					GGroup< Oferta *, LessPtr< Oferta > > ofertas =
					problemData->ofertasDisc[ disciplina->getId() ];
					
					ITERA_GGROUP_LESSPTR( itOft, ofertas, Oferta )
					{
					   if ( itOft->campus->getId() == itCampus->getId() )
					   {            
						  v.reset();
						  v.setType( VariablePre::V_PRE_ALUNOS );

						  v.setTurma( turma );
						  v.setDisciplina( disciplina );
						  v.setOferta( *itOft );
						  v.setUnidade( *itUnidade );
						  v.setSubCjtSala( *itCjtSala );

						  it_v = vHashPre.find( v );
						  if ( it_v != vHashPre.end() )
						  {
							 row.insert( it_v->second, -1.0 );
						  }
					   }
					}
				}
			}

            if ( row.getnnz() != 0 )
            {
               cHashPre[ c ] = lp->getNumRows();
               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}
   
// Restricao 1.13
int SolverMIP::cria_preRestricao_abre_turmas_em_sequencia( int campusId, int cjtAlunosId, int prioridade, int r )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus *campus = problemData->refCampus[ campusId ];
   
   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
		   problemData->cp_discs[ campusId ].end() )
	  {
		  continue;
 	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion
	  
	  if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
	  {
		  continue;
	  }

	  map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		  itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

	  if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	  {
		  if ( itMapDiscCjt->second	!= cjtAlunosId )
			  //&& NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
			  continue;
	  }
	  else
	  {
		  if ( problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
		  {
			  std::cout<<"\nAtencao em cria_preRestricao_abre_turmas_em_sequencia: disciplina "
						<<disciplina->getId() <<" nao pertence a nenhum conjunto\n";
		  }
	  }

      if ( disciplina->getNumTurmas() > 1 )
      {
         for ( int turma = 0; turma < ( disciplina->getNumTurmas() - 1 ); turma++ )
         {
            c.reset();
            c.setType( ConstraintPre::C_PRE_ABRE_TURMAS_EM_SEQUENCIA );

            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() ); 
            if ( cHashPre.find( c ) != cHashPre.end() )
            {
               continue;
            }

			nnz = 2*disciplina->getNSalasAptas();
            OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0, name );

            ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
            {
				if ( itCampus->getId() != campusId )
				{
					continue;
				}

               ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                        v.reset();
                        v.setType( VariablePre::V_PRE_OFERECIMENTO );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );

                        it_v = vHashPre.find( v );
                        if ( it_v != vHashPre.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        v.reset();
                        v.setType( VariablePre::V_PRE_OFERECIMENTO );

                        int turmaSuc = turma + 1;
                        v.setTurma(turmaSuc);
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );

                        it_v = vHashPre.find( v );
                        if ( it_v != vHashPre.end() )
                        {
                           row.insert( it_v->second, -1.0 );
                        }
                  }
               }
            }

			if ( ( prioridade > 1 && FIXAR_P1 ) || r>1 )
			{
                v.reset();
                v.setType( VariablePre::V_PRE_FOLGA_ABRE_TURMA_SEQUENCIAL );

                v.setTurma( turma );
                v.setDisciplina( disciplina );
				v.setCampus( campus );

                it_v = vHashPre.find( v );
                if ( it_v != vHashPre.end() )
                {
                    row.insert( it_v->second, 1.0 );
                }				
			}

            if ( row.getnnz() != 0 )
            {
               cHashPre[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}


// Restrição 1.14
int SolverMIP::cria_preRestricao_turma_mesma_disc_oft_sala_dif( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
				
		if ( cp->getId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					  Disciplina* disciplina = ( *itDisc );
					  
					  #pragma region Equivalencias
						if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
								problemData->mapDiscSubstituidaPor.end() ) &&
								!problemData->ehSubstituta( disciplina ) )
					  {
						  continue;
					  }
					  #pragma endregion
					  
						// Pula a restrição caso a disciplina seja de conjuntoAluno anterior

						map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
						itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

	 					if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	 					{
						if ( itMapDiscCjt->second != cjtAlunosId &&
							NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
							continue;
						}
						else
						{
							continue;
						}

					  if ( disciplina->getNumTurmas() > 1 )
					  {
							// Listando todas as ofertas que contem uma disciplina especificada.
							GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ disciplina->getId() ];

							ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
							{
								  Oferta* oft = *itOferta;

								  if ( oft->campus != cp )
									  continue;

								  // Calculando P_{d,o}
								  int qtdDem = 0;
								  ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
								  {
										if ( itDem->disciplina->getId() == disciplina->getId() &&
											 itDem->getOfertaId() == itOferta->getId() )
										{
											qtdDem += itDem->getQuantidade();
										}
								  }

								  if ( qtdDem <= 0 )
								  {
										continue;
								  }

								  c.reset();
								  c.setType( ConstraintPre::C_PRE_TURMA_MESMA_DISC_OFT_SALA_DIF );

								  c.setDisciplina( disciplina );
								  c.setUnidade( *itUnidade );
								  c.setSubCjtSala( *itCjtSala );
								  c.setOferta( oft );

								  sprintf( name, "%s", c.toString().c_str() ); 
								  if ( cHashPre.find( c ) != cHashPre.end() )
								  {
									  continue;
								  }

								  nnz = disciplina->getNumTurmas() + 1;

								  OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
						  
								  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
								  {
										v.reset();
										v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT);
										v.setTurma( turma );
										v.setDisciplina( *itDisc );
										v.setUnidade( *itUnidade );
										v.setSubCjtSala( *itCjtSala );
										v.setOferta( oft );

										it_v = vHashPre.find( v );
										if ( it_v != vHashPre.end() )
										{
										   row.insert( it_v->second, 1.0 );
										}
								  }

								  v.reset();
								  v.setType( VariablePre::V_PRE_SLACK_SALA);
								  v.setDisciplina( *itDisc );
								  v.setUnidade( *itUnidade );
								  v.setSubCjtSala( *itCjtSala );
								  v.setOferta( oft );

								  it_v = vHashPre.find( v );
								  if ( it_v != vHashPre.end() )
								  {
									  row.insert( it_v->second, -1.0 );
								  }

								  if ( row.getnnz() != 0 )
								  {
									 cHashPre[ c ] = lp->getNumRows();

  									 lp->addRow( row );
									 restricoes++;
								  }
							  }
					  }
				}
			}
		}
	}

	return restricoes;
}

// Restrição 1.14
int SolverMIP::cria_preRestricao_turma_mesma_disc_sala_dif( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
				
		if ( cp->getId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					  Disciplina* disciplina = ( *itDisc );
					  
					  #pragma region Equivalencias
						if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
								problemData->mapDiscSubstituidaPor.end() ) &&
								!problemData->ehSubstituta( disciplina ) )
					  {
						  continue;
					  }
					  #pragma endregion
					  
						// Pula a restrição caso a disciplina seja de conjuntoAluno anterior

						map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
						itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

	 					if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	 					{
							if ( itMapDiscCjt->second != cjtAlunosId &&
								NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
								continue;
						}
						else
						{
							continue;
						}

					  if ( disciplina->getNumTurmas() > 1 )
					  {
							if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
							{
								continue;
							}

							c.reset();
							c.setType( ConstraintPre::C_PRE_TURMA_MESMA_DISC_SALA_DIF );
							c.setDisciplina( disciplina );
							c.setUnidade( *itUnidade );
							c.setSubCjtSala( *itCjtSala );
								  
							sprintf( name, "%s", c.toString().c_str() ); 
							if ( cHashPre.find( c ) != cHashPre.end() )
							{
								continue;
							}

							nnz = disciplina->getNumTurmas() + 1;

							OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
						  
							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								v.reset();
								v.setType( VariablePre::V_PRE_OFERECIMENTO );
								v.setTurma( turma );
								v.setDisciplina( *itDisc );
								v.setUnidade( *itUnidade );
								v.setSubCjtSala( *itCjtSala );

								it_v = vHashPre.find( v );
								if ( it_v != vHashPre.end() )
								{
									row.insert( it_v->second, 1.0 );
								}
							}

							v.reset();
							v.setType( VariablePre::V_PRE_SLACK_DISC_SALA);
							v.setDisciplina( *itDisc );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );

							it_v = vHashPre.find( v );
							if ( it_v != vHashPre.end() )
							{
								row.insert( it_v->second, -1.0 );
							}

							if ( row.getnnz() != 0 )
							{
								cHashPre[ c ] = lp->getNumRows();

  								lp->addRow( row );
								restricoes++;
							}
					  }
				}
			}
		}
	}

	return restricoes;
}


// Restrição 1.15
int SolverMIP::cria_preRestricao_limite_sup_creds_sala( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				// --------------------------------------------------------
				c.reset();
				c.setType( ConstraintPre::C_PRE_LIM_SUP_CREDS_SALA );
				c.setCampus( *itCampus );
				c.setUnidade( *itUnidade );
				c.setSubCjtSala( *itCjtSala );

				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHashPre.find( c ) != cHashPre.end() )
				{
					continue;
				}

				nnz = 100 + 1;

				OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );
						  
				v.reset();
				v.setType( VariablePre::V_PRE_LIM_SUP_CREDS_SALA);
				v.setCampus( *itCampus );

				it_v = vHashPre.find( v );
				if ( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -1.0 );
				}

				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					  Disciplina* disciplina = ( *itDisc );
					  
					  #pragma region Equivalencias
					  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							 problemData->mapDiscSubstituidaPor.end() ) &&
							!problemData->ehSubstituta( disciplina ) )
					  {
							continue;
					  }
					  #pragma endregion
					  
					  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					  {
						  v.reset();
						  v.setType( VariablePre::V_PRE_CREDITOS);
						  v.setUnidade( *itUnidade );
						  v.setSubCjtSala( *itCjtSala );
						  v.setDisciplina( disciplina );
						  v.setTurma( turma );

						  it_v = vHashPre.find( v );
						  if ( it_v != vHashPre.end() )
						  {
							  row.insert( it_v->second, 1.0 );
						  }
					  }
				}

				if ( row.getnnz() != 0 )
				{
					cHashPre[ c ] = lp->getNumRows();

  					lp->addRow( row );
					restricoes++;
				}
				// --------------------------------------------------------
			}
		}
	}

	return restricoes;
}

// Restrição 1.26
int SolverMIP::cria_preRestricao_soma_cred_sala( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				// --------------------------------------------------------
				c.reset();
            c.setType( ConstraintPre::C_PRE_SOMA_CRED_SALA );
				c.setCampus( *itCampus );
				c.setUnidade( *itUnidade );
				c.setSubCjtSala( *itCjtSala );

				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHashPre.find( c ) != cHashPre.end() )
				{
					continue;
				}

				nnz = 100 + 1;

				OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0, name );
						  
				v.reset();
            v.setType( VariablePre::V_PRE_CRED_SALA_F1);
				v.setCampus( *itCampus );
            v.setUnidade(*itUnidade);
            v.setSubCjtSala(*itCjtSala);

				it_v = vHashPre.find( v );
				if ( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -1.0 );
				}

            v.reset();
            v.setType( VariablePre::V_PRE_CRED_SALA_F2);
				v.setCampus( *itCampus );
            v.setUnidade(*itUnidade);
            v.setSubCjtSala(*itCjtSala);

				it_v = vHashPre.find( v );
				if ( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -1.0 );
				}

            v.reset();
            v.setType( VariablePre::V_PRE_CRED_SALA_F3);
				v.setCampus( *itCampus );
            v.setUnidade(*itUnidade);
            v.setSubCjtSala(*itCjtSala);

				it_v = vHashPre.find( v );
				if ( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -1.0 );
				}

				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					  Disciplina* disciplina = ( *itDisc );
					  
					  #pragma region Equivalencias
					  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							 problemData->mapDiscSubstituidaPor.end() ) &&
							!problemData->ehSubstituta( disciplina ) )
					  {
							continue;
					  }
					  #pragma endregion
					  
					  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					  {
						  v.reset();
						  v.setType( VariablePre::V_PRE_CREDITOS);
						  v.setUnidade( *itUnidade );
						  v.setSubCjtSala( *itCjtSala );
						  v.setDisciplina( disciplina );
						  v.setTurma( turma );

						  it_v = vHashPre.find( v );
						  if ( it_v != vHashPre.end() )
						  {
							  row.insert( it_v->second, disciplina->getTempoCredSemanaLetiva() );
						  }
					  }
				}

				if ( row.getnnz() != 0 )
				{
					cHashPre[ c ] = lp->getNumRows();

  					lp->addRow( row );
					restricoes++;
				}
				// --------------------------------------------------------
			}
		}
	}

	return restricoes;
}

// Restricao 1.16
int SolverMIP::cria_preRestricao_ativa_var_aloc_aluno_oft( int campusId, int cjtAlunosId  )
{
    int restricoes = 0;
    char name[ 100 ];
    int nnz;

    VariablePre v;
    ConstraintPre c;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;
    
	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;

		if ( cp->getId() != campusId )
		{
			continue;
		}
		
		ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *it_disc;

					#pragma region Equivalencias
					  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							 problemData->mapDiscSubstituidaPor.end() ) &&
							!problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion

					  
					// Pula a restrição caso a disciplina seja de conjuntoAluno anterior

					map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
					itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

	 				if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	 				{
					if ( itMapDiscCjt->second != cjtAlunosId &&
						NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
						continue;
					}
					else
					{
						continue;
					}

					// Listando todas as ofertas que contem uma disciplina especificada.
					GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ it_disc->getId() ];

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{
							 Oferta* oft = *itOferta;

							 if ( oft->campus != cp )
								 continue;

							 // Calculando P_{d,o}
							 int qtdDem = 0;
							 ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
							 {
								if ( itDem->disciplina->getId() == disciplina->getId() &&
								   itDem->getOfertaId() == itOferta->getId() )
								{
								   qtdDem += itDem->getQuantidade();
								}
							 }

							 if ( qtdDem <= 0 )
							 {
								continue;
							 }

							 for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							 {
								// --------------------------------------------------------
								c.reset();
								c.setType( ConstraintPre::C_PRE_ATIVA_C );
								c.setCampus( *itCampus );
								c.setTurma( turma );
								c.setDisciplina( disciplina );
								c.setUnidade( *itUnidade );
								c.setSubCjtSala( *itCjtSala );
								c.setOferta( oft );

								sprintf( name, "%s", c.toString().c_str() ); 
								if ( cHashPre.find( c ) != cHashPre.end() )
								{
									continue;
								}

								nnz = 2;

								OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

								// variavel a_{i,d,oft,s}
								v.reset();
								v.setType( VariablePre::V_PRE_ALUNOS );
								v.setTurma( turma );               // i
								v.setDisciplina( disciplina );     // d
								v.setOferta( *itOferta );          // oft
								v.setUnidade( *itUnidade );		   // u
								v.setSubCjtSala( *itCjtSala );	   // s
								
								it_v = vHashPre.find( v );
								if ( it_v != vHashPre.end() )
								{
									row.insert( it_v->second, 1.0 );
								}

								// variavel c_{i,d,oft,s}
								v.reset();
								v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT );
								v.setTurma( turma );               // i
								v.setDisciplina( disciplina );     // d
								v.setOferta( *itOferta );          // oft
								v.setUnidade( *itUnidade );		   // u
								v.setSubCjtSala( *itCjtSala );	   // s
								
								it_v = vHashPre.find( v );
								if ( it_v != vHashPre.end() )
								{
									row.insert( it_v->second, -qtdDem );
								}

								// insere constraint
								if ( row.getnnz() != 0 )
								{
									cHashPre[ c ] = lp->getNumRows();

  									lp->addRow( row );
									restricoes++;
								}
								// --------------------------------------------------------
							}
				     }
				}
			}
		}
   }

	return restricoes;
}


// Restricao 1.17
int SolverMIP::cria_preRestricao_fixa_nao_compartilhamento( int campusId )
{
   int restricoes = 0;

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() < 2 )
   {
	   return restricoes;
   }   
   
   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;
   
   // para cada campus
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus *cp = *itCampus;

	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

	   // para cada par de cursos compativeis
	   std::map< std::pair< Curso *, Curso * >, std::vector< int > >::iterator
               it_cursoComp_disc = problemData->cursosComp_disc.begin();
        for (; it_cursoComp_disc != problemData->cursosComp_disc.end(); it_cursoComp_disc++ )
        {
			Curso* c1 = it_cursoComp_disc->first.first;
			Curso* c2 = it_cursoComp_disc->first.second;
			
			// para cada disciplina em comum (possivel de ser compartilhada) ao par de cursos
            std::vector< int >::iterator it_discComum = it_cursoComp_disc->second.begin();
            for (; it_discComum != it_cursoComp_disc->second.end(); ++it_discComum )
            {
				Disciplina * discComum = problemData->retornaDisciplina( *it_discComum );
				  
				if (discComum == NULL) continue;

				#pragma region Equivalência de disciplinas
				if ( ( problemData->mapDiscSubstituidaPor.find( discComum ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( discComum ) )
				{
					continue;
				}
				#pragma endregion
				
				GGroup<Oferta*, LessPtr<Oferta>> ofts1 = cp->retornaOfertasComCursoDisc( c1->getId(), discComum );
				GGroup<Oferta*, LessPtr<Oferta>> ofts2 = cp->retornaOfertasComCursoDisc( c2->getId(), discComum );

				// para cada oferta contendo discComum do curso c1
				ITERA_GGROUP_LESSPTR( itOft1, ofts1, Oferta )
				{
					Oferta *oft1 = *itOft1;
					int periodo1 = oft1->periodoDisciplina( discComum );

					if ( oft1->getCampusId() != campusId )
					{
						continue;
					}

					// para cada oferta contendo discComum do curso c2
					ITERA_GGROUP_LESSPTR( itOft2, ofts2, Oferta )
					{
						Oferta *oft2 = *itOft2;
						int periodo2 = oft2->periodoDisciplina( discComum );

						if ( oft2->getId() == oft1->getId() )
						{
							continue;
						}
						if ( oft2->getCampusId() != campusId )
						{
							continue;
						}

						// Cria a restrição somente para períodos que possuem mais de uma semana letiva, ou sl's diferentes
						if ( oft1->curriculo->retornaSemanasLetivasNoPeriodo( periodo1 ).size() == 1 &&
							 oft2->curriculo->retornaSemanasLetivasNoPeriodo( periodo2 ).size() == 1 &&
							 oft1->curriculo->retornaSemanasLetivasNoPeriodo( periodo1 ).begin()->getId() ==
							 oft2->curriculo->retornaSemanasLetivasNoPeriodo( periodo2 ).begin()->getId() )
						{
							continue;
						}

						// para cada turma da disciplina em comum
						for ( int turma = 0; turma < discComum->getNumTurmas(); turma++ )
						{
							c.reset();
							c.setType( ConstraintPre::C_PRE_FIXA_NAO_COMPARTILHAMENTO );
							c.setParOfertas( std::make_pair(oft1, oft2) );
							c.setDisciplina( discComum );
							c.setTurma( turma );

							sprintf( name, "%s", c.toString().c_str() ); 

							if ( cHashPre.find( c ) != cHashPre.end() )
							{
								continue;
							}

							nnz = 300;

							OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

							ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
							{
								ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
								{
									if ( itCjtSala->disciplinas_associadas.find( discComum ) ==
										 itCjtSala->disciplinas_associadas.end() )
										continue;

									v.reset();
									v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT );
									v.setTurma( turma );
									v.setDisciplina( discComum );
									v.setOferta( oft1 );
									v.setSubCjtSala( *itCjtSala );
									v.setUnidade( *itUnidade );

									it_v = vHashPre.find( v );
									if( it_v != vHashPre.end() )
									{
										row.insert( it_v->second, 1 );
									}

									v.reset();
									v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT );
									v.setTurma( turma );
									v.setDisciplina( discComum );
									v.setOferta( oft2 );
									v.setSubCjtSala( *itCjtSala );
									v.setUnidade( *itUnidade );

									it_v = vHashPre.find( v );
									if( it_v != vHashPre.end() )
									{
										row.insert( it_v->second, 1 );
									}
								}
							}
								
							if ( row.getnnz() != 0 )
							{
								cHashPre[ c ] = lp->getNumRows();
								lp->addRow( row );
								restricoes++;
							}
						}
					}
				}
			}
		}
   }

   return restricoes;

}


// Restricao 1.18
/*
    Metodo somente utilizado para o modelo Tatico_Aluno

	Define qual aluno foi atendido em cada atendimento feito.
*/
int SolverMIP::cria_preRestricao_atendimento_aluno( int campusId, int cjtAlunosId  )
{
    int restricoes = 0;
   
    char name[ 100 ];
    int nnz = 0;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itOferta, problemData->ofertas, Oferta )
   {
	   Oferta *oferta = *itOferta;

	   if ( oferta->getCampusId() != campusId )
	   {
			continue;
	   }

       map < Disciplina*, int, LessPtr< Disciplina > >::iterator itPrdDisc = 
         oferta->curriculo->disciplinas_periodo.begin();

      for (; itPrdDisc != oferta->curriculo->disciplinas_periodo.end(); itPrdDisc++ )
      {
		  disciplina = itPrdDisc->first;
		  					  
		  // Pula a restrição caso a disciplina seja de conjuntoAluno anterior
 
		  map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		  itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

	      if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	 	  {
			  if ( itMapDiscCjt->second != cjtAlunosId &&
					NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
					continue;
		  }
		  else
		  {
			  continue;
	 	  }

		  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
		  {
				 c.reset();
				 c.setType( ConstraintPre::C_ATENDIMENTO_ALUNO );

				 c.setOferta( oferta );
				 c.setDisciplina( disciplina );
				 c.setTurma( turma );

				 sprintf( name, "%s", c.toString().c_str() ); 
				 if ( cHashPre.find( c ) != cHashPre.end() )
				 {
					continue;
				 }
				 
				 nnz = 50;
				 
				 OPT_ROW row( nnz , OPT_ROW::EQUAL, 0.0 , name );

				 ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
				 {
					 Aluno *aluno = *itAluno;

					 if ( aluno->getOferta() != oferta )
					 {
						continue;
					 }

					 if ( !aluno->demandaDisciplina( disciplina->getId() ) )
					 {
						continue;
					 }

					 v.reset();
					 v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
					 v.setTurma( turma );
					 v.setDisciplina( disciplina );
					 v.setAluno( aluno );
					 v.setCampus( oferta->campus );

					 it_v = vHashPre.find( v );
					 if ( it_v != vHashPre.end() )
					 {
						 row.insert( it_v->second, -1.0 );
					 }
				 }

				 ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
				 {
					if ( itCampus->getId() != campusId )
					{
						continue;
					}
							
					ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
					{
						ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
						{
							if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
								 itCjtSala->disciplinas_associadas.end() )
							{
								continue;
							}
			
							v.reset();
							v.setType( VariablePre::V_PRE_ALUNOS );
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setOferta( oferta );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );

							it_v = vHashPre.find( v );
							if ( it_v != vHashPre.end() )
							{
								row.insert( it_v->second, 1.0 );
							}
						}
					}
				 }

				 if ( row.getnnz() != 0 )
				 {
					cHashPre[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				 }
		  }
      }
   }

	return restricoes;
}


// Restricao 1.19
/*
    Metodo somente utilizado para o modelo Tatico_Aluno
   
	Garante que cada aluno esteja em apenas 1 turma de uma disciplina
*/
int SolverMIP::cria_preRestricao_aluno_unica_turma_disc( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
      
   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;   

   Campus *campus = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = itAlDemanda->demanda->disciplina;							  

			// Pula a restrição caso a disciplina seja de conjuntoAluno anterior
 
			map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
			itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

			if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	 		{
				if ( itMapDiscCjt->second != cjtAlunosId &&
					NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
					continue;
			}
			else
			{
				continue;
	 		}

			c.reset();
			c.setType( ConstraintPre::C_ALUNO_UNICA_TURMA_DISC );
			c.setAluno( aluno );
			c.setDisciplina( disciplina );
			c.setCampus( campus );

			sprintf( name, "%s", c.toString().c_str() ); 

			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			nnz = disciplina->getNumTurmas();

			OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( disciplina );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
	}

	return restricoes;
}


// Restricao 1.20
int SolverMIP::cria_preRestricao_aluno_discPraticaTeorica( int campusId, int cjtAlunosId  )
{
   int restricoes = 0;
      
   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;   

   Campus *campus = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}
						  

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *discPratica = itAlDemanda->demanda->disciplina;
			
			// Pula a restrição caso a disciplina seja de conjuntoAluno anterior
 
			map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
			itMapDiscCjt = problemData->cjtDisciplinas.find( discPratica );

			if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	 		{
				if ( itMapDiscCjt->second != cjtAlunosId &&
					NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
					continue;
			}
			else
			{
				continue;
	 		}

			// Pula disciplina teorica
			if ( discPratica->getId() > 0 )
				continue;

			Disciplina *discTeorica = problemData->refDisciplinas[ - discPratica->getId() ];

			if ( discTeorica == NULL )
			{
				std::cout<<"\nErro em cria_preRestricao_aluno_discPraticaTeorica: disciplina teorica nao encontrada.\n";
				continue;
			}
			
			c.reset();
			c.setType( ConstraintPre::C_ALUNO_DISC_PRATICA_TEORICA );
			c.setAluno( aluno );
			c.setDisciplina( discPratica );
			c.setCampus( campus );

			sprintf( name, "%s", c.toString().c_str() ); 

			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			nnz = discPratica->getNumTurmas() + discTeorica->getNumTurmas() + 1;

			OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

			for ( int turma = 0; turma < discPratica->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( discPratica );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			}

			for ( int turma = 0; turma < discTeorica->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( discTeorica );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -1.0 );
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
	}

	return restricoes;

}

// Restricao 1.21
int SolverMIP::cria_preRestricao_prioridadesDemanda( int campusId, int prior, int cjtAlunosId  )
{
    int restricoes = 0;

    if ( prior < 2 )
	   return restricoes;

    char name[ 200 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;   

    Campus *campus = problemData->refCampus[campusId];

    GGroup< Aluno *, LessPtr< Aluno > > alunos;
	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator 
		itMapAlunoCjt = problemData->cjtAlunos.find( cjtAlunosId );	
	if ( itMapAlunoCjt != problemData->cjtAlunos.end() )
	{
		alunos = itMapAlunoCjt->second;
	}

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		if ( NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
		{
			if ( alunos.find( aluno ) == alunos.end() )
				continue;
		}

		c.reset();
		c.setType( ConstraintPre::C_ALUNO_PRIORIDADES_DEMANDA );
		c.setAluno( aluno );
		c.setCampus( campus );

		sprintf( name, "%s", c.toString().c_str() ); 

		if ( cHashPre.find( c ) != cHashPre.end() )
		{
			continue;
		}

		nnz = aluno->demandas.size()*3 + 2;
		
		double cargaHorariaNaoAtendida = problemData->cargaHorariaNaoAtendidaPorPrioridade( prior-1, aluno->getAlunoId() );		
		double cargaHorariaP2 = problemData->cargaHorariaAtualRequeridaPorPrioridade( prior, aluno );

		double rhs = cargaHorariaNaoAtendida;
		if (rhs>cargaHorariaP2)
			rhs=cargaHorariaP2;

		OPT_ROW row( nnz, OPT_ROW::EQUAL , rhs, name );
		
		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = itAlDemanda->demanda->disciplina;

			if ( itAlDemanda->getPrioridade() != prior )
				continue;

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( disciplina );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					double tempo = disciplina->getTotalCreditos() * disciplina->getTempoCredSemanaLetiva();

					row.insert( it_v->second, tempo );
				}
			}
		}

		VariablePre v;
		v.reset();
		v.setType( VariablePre::V_PRE_SLACK_PRIOR_INF );
		v.setAluno( aluno );
		v.setCampus( campus );
		it_v = vHashPre.find( v );
		if( it_v != vHashPre.end() )
		{
			row.insert( it_v->second, -1.0 );
		}

		v.reset();
		v.setType( VariablePre::V_PRE_SLACK_PRIOR_SUP );
		v.setAluno( aluno );
		v.setCampus( campus );
		it_v = vHashPre.find( v );
		if( it_v != vHashPre.end() )
		{
			row.insert( it_v->second, 1.0 );
		}


		if ( row.getnnz() >= 3 )
		{
			cHashPre[ c ] = lp->getNumRows();
			lp->addRow( row );
			restricoes++;
		}
	}

	return restricoes;

}

int SolverMIP::cria_preRestricao_limite_cred_aluno(int campusId, int cjtAlunosId, int prior)
{
   int restricoes = 0;

    char name[ 200 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;   

	Campus *cp = problemData->refCampus[campusId];

   std::map<Disciplina*,std::list<VariablePreHash::iterator> > mapDiscVarCred;

   for (it_v = vHashPre.begin(); it_v != vHashPre.end(); it_v++)
   {
      v = it_v->first;

      if ( v.getType() == VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC )
      {
         mapDiscVarCred[v.getDisciplina()].push_back(it_v);
      }
   }

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para cada conjunto de alunos cp com id menor ou igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;

		if ( grupoAlunosId > cjtAlunosId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

         c.reset();
         c.setType( ConstraintPre::C_PRE_MAX_CREDS_ALUNO_SEMANA );
         c.setAluno( aluno );
         c.setCampus( cp );

         sprintf( name, "%s", c.toString().c_str() ); 

         if ( cHashPre.find( c ) != cHashPre.end() )
         {
            continue;
         }

         int maxTempoSemana = 0;

         OPT_ROW row( 100, OPT_ROW::LESS , maxTempoSemana, (char*)c.toString().c_str() );

			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;

            int ttSem = disciplina->getTempoTotalSemana();
            if ( ttSem > maxTempoSemana )
               maxTempoSemana = ttSem;

            std::list<VariablePreHash::iterator> listVars = mapDiscVarCred[disciplina];

            for (std::list<VariablePreHash::iterator>::iterator itVars = listVars.begin();
               itVars != listVars.end();
               itVars++)
            {
               int col = (*itVars)->second;
               v = (*itVars)->first;

               if ( v.getAluno() != aluno )
                  continue;

               double coef = disciplina->getTotalCreditos();
               coef *= disciplina->getTempoCredSemanaLetiva();

               row.insert(col,coef);
            }

            row.setRhs(maxTempoSemana);

            if ( row.getnnz() >= 1 )
            {
               cHashPre[ c ] = lp->getNumRows();
               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

	return restricoes;
}


int SolverMIP::cria_preRestricao_evita_sobrepos_turmas_mesmos_alunos( int campusId, int cjtAlunosAtualId, int prioridade )
{
   int restricoes = 0;
   
   if ( prioridade < 2 )
   {
	   return restricoes;
   }
   
   char name[ 200 ];						   
   int nnz = 50;

   GGroup< Sala *, LessPtr< Sala > > salas = this->problemData->getSalas();

   ConstraintPre c;
   VariablePreHash::iterator vit;
   ConstraintPreHash::iterator cit;

   Campus * campus = problemData->refCampus[campusId];
   	
   GGroup< int > disciplinas = problemData->cp_discs[campusId];

   ITERA_GGROUP_N_PT( itDisc, disciplinas, int )
   {
	   Disciplina * disciplina = problemData->refDisciplinas[*itDisc];

	   if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
	   {
		   continue;
	   }

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt == problemData->cjtDisciplinas.end() )
		{
			continue; // disciplina não pertence a nenhum cjtDisciplina, erro!
		}

	   for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
	   {
		   // só para turmas criadas em p1
		   if ( ! problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId ) )
		   {
				continue;
		   }

		   Unidade* u = retornaUnidadeDeAtendimento( turma, disciplina, campus );
		   ConjuntoSala* s = retornaSalaDeAtendimento( turma, disciplina, campus );

		   // Para cada dia
		   ITERA_GGROUP_N_PT( itDia, disciplina->diasLetivos, int )
		   {
			    int dia = *itDia;

				// -----------------------------------------------------
				// Procura se há atendimento tatico fixado em p1
				Variable varTatico;
				varTatico.reset();
				varTatico.setType( Variable::V_CREDITOS );
				varTatico.setDisciplina( disciplina );
				varTatico.setTurma( turma );
				varTatico.setDia( dia );
				varTatico.setUnidade( u );
				varTatico.setSubCjtSala( s );	

				bool found = false;
				double nCredsDisciplinaNoDia = fixaLimitesVariavelTaticoPriorAnterior( &varTatico, found );
				if ( nCredsDisciplinaNoDia <= 0.0 || !found )
				{
					continue;
				}
				// -----------------------------------------------------
					
				
			   // Calcula o lado direito geral das restrições
			   double rhs_geral = 99999999;	   
			   GGroup<Calendario*> calendarios = campus->getCalendarios();
			   ITERA_GGROUP( itSl, calendarios, Calendario )
			   {
					double tempo = itSl->getTempoTotal( dia );
					if ( rhs_geral - tempo > 1e-5 ) // tempo < rhs_geral
						rhs_geral = tempo;
			   }

			   ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
			   {
				   // Para cada sala diferente da sala s
				   ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
					{
						ConjuntoSala *cjtSala = *itCjtSala;
		   
						if ( cjtSala == s )
						{
							continue;
						}

						c.reset();
						c.setType( ConstraintPre::C_PRE_EVITA_SOBREPOS_SALA_DIA_ALUNO );
						c.setSubCjtSala( cjtSala );
						c.setDia( dia );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						cit = cHashPre.find(c);
						if ( cit != cHashPre.end() )
						{
							continue;
						}

						double TEMPO_JA_USADO = 0.0;

						// Lado direito caso so haja 1 semana letiva na restrição
						double rhs = disciplina->getCalendario()->getTempoTotal( dia );
						
						cHashPre[ c ] = lp->getNumRows();
				   
						sprintf( name, "%s", c.toString().c_str() );
						OPT_ROW row( nnz, OPT_ROW::LESS , rhs, name );
						
												
						VariablePre v;
						v.reset();
						v.setType( VariablePre::V_PRE_ABERTURA );
						v.setTurma( turma );            // i
						v.setDisciplina( disciplina );  // d
						v.setCampus( campus );			// cp
												
						double tempoDiscV = disciplina->getTempoCredSemanaLetiva() * nCredsDisciplinaNoDia;

						vit = vHashPre.find( v );
					    if ( vit != vHashPre.end())
					    {
							row.insert( vit->second, tempoDiscV );

							TEMPO_JA_USADO += tempoDiscV;
					    }
						
						// ---------------------------------------------------------
						// Procura os atendimentos feitos na sala cjtSala
						GGroup< Trio< int,Disciplina*,int > > atends = retornaAtendEmCjtSalaDia( cjtSala, dia );

						GGroup< Trio< int,Disciplina*,int > >::iterator itAtends = atends.begin();
						for ( ; itAtends != atends.end(); itAtends++ )
						{
							int turmaSum = (*itAtends).first;
							Disciplina *discSum = (*itAtends).second;
							double nCredsDiscSumNoDia = (*itAtends).third;
							double tempo1Cred = discSum->getTempoCredSemanaLetiva();

							v.reset();
							v.setType( VariablePre::V_PRE_TURMAS_COMPART );
							v.setTurma1( turma );				// i
							v.setDisciplina1( disciplina );     // d
							v.setTurma2( turmaSum );			// i
							v.setDisciplina2( discSum );		// d
							
							vit = vHashPre.find( v );
							if ( vit != vHashPre.end() )
							{
								double tempoDiscSum = tempo1Cred*nCredsDiscSumNoDia;

								row.insert( vit->second, tempoDiscSum );

								// Se tiver aluno em comum
								if ( problemData->possuiAlunosEmComum( turma, disciplina, turmaSum, discSum, campus ) )
								{
									TEMPO_JA_USADO += tempoDiscSum;								
								}

								if ( rhs - discSum->getCalendario()->getTempoTotal( dia ) > 1e-5 )
								{
									row.setRhs( rhs_geral );
									rhs = rhs_geral;
								}
							}
							else // Se não achar a variavel, procurar pela análoga, com os pares turma/disc trocados
							{
								v.reset();
								v.setType( VariablePre::V_PRE_TURMAS_COMPART );
								v.setTurma2( turma );				// i
								v.setDisciplina2( disciplina );     // d
								v.setTurma1( turmaSum );			// i
								v.setDisciplina1( discSum );		// d

								vit = vHashPre.find( v );
								if ( vit != vHashPre.end() )
								{
									double tempoDiscSum = tempo1Cred*nCredsDiscSumNoDia;

									row.insert( vit->second, tempoDiscSum );

									// Se tiver aluno em comum
									if ( problemData->possuiAlunosEmComum( turma, disciplina, turmaSum, discSum, campus ) )
									{
										TEMPO_JA_USADO += tempoDiscSum;								
									}

									if ( rhs - discSum->getCalendario()->getTempoTotal( dia ) > 1e-5 )
									{
										row.setRhs( rhs_geral );
										rhs = rhs_geral;
									}
								}
							}

						}

						if ( TEMPO_JA_USADO - row.getRhs() > 1e-5 ) // se TEMPO_JA_USADO > row.getRhs()
						{
							row.setRhs( TEMPO_JA_USADO );
						}

						if ( row.getnnz() > 1 )
						{
							lp->addRow( row );
							restricoes++;
						}
					}
			   }
		   }
	   }   
   }

   return restricoes;

}

/*
// Usada só em p2, quando não tinha cliques
int SolverMIP::cria_preRestricao_ativa_var_compart_turma( int campusId, int cjtAlunosId, int prior  )
{
    int restricoes = 0;

    if ( prior < 2 )
	   return restricoes;

    char name[ 200 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;   

    Campus *campus = problemData->refCampus[campusId];

    GGroup< Aluno *, LessPtr< Aluno > > alunos;
	map< int , GGroup< Aluno *, LessPtr< Aluno > > >::iterator 
		itMapAlunoCjt = problemData->cjtAlunos.find( cjtAlunosId );	
	if ( itMapAlunoCjt != problemData->cjtAlunos.end() )
	{
		alunos = itMapAlunoCjt->second;
	}

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}
		
		ITERA_GGROUP_LESSPTR( it1AlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina1 = it1AlDemanda->demanda->disciplina;

			for ( int turma1 = 0; turma1 < disciplina1->getNumTurmas(); turma1++ )
			{

				ITERA_GGROUP_INIC_LESSPTR( it2AlDemanda, it1AlDemanda, aluno->demandas, AlunoDemanda )
				{
					Disciplina *disciplina2 = it2AlDemanda->demanda->disciplina;

					if ( disciplina1 == disciplina2 )
						continue;

					// FILTRAR
					if ( it2AlDemanda->getPrioridade() != prior && 
						 it1AlDemanda->getPrioridade() != prior )
						continue;

					for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
					{

						c.reset();
						c.setType( ConstraintPre::C_PRE_ATIVA_VAR_COMPART_TURMA );
						c.setAluno( aluno );
						c.setTurma1( turma1 );
						c.setTurma2( turma2 );
						c.setDisciplina1( disciplina1 );
						c.setDisciplina2( disciplina2 );
						c.setCampus( campus );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHashPre.find( c ) != cHashPre.end() )
						{
							continue;
						}

						nnz = 3;
		
						OPT_ROW row( nnz, OPT_ROW::LESS, 1.0, name );


						VariablePre v;
						v.reset();
						v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
						v.setAluno( aluno );
						v.setDisciplina( disciplina1 );
						v.setTurma( turma1 );
						v.setCampus( campus );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1.0 );
						}

						v.reset();
						v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
						v.setAluno( aluno );
						v.setDisciplina( disciplina2 );
						v.setTurma( turma2 );
						v.setCampus( campus );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1.0 );
						}
				
						v.reset();
						v.setType( VariablePre::V_PRE_TURMAS_COMPART );				
						v.setDisciplina1( disciplina1 );
						v.setTurma1( turma1 );
						v.setDisciplina2( disciplina2 );
						v.setTurma2( turma2 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, -1.0 );
						}
						else
						{	// Analoga
							v.reset();
							v.setType( VariablePre::V_PRE_TURMAS_COMPART );				
							v.setDisciplina2( disciplina1 );
							v.setTurma2( turma1 );
							v.setDisciplina1( disciplina2 );
							v.setTurma1( turma2 );

							it_v = vHashPre.find( v );
							if( it_v != vHashPre.end() )
							{
								row.insert( it_v->second, -1.0 );
							}						
						}


						if ( row.getnnz() == 3 )
						{
							cHashPre[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}

					}
				}
			}
		}
	}

	return restricoes;
}
*/

// Usada agora para p1 também. Tentativa de minimizar os conflitos
// entre turmas a serem enviadas ao tático
int SolverMIP::cria_preRestricao_ativa_var_compart_turma( int campusId, int cjtAlunosId, int prior  )
{
    int restricoes = 0;
    char name[ 200 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;   

    Campus *campus = problemData->refCampus[campusId];

    GGroup< Aluno *, LessPtr< Aluno > > alunos;
	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator 
		itMapAlunoCjt = problemData->cjtAlunos.find( cjtAlunosId );	
	if ( itMapAlunoCjt != problemData->cjtAlunos.end() )
	{
		alunos = itMapAlunoCjt->second;
	}

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}
		
		ITERA_GGROUP_LESSPTR( it1AlDemanda, aluno->demandas, AlunoDemanda )
		{
			if ( it1AlDemanda->getPrioridade() > prior )
				continue;

			Disciplina *disciplina1 = it1AlDemanda->demanda->disciplina;

			for ( int turma1 = 0; turma1 < disciplina1->getNumTurmas(); turma1++ )
			{
				ITERA_GGROUP_INIC_LESSPTR( it2AlDemanda, it1AlDemanda, aluno->demandas, AlunoDemanda )
				{
					if ( it2AlDemanda->getPrioridade() > prior )
						continue;

					Disciplina *disciplina2 = it2AlDemanda->demanda->disciplina;

					if ( disciplina1 == disciplina2 )
						continue;

					for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
					{
						c.reset();
						c.setType( ConstraintPre::C_PRE_ATIVA_VAR_COMPART_TURMA );
						c.setAluno( aluno );
						c.setTurma1( turma1 );
						c.setTurma2( turma2 );
						c.setDisciplina1( disciplina1 );
						c.setDisciplina2( disciplina2 );
						c.setCampus( campus );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHashPre.find( c ) != cHashPre.end() )
						{
							continue;
						}

						nnz = 3;
		
						OPT_ROW row( nnz, OPT_ROW::LESS, 1.0, name );

						VariablePre v;
						v.reset();
						v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
						v.setAluno( aluno );
						v.setDisciplina( disciplina1 );
						v.setTurma( turma1 );
						v.setCampus( campus );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1.0 );
						}

						v.reset();
						v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
						v.setAluno( aluno );
						v.setDisciplina( disciplina2 );
						v.setTurma( turma2 );
						v.setCampus( campus );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1.0 );
						}
				
						v.reset();
						v.setType( VariablePre::V_PRE_TURMAS_COMPART );				
						v.setDisciplina1( disciplina1 );
						v.setTurma1( turma1 );
						v.setDisciplina2( disciplina2 );
						v.setTurma2( turma2 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, -1.0 );
						}
						else
						{	// Analoga
							v.reset();
							v.setType( VariablePre::V_PRE_TURMAS_COMPART );				
							v.setDisciplina2( disciplina1 );
							v.setTurma2( turma1 );
							v.setDisciplina1( disciplina2 );
							v.setTurma1( turma2 );

							it_v = vHashPre.find( v );
							if( it_v != vHashPre.end() )
							{
								row.insert( it_v->second, -1.0 );
							}						
						}
						
						if ( row.getnnz() == 3 )
						{
							cHashPre[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}
	}

	return restricoes;

}

/*
	sum[i] sum[d] nCreds_{i,d,t} *s_{i,d,a} <= NroMaxCredsFixados_{a,t,sl}
	for all a
	for all t
	for all sl

	ou, caso o aluno não tenha nenhuma aula já alocado no dia t:

	sum[i] sum[d] nCreds_{i,d,t} *s_{i,d,a} <= Min{ MaxCreds{t,sl1}, MaxCreds{t,sl2} }
	for all a
	for all t

*/
int SolverMIP::cria_preRestricao_maxCredsAlunoDia( int campusId, int cjtAlunosAtualId, int prioridade )
{
   int restricoes = 0;

   if ( prioridade < 2 )
	   return restricoes;
   
   char name[ 100 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;
      
	if ( problemData->cjtAlunos.size() > 1 )
	{
		std::cout<<"\nMais de 1 grupo de alunos! Acrescentar filtro de alunos na funcao "
			     <<"SolverMIP::cria_preRestricao_maxCredsAlunoDia\n";
	}

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus *campus = *itCampus;

	   if ( campus->getId() != campusId )
	   {
		   continue;
	   }

      GGroup< int >::iterator itDiasLetCampus = campus->diasLetivos.begin();

      ITERA_GGROUP_N_PT( itDiasLetCampus, campus->diasLetivos, int )
      {
		 int dia = *itDiasLetCampus;

         ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
         {
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->campus->getId() != campusId )
			{
				continue;
			}
			
			int k = retornaCombinacaoSLAlunoTaticoAnterior( aluno, dia );
			
			// se a variavel c_{a,t,k} existir para o aluno (pesquisa no tatico anterior)
			// significa que o aluno já possui alguma aula alocada no dia
			if ( k != -1 )
			{
				GGroup< Calendario*, LessPtr<Calendario> > calendarios = itAluno->retornaSemanasLetivas();

				ITERA_GGROUP_LESSPTR( itSL, calendarios, Calendario )
				{
					Calendario *sl = *itSL;

					c.reset();
					c.setType( ConstraintPre::C_PRE_MAX_CREDS_ALUNO_DIA );
					c.setAluno( aluno );
					c.setDia( dia );
					c.setCampus( *itCampus );
					c.setSemanaLetiva( sl );

					sprintf( name, "%s", c.toString().c_str() ); 
					if ( cHashPre.find( c ) != cHashPre.end() )
					{
					   continue;
					}

					// Calcula rhs								
					int rhs = 0.0;
					std::map< Trio<int, int, Calendario*>, int >::iterator it_map = aluno->combinaCredSL.begin();
					for ( ; it_map != aluno->combinaCredSL.end(); it_map++  )
					{
						if ( it_map->first.first == dia &&
							 it_map->first.second == k &&
							 it_map->first.third == sl )
						{
							rhs = aluno->getNroMaxCredCombinaSL( k, sl, dia );
						}
					}

					nnz = 5;
				
					OPT_ROW row( nnz, OPT_ROW::LESS , rhs, name );
				
					ITERA_GGROUP_LESSPTR( it_al_dem, aluno->demandas, AlunoDemanda )
					{
						disciplina = ( *it_al_dem )->demanda->disciplina;

						#pragma region Equivalencias
						if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							   problemData->mapDiscSubstituidaPor.end() ) &&
							 !problemData->ehSubstituta( disciplina ) )
						{
							continue;
						}
						#pragma endregion	

						// Só considera disciplinas da semana letiva corrente
						if ( disciplina->getCalendario() != *itSL )
						{
							continue;
						}

						// P1 - aluno já alocado em uma turma
						if ( (*it_al_dem)->getPrioridade() < prioridade )
						{
 							int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );

							if ( turma != -1 )
							{
								double nCredsDia = retornaNCredsAlocados( turma, disciplina, dia, campusId );

								// Se a alocação for no dia
								if ( nCredsDia > 1e-5 )
								{
									v.reset();
									v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
									v.setTurma( turma );
									v.setDisciplina( disciplina );
									v.setAluno( aluno );
									v.setCampus( campus );

									it_v = vHashPre.find( v );
									if ( it_v != vHashPre.end() )
									{								
										row.insert( it_v->second, nCredsDia );  
									}
								}
							}
							else
							{
								std::cout<<"\n\nAtencao em SolverMIP::cria_preRestricao_maxCredsAlunoDia(), isto pode ser um erro."
										 <<"\nAluno nao encontrado em turma alguma para demanda de prioridade anterior!"
										 <<"\nAluno: "<<aluno->getAlunoId()<<" Disciplina: "<<disciplina->getId();
							}
						}
						else // P2 - aluno tentando ser alocado em uma turma já existente
						{
							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								double nCredsDia = retornaNCredsAlocados( turma, disciplina, dia, campusId );

								if ( nCredsDia > 1e-5 ) // Se já existe a turma fixada no dia
								{
									v.reset();
									v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
									v.setTurma( turma );
									v.setDisciplina( disciplina );
									v.setAluno( aluno );
									v.setCampus( campus );

									it_v = vHashPre.find( v );
									if ( it_v != vHashPre.end() )
									{								
										row.insert( it_v->second, nCredsDia );  
									}
								}
							}
						}
					}

					if ( row.getnnz() > 0 )
					{
					   cHashPre[ c ] = lp->getNumRows();

					   lp->addRow( row );
					   restricoes++;
					}
				}
			}
			else
			{
				// a variavel c_{a,t,k} não existe para o aluno (pesquisa no tatico anterior)
				// significa que o aluno não possui aula alocada no dia.
				// O rhs da restrição será Min{ MaxCreds{t,sl1}, MaxCreds{t,sl2} },
				// logo a restrição não será por semana letiva

				c.reset();
				c.setType( ConstraintPre::C_PRE_MAX_CREDS_ALUNO_DIA );
				c.setAluno( aluno );
				c.setDia( dia );
				c.setCampus( *itCampus );
				
				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHashPre.find( c ) != cHashPre.end() )
				{
					continue;
				}

				// Calcula rhs								
				double rhs = 9999999.9;

				nnz = 5;				
				OPT_ROW row( nnz, OPT_ROW::LESS , rhs, name );

				ITERA_GGROUP_LESSPTR( it_al_dem, aluno->demandas, AlunoDemanda )
				{
					disciplina = ( *it_al_dem )->demanda->disciplina;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion	

					// P2 - aluno tentando ser alocado em uma turma já existente no dia
					if ( (*it_al_dem)->getPrioridade() == prioridade )
					{
						for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
						{
							double nCredsDia = retornaNCredsAlocados( turma, disciplina, dia, campusId );

							if ( nCredsDia > 1e-5 ) // Se já existe a turma fixada no dia
							{
								v.reset();
								v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
								v.setTurma( turma );
								v.setDisciplina( disciplina );
								v.setAluno( aluno );
								v.setCampus( campus );

								it_v = vHashPre.find( v );
								if ( it_v != vHashPre.end() )
								{
									double maxTempoDia = disciplina->getCalendario()->getTempoTotal( dia );
									if ( rhs - maxTempoDia > 1e-5 )
									{
										rhs = maxTempoDia;
									}

									row.insert( it_v->second, nCredsDia*disciplina->getTempoCredSemanaLetiva() );  
								}
							}
						}
					}					
				}

				row.setRhs( rhs );

				if ( row.getnnz() > 0 )
				{
					cHashPre[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}
         }
      }
   }

   return restricoes;
 
}


int SolverMIP::cria_preRestricao_distribuicao_aluno( int campusId, int cjtAlunosId  )
{
    int restricoes = 0;

	//map<Disciplina *, map<int, map<Disciplina *, map<int, set<Aluno*, LessPtr< Aluno > > > ,LessPtr< Disciplina > > >,LessPtr< Disciplina > > mapAlunos;
   
    char name[ 100 ];

    ConstraintPre c;
	ConstraintPreHash::iterator cit;
    VariablePre v;
    VariablePreHash::iterator vit;

	vit = vHashPre.begin();

	while(vit != vHashPre.end())
	{
		if(vit->first.getType() == VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC)
		{
			VariablePre v = vit->first;

			Aluno *aluno = v.getAluno();
			Disciplina *disc = v.getDisciplina();
			int turma = v.getTurma();

			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;

				if(*disciplina < *disc)
				{
					for ( int turma2 = 0; turma2 < disciplina->getNumTurmas(); turma2++ )
					{
						c.reset();
						c.setType(ConstraintPre::C_PRE_DISTR_ALUNOS);
						c.setDisciplina(disciplina);
						c.setTurma(turma2);
						c.setDisciplina2(disc);
						c.setTurma2(turma);
						c.setAluno(aluno);

						cit = cHashPre.find(c);

						if(cit != cHashPre.end())
							lp->chgCoef(cit->second, vit->second, 1.0);
						else
						{
							sprintf( name, "%s", c.toString().c_str() ); 
							OPT_ROW row( 3 , OPT_ROW::LESS, 1.0 , name );

							row.insert(vit->second, 1.0);

							cHashPre[ c ] = lp->getNumRows();

							lp->addRow( row );
							restricoes++;

							//mapAlunos[disciplina][turma2][disc][turma].insert(aluno);
						}
					}
				}
				else if(*disc < *disciplina)
				{
					for ( int turma2 = 0; turma2 < disciplina->getNumTurmas(); turma2++ )
					{
						c.reset();
						c.setType(ConstraintPre::C_PRE_DISTR_ALUNOS);
						c.setDisciplina(disc);
						c.setTurma(turma);
						c.setDisciplina2(disciplina);
						c.setTurma2(turma2);
						c.setAluno(aluno);

						cit = cHashPre.find(c);

						if(cit != cHashPre.end())
							lp->chgCoef(cit->second, vit->second, 1.0);
						else
						{
							sprintf( name, "%s", c.toString().c_str() ); 
							OPT_ROW row( 3 , OPT_ROW::LESS, 1.0 , name );

							row.insert(vit->second, 1.0);

							cHashPre[ c ] = lp->getNumRows();

							lp->addRow( row );
							restricoes++;

							//mapAlunos[disc][turma][disciplina][turma2].insert(aluno);
						}
					}
				}
			}
		}

		vit++;
	}

	cit = cHashPre.begin();

	while(cit != cHashPre.end())
	{
      if(cit->first.getType() == ConstraintPre::C_PRE_DISTR_ALUNOS)
		{
			ConstraintPre c = cit->first;

			Disciplina *disciplina = c.getDisciplina();
			int turma = c.getTurma();
			Disciplina *disciplina2 = c.getDisciplina2();
			int turma2 = c.getTurma2();

         VariablePre v2;
			
	      v2.reset();
		   v2.setType(VariablePre::V_PRE_FOLGA_DISTR_ALUNOS);
			v2.setDisciplina(disciplina);
		   v2.setTurma(turma);
			v2.setDisciplina2(disciplina2);
			v2.setTurma2(turma2);

         vit = vHashPre.find(v2);

         if(vit != vHashPre.end())
            lp->chgCoef(cit->second, vit->second, -1.0);
         else
         {
            v2.reset();
            v2.setType(VariablePre::V_PRE_FOLGA_DISTR_ALUNOS);
            v2.setDisciplina2(disciplina);
            v2.setTurma2(turma);
            v2.setDisciplina(disciplina2);
            v2.setTurma(turma2);

            vit = vHashPre.find(v2);

            if(vit != vHashPre.end())
               lp->chgCoef(cit->second, vit->second, -1.0);
         }
      }

		cit++;
	}

	return restricoes;
}

int SolverMIP::cria_preRestricao_aluno_sala( int campusId, int grupoAlunosAtualId )
{
    int restricoes = 0;

    char name[ 200 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;   

	Campus *cp = problemData->refCampus[campusId];

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para cada conjunto de alunos com id menor ou igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;

		if ( grupoAlunosId > grupoAlunosAtualId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			// Itera as salas
			ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
			{
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{
					// Itera as disciplinas
					ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
					{
						Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;

						if ( (*itCjtSala)->disciplinas_associadas.find( disciplina ) ==  
							 (*itCjtSala)->disciplinas_associadas.end() )
						{
							continue;
						}

						for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
						{
							c.reset();
							c.setType( ConstraintPre::C_PRE_ALUNO_SALA );
							c.setAluno( aluno );
							c.setDisciplina( disciplina );
							c.setTurma( turma );
							c.setUnidade( *itUnidade );
							c.setSubCjtSala( *itCjtSala );

							sprintf( name, "%s", c.toString().c_str() ); 

							if ( cHashPre.find( c ) != cHashPre.end() )
							{
								std::cout<<"\nERRO: nao deveria ter repetido, como??\n";
								continue;
							}

							nnz = 3;

							OPT_ROW row( nnz, OPT_ROW::GREATER , -1.0 , name );

							v.reset();
							v.setType( VariablePre::V_PRE_ALUNO_SALA ); // as_{a,s}
							v.setAluno( aluno );
							v.setSubCjtSala( *itCjtSala );
							v.setUnidade( *itUnidade );
							it_v = vHashPre.find( v );
							if( it_v != vHashPre.end() )
							{
								row.insert( it_v->second, 1.0 );
							}

							VariablePre v;
							v.reset();
							v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC ); // s_{i,d,a}
							v.setAluno( aluno );
							v.setDisciplina( disciplina );
							v.setTurma( turma );
							v.setCampus( cp );
							it_v = vHashPre.find( v );
							if( it_v != vHashPre.end() )
							{
								row.insert( it_v->second, -1.0 );
							}

							v.reset();
							v.setType( VariablePre::V_PRE_OFERECIMENTO ); // o_{i,d,u,s}
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setSubCjtSala( *itCjtSala );
							v.setUnidade( *itUnidade );
							it_v = vHashPre.find( v );
							if( it_v != vHashPre.end() )
							{
								row.insert( it_v->second, -1.0 );
							}

							if ( row.getnnz() == 3 )
							{
								cHashPre[ c ] = lp->getNumRows();
								lp->addRow( row );
								restricoes++;
							}
						}
					}
				}
			}
		}
	}

	return restricoes;
}


int SolverMIP::cria_preRestricao_formandos( int campusId, int cjtAlunosId, int prioridade, int r )
{
    int restricoes = 0;

	if ( !problemData->parametros->violar_min_alunos_turmas_formandos )
		return restricoes;		

	if ( prioridade==1 && r==1 ) // só considera formandos na segunda rodada
		return restricoes;
		
    char name[ 100 ];

    ConstraintPre c;
	ConstraintPreHash::iterator cit;
    VariablePre v;
    VariablePreHash::iterator vit;

	vit = vHashPre.begin();

	for ( ; vit != vHashPre.end(); vit++ )
	{
		// s_{i,d,a}
		if( vit->first.getType() == VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC )
		{			
			VariablePre v = vit->first;

			Aluno *aluno = v.getAluno();
			Disciplina *disciplina = v.getDisciplina();
			int turma = v.getTurma();
			Campus *campus = v.getCampus();

			if ( !aluno->ehFormando() )
				continue;

			// -----------------------------------------
			// Constraint 1
		
			c.reset();
			c.setType( ConstraintPre::C_PRE_FORMANDOS1 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashPre.find(c);

			if(cit != cHashPre.end())
			{
				lp->chgCoef(cit->second, vit->second, -1.0);
			}
			else
			{
				int nnz=50;
				sprintf( name, "%s", c.toString().c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::GREATER, 0.0, name );

				row.insert(vit->second, -1.0);

				cHashPre[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}						
		
			// -----------------------------------------
			// Constraint 2
			
			c.reset();
			c.setType( ConstraintPre::C_PRE_FORMANDOS2 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashPre.find(c);

			if(cit != cHashPre.end())
			{
				lp->chgCoef(cit->second, vit->second, -1.0);
			}
			else
			{
				int nnz=50;
				sprintf( name, "%s", c.toString().c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );

				row.insert(vit->second, -1.0);

				cHashPre[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}
		}

		// f_{i,d,cp}
		else if( vit->first.getType() == VariablePre::V_PRE_FORMANDOS_NA_TURMA )
		{			
			VariablePre v = vit->first;

			Campus *campus = v.getCampus();
			Disciplina *disciplina = v.getDisciplina();
			int turma = v.getTurma();

			// -----------------------------------------
			// Constraint 1

			double M = problemData->getNroDemandaPorFormandos( disciplina, campus, prioridade );

			c.reset();
			c.setType( ConstraintPre::C_PRE_FORMANDOS1 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashPre.find(c);
			if(cit != cHashPre.end())
			{
				lp->chgCoef(cit->second, vit->second, M);
			}
			else
			{
				int nnz=50;
				sprintf( name, "%s", c.toString().c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::GREATER, 0.0, name );

				row.insert(vit->second, M);

				cHashPre[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}						
		
			// -----------------------------------------
			// Constraint 2
						
			c.reset();
			c.setType( ConstraintPre::C_PRE_FORMANDOS2 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashPre.find(c);

			if(cit != cHashPre.end())
			{
				lp->chgCoef(cit->second, vit->second, 1.0);
			}
			else
			{
				int nnz=50;
				sprintf( name, "%s", c.toString().c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );

				row.insert(vit->second, 1.0);

				cHashPre[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}		
		}
	}
	
	return restricoes;
}

   /********************************************************************
   **    CRIAÇÃO DE VARIAVEIS E RESTRIÇÕES DO TATICO SEM HORARIOS     **
   *********************************************************************/ 
   
#ifndef TATICO_COM_HORARIOS

  
/*
	Novo modelo tatico - aluno - sem horarios - cjt de alunos

	VARIAVEIS TATICO POR ALUNO E SEM HORARIOS
*/

int SolverMIP::cria_variaveis_aluno_sh( int campusId, int cjtAlunosAtualId, int prioridade )
{
	int num_vars = 0;
	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_variaveis
	int numVarsAnterior = 0;
#endif

	timer.start();
	num_vars += cria_variavel_oferecimentos( campusId, cjtAlunosAtualId, prioridade ); // variável 'o'
	timer.stop();
	dif = timer.getCronoCurrSecs();
	
#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"o\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_creditos( campusId, cjtAlunosAtualId, prioridade ); // x
	timer.stop();
	dif = timer.getCronoCurrSecs();
	
#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"x\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_abertura( campusId, cjtAlunosAtualId, prioridade ); // z
	timer.stop();
	dif = timer.getCronoCurrSecs();
	
#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"z\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_consecutivos( campusId, cjtAlunosAtualId, prioridade ); // c
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"c\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	

	timer.start();
	num_vars += cria_variavel_de_folga_dist_cred_dia_superior( campusId, cjtAlunosAtualId, prioridade ); // fcp
	timer.stop();
	dif = timer.getCronoCurrSecs();
	
#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fcp\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_de_folga_dist_cred_dia_inferior( campusId, cjtAlunosAtualId, prioridade ); // fcm
	timer.stop();
	dif = timer.getCronoCurrSecs();
	
#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fcm\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_de_folga_demanda_disciplina_aluno( campusId, cjtAlunosAtualId, prioridade ); // fd
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_combinacao_divisao_credito( campusId, cjtAlunosAtualId, prioridade ); // m
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"m\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_de_folga_combinacao_divisao_credito( campusId, cjtAlunosAtualId, prioridade ); // fk
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fk\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_abertura_compativel( campusId, cjtAlunosAtualId, prioridade ); // zc
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"zc\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_maxCreds_combina_sl_sala( campusId, cjtAlunosAtualId ); // cs
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"cs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif   


	timer.start();
	num_vars += cria_variavel_maxCreds_combina_Sl_aluno( campusId, cjtAlunosAtualId, prioridade ); // ca
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"ca\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_max_creds_aluno( campusId, cjtAlunosAtualId, prioridade ); // H
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"H\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_min_creds_aluno( campusId, cjtAlunosAtualId, prioridade ); // h
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"h\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_folgafolga_demanda_p_t( campusId, cjtAlunosAtualId, prioridade ); // ffd
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"ffd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_folga_aluno_unids_distintas_dia( campusId, cjtAlunosAtualId, prioridade ); // fu_{i1,d1,i2,d2,t}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fu\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_folga_abre_turma_sequencial( campusId, cjtAlunosAtualId, prioridade ); // ft_{i,d}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"ft\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	

	return num_vars;
}
   

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var x_{i,d,u,tps,t}

%Desc 
número de créditos da turma $i$ da disciplina $d$ na unidade $u$ 
em salas do tipo (capacidade) $tps$ no dia $t$. 

%ObjCoef
\theta \cdot \sum\limits_{u \in U}\sum\limits_{tps \in SCAP_{u}} 
\sum\limits_{d \in D}\sum\limits_{t \in T}
\sum\limits_{i \in I_{d}} x_{i,d,u,tps,t}

%DocEnd
/====================================================================*/
int SolverMIP::cria_variavel_creditos( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disc );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

				if ( cjtAluno > cjtAlunosAtualId )
				{
					continue;
				}

                for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                {

				   GGroup< int /*Dias*/ >::iterator itDiscSala_Dias = problemData->disc_Conjutno_Salas__Dias
					  [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].begin();

				   for (; itDiscSala_Dias != problemData->disc_Conjutno_Salas__Dias[
						  std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].end();
						  itDiscSala_Dias++ )
				   {				   
						 Variable v;
						 v.reset();
						 v.setType( Variable::V_CREDITOS );

						 v.setTurma( turma );            // i
						 v.setDisciplina( disciplina );  // d
						 v.setUnidade( *itUnidade );     // u
						 v.setSubCjtSala( *itCjtSala );  // tps  
						 v.setDia( *itDiscSala_Dias );   // t					 		

						 double lowerBound;
						 double upperBound;

						 if ( P > 1 && FIXAR_TATICO_P1 )
						 {
							 bool found = false;
							 double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
							 if ( found ) // fixa!
							 {
								lowerBound = value - 1e-8;
								upperBound = lowerBound + 1e-8 + 1e-8;
							 }
							 else // livre!
							 {
								 lowerBound = 0.0;
								 upperBound = itCjtSala->maxCredsDiaPorSL( *itDiscSala_Dias, v.getDisciplina()->getCalendario() );
								 if ( upperBound - disciplina->getTotalCreditos() > 1e-5 )
								 {
									upperBound = disciplina->getTotalCreditos();
								 }
							 }
						 }
						 else
						 {
							 // Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
							 if ( cjtAluno != cjtAlunosAtualId )
							 {
								 lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v )  - 1e-8;
								 upperBound = lowerBound + 1e-8 + 1e-8;
							 }
							 // Se for variavel do cjt atual, deixa seus limites livres
							 else
							 {
								 lowerBound = 0.0;
								 upperBound = itCjtSala->maxCredsDiaPorSL( *itDiscSala_Dias, v.getDisciplina()->getCalendario() );						 						 
								 if ( upperBound - disciplina->getTotalCreditos() > 1e-5 )
								 {
									upperBound = disciplina->getTotalCreditos();
								 }							 
							 }
						 }

						 if ( problemData->parametros->modo_otimizacao == "OPERACIONAL" )
						 {
							double custo = 0.0;

							if ( problemData->usarProfDispDiscTatico )
							{
							   if ( problemData->disc_Dias_Prof_Tatico[ v.getDisciplina()->getId() ].find( v.getDia() )
									 == problemData->disc_Dias_Prof_Tatico[ v.getDisciplina()->getId() ].end() )
							   {
								  custo = 100.0;
							   }
							}

							if ( vHash.find( v ) == vHash.end() )
							{
							   vHash[ v ] = lp->getNumCols();

							   if ( problemData->parametros->funcao_objetivo == 0 )
							   {
								  OPT_COL col( OPT_COL::VAR_INTEGRAL, custo, lowerBound, upperBound,
									 ( char * )v.toString().c_str() );

								  lp->newCol( col );
							   }
							   else if ( problemData->parametros->funcao_objetivo == 1
								  || problemData->parametros->funcao_objetivo == 2 )
							   {
								  OPT_COL col( OPT_COL::VAR_INTEGRAL, 0.0, lowerBound, upperBound,
									 ( char * )v.toString().c_str() );

								  lp->newCol( col );
							   }

							   num_vars++;
							}
						 }
						 else
						 {
							if ( vHash.find( v ) == vHash.end() )
							{
							   if ( !criaVariavelTatico( &v ) )
									continue;

							   double custo = 0.0;

							   if ( problemData->usarProfDispDiscTatico )
							   {
								  if ( problemData->disc_Dias_Prof_Tatico[ v.getDisciplina()->getId() ].find( v.getDia() )
										== problemData->disc_Dias_Prof_Tatico[ v.getDisciplina()->getId() ].end() )
								  {
									 custo = 100.0;
								  }
							   }

							   vHash[ v ] = lp->getNumCols();
						   
							   double coef = 0.0;

							   if ( problemData->parametros->funcao_objetivo == 0 )
							   {							
									coef = -1.0;
							   }
							   else if ( problemData->parametros->funcao_objetivo == 1 )
							   {
									coef = 1.0;
							   }						   

							   OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound,
											( char * )v.toString().c_str() );
                          
							   lp->newCol( col );						 
						  
							}

							num_vars++;
						 }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var o_{i,d,u,tps,t} 

%Desc 
indica se a turma $i$ da disciplina $d$ foi alocada na unidade $u$ 
para alguma sala do tipo (capacidade) $tps$ no dia $t$.

%DocEnd
/====================================================================*/
int SolverMIP::cria_variavel_oferecimentos( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

				if ( cjtAluno > cjtAlunosAtualId )
				{
					continue;
				}

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
				                 
				  GGroup< int /*Dias*/ >::iterator itDiscSala_Dias = problemData->disc_Conjutno_Salas__Dias
                  [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].begin();

				  for (; itDiscSala_Dias != problemData->disc_Conjutno_Salas__Dias[
						std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].end();
						itDiscSala_Dias++ )
                  {
						Variable v;
						v.reset();
						v.setType( Variable::V_OFERECIMENTO );

						v.setTurma( turma );            // i
						v.setDisciplina( disciplina );  // d
						v.setUnidade( *itUnidade );     // u
						v.setSubCjtSala( *itCjtSala );  // tps  
						v.setDia( *itDiscSala_Dias );   // t

						if ( vHash.find( v ) == vHash.end() )
						{
							double coef;
							if ( problemData->parametros->funcao_objetivo == 0 ) //max
							{
								coef = -1.0;
							}
							else // min
							{
								coef = 1.0;						 
							}

							if ( !criaVariavelTatico( &v ) )
								continue;

							double lowerBound;
							double upperBound;

							if ( P > 1 && FIXAR_TATICO_P1 )
							{
								bool found = false;
								double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );

								if ( found ) // fixa!
								{
									lowerBound = value - 1e-8;
									upperBound = lowerBound + 1e-8 + 1e-8;
								}
								else // livre!
								{
									lowerBound = 0.0;
									upperBound = 1.0;							 
								}
							}
							else
							{
								// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
								if ( cjtAluno != cjtAlunosAtualId )
								{
									lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
									upperBound = lowerBound + 1e-8 + 1e-8;
								}
								// Se for variavel do cjt atual, deixa seus limites livres
								else
								{
									lowerBound = 0.0;
									upperBound = 1.0;						 						 
								}
							}

							vHash[ v ] = lp->getNumCols();

							OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound,
								( char * )v.toString().c_str());

							lp->newCol( col );
							num_vars++;
						}
                   }
               }
            }
         }
      }
   }

   return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var z_{i,d,cp} 

%Desc 
indica se houve abertura da $i$-ésima turma da disciplina $d$ no campus $cp$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_abertura( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			continue;
		 }

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion

		 int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

		 if ( cjtAluno > cjtAlunosAtualId )
		 {
		 	 continue;
		 }		 

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_ABERTURA );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( *it_campus );	    // cp

            std::pair< int, int > dc
               = std::make_pair( disciplina->getId(), it_campus->getId() );

            if ( problemData->demandas_campus.find( dc )
               == problemData->demandas_campus.end() )
            {
               problemData->demandas_campus[ dc ] = 0;
            }

            if ( vHash.find(v) == vHash.end() )
            {
			    if ( !criaVariavelTatico( &v ) )
					continue;

				double lowerBound;
				double upperBound;

				if ( P > 1 && FIXAR_TATICO_P1 )
				{
					bool found = false;
					double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
					if ( found ) // fixa!
					{
						lowerBound = value - 1e-8;
						upperBound = lowerBound + 1e-8 + 1e-8;
					}
					else // livre!
					{
						lowerBound = 0.0;
						upperBound = 1.0;							 
					}
				}
				else
				{
					// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
					if ( cjtAluno != cjtAlunosAtualId )
					{
						lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
						upperBound = lowerBound + 1e-8 + 1e-8;
					}
					// Se for variavel do cjt atual, deixa seus limites livres
					else
					{
						lowerBound = 0.0;
						upperBound = 1.0;						 						 
					}
				}
                vHash[v] = lp->getNumCols();
			   
			    double coef = 0.0;

			    OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

                lp->newCol( col );

                num_vars++;
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var c_{i,d,t} 

%Desc 
indica se houve abertura de turma $i$ da disciplina $d$ em dias consecutivos.

%ObjCoef
\delta \cdot \sum\limits_{d \in D} 
\sum\limits_{i \in I_{d}} \sum\limits_{t \in T-{1}} c_{i,d,t}

%Data \delta
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_consecutivos( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	  if ( it_campus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( it_unidade, it_campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_conjunto_sala, it_unidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, it_conjunto_sala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

				if ( cjtAluno > cjtAlunosAtualId )
				{
		 			continue;
				}

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos
                     = it_conjunto_sala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     Variable v;
                     v.reset();
                     v.setType( Variable::V_DIAS_CONSECUTIVOS );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );     // t
					 v.setCampus( *it_campus );      // cp

                     if ( vHash.find( v ) == vHash.end() )
                     {
						if ( !criaVariavelTatico( &v ) )
							continue;

                        vHash[v] = lp->getNumCols();
					    
						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{
							coef = -1.0;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{
							coef = 1.0;
						}

						double lowerBound;
						double upperBound;
						
						if ( P > 1 && FIXAR_TATICO_P1 )
						{
							bool found = false;
							double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
							if ( found ) // fixa!
							{
								lowerBound = value - 1e-8;
								upperBound = lowerBound + 1e-8 + 1e-8;
							}
							else // livre!
							{
								lowerBound = 0.0;
								upperBound = 1.0;							 
							}
						}
						else
						{
							// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
							if ( cjtAluno != cjtAlunosAtualId )
							{
								lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
								upperBound = lowerBound + 1e-8 + 1e-8;
							}
							// Se for variavel do cjt atual, deixa seus limites livres
							else
							{
								lowerBound = 0.0;
								upperBound = 1.0;						 						 
							}
						}

						OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );
						                           
						lp->newCol( col );

                        num_vars++;
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fcp_{i,d,t}

%Desc 
variável de folga superior para a restrição de fixação da distribuição de créditos por dia.
%ObjCoef
\xi \cdot \sum\limits_{d \in D} \sum\limits_{t \in T} fcp_{i,d,t}

%Data \xi
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_dist_cred_dia_superior( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  if ( itCampus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				// A disciplina deve ser ofertada no campus especificado
				if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
					 problemData->cp_discs[campusId].end() )
				{
					continue;
				}

			   #pragma region Equivalencias
			   if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
			   {
				   continue;
			   }
			   #pragma endregion
			   
			   int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

			   if ( cjtAluno > cjtAlunosAtualId )
			   {
					continue;
			   }

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos
                     = itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() 
                           && it_fix->getDiaSemana() == ( *itDiasLetDisc ) )
                        {
                           Variable v;
                           v.reset();
                           v.setType( Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR );

                           v.setTurma( turma );
                           v.setDisciplina( disciplina );
                           v.setDia( *itDiasLetDisc );
                           v.setSubCjtSala( *itCjtSala );

                           if ( vHash.find( v ) == vHash.end() )
                           {
							    if ( !criaVariavelTatico( &v ) )
									continue;

                                vHash[v] = lp->getNumCols();
                                int cred_disc_dia = it_fix->disciplina->getMaxCreds();

								double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{
									coef = -itCampus->getCusto()/2;
								}
								else if ( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = itCampus->getCusto()/2;
								}
               
								double lowerBound;
								double upperBound;

								if ( P > 1 && FIXAR_TATICO_P1 )
								{
									bool found = false;
									double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
									if ( found ) // fixa!
									{
										lowerBound = value - 1e-8;
										upperBound = lowerBound + 1e-8 + 1e-8;
									}
									else // livre!
									{
										lowerBound = 0.0;
										upperBound = cred_disc_dia;							 
									}
								}
								else
								{
									// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
									if ( cjtAluno != cjtAlunosAtualId )
									{
										lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
										upperBound = lowerBound + 1e-8 + 1e-8;
									}
									// Se for variavel do cjt atual, deixa seus limites livres
									else
									{
										lowerBound = 0.0;
										upperBound = cred_disc_dia;						 						 
									}
								}

								OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, cred_disc_dia,
										( char * )v.toString().c_str() );
			                 
								lp->newCol( col );

                                num_vars++;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

   
/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fcm_{i,d,t}  

%Desc 
variável de folga inferior para a restrição de fixação da distribuição de créditos de uma disciplina por dia.

%ObjCoef
\xi \cdot \sum\limits_{d \in D} \sum\limits_{t \in T} fcm_{i,d,t}

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_dist_cred_dia_inferior( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				// A disciplina deve ser ofertada no campus especificado
				if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
					 problemData->cp_discs[campusId].end() )
				{
					continue;
				}

			   #pragma region Equivalencias
			   if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					  problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
			   {
				  continue;
			   }
			   #pragma endregion
			   
				int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

				if ( cjtAluno > cjtAlunosAtualId )
				{
					continue;
				}

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos =
                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() 
                           && it_fix->getDiaSemana() == ( *itDiasLetDisc ) )
                        {
                           Variable v;
                           v.reset();
                           v.setType( Variable::V_SLACK_DIST_CRED_DIA_INFERIOR );

                           v.setTurma( turma );
                           v.setDisciplina( disciplina );
                           v.setDia( *itDiasLetDisc );
                           v.setSubCjtSala( *itCjtSala );

                           if ( vHash.find( v ) == vHash.end() )
                           {
							    if ( !criaVariavelTatico( &v ) )
									continue;

                                vHash[v] = lp->getNumCols();
                                int cred_disc_dia = it_fix->disciplina->getMinCreds();

							    double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{
									coef = -itCampus->getCusto()/2;
								}
								else if ( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = itCampus->getCusto()/2;
								}               

								double lowerBound;
								double upperBound;

								if ( P > 1 && FIXAR_TATICO_P1 )
								{
									bool found = false;
									double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
									if ( found ) // fixa!
									{
										lowerBound = value - 1e-8;
										upperBound = lowerBound + 1e-8 + 1e-8;
									}
									else // livre!
									{
										lowerBound = 0.0;
										upperBound = cred_disc_dia;							 
									}
								}
								else
								{
									// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
									if ( cjtAluno != cjtAlunosAtualId )
									{
										lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
										upperBound = lowerBound + 1e-8 + 1e-8;
									}
									// Se for variavel do cjt atual, deixa seus limites livres
									else
									{
										lowerBound = 0.0;
										upperBound = cred_disc_dia;
									}
								}

								OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound,
											( char* )v.toString().c_str() );

								lp->newCol( col );

                                num_vars += 1;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var m_{d,i,k} 

%Desc 
variável binária que indica se a combinação de divisão de créditos de uma disciplina
$k$ foi escolhida para a turma $i$ da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_combinacao_divisao_credito( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
		   problemData->cp_discs[campusId].end() )
	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
		 	 problemData->mapDiscSubstituidaPor.end() ) &&
		   !problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion
	  
	  int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );
	  if ( cjtAluno > cjtAlunosAtualId )
	  {
		  continue;
	  }

      for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
      {
         for ( unsigned k = 0; k < disciplina->combinacao_divisao_creditos.size(); k++ )
         { 
            Variable v;
            v.reset();
            v.setType( Variable::V_COMBINACAO_DIVISAO_CREDITO );

            v.setTurma( turma );           // i
            v.setDisciplina( disciplina ); // d
            v.setK( k );	                // k

            if ( vHash.find( v ) == vHash.end() )
            {
			    if ( !criaVariavelTatico( &v ) )
					continue;

                vHash[ v ] = lp->getNumCols();
				
				double lowerBound;
				double upperBound;
				
				if ( P > 1 && FIXAR_TATICO_P1 )
				{
					bool found = false;
					double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
					if ( found ) // fixa!
					{
						lowerBound = value - 1e-8;
						upperBound = lowerBound + 1e-8 + 1e-8;
					}
					else // livre!
					{
						lowerBound = 0.0;
						upperBound = 1.0;							 
					}
				}
				else
				{
					// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
					if ( cjtAluno != cjtAlunosAtualId )
					{
						lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
						upperBound = lowerBound + 1e-8 + 1e-8;
					}
					// Se for variavel do cjt atual, deixa seus limites livres
					else
					{
						lowerBound = 0.0;
						upperBound = 1.0;
					}
				}

                OPT_COL col( OPT_COL::VAR_BINARY, 0.0, lowerBound, upperBound,
                            ( char * )v.toString().c_str() );

                lp->newCol( col );
                num_vars++;
            }
         }
      }
   }

   return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fkp_{d,i,t} 

%Desc 
variável de folga superior para a restrição de combinação de divisão de créditos de uma disciplina.

%ObjCoef
\psi \cdot \sum\limits_{d \in D} 
\sum\limits_{t \in T} \sum\limits_{i \in I_{d}} fkp_{d,i,k}

%Data \psi
%Desc
peso associado a função objetivo.

%Var fkm_{d,i,t} 

%Desc 
variável de folga inferior para a restrição de combinação de divisão de créditos de uma disciplina.

%ObjCoef
\psi \cdot \sum\limits_{d \in D} 
\sum\limits_{t \in T} \sum\limits_{i \in I_{d}} fkm_{d,i,k}

%Data \psi
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_combinacao_divisao_credito( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_unidade, it_campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_conjunto_sala, it_unidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, it_conjunto_sala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion
				
				int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

				if ( cjtAluno > cjtAlunosAtualId )
				{
					continue;
				}

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos =
                     it_conjunto_sala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     Variable v;
                     v.reset();
                     v.setType( Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );	    // t

                     if ( vHash.find( v ) == vHash.end() )
                     {
						if ( !criaVariavelTatico( &v ) )
							continue;

                        vHash[v] = lp->getNumCols();

						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{
							coef = -10*it_campus->getCusto();
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{
							coef = 10*it_campus->getCusto();
						}                           

						double lowerBound;
						double upperBound;

						if ( P > 1 && FIXAR_TATICO_P1 )
						{
							bool found = false;
							double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
							if ( found ) // fixa!
							{
								lowerBound = value - 1e-8;
								upperBound = lowerBound + 1e-8 + 1e-8;
							}
							else // livre!
							{
								lowerBound = 0.0;
								upperBound = 10000.0;							 
							}
						}
						else
						{
							// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
							if ( cjtAluno != cjtAlunosAtualId )
							{
								lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
								upperBound = lowerBound + 1e-8 + 1e-8;
							}
							// Se for variavel do cjt atual, deixa seus limites livres
							else
							{
								lowerBound = 0.0;
								upperBound = 10000.0;
							}
						}

						OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound,
                              ( char * )v.toString().c_str() );

                        lp->newCol( col );

                        num_vars++;
                     }

                     v.reset();
                     v.setType( Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );	 // t

                     if ( vHash.find( v ) == vHash.end() )
                     {
						if ( !criaVariavelTatico( &v ) )
							continue;

                        vHash[v] = lp->getNumCols();

						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{
							coef = -it_campus->getCusto()/2;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{
							coef = it_campus->getCusto()/2;
						}                           

						double lowerBound;
						double upperBound;

						if ( P > 1 && FIXAR_TATICO_P1 )
						{
							bool found = false;
							double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
							if ( found ) // fixa!
							{
								lowerBound = value - 1e-8;
								upperBound = lowerBound + 1e-8 + 1e-8;
							}
							else // livre!
							{
								lowerBound = 0.0;
								upperBound = 10000.0;							 
							}
						}
						else
						{
							// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
							if ( cjtAluno != cjtAlunosAtualId )
							{
								lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
								upperBound = lowerBound + 1e-8 + 1e-8;
							}
							// Se for variavel do cjt atual, deixa seus limites livres
							else
							{
								lowerBound = 0.0;
								upperBound = 10000.0;
							}
						}

						OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound,
                              ( char * )v.toString().c_str() );
						                           
						lp->newCol( col );

                        num_vars++;
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var zc_{d,t} 

%Desc 
indica se houve abertura da disciplina $d$ no dia $t$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_abertura_compativel( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_unidade, it_campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_conjunto_sala, it_unidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, it_conjunto_sala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

				if ( cjtAluno > cjtAlunosAtualId )
				{
		 			continue;
				}

               // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
               GGroup< int > dias_letivos =
                  it_conjunto_sala->dias_letivos_disciplinas[ ( disciplina ) ];

               ITERA_GGROUP_N_PT( itDiasLetDisc, dias_letivos, int )
               {
                  Variable v;
                  v.reset();
                  v.setType( Variable::V_ABERTURA_COMPATIVEL );

                  v.setDisciplina( disciplina );  // d
                  v.setDia( *itDiasLetDisc );     // t
				  v.setCampus( *it_campus );	  // cp

                  if ( vHash.find( v ) == vHash.end() )
                  {
					 if ( !criaVariavelTatico( &v ) )
						continue;

                     vHash[ v ] = lp->getNumCols();

					 double coef = 0.0;

					 if ( problemData->parametros->funcao_objetivo == 0 )
					 {
					 	coef = -1.0;
					 }
					 else if ( problemData->parametros->funcao_objetivo == 1 )
					 {
				 		coef = 1.0;
			 		 }

					 double lowerBound;
					 double upperBound;
					 
					 if ( P > 1 && FIXAR_TATICO_P1 )
					 {
						bool found = false;
						double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
						if ( found ) // fixa!
						{
							lowerBound = value - 1e-8;
							upperBound = lowerBound + 1e-8 + 1e-8;
						}
						else // livre!
						{
							lowerBound = 0.0;
							upperBound = 1.0;							 
						}
					 }
					 else
					 {
						 // Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
						 if ( cjtAluno != cjtAlunosAtualId )
						 {
							lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
							upperBound = lowerBound + 1e-8 + 1e-8;
						 }
						 // Se for variavel do cjt atual, deixa seus limites livres
						 else
						 {
							lowerBound = 0.0;
							upperBound = 1.0;						 						 
						 }
					 }

                     OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound,
                        ( char * )v.toString().c_str() );

                     lp->newCol( col );
                     num_vars++;
                  }
               }
            }
         }
      }
   }

   return num_vars;
}


// cs_{s,t,k} -> Usado somente quando tem 2 semanas letivas
// Não pode ter fixação do valor na modelagem por cjt de alunos!
int SolverMIP::cria_variavel_maxCreds_combina_sl_sala( int campusId, int cjtAlunosAtualId )
{
   int num_vars = 0;

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() != 2 )
   {
	   return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			std::map< int, Sala * >::iterator itSala = itCjtSala->salas.begin();
			for( ; itSala != itCjtSala->salas.end(); itSala++ )
			{
				Sala *s = itSala->second;

				ITERA_GGROUP_N_PT( itDia, s->diasLetivos, int )
				{
					int dia = *itDia;

					std::map< Trio<int, int, Calendario*>, int >::iterator it_map = s->combinaCredSL.begin();
					for ( ; it_map != s->combinaCredSL.end(); it_map++ )
					{
						if ( it_map->first.first == dia )
						{
							Variable v;
							v.reset();
							v.setType( Variable::V_COMBINA_SL_SALA );
							v.setSala( s );
							v.setDia( dia );
							v.setCombinaSL( it_map->first.second );

							if ( vHash.find( v ) == vHash.end() )
							{
								if ( !criaVariavelTatico( &v ) )
									continue;

								vHash[v] = lp->getNumCols();
						   
								OPT_COL col( OPT_COL::VAR_BINARY, 0.0, 0.0, 1.0, (char*)v.toString().c_str() );

								lp->newCol( col );
								num_vars++;
							}
						}
					}
				}
			}
		 }
	  }
   }

   return num_vars;
}



// ca_{a,t,k}
int SolverMIP::cria_variavel_maxCreds_combina_Sl_aluno( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	   Aluno *aluno = *itAluno;

	   if ( aluno->getOferta()->getCampusId() != campusId )
	   {
			continue;
	   }
	   		
	   int cjtAluno = problemData->retornaCjtAlunosId( aluno );

	   if ( cjtAluno > cjtAlunosAtualId )
	   {
			continue;
	   }

	   ITERA_GGROUP_N_PT( itDia, aluno->getOferta()->campus->diasLetivos, int )
	   {
		   int dia = *itDia;

		   std::map< Trio< int/*dia*/, int /*k_id*/, Calendario* /*sl*/ >,
					  int/*nroCreds*/ >::iterator it_map = aluno->combinaCredSL.begin();

			for ( ; it_map != aluno->combinaCredSL.end(); it_map++ )
			{
				if ( it_map->first.first == dia )
				{
					Variable v;
					v.reset();
					v.setType( Variable::V_COMBINA_SL_ALUNO);

					v.setAluno( aluno );
					v.setDia( dia );
					v.setCombinaSLAluno( it_map->first.second );

					if ( vHash.find( v ) == vHash.end() )
					{
						if ( !criaVariavelTatico( &v ) )
							continue;
												   
						double lowerBound;
						double upperBound;
						
						if ( P > 1 && FIXAR_TATICO_P1 )
						{   // livre sempre!
							lowerBound = 0.0;
							upperBound = 1.0;		 
						}
						else
						{
							// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
							if ( cjtAluno != cjtAlunosAtualId )
							{
								lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
								upperBound = lowerBound + 1e-8 + 1e-8;
							}
							// Se for variavel do cjt atual, deixa seus limites livres
							else
							{
								lowerBound = 0.0;
								upperBound = 1.0;
							}
						}

						vHash[v] = lp->getNumCols();

						OPT_COL col( OPT_COL::VAR_BINARY, 0.0, lowerBound, upperBound, (char*)v.toString().c_str() );

						lp->newCol( col );
						num_vars++;
					}
				}
			}
	    }
   }

   return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var \underline{h}_{a} 

%Desc 
mínimo de créditos alocados na semana para o aluno $a$.

%DocEnd
/====================================================================*/
int SolverMIP::cria_variavel_min_creds_aluno( int campusId, int cjtAlunosAtualId, int P )
{
   int num_vars = 0;
   
	if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE)
	{
		return num_vars;
	}

   Disciplina * disciplina = NULL;

   Campus* campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( it_aluno, problemData->alunos, Aluno )
   {
	    if ( it_aluno->getOferta()->campus->getId() != campusId )
	    {
		    continue;
	    }

		int cjtAluno = problemData->retornaCjtAlunosId( *it_aluno );
		if ( cjtAluno > cjtAlunosAtualId )
		{
			continue;
		}

		Variable v;
		v.reset();
		v.setType( Variable::V_MIN_CRED_SEMANA_ALUNO );

		v.setAluno( *it_aluno );

		if ( vHash.find( v ) == vHash.end() )
		{
			if ( !criaVariavelTatico( &v ) )
				continue;

			vHash[ v ] = lp->getNumCols();
                  
			double obj = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
				{
					obj = campus->getCusto()/4;
				}
				else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
				{
					obj = campus->getCusto()/4;
				}
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
				{
					obj = campus->getCusto()/4;
				}
				else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
				{
					obj = campus->getCusto()/4;
				}
			}
               
			double lowerBound;
			double upperBound;
			
			if ( P > 1 && FIXAR_TATICO_P1 )
			{
				bool found = false;
				double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
				if ( found ) // fixa só o minimo!
				{
					lowerBound = value - 1e-8;
					upperBound = 1000.0;
				}
				else // livre!
				{
					lowerBound = 0.0;
					upperBound = 1000.0;							 
				}
			}
			else
			{
				// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
				if ( cjtAluno != cjtAlunosAtualId )
				{
					lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
					upperBound = lowerBound + 1e-8 + 1e-8;
				}
				// Se for variavel do cjt atual, deixa seus limites livres
				else
				{
					lowerBound = 0.0;
					upperBound = 1000.0;
				}
			}

			OPT_COL col( OPT_COL::VAR_INTEGRAL, obj, lowerBound, upperBound, ( char * )v.toString().c_str() );

			lp->newCol( col );

			num_vars++;
		}
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var \overline{h}_{a} 

%Desc 
máximo de créditos alocados na semana para o aluno $a$.

%DocEnd
/====================================================================*/
int SolverMIP::cria_variavel_max_creds_aluno( int campusId, int cjtAlunosAtualId, int P )
{
    int num_vars = 0;

	if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE)
	{
		return num_vars;
	}

   Disciplina * disciplina = NULL;

   Campus* campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( it_aluno, problemData->alunos, Aluno )
   {
	    if ( it_aluno->getOferta()->campus->getId() != campusId )
	    {
		    continue;
	    }
	   
		int cjtAluno = problemData->retornaCjtAlunosId( *it_aluno );
		if ( cjtAluno > cjtAlunosAtualId )
		{
			continue;
		}
		
		Variable v;
		v.reset();
		v.setType( Variable::V_MAX_CRED_SEMANA_ALUNO );

		v.setAluno( *it_aluno );

		if ( vHash.find( v ) == vHash.end() )
		{
			if ( !criaVariavelTatico( &v ) )
				continue;

			vHash[v] = lp->getNumCols();

			double obj = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
				{
					obj = -campus->getCusto()/4;
				}
				else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
				{
					obj = 0.0;
				}
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
				{
					obj = -campus->getCusto()/4;
				}
				else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
				{
					obj = 0.0;
				}
			}

			double lowerBound;
			double upperBound;
			
			if ( P > 1 && FIXAR_TATICO_P1 )
			{
				bool found = false;
				double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
				if ( found ) // fixa só o minimo!
				{
					lowerBound = value - 1e-8;
					upperBound = 1000.0;
				}
				else // livre!
				{
					lowerBound = 0.0;
					upperBound = 1000.0;							 
				}
			}
			else
			{
				// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
				if ( cjtAluno != cjtAlunosAtualId )
				{
					lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
					upperBound = lowerBound + 1e-8 + 1e-8;
				}
				// Se for variavel do cjt atual, deixa seus limites livres
				else
				{
					lowerBound = 0.0;
					upperBound = 1000.0;
				}
			}
               
			OPT_COL col( OPT_COL::VAR_INTEGRAL, obj, lowerBound, upperBound, ( char * )v.toString().c_str() );

			lp->newCol( col );

			num_vars++;
		}
   }

   return num_vars;
}


// fd_{i,d,cp}
int SolverMIP::cria_variavel_de_folga_demanda_disciplina_aluno( int campusId, int cjtAlunosAtualId, int P )
{
	int num_vars = 0;
   
   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }
	     
	  GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

      ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
      {
		  Disciplina * disciplina = problemData->refDisciplinas[ *it_disciplina ];
		  
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion
		 		 
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			  continue;
		 
		 int cjtAluno = problemData->retornaCjtAlunosId( disciplina->getId() );

		 if ( cjtAluno > cjtAlunosAtualId )
		 {
		 	 continue;
		 }

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_SLACK_DEMANDA_ALUNO );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( *it_campus );	    // cp

            std::pair< int, int > dc
               = std::make_pair( disciplina->getId(), it_campus->getId() );

            if ( problemData->demandas_campus.find( dc )
               == problemData->demandas_campus.end() )
            {
               problemData->demandas_campus[ dc ] = 0;
            }

            if ( vHash.find(v) == vHash.end() )
            {
			    if ( !criaVariavelTatico( &v ) )
					continue;

                lp->getNumCols();
                vHash[v] = lp->getNumCols();

			    double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					// Numero de aluno alocados para a turma
					int nroAlunos = problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId );
					
					coef = - 50 * nroAlunos * disciplina->getTotalCreditos() * 50.0; // TODO: receita = 50.0? usar que valor?
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 10 * disciplina->getTotalCreditos() * it_campus->getCusto();
			 	}

				double lowerBound;
				double upperBound;

				if ( P > 1 && FIXAR_TATICO_P1 )
				{
					bool found = false;
					double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
					if ( found ) // fixa!
					{
						lowerBound = value - 1e-8;
						upperBound = lowerBound + 1e-8 + 1e-8;
					}
					else // livre!
					{
						lowerBound = 0.0;
						upperBound = 1.0;							 
					}
				}
				else
				{
					// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
					if ( cjtAluno != cjtAlunosAtualId )
					{
						lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
						upperBound = lowerBound + 1e-8 + 1e-8;
					}
					// Se for variavel do cjt atual, deixa seus limites livres
					else
					{
						lowerBound = 0.0;
						upperBound = 1.0;						 						 
					}
				}

			    OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );
            
                lp->newCol( col );
				 
                num_vars++;
            }
         }
      }
   }
	
	return num_vars;
	
}


// ffd_{i1,-d,i2,d,cp}
int SolverMIP::cria_variavel_folgafolga_demanda_p_t( int campusId, int cjtAlunosAtualId, int P )
{
	int num_vars = 0;
     
    Campus* campus = problemData->refCampus[ campusId ];
	     
	GGroup< int > disciplinas = problemData->cp_discs.find( campusId )->second;

	ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
	{
		Disciplina * discPratica = problemData->refDisciplinas[ *it_disciplina ];

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( discPratica ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( discPratica ) )
		{
			continue;
		}
		#pragma endregion

		if ( discPratica->getId() > 0 )
		{
			continue;
		}
		
		std::map< int, Disciplina * >::iterator itMapDisc =
			problemData->refDisciplinas.find( - discPratica->getId() );
				
		if ( itMapDisc == problemData->refDisciplinas.end() )
		{
			continue;
		}
		
		Disciplina *discTeorica = itMapDisc->second;

		if ( ! problemData->haDemandaDiscNoCampus( discPratica->getId(), campusId ) )
		{
			continue;
		}

		int cjtAlunoP = problemData->retornaCjtAlunosId( discPratica->getId() );
		int cjtAlunoT = problemData->retornaCjtAlunosId( discTeorica->getId() );
		
		if ( cjtAlunoP != cjtAlunoT )
		{
			std::cout << "\nAtencao em SolverMIP::cria_variavel_folgafolga_demanda_p_t( int campusId, int cjtAlunosAtualId ):"
				      << "\nPar de disciplinas pratica (id=" << discPratica->getId()
					  << ") e teorica em conjunto de alunos diferentes!\n";
			continue;
		}
		if ( cjtAlunoP > cjtAlunosAtualId )
		{
		 	continue;
		}

		for ( int turma1 = 0; turma1 < discPratica->getNumTurmas(); turma1++ )
		{
			for ( int turma2 = 0; turma2 < discTeorica->getNumTurmas(); turma2++ )
			{		
				GGroup<Aluno*> alunosEmComum = problemData->alunosEmComum( turma1, discPratica, turma2, discTeorica, campus );
				
				if ( alunosEmComum.size() == 0 )
				{
					continue;
				}

				Variable v;
				v.reset();
				v.setType( Variable::V_SLACK_SLACKDEMANDA_PT );

				v.setTurma1( turma1 );            // i1
				v.setDisciplina1( discPratica );  // -d
				v.setTurma2( turma2 );            // i2
				v.setDisciplina2( discTeorica );  // d
				v.setCampus( campus );	     // cp

				if ( vHash.find(v) == vHash.end() )
				{
					if ( !criaVariavelTatico( &v ) )
						continue;

					lp->getNumCols();
					vHash[v] = lp->getNumCols();

					double coef = 0.0;
						
					if ( problemData->parametros->funcao_objetivo == 0 )
					{
						double precoDosCreditos = 0.0;
						ITERA_GGROUP( itAluno, alunosEmComum, Aluno )
						{
							precoDosCreditos += itAluno->getOferta()->getReceita();
						}
						coef = - ( discTeorica->getTotalCreditos() +
								   discPratica->getTotalCreditos() ) * precoDosCreditos;					
					}
					else if ( problemData->parametros->funcao_objetivo == 1 )
					{						
						coef = 10*( discTeorica->getTotalCreditos() + discPratica->getTotalCreditos() )
								* campus->getCusto() * alunosEmComum.size();
			 		}

					double lowerBound;
					double upperBound;

					if ( P > 1 && FIXAR_TATICO_P1 )
					{
						bool found = false;
						double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
						if ( found ) // fixa!
						{
							lowerBound = value - 1e-8;
							upperBound = lowerBound + 1e-8 + 1e-8;
						}
						else // livre!
						{
							lowerBound = 0.0;
							upperBound = 1.0;							 
						}
					}
					else
					{
						// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
						if ( cjtAlunoP != cjtAlunosAtualId )
						{
							lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
							upperBound = lowerBound + 1e-8 + 1e-8;
						}
						// Se for variavel do cjt atual, deixa seus limites livres
						else
						{
							lowerBound = 0.0;
							upperBound = 1.0;						 						 
						}
					}

					OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

					lp->newCol( col );
				 
					num_vars++;
				}
			}
		}
   }
	
	return num_vars;
	
}


// fu_{i1,d1,i2,d2,t}
int SolverMIP::cria_variavel_folga_aluno_unids_distintas_dia( int campusId, int cjtAlunosAtualId, int P )
{
	int num_vars = 0;

	if ( ! problemData->parametros->minimizar_desloc_aluno )
	{
		return num_vars;
	}

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   Campus * campus = *it_campus;

	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }
	     
	  GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

	  // Disciplina 1
      ITERA_GGROUP_N_PT( it_disc1, disciplinas, int )
      {
		  Disciplina * disciplina1 = problemData->refDisciplinas[ *it_disc1 ];
		  
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina1 ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
		 	 !problemData->ehSubstituta( disciplina1 ) )
		 {
			continue;
		 }
		 #pragma endregion
		 		 
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina1->getId(), campusId ) )
			  continue;
		
		 // Turma 1
         for ( int turma1 = 0; turma1< disciplina1->getNumTurmas(); turma1++ )
         {
			 Unidade * u1 = this->retornaUnidadeDeAtendimento( turma1, disciplina1, campus );

			 if ( u1 == NULL )
				 continue;

			  // Disciplina 2
			  ITERA_GGROUP_INIC_N_PT( it_disc2, it_disc1, disciplinas, int )
			  {
				  Disciplina * disciplina2 = problemData->refDisciplinas[ *it_disc2 ];
		  
				  #pragma region Equivalencias
				  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina2 ) !=
					     problemData->mapDiscSubstituidaPor.end() ) &&
					   !problemData->ehSubstituta( disciplina2 ) )
				  {
					  continue;
				  }
				  #pragma endregion
		 		 
				  if ( ! problemData->haDemandaDiscNoCampus( disciplina2->getId(), campusId ) )
					  continue;

				  // Turma 2
				  for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
				  {
					   Unidade * u2 = this->retornaUnidadeDeAtendimento( turma2, disciplina2, campus );

					   if ( u2 == NULL || u1 == u2 )
							continue;

					    GGroup<Aluno*> alunosEmComum = 
							problemData->alunosEmComum( turma1, disciplina1, turma2, disciplina2, campus );

						if ( alunosEmComum.size() == 0 )
							continue;

						int nroAlunos = alunosEmComum.size();
						
						int cjtAluno = problemData->retornaCjtAlunosId( disciplina2->getId() ); // tanto faz disciplina 1 ou 2
						if ( cjtAluno > cjtAlunosAtualId )
						{
		 					continue;
						}

						GGroup<int> dias = problemData->diasComunsEntreDisciplinas( disciplina1, disciplina2 );

						ITERA_GGROUP_N_PT( it_dias, dias, int )
						{
							Variable v;
							v.reset();
							v.setType( Variable::V_SLACK_ALUNO_VARIAS_UNID_DIA );

							v.setTurma1( turma1 );            // i1
							v.setDisciplina1( disciplina1 );  // d1
							v.setTurma2( turma2 );            // i2
							v.setDisciplina2( disciplina2 );  // d2
							v.setCampus( campus );		      // cp
							v.setDia( *it_dias );			  // t

							if ( vHash.find(v) == vHash.end() )
							{
								if ( !criaVariavelTatico( &v ) )
									continue;

								lp->getNumCols();
								vHash[v] = lp->getNumCols();

								double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{					
									coef = - 10 * nroAlunos;
								}
								else if ( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = 10 * nroAlunos;
			 					}

								double lowerBound;
								double upperBound;
								
								if ( P > 1 && FIXAR_TATICO_P1 )
								{
									bool found = false;
									double value = fixaLimitesVariavelTaticoPriorAnterior( &v, found );
									if ( found ) // fixa!
									{
										lowerBound = value - 1e-8;
										upperBound = lowerBound + 1e-8 + 1e-8;
									}
									else // livre!
									{
										lowerBound = 0.0;
										upperBound = 1.0;							 
									}
								}
								else
								{
									// Se for variavel de cjt anterior, fixa o seu valor igual ao da solução anterior
									if ( cjtAluno != cjtAlunosAtualId )
									{
										lowerBound = fixaLimitesVariavelTaticoCjtAlunosAnterior( &v ) - 1e-8;
										upperBound = lowerBound + 1e-8 + 1e-8;
									}
									// Se for variavel do cjt atual, deixa seus limites livres
									else
									{
										lowerBound = 0.0;
										upperBound = 1.0;						 						 
									}
								}
                  
								OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

								lp->newCol( col );
				 
								num_vars++;
							}
						}
				  }
			  }
          }
      }
   }
	
	return num_vars;
}
   
 
// ft_{i,d,cp}
// Só para P2 em diante
int SolverMIP::cria_variavel_folga_abre_turma_sequencial( int campusId, int cjtAlunosId, int P )
{
	int num_vars = 0;
	
	if ( P < 2 )
	{
	   return num_vars;
	}

   std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_disciplina, it_CpDisc->second, int )
      {
		 Disciplina *disciplina = problemData->refDisciplinas[ *it_disciplina ];
		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
		 	continue;
		 }
		 #pragma endregion
	 
		 int discGrupoAlunosId = problemData->retornaCjtAlunosId( disciplina->getId() );

 		 if ( discGrupoAlunosId > cjtAlunosId || 
			  discGrupoAlunosId == 0 )
		 {
			 continue;
		 }
		 
         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_FOLGA_ABRE_TURMA_SEQUENCIAL );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( cp );				// cp

            if ( vHash.find(v) == vHash.end() )
            {
                lp->getNumCols();
                vHash[v] = lp->getNumCols();

			    double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{							 
					coef = -10 * (turma+1);
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{					
					coef = 10 * (turma+1);
				}						                
						 
				double lowerBound = 0.0;
				double upperBound = disciplina->diasLetivos.size();

				OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound,
                     ( char * )v.toString().c_str() );

                lp->newCol( col ); 
                
				num_vars++;
            }
         }
      }
   }

	return num_vars;

}

 
/*----------------------------------------------------------------------------------
**							TATICO	POR ALUNO SEM HORARIOS					       **
----------------------------------------------------------------------------------*/


// ==============================================================
//							CONSTRAINTS
// ==============================================================

int SolverMIP::cria_restricoes_aluno_sh( int campusId, int cjtAlunosId, int prioridade )
{
	int restricoes = 0;

	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_restricoes
	int numRestAnterior = 0;
#endif

	timer.start();
	restricoes += cria_restricao_carga_horaria( campusId, cjtAlunosId );				// Restricao 1.2.2
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.2\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_tempo_sd( campusId, cjtAlunosId );					// Restricao 1.2.3.a
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.3.a\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_tempo_s_t_SL( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();
	
#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.3.b\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_ativacao_var_o( campusId, cjtAlunosId );					// Restricao 1.2.5
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_evita_sobreposicao( campusId, cjtAlunosId );			// Restricao 1.2.6
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.6\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	
	timer.start();
	restricoes += cria_restricao_max_cred_disc_aluno( campusId, cjtAlunosId );		// Restricao 1.2.11
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.11\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
	

	timer.start();
	restricoes += cria_restricao_lim_cred_diar_disc( campusId, cjtAlunosId );			// Restricao 1.2.13
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.13\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_aloc_dem_disc( campusId, cjtAlunosId );			// Restricao 1.2.14
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.14\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	//restricoes += cria_restricao_turma_disc_dias_consec();		// Restricao 1.2.17
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	//std::cout << "numRest \"1.2.17\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	std::cout << "numRest \"1.2.17\": NAO ESTA SENDO CRIADA DEVIDO A ERROS DE IMPLEMENTACAO - VER ToDo 12 (MARIO)"  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_min_creds_semana_aluno( campusId, cjtAlunosId );		// Restricao 1.2.18
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.18\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_creds_semana_aluno( campusId, cjtAlunosId );		// Restricao 1.2.19
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.19\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_de_folga_dist_cred_dia( campusId, cjtAlunosId );		// Restricao 1.2.22
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.22\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_limita_abertura_turmas_aluno( campusId, cjtAlunosId );			// Restricao 1.2.24
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.24\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_abre_turmas_em_sequencia( campusId, cjtAlunosId, prioridade );						// Restricao 1.2.25
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.25\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_divisao_credito( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.26\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_combinacao_divisao_credito( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.27\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_ativacao_var_zc( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.31\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_disciplinas_incompativeis( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.32\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	
	timer.start();
	restricoes += cria_restricao_ativacao_var_cs( campusId, cjtAlunosId ); // Restricao 1.2.49
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.49\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
		
	
	/*timer.start();
	restricoes += cria_restricao_evita_sobrepos_turmas_mesmos_alunos( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.50\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif*/

	timer.start();
	restricoes += cria_restricao_disc_pratica_teorica( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.51\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_ativacao_var_ca( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.52\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_aluno_unid_dif_dia( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.53\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_evita_sobrepos_cliqueAlunos( campusId, cjtAlunosId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.54\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
	
	return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Carga horária de todas as turmas de cada disciplina

%MatExp 

\begin{eqnarray}
\sum\limits_{u \in U}\sum\limits_{tps \in SCAP_{u}}\sum\limits_{t \in T} x_{i,d,u,tps,t}  =  C_{d} \cdot z_{i,d,cp} \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad 
\forall cp \in CP 
\end{eqnarray}

%Data C_{d}
%Desc
Total de créditos da disciplina $d$.

%Data I_{d}
%Desc
Máximo de turmas que podem ser abertas da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_carga_horaria( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   int nnz;
   char name[ 100 ];

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			 continue;
		 }

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion

		  map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		    itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		  if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		  {
			  if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
				   NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
           {
				  continue;
           }
		  }
		  else
		  {
			  continue;
		  }

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( Constraint::C_CARGA_HORARIA );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = ( itCampus->getTotalSalas() * 7 );

            OPT_ROW row( nnz + 1, OPT_ROW::EQUAL , 0 , name );

            v.reset();
            v.setType( Variable::V_CREDITOS );

            // ---

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
                  GGroup< int /*dias*/ > disc_sala_dias
                     = problemData->disc_Conjutno_Salas__Dias
                     [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ];

                  ITERA_GGROUP_N_PT( itDiscSala_Dias, disc_sala_dias, int )
                  {
                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );                   

                     it_v = vHash.find( v );
                     if( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }
                  }
               }
            }

            // ---

            v.reset();
            v.setType( Variable::V_ABERTURA );

            v.setCampus( *itCampus );
            v.setDisciplina( disciplina );
            v.setTurma( turma );

            it_v = vHash.find( v );
            if( it_v != vHash.end() )
            {
               row.insert( it_v->second,
                  -( disciplina->getCredPraticos() + 
                  disciplina->getCredTeoricos() ) );
            }

            // ---

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Máximo de tempo por sala e dia
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{d \in D}\sum\limits_{i \in I_{d}} sl_{d} \cdot x_{i,d,u,tps,t} \leq  HTPS_{t,tps} \nonumber \qquad 
\forall u \in U \quad
\forall tps \in SCAP_{u} \quad
\forall t \in T
\end{eqnarray}

%Data HTPS_{t,tps}
%Desc
máximo de tempo permitido por dia $t$ para o conjunto de salas do tipo (capacidade) $tps$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_tempo_sd( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   // Metodo somente utilizado quando há 1 semana letiva
   if ( problemData->calendarios.size() != 1 )
   {
	   return restricoes;
   }

   int nnz;
   char name[ 100 ];

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;
   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            //////////////////////////////////////////////////////////////////////
            // Percorre cada disciplina do conjunto de salas
            std::map< Disciplina *, GGroup< int > >::iterator
               it_disc_dias = itCjtSala->dias_letivos_disciplinas.begin();

            for (; it_disc_dias != itCjtSala->dias_letivos_disciplinas.end(); it_disc_dias++ )
            {
               // Verifica se a disciplina foi substituída
               disciplina = it_disc_dias->first;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               GGroup< int >::iterator itDiasLetCjtSala =
                  it_disc_dias->second.begin();

               for (; itDiasLetCjtSala != it_disc_dias->second.end(); itDiasLetCjtSala++ )
               {
                  c.reset();
                  c.setType( Constraint::C_MAX_TEMPO_SD );

                  c.setUnidade( *itUnidade );
                  c.setSubCjtSala( *itCjtSala );
                  c.setDia( *itDiasLetCjtSala );

                  sprintf( name, "%s", c.toString().c_str() );
                  if ( cHash.find( c ) != cHash.end() )
                  {
                     continue;
                  }

                  nnz = 0;
                  ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
                  {
					 // A disciplina deve ser ofertada no campus especificado
					 if ( problemData->cp_discs[campusId].find( itDisc->getId() ) ==
						  problemData->cp_discs[campusId].end() )
					 {
						 continue;
					 }
                     if ( itDisc->getNumTurmas() >= 0 )
                     {
                        nnz += ( itDisc->getNumTurmas() );
                     }
                  }

                  int HTPS = itCjtSala->maxTempoPermitidoPorDia( *itDiasLetCjtSala );
                  OPT_ROW row( nnz, OPT_ROW::LESS , HTPS, name );

                  ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
                  {
					 #pragma region Equivalencias
					 if ( ( problemData->mapDiscSubstituidaPor.find( *itDisc ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						  !problemData->ehSubstituta( *itDisc ) )
					 {
						continue;
					 }
					 #pragma endregion

					 // A disciplina deve ser ofertada no campus especificado
					 if ( problemData->cp_discs[campusId].find( itDisc->getId() ) ==
						  problemData->cp_discs[campusId].end() )
					 {
						 continue;
					 }

                     for ( int turma = 0; turma < itDisc->getNumTurmas(); turma++ )
                     {
                        v.reset();
                        v.setType( Variable::V_CREDITOS );

                        v.setTurma( turma );
                        v.setUnidade( *itUnidade );
                        v.setDisciplina( *itDisc );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiasLetCjtSala );

                        it_v = vHash.find( v );
                        if( it_v != vHash.end() )
                        {
							row.insert( it_v->second, itDisc->getTempoCredSemanaLetiva() );
                        }
                     }
                  }

                  if ( row.getnnz() != 0 )
                  {
                     cHash[ c ] = lp->getNumRows();

                     lp->addRow( row );
                     restricoes++;
                  }
               }
            }
            //////////////////////////////////////////////////////////////////////
         }
      }
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Máximo de tempo por sala, dia e semana letiva, de acordo com a divisao
de horarios por semana letiva escolhida.
%Desc 

%MatExp

\begin{eqnarray}

\sum\limits_{d \in D_{sl}}\sum\limits_{i \in I_{d}} x_{i,d,u,s,t} \leq  \sum\limits_{k \in CS_{k}}( Q_{sl,k,s,t} \cdot cs_{s,t,k} ) \nonumber \qquad

\forall u \in U \quad
\forall s \in S_{u} \quad
\forall t \in T \quad
\forall sl \in SL
\end{eqnarray}

%Data Q_{sl,t,s,k}
%Desc
máximo de tempo da semana letiva $sl$ permitidos por dia $t$
para a sala $s$, na divisão de horarios k.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_tempo_s_t_SL( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() != 2 )
   {
	   return restricoes;
   }

   char name[ 100 ];
   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			std::map< int, Sala * >::iterator itSala = itCjtSala->salas.begin();
			for( ; itSala != itCjtSala->salas.end(); itSala++ )
			{
				Sala *s = itSala->second;

				ITERA_GGROUP_N_PT( itDia, s->diasLetivos, int )
				{
					int dia = *itDia;
				
					ITERA_GGROUP_LESSPTR( it_Sl, problemData->calendarios, Calendario )
					{
						//  Cria restrição
						c.reset();
						c.setType( Constraint::C_MAX_TEMPO_S_D_SL );
						c.setUnidade( *itUnidade );
						c.setSubCjtSala( *itCjtSala );
						c.setDia( dia );
						c.setSemanaLetiva( *it_Sl );

						sprintf( name, "%s", c.toString().c_str() );
						if ( cHash.find( c ) != cHash.end() )
						{
							continue;
						}

						int nnz = 100;
					
						OPT_ROW row( nnz, OPT_ROW::LESS , 0, name );

						bool INSERIU = false;

						ITERA_GGROUP( itDisc, s->disciplinasAssociadas, Disciplina )
						{
							Disciplina *disciplina = *itDisc;

							// Verifica se é a semana letiva corrente
							if ( disciplina->getCalendario() != *it_Sl )
							{
								continue;
							}

							#pragma region Equivalencias
							if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
									problemData->mapDiscSubstituidaPor.end() ) &&
								 !problemData->ehSubstituta( disciplina ) )
							{
								continue;
							}
							#pragma endregion		

							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								v.reset();
								v.setType( Variable::V_CREDITOS );
								v.setTurma( turma );
								v.setUnidade( *itUnidade );
								v.setDisciplina( disciplina );
								v.setSubCjtSala( *itCjtSala );
								v.setDia( dia );

								it_v = vHash.find( v );
								if( it_v != vHash.end() )
								{
									row.insert( it_v->second, 1 );

									INSERIU = true;
								}
							}
						}
						std::map< Trio<int, int, Calendario*>, int >::iterator it_map = s->combinaCredSL.begin();
						for ( ; it_map != s->combinaCredSL.end(); it_map++  )
						{
							if ( it_map->first.first == dia && it_map->first.third == *it_Sl )
							{
								v.reset();
								v.setType( Variable::V_COMBINA_SL_SALA );
								v.setSala( s );
								v.setDia( dia );
								v.setCombinaSL( it_map->first.second );

								it_v = vHash.find( v );
								if( it_v != vHash.end() )
								{
									int coef = s->getNroCredCombinaSL( it_map->first.second, *it_Sl, dia );

									row.insert( it_v->second, -coef );
								}
							}
						}
					
						if ( row.getnnz() != 0 && INSERIU )
						{
							cHash[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
         }
      }
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável $o$
%Desc 

%MatExp

\begin{eqnarray}
C_{d} \cdot o_{i,d,u,tps,t}  \geq  x_{i,d,u,tps,t}  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall u \in U \quad
\forall tps \in SCAP_{u} \quad
\forall t \in T
\end{eqnarray}

%Data C_{d}
%Desc
Total de créditos da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_ativacao_var_o( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );
			   
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
				itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

				if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
				{
					if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
						NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
						continue;
				}
				else
				{
					continue;
				}

               GGroup< int /*Dias*/ >::iterator itDiscSala_Dias = problemData->disc_Conjutno_Salas__Dias
                  [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].begin();

               for (; itDiscSala_Dias != problemData->disc_Conjutno_Salas__Dias[
                      std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].end();
                      itDiscSala_Dias++ )
                  {
                     for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                     {
                        c.reset();
                        c.setType( Constraint::C_VAR_O );

                        c.setUnidade( *itUnidade );
                        c.setSubCjtSala( *itCjtSala );
                        c.setDia( *itDiscSala_Dias );
                        c.setDisciplina( disciplina );
                        c.setTurma( turma );

                        sprintf( name, "%s", c.toString().c_str() ); 
                        if ( cHash.find( c ) != cHash.end() )
                        {
                           continue;
                        }

                        nnz = 2;

                        OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

                        v.reset();
                        v.setType(Variable::V_OFERECIMENTO);

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiscSala_Dias );

                        it_v = vHash.find( v );
                        if( it_v != vHash.end() )
                        {
                           row.insert( it_v->second,
                              -( disciplina->getCredPraticos() + 
                              disciplina->getCredTeoricos() ) );
                        }

                        v.reset();
                        v.setType( Variable::V_CREDITOS );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiscSala_Dias );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        if ( row.getnnz() != 0 )
                        {
                           cHash[ c ] = lp->getNumRows();

                           lp->addRow( row );
                           restricoes++;
                        }
                     }
                  }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Evitar sobreposição de turmas da mesma disciplina
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{tps \in SCAP_{u}} o_{i,d,u,tps,t}  \leq  1  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall u \in U \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_evita_sobreposicao( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         GGroup< int >::iterator itDiasLetUnid =
            itUnidade->dias_letivos.begin();

         for (; itDiasLetUnid != itUnidade->dias_letivos.end(); itDiasLetUnid++ )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
            {
                disciplina = ( *it_disciplina );
			   
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

				// A disciplina deve ser ofertada no campus especificado
				if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
					 problemData->cp_discs[campusId].end() )
				{
					continue;
				}

				map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
				itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

				if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
				{
					if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
						NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
						continue;
				}
				else
				{
					continue;
				}

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  c.reset();
                  c.setType( Constraint::C_EVITA_SOBREPOSICAO_TD );

                  c.setUnidade( *itUnidade );
                  c.setDia( *itDiasLetUnid );
                  c.setDisciplina( disciplina );
                  c.setTurma( turma );

                  sprintf( name, "%s", c.toString().c_str() ); 
                  if ( cHash.find( c ) != cHash.end() )
                  {
                     continue;
                  }

                  nnz = itUnidade->salas.size();

                  OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiasLetUnid );

                     it_v = vHash.find( v );
                     if( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }
                  }

                  if ( row.getnnz() != 0 )
                  {
                     cHash[ c ] = lp->getNumRows();

                     lp->addRow( row );
                     restricoes++;
                  }
               }
            }
         }
      }
   }

   return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint
Limite de créditos diários de disciplina (*)
%Desc 

%MatExp

\begin{eqnarray}
x_{i,d,u,tps,t}  \leq \overline{H_{d}}  \nonumber \qquad 
\forall d \in D \quad
\forall u \in U \quad
\forall tps \in SCAP_{u} \quad
\forall t \in T \quad
\forall i \in I_{d}
\end{eqnarray}

%Data \overline{H_{d}}
%Desc
máximo de créditos diários da disciplina $d$.

%DocEnd
/====================================================================*/

// TRIEDA-406 Cont-Limite de créditos diários de disciplina
int SolverMIP::cria_restricao_lim_cred_diar_disc( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			 ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
             {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

				map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
				itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

				if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
				{
					if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
						NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
						continue;
				}
				else
				{
					continue;
				}

               GGroup< int /*Dias*/ > disc_sala_dias
                  = problemData->disc_Conjutno_Salas__Dias
                  [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ];

               ITERA_GGROUP_N_PT( itDiscSala_Dias, disc_sala_dias, int )
               {
                  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                  {
                     c.reset();
                     c.setType( Constraint::C_LIM_CRED_DIAR_DISC );

                     c.setTurma( turma );
                     c.setDisciplina( disciplina );
                     c.setUnidade( *itUnidade );
                     c.setSubCjtSala( *itCjtSala );
                     c.setDia( *itDiscSala_Dias );

                     sprintf( name, "%s", c.toString().c_str() );
                     if ( cHash.find( c ) != cHash.end() )
                     {
                        continue;
                     }

                     nnz = 1;

                     // 1.2.13
                     // Limite de créditos diários de disciplina (*)
                     int maximo_creditos = itCjtSala->maxCredsDiaPorSL( *itDiscSala_Dias, disciplina->getCalendario() );
                     int maximo_creditos_fixacao
                        = problemData->creditosFixadosDisciplinaDia( disciplina, *itDiscSala_Dias, *itCjtSala );

                     // Quando existir uma fixação, o máximo de créditos deverá
                     // ser exatamente a fixação. Caso contrário, continua sendo
                     // o máximo de créditos por dia do conjunto de salas
                     OPT_ROW::ROWSENSE row_sense = OPT_ROW::LESS;
                     if ( maximo_creditos_fixacao != 0 )
                     {
                        maximo_creditos = maximo_creditos_fixacao;
                        row_sense = OPT_ROW::EQUAL;
                     }

                     OPT_ROW row( 1, row_sense , maximo_creditos , name );

                     v.reset();
                     v.setType( Variable::V_CREDITOS );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );

                     it_v = vHash.find( v );
                     if( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }

                     if ( row.getnnz() != 0 )
                     {
                        cHash[ c ] = lp->getNumRows();

                        lp->addRow( row );
                        restricoes++;
                     }
                  }
               }
            }
         }
      }
   }

   return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Contabiliza se há turmas da mesma disciplina em dias consecutivos (*)
%Desc 

%MatExp

\begin{eqnarray}
c_{i,d,t}  \geq \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}}(o_{i,d,u,tps,t} - o_{i,d,u,tps,t-1}) - 1  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall (t \geq 2) \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-392
int SolverMIP::cria_restricao_turma_disc_dias_consec( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina,
      problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
		   problemData->cp_discs[campusId].end() )
	  {
		  continue;
	  }

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue;
		}

      for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
      {
         GGroup< int >::iterator itDiasLetDisc =
            disciplina->diasLetivos.begin();

         for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
         {
            c.reset();
            c.setType( Constraint::C_TURMA_DISC_DIAS_CONSEC );

            c.setDisciplina( disciplina );
            c.setTurma( turma );
            c.setDia( *itDiasLetDisc );

            sprintf( name, "%s", c.toString().c_str() ); 

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = ( problemData->totalSalas * 2 + 1 );
            OPT_ROW row( nnz, OPT_ROW::GREATER , -1 , name );

            v.reset();
            v.setType( Variable::V_DIAS_CONSECUTIVOS );
            v.setTurma( turma );
            v.setDisciplina( disciplina );
            v.setDia( *itDiasLetDisc );
			v.setCampus( problemData->refCampus[campusId] );      // cp

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
            {
			   if ( itCampus->getId() != campusId )
			   {
				   continue;
			   }

               ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiasLetDisc );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, -1.0 );
                     }

                     v.setDia( ( *itDiasLetDisc ) - 1 );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }
                  }
               }
            }

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Fixação da distribuição de créditos por dia (*)
%Desc 

%MatExp

\begin{eqnarray}
x_{i,d,u,s,t} + fcp_{i,d,s,t} - fcm_{i,d,s,t} = FC_{d,s,t} \cdot z_{i,d,cp}  \nonumber \qquad 
\forall cp \in CP
\forall s \in S_{u} \quad
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-395
int SolverMIP::cria_restricao_de_folga_dist_cred_dia( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		    continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			 ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion


				map< Disciplina *, int, LessPtr< Disciplina > >::iterator 
					itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

				if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
				{
					if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
						NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
						continue;
				}
				else
				{
					continue;
				}

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  GGroup< int >::iterator itDiasLetDisc = disciplina->diasLetivos.begin();

                  for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() &&
                             it_fix->getDiaSemana() == ( *itDiasLetDisc ) &&
						     it_fix->sala != NULL )
                        {
						   Sala *s = (*itCjtSala)->salas.begin()->second;
						   if ( s->getId() != it_fix->sala->getId() )
						   {
							   continue;
						   }

                           c.reset();
                           c.setType( Constraint::C_SLACK_DIST_CRED_DIA );

                           c.setTurma( turma );
                           c.setDisciplina( disciplina );
                           c.setDia( *itDiasLetDisc );
                           c.setSubCjtSala( *itCjtSala );

                           sprintf( name, "%s", c.toString().c_str() );
                           if ( cHash.find( c ) != cHash.end() )
                           {
                              continue;
                           }

                           if ( disciplina->getNumTurmas() < 0 )
                           {
                              continue;
                           }

                           nnz = 4;

                           OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

							v.reset();
							v.setType( Variable::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetDisc );

							it_v = vHash.find(v);
							if( it_v != vHash.end() )
							{
								row.insert( it_v->second, 1.0 );
							}

							v.reset();
							v.setType( Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR );
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setDia( *itDiasLetDisc );
							v.setSubCjtSala( *itCjtSala );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, 1.0 );
							}

							v.reset();
							v.setType( Variable::V_SLACK_DIST_CRED_DIA_INFERIOR );
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setDia( *itDiasLetDisc );
							v.setSubCjtSala( *itCjtSala );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, -1.0 );
							}

							v.reset();
							v.setType( Variable::V_ABERTURA );

							v.setCampus( *itCampus );
							v.setDisciplina( disciplina );
							v.setTurma( turma );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second,
									-( it_fix->disciplina->getMaxCreds() ) ); // TODO!!!! coeficiente..
							}

							if ( row.getnnz() != 0 )
							{
								cHash[ c ] = lp->getNumRows();

								lp->addRow( row );
								restricoes++;
							}						  
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Abertura sequencial de turmas
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} \sum\limits_{t \in T} o_{i,d,u,tps,t} \geq \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} \sum\limits_{t \in T} o_{i',d,u,tps,t} \nonumber \qquad 
\forall d \in D \quad
\forall i,i' \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/


int SolverMIP::cria_restricao_abre_turmas_em_sequencia( int campusId, int cjtAlunosAtualId, int prioridade )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus *campus = problemData->refCampus[ campusId ];

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

	  if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
	  {
		  continue;
	  }

	  map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		  itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

	  if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
	  {
		  if ( itMapDiscCjt->second	!= cjtAlunosAtualId )
			  continue;
	  }
	  else
	  {
		  if ( problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
		  {
			  std::cout<<"\nAtencao em cria_restricao_abre_turmas_em_sequencia: disciplina "
						<<disciplina->getId() <<" nao pertence a nenhum conjunto\n";
		  }
	  }


      if ( disciplina->getNumTurmas() > 1 )
      {
         for ( int turma = 0; turma < ( disciplina->getNumTurmas() - 1 ); turma++ )
         {
            c.reset();
            c.setType( Constraint::C_ABRE_TURMAS_EM_SEQUENCIA );

            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() ); 
            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = 9999;
            OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0, name );

            ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
            {
				if ( itCampus->getId() != campusId )
				{
					continue;
				}

               ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     GGroup< int /*Dias*/ > disc_sala_dias =
                        problemData->disc_Conjutno_Salas__Dias[ std::make_pair< int, int >
                        ( disciplina->getId(), itCjtSala->getId() ) ];

                     ITERA_GGROUP_N_PT( itDiscSala_Dias, disc_sala_dias, int )
                     {
                        v.reset();
                        v.setType( Variable::V_OFERECIMENTO );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiscSala_Dias );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        v.reset();
                        v.setType( Variable::V_OFERECIMENTO );

                        int turmaSuc = turma + 1;
                        v.setTurma(turmaSuc);

                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiscSala_Dias );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, -1.0 );
                        }
                     }
                  }
               }
            }

			if ( prioridade > 1 && FIXAR_P1 ) // se for p2 e o PRE-modelo tiver sido fixado
			{
                v.reset();
                v.setType( Variable::V_FOLGA_ABRE_TURMA_SEQUENCIAL );

                v.setTurma( turma );
                v.setDisciplina( disciplina );
				v.setCampus( campus );

                it_v = vHash.find( v );
                if ( it_v != vHash.end() )
                {
                    row.insert( it_v->second, 1.0 );
                }				
			}

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Regra de divisão de créditos
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} x_{i,d,u,tps,t} = \sum\limits_{k \in K_{d}}N_{d,k,t} \cdot m_{d,i,k} + fkp_{d,i,t} - fkm_{d,i,t} \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall t \in T
\end{eqnarray}

%Data N_{d,k,t}
%Desc
número de créditos determinados para a disciplina $d$ no dia $t$ na combinação de divisão de crédito $k$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_divisao_credito( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );
	  
	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
		   !problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	


		map< Disciplina *, int, LessPtr< Disciplina > >::iterator 
			itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue;
		}

      if ( disciplina->divisao_creditos.size() != 0 )
      {
         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            ITERA_GGROUP_N_PT( itDiasLetDisc, disciplina->diasLetivos, int )
            {
               c.reset();
               c.setType( Constraint::C_DIVISAO_CREDITO );

               c.setDisciplina( disciplina );
               c.setTurma( turma );
               c.setDia( *itDiasLetDisc );

               sprintf( name, "%s", c.toString().c_str() ); 

               if ( cHash.find( c ) != cHash.end() )
               {
                  continue;
               }

               nnz = ( problemData->totalSalas + ( (int)( disciplina->combinacao_divisao_creditos.size() ) * 2 ) );
               OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

               ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
               {
				   if ( itCampus->getId() != campusId )
				   {
					    continue;
				   }

                  ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
                  {
                     ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                     {
                        v.reset();
                        v.setType( Variable::V_CREDITOS );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiasLetDisc );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        v.reset();
                        v.setType( Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M );

                        v.setDisciplina( disciplina );
                        v.setTurma( turma );
                        v.setDia( *itDiasLetDisc );

                        it_v = vHash.find( v );
                        if( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, -1.0 );
                        }

                        v.reset();
                        v.setType( Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P );

                        v.setDisciplina( disciplina );
                        v.setTurma( turma );
                        v.setDia( *itDiasLetDisc );

                        it_v = vHash.find( v );
                        if( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        for ( int k = 0; k < (int)disciplina->combinacao_divisao_creditos.size(); k++ )
                        {	
                           v.reset();
                           v.setType( Variable::V_COMBINACAO_DIVISAO_CREDITO );

                           v.setDisciplina( disciplina );
                           v.setTurma( turma );
                           v.setK( k );

                           int d = *itDiasLetDisc;

                           // N{d,k,t}
                           int numCreditos = ( disciplina->combinacao_divisao_creditos[ k ] )[ ( *itDiasLetDisc ) - 2 ].second;

                           it_v = vHash.find( v );
                           if ( it_v != vHash.end() )
                           {
                              row.insert( it_v->second, -numCreditos );
                           }
                        }
                     }
                  }
               }

               if ( row.getnnz() != 0 )
               {
                  cHash[ c ] = lp->getNumRows();

                  lp->addRow( row );
                  restricoes++;
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Somente uma combinação de regra de divisão de créditos pode ser escolhida
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{k \in K_{d}} m_{d,i,k} \leq 1 \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_combinacao_divisao_credito( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
		   !problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	


		map< Disciplina *, int, LessPtr< Disciplina > >::iterator 
			itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue;
		}

      for ( int i = 0; i < disciplina->getNumTurmas(); i++ )
      {
         c.reset();
         c.setType( Constraint::C_COMBINACAO_DIVISAO_CREDITO );

         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString().c_str() ); 

         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

         nnz = (int)( disciplina->combinacao_divisao_creditos.size() );
         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

         for ( int k = 0; k < (int)disciplina->combinacao_divisao_creditos.size(); k++ )
         {
            v.reset();
            v.setType( Variable::V_COMBINACAO_DIVISAO_CREDITO );

            v.setTurma( i );
            v.setDisciplina( disciplina );
            v.setK( k );

            it_v = vHash.find( v );

            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável zc
%Desc

%MatExp
\begin{eqnarray}
\sum\limits_{i \in I} \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} o_{i,d,u,tps,t} \leq zc_{d,t} \cdot N \nonumber \qquad 
\forall d \in D \quad
\forall t \in T
\end{eqnarray}


%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_ativacao_var_zc( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus *campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );
	  
	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
		   !problemData->ehSubstituta( disciplina ) )
	  {
		   continue;
	  }
	  #pragma endregion

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue;
		}

      GGroup< int >::iterator itDiasLetDisc = disciplina->diasLetivos.begin();

      for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
      {
         c.reset();
         c.setType( Constraint::C_VAR_ZC );

         c.setDisciplina( disciplina );
         c.setDia( *itDiasLetDisc );
		 c.setCampus( campus );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

         nnz = 100;

         OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );
		 
		 ITERA_GGROUP_LESSPTR( itUnidade, campus->unidades, Unidade )
		 {
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
					v.reset();
					v.setType( Variable::V_OFERECIMENTO );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );
					v.setDia( *itDiasLetDisc );

					it_v = vHash.find( v );
					if ( it_v != vHash.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
				}
			}
		 }

         v.reset();
         v.setType( Variable::V_ABERTURA_COMPATIVEL );

         v.setDisciplina( disciplina );
         v.setDia( *itDiasLetDisc );
		 v.setCampus( campus );

         it_v = vHash.find( v );
         if ( it_v != vHash.end() )
         {
            row.insert( it_v->second, -100.0 );
         }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Disciplinas incompatíveis
%Desc

%MatExp
\begin{eqnarray}
zc_{d_1,t} + zc_{d_2,t} \leq 1 \nonumber \qquad 
(d_1, d_2),
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_disciplinas_incompativeis( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   Campus *campus = problemData->refCampus[ campusId ];

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );
	  
	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
		   !problemData->ehSubstituta( disciplina ) )
	  {
		   continue;
	  }
	  #pragma endregion

      ITERA_GGROUP_N_PT( itDiasLetDisc, disciplina->diasLetivos, int )
      {
         ITERA_GGROUP_N_PT( it_inc, disciplina->ids_disciplinas_incompativeis, int )
         {
            //Disciplina * nova_disc = new Disciplina();
			std::map< int, Disciplina* >::iterator it_Ref_Disc = problemData->refDisciplinas.find( *it_inc );
			if ( it_Ref_Disc == problemData->refDisciplinas.end() )
			{ 
				continue;
			}
			
			Disciplina * nova_disc = it_Ref_Disc->second;

			// A disciplina deve ser ofertada no campus especificado
			if ( problemData->cp_discs[campusId].find( nova_disc->getId() ) ==
				problemData->cp_discs[campusId].end() )
 			{
				continue;
			}

			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( nova_disc ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( nova_disc ) )
			{
				continue;
			}
			#pragma endregion

            c.reset();
            c.setType( Constraint::C_DISC_INCOMPATIVEIS );

            c.setDisciplina( nova_disc );
            c.setDia( *itDiasLetDisc );
			c.setCampus( campus );

            sprintf( name, "%s", c.toString().c_str() ); 

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = 2;
            OPT_ROW row( nnz, OPT_ROW::LESS, 1.0, name );

            v.reset();
            v.setType( Variable::V_ABERTURA_COMPATIVEL );

            v.setDisciplina( disciplina );
            v.setDia( *itDiasLetDisc );
			v.setCampus( campus );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            v.setDisciplina( nova_disc );

            it_v = vHash.find( v );
			if ( it_v != vHash.end() )
            {
               row.insert(it_v->second, 1.0);
            }

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }

         }
      }
   }

   return restricoes;
}


int SolverMIP::cria_restricao_ativacao_var_cs( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() != 2 )
   {
	   return restricoes;
   }

   char name[ 100 ];   
   VariableHash::iterator it_v;
   Variable v;
   Constraint c;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			std::map< int, Sala * >::iterator itSala = itCjtSala->salas.begin();
			for( ; itSala != itCjtSala->salas.end(); itSala++ )
			{
				Sala *s = itSala->second;

				ITERA_GGROUP_N_PT( itDia, s->diasLetivos, int )
				{
					int dia = *itDia;

					c.reset();
					c.setType( Constraint::C_VAR_CS );
					c.setUnidade( *itUnidade );
					c.setSubCjtSala( *itCjtSala );
					c.setDia( dia );

					sprintf( name, "%s", c.toString().c_str() );
					if ( cHash.find( c ) != cHash.end() )
					{
						continue;
					}

					int nnz = s->getCombinaCredSLSize()[dia];
					
					OPT_ROW row( nnz, OPT_ROW::LESS , 1, name );

					std::map< Trio<int, int, Calendario*>, int >::iterator it_map = s->combinaCredSL.begin();
					for ( ; it_map != s->combinaCredSL.end(); it_map++ )
					{
						if ( it_map->first.first == dia )
						{
							v.reset();
							v.setType( Variable::V_COMBINA_SL_SALA );
							v.setSala( s );
							v.setDia( dia );
							v.setCombinaSL( it_map->first.second );

							it_v = vHash.find( v );
							if( it_v != vHash.end() )
							{
								row.insert( it_v->second, 1 );
							}
						}
					}
					
					if ( row.getnnz() != 0 )
					{
						cHash[ c ] = lp->getNumRows();
						lp->addRow( row );
						restricoes++;
					}
				}
			}
		 }
	  }
   }
   return restricoes;
}


/*----------------------------------------------------------------
	RESTRICOES SOMENTE PARA O MODELO TATICO - ALUNO - SEM HORARIOS
----------------------------------------------------------------*/

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Turmas de disciplinas de mesmo aluno não devem exceder máximo de créditos por dia
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{d \in D_{a}} \sum\limits_{u \in U} \sum\limits_{s \in S_{u}} \sum\limits_{i \in I_{a,d}} x_{i,d,u,s,t} 
			\leq \sum\limits_{k} ( Nh_{a,t,sl,k} \cdot ca_{a,t,k} )  \nonumber \qquad 
\forall a \in A \quad
\forall cp \in CP
\forall t \in T \quad
\end{eqnarray}

%Data Nh_{a,t,sl,k}
%Desc
máximo de créditos permitidos por dia $t$ para a combinacao de horarios .

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_cred_disc_aluno( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;
   
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      GGroup< int >::iterator itDiasLetCampus = itCampus->diasLetivos.begin();

      ITERA_GGROUP_N_PT( itDiasLetCampus, itCampus->diasLetivos, int )
      {
		 int dia = *itDiasLetCampus;

         ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
         {
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->campus->getId() != campusId )
			{
				continue;
			}

			GGroup< Aluno *, LessPtr< Aluno > > alunosCjtAtual = problemData->cjtAlunos[ cjtAlunosAtualId ];
			if ( alunosCjtAtual.find( aluno ) == alunosCjtAtual.end() )
			{
				if ( NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
					continue;
			}
			
			GGroup< Calendario*, LessPtr<Calendario> > calendarios = itAluno->retornaSemanasLetivas();

			ITERA_GGROUP_LESSPTR( itSL, calendarios, Calendario )
			{
				Calendario *sl = *itSL;

				c.reset();
				c.setType( Constraint::C_MAX_CRED_DISC_ALUNO );

				c.setAluno( aluno );
				c.setDia( dia );
				c.setCampus( *itCampus );
				c.setSemanaLetiva( sl );

				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHash.find( c ) != cHash.end() )
				{
				   continue;
				}

				nnz =  50; /*FIX-ME*/

				OPT_ROW row( nnz + 1, OPT_ROW::LESS , 0.0, name );

				bool inseriuX = false;
				bool inseriuCa = false;

				ITERA_GGROUP_LESSPTR( it_al_dem, aluno->demandas, AlunoDemanda )
				{
					disciplina = ( *it_al_dem )->demanda->disciplina;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion	

				   // Só considera disciplinas da semana letiva corrente
				   if ( disciplina->getCalendario() != *itSL )
				   {
					   continue;
				   }

				   ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				   {
					  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					  {
						 if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
							  itCjtSala->disciplinas_associadas.end() )
							continue;

						 int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );

						 if ( turma != -1 )
						 {
							v.reset();
							v.setType( Variable::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetCampus );
							
							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
							   row.insert( it_v->second, 1.0 );

							   inseriuX = true;
							}
						 }
					  }
				   }
				}

				std::map< Trio<int, int, Calendario*>, int >::iterator it_map = aluno->combinaCredSL.begin();
				for ( ; it_map != aluno->combinaCredSL.end(); it_map++  )
				{
					if ( it_map->first.first == dia && it_map->first.third == sl )
					{
						int k = it_map->first.second;
						
						v.reset();
						v.setType( Variable::V_COMBINA_SL_ALUNO );
						v.setAluno( aluno );
						v.setDia( dia );
						v.setCombinaSLAluno( k );

						it_v = vHash.find( v );
						if( it_v != vHash.end() )
						{
							int coef = aluno->getNroMaxCredCombinaSL( k, sl, dia );

							row.insert( it_v->second, -coef );

							inseriuCa = true;
						}
					}
				}

				if ( inseriuX && inseriuCa )
				{
				   cHash[ c ] = lp->getNumRows();

				   lp->addRow( row );
				   restricoes++;
				}
			}
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Mínimo de créditos alocados para turmas de um aluno (*)
%Desc 

%DocEnd
/====================================================================*/

// TRIEDA-393
int SolverMIP::cria_restricao_min_creds_semana_aluno( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   
	if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE )
	{
		return restricoes;
	}

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus* campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	    Aluno *aluno = *itAluno;

	    if ( aluno->getOferta()->getCampusId() != campusId )
	    {
		    continue;
	    }	

		GGroup< Aluno *, LessPtr< Aluno > > alunosCjtAtual = problemData->cjtAlunos[ cjtAlunosAtualId ];
		if ( alunosCjtAtual.find( aluno ) == alunosCjtAtual.end() )
		{
			if ( NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}

         GGroup< int >::iterator itDiasLetivos = 
            campus->diasLetivos.begin();

         for (; itDiasLetivos != campus->diasLetivos.end();
            itDiasLetivos++ )
         {
            c.reset();
            c.setType( Constraint::C_MIN_CREDS_SEMANA_ALUNO );

            c.setAluno( aluno );
            c.setDia( *itDiasLetivos );

            sprintf( name, "%s", c.toString().c_str() ); 

            if (cHash.find(c) != cHash.end())
            {
               continue;
            }

			nnz = ( ( aluno->demandas.size() * campus->diasLetivos.size() ) + 1 );

            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

			ITERA_GGROUP_LESSPTR( it_al_dem, aluno->demandas, AlunoDemanda )
			{
				disciplina = ( *it_al_dem )->demanda->disciplina;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

				ITERA_GGROUP_LESSPTR( itUnidade, campus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{
						if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
							 itCjtSala->disciplinas_associadas.end() )
							continue;

						int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );

						if ( turma != -1 )
						{
							v.reset();
							v.setType( Variable::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetivos );
							
							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, -disciplina->getTempoCredSemanaLetiva() );
							}
						}
					}
				}
			}
			
            v.reset();
            v.setType( Variable::V_MIN_CRED_SEMANA_ALUNO );

            v.setAluno( aluno );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            // Para evitar a criação da restrição no caso em que só a variável h seja encontrada. Isso é só uma
            // garantia. Como os dias letivos estão sendo respeitados, não devemos notar erros.
            if ( row.getnnz() > 1 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
        }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Máximo de créditos alocados para turmas de um aluno (*)
%Desc 

%MatExp

\begin{eqnarray}
\overline{h}_{a} \geq \sum\limits_{d \in D_{a}} \sum\limits_{u \in U} \sum\limits_{s \in S_{u}} tempo_{d} \cdot x_{i,d,u,s,t} \nonumber \qquad 
\forall a \in A \quad
\forall i \in I_{a,d} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-394
int SolverMIP::cria_restricao_max_creds_semana_aluno( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

	if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE )
	{
		return restricoes;
	}

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus* campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	    Aluno *aluno = *itAluno;

	    if ( aluno->getOferta()->getCampusId() != campusId )
	    {
		    continue;
	    }

		GGroup< Aluno *, LessPtr< Aluno > > alunosCjtAtual = problemData->cjtAlunos[ cjtAlunosAtualId ];
		if ( alunosCjtAtual.find( aluno ) == alunosCjtAtual.end() )
		{
			if ( NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}

         GGroup< int >::iterator itDiasLetivos = 
            campus->diasLetivos.begin();

         for (; itDiasLetivos != campus->diasLetivos.end();
            itDiasLetivos++ )
         {
            c.reset();
            c.setType( Constraint::C_MAX_CREDS_SEMANA_ALUNO );

            c.setAluno( aluno );
            c.setDia( *itDiasLetivos );

            sprintf( name, "%s", c.toString().c_str() ); 

            if (cHash.find(c) != cHash.end())
            {
               continue;
            }

			nnz = ( ( aluno->demandas.size() * campus->diasLetivos.size() ) + 1 );

            OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0 , name );

			ITERA_GGROUP_LESSPTR( it_al_dem, aluno->demandas, AlunoDemanda )
			{
				disciplina = ( *it_al_dem )->demanda->disciplina;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

				ITERA_GGROUP_LESSPTR( itUnidade, campus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{
						if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
							 itCjtSala->disciplinas_associadas.end() )
							continue;

						int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );

						if ( turma != -1 )
						{
							v.reset();
							v.setType( Variable::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetivos );
							
							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, -disciplina->getTempoCredSemanaLetiva() );
							}
						}
					}
				}
			}
			
            v.reset();
            v.setType( Variable::V_MAX_CRED_SEMANA_ALUNO );

            v.setAluno( aluno );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            // Para evitar a criação da restrição no caso em que só a variável h seja encontrada. Isso é só uma
            // garantia. Como os dias letivos estão sendo respeitados, não devemos notar erros.
            if ( row.getnnz() > 1 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
        }
   }

   return restricoes;
}



int SolverMIP::cria_restricao_evita_sobrepos_turmas_mesmos_alunos( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   char name[ 200 ];						   
   int nnz = 50;

   GGroup< Sala *, LessPtr< Sala > > salas = this->problemData->getSalas();

   Constraint c;
   VariableHash::iterator vit;
   ConstraintHash::iterator cit;

   Campus * campus = problemData->refCampus[campusId];
   	
   GGroup< int > disciplinas = problemData->cp_discs[campusId];

   ITERA_GGROUP_N_PT( itDisc, disciplinas, int )
   {
	   Disciplina * disciplina = problemData->refDisciplinas[*itDisc];

	   if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
	   {
		   continue;
	   }

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second != cjtAlunosAtualId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue; // disciplina não pertence a nenhum cjtDisciplina, erro!
		}

	   for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
	   {
		   if ( ! problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId ) )
				continue;

		   Unidade* u = retornaUnidadeDeAtendimento( turma, disciplina, campus );
		   ConjuntoSala* s = retornaSalaDeAtendimento( turma, disciplina, campus );

		   // Para cada dia
		   ITERA_GGROUP_N_PT( itDia, disciplina->diasLetivos, int )
		   {
			   int dia = *itDia;


			   // Calcula o lado direito geral das restrições
			   double rhs_geral = 99999999;	   
			   GGroup<Calendario*> calendarios = campus->getCalendarios();
			   ITERA_GGROUP( itSl, calendarios, Calendario )
			   {
					double tempo = itSl->getTempoTotal( dia );
					if ( rhs_geral - tempo > 1e-5 ) // Se rhs_geral > tempo
						rhs_geral = tempo;
			   }

			   ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
			   {
				   // Para cada sala diferente da sala s
				   ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
					{
						ConjuntoSala *cjtSala = *itCjtSala;
		   
						if ( cjtSala == s )
						{
							continue;
						}

						c.reset();
						c.setType( Constraint::C_EVITA_SOBREPOS_TURMAS_ALUNOS );
						c.setSubCjtSala( cjtSala );
						c.setDia( dia );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						cit = cHash.find(c);
						if ( cit != cHash.end() )
						{
							continue;
						}

						cHash[ c ] = lp->getNumRows();				   
			   
						// Lado direito caso so haja 1 semana letiva na restrição
						double rhs = disciplina->getCalendario()->getTempoTotal( dia );

						sprintf( name, "%s", c.toString().c_str() );
						OPT_ROW row( nnz, OPT_ROW::LESS , rhs, name );
											    
						Variable v;
						v.reset();
						v.setType( Variable::V_CREDITOS );
						v.setTurma( turma );            // i
						v.setDisciplina( disciplina );  // d
						v.setUnidade( u );				// u
						v.setSubCjtSala( s );			// tps  
						v.setDia( dia );				// t

						int tempoDiscV = disciplina->getTempoCredSemanaLetiva();

						vit = vHash.find( v );
					    if ( vit != vHash.end())
					    {
							row.insert( vit->second, tempoDiscV );
					    }
						
						// Procura os atendimentos feitos na sala cjtSala que têm aluno em comum com i/d

						GGroup< std::pair< int,Disciplina* > > atends = retornaAtendEmCjtSala( cjtSala );

						GGroup< std::pair< int,Disciplina* > >::iterator itAtends = atends.begin();
						for ( ; itAtends != atends.end(); itAtends++ )
						{
							int turmaSum = (*itAtends).first;
							Disciplina *discSum = (*itAtends).second;

							// Só se tiver aluno em comum
							if ( problemData->alunosEmComum( turma, disciplina, turmaSum, discSum, campus ).size() == 0 )
							{
								continue;
							}

							int tempoDiscV = discSum->getTempoCredSemanaLetiva();

							v.reset();
							v.setType( Variable::V_CREDITOS );
							v.setTurma( turmaSum );         // i
							v.setDisciplina( discSum );     // d
							v.setUnidade( *itUnid );		// u
							v.setSubCjtSala( cjtSala );		// tps  
							v.setDia( dia );				// t

							vit = vHash.find( v );
							if ( vit != vHash.end() )
							{
								row.insert( vit->second, tempoDiscV );
								
								// Se rhs for maior do que discSum->getCalendario()->getTempoTotal( dia )
								if ( rhs - discSum->getCalendario()->getTempoTotal( dia ) > 1e-5 )
								{
									row.setRhs( rhs_geral );
									rhs = rhs_geral;
								}
							}

						}

						if ( row.getnnz() > 1 )
						{
							lp->addRow( row );
							restricoes++;
						}
					}
			   }
		   }
	   }   
   }

   return restricoes;

}

/*
	Para cada i, d, cp:

	z_{i,d,cp} + fd_{i,d,cp} = 1

	min nAlunos_{i,d,cp} * fd_{i,d,cp}
*/
int SolverMIP::cria_restricao_aloc_dem_disc( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   Campus* cp = problemData->refCampus[ campusId ];

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
       disciplina = ( *it_disciplina );

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion	

		if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			 continue;

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second != cjtAlunosAtualId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue;
		}

      for ( int i = 0; i < disciplina->getNumTurmas(); ++i )
      {	  
         c.reset();
         c.setType( Constraint::C_ALOC_DEM );
		 c.setCampus( cp );
         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

		 nnz = 2;
         OPT_ROW row( nnz, OPT_ROW::EQUAL, 1.0, name );

		 v.reset();
		 v.setType( Variable::V_ABERTURA );
		 v.setTurma( i );
		 v.setDisciplina( disciplina );
		 v.setCampus( cp );

		 it_v = vHash.find( v );
		 if( it_v != vHash.end() )
		 {
			row.insert( it_v->second, 1.0 );
		 }

		 v.reset();
		 v.setType( Variable::V_SLACK_DEMANDA_ALUNO );
		 v.setTurma( i );
		 v.setDisciplina( disciplina );
		 v.setCampus( cp );

		 it_v = vHash.find( v );
		 if( it_v != vHash.end() )
		 {
			row.insert( it_v->second, 1.0 );
		 }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*
	Para cada i, d, cp:

	minAlunos * z_{i,d,cp} <= sum[u]sum[s]sum[t] o_{i,d,u,s,t}
*/
int SolverMIP::cria_restricao_limita_abertura_turmas_aluno( int campusId, int cjtAlunosAtualId )
{
  int restricoes = 0;
	
   int nnz;
   char name[ 100 ];

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   int minAlunos;
   if ( problemData->parametros->min_alunos_abertura_turmas )
   {
		minAlunos = problemData->parametros->min_alunos_abertura_turmas_value;
		if ( minAlunos <= 0 ) minAlunos = 1;
   }
   else
   {
	   minAlunos = 1;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			 continue;
		 }
		
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			 continue;
		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion

		  map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		    itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		  if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		  {
			  if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
				   NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				  continue;
		  }
		  else
		  {
			  continue;
		  }

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( Constraint::C_LIMITA_ABERTURA_TURMAS );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = ( itCampus->getTotalSalas() * 7 );

            OPT_ROW row( nnz + 1, OPT_ROW::LESS , 0 , name );

            v.reset();
            v.setType( Variable::V_OFERECIMENTO );

            // Insere variaveis Oferecimento (o) ---

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
				   if ( itCjtSala->disciplinas_associadas.find( disciplina) ==
					    itCjtSala->disciplinas_associadas.end() )
				   {
					   continue;
				   }
				   					
				   ITERA_GGROUP_N_PT ( it_Dia, itCjtSala->dias_letivos_disciplinas[disciplina], int )
				   {
						int dia = *it_Dia;
																								
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setUnidade( *itUnidade );
						v.setSubCjtSala( *itCjtSala );
						v.setDia( dia );                   

						it_v = vHash.find( v );
						if( it_v != vHash.end() )
						{
							Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
							trio.set(campusId, turma, disciplina);
							int nAlunos = problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size();

							row.insert( it_v->second, -nAlunos );
						}
				   }
                }
            }

            // Insere variaveis Abertura (z) ---

            v.reset();
            v.setType( Variable::V_ABERTURA );
            v.setCampus( *itCampus );
            v.setDisciplina( disciplina );
            v.setTurma( turma );

            it_v = vHash.find( v );
            if( it_v != vHash.end() )
            {
               row.insert( it_v->second, minAlunos );
            }

            // Insere restrição no Hash ---

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

	return restricoes;
}


/*
	Para cada (i1, d, cp) e (i2, -d, cp) com alunos em comum:

	fd{i1,d,cp} + fd_{i2,-d,cp} - 2*ffd_{i1,d,i2,-d,cp} <= 0
*/
int SolverMIP::cria_restricao_disc_pratica_teorica( int campusId, int cjtAlunosAtualId )
{
    int restricoes = 0;
    int nnz;
    char name[ 100 ];

    Variable v;
    Constraint c;
    VariableHash::iterator it_v;
   
    Campus* campus = problemData->refCampus[ campusId ];
	     
	GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

	ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
	{
		Disciplina * discPratica = problemData->refDisciplinas[ *it_disciplina ];

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( discPratica ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( discPratica ) )
		{
			continue;
		}
		#pragma endregion

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( discPratica );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second != cjtAlunosAtualId &&
				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}
		else
		{
			continue;
		}

		if ( discPratica->getId() > 0 )
		{
			continue;
		}
		
		std::map< int, Disciplina * >::iterator itMapDisc =
			problemData->refDisciplinas.find( - discPratica->getId() );
				
		if ( itMapDisc == problemData->refDisciplinas.end() )
		{
			continue;
		}
		
		Disciplina *discTeorica = itMapDisc->second;

		if ( ! problemData->haDemandaDiscNoCampus( discPratica->getId(), campusId ) )
		{
			continue;
		}

		for ( int turma1 = 0; turma1 < discPratica->getNumTurmas(); turma1++ )
		{
			for ( int turma2 = 0; turma2 < discTeorica->getNumTurmas(); turma2++ )
			{		
				GGroup<Aluno*> alunos = problemData->alunosEmComum( turma1, discPratica, turma2, discTeorica, campus );
				
				if ( alunos.size() == 0 )
				{
					continue;
				}

				c.reset();
				c.setType( Constraint::C_DISC_PRATICA_TEORICA );
				c.setCampus( campus );
				c.setDisciplina1( discPratica );
				c.setTurma1( turma1 );
				c.setDisciplina2( discTeorica );
				c.setTurma2( turma2 );

				sprintf( name, "%s", c.toString().c_str() );

				if ( cHash.find( c ) != cHash.end() )
				{
					continue;
				}
			
				nnz = 3;
				OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

				// Variavel de folga fd_{dp,i1,cp}
				v.reset();
				v.setType( Variable::V_SLACK_DEMANDA_ALUNO );
				v.setDisciplina( discPratica );  // dp
				v.setTurma( turma1 );			 // i1
				v.setCampus( campus );			 // cp

				it_v = vHash.find( v );
				if( it_v != vHash.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			
				// Variavel de folga fd_{dt,i2,cp}
				v.reset();
				v.setType( Variable::V_SLACK_DEMANDA_ALUNO );
				v.setDisciplina( discTeorica );  // dt
				v.setTurma( turma2 );			 // i2
				v.setCampus( campus );			 // cp

				it_v = vHash.find( v );
				if( it_v != vHash.end() )
				{
					row.insert( it_v->second, 1.0 );
				}

				// Variavel de folga ffd_{i1,dp,i2,dt,cp}
				v.reset();
				v.setType( Variable::V_SLACK_SLACKDEMANDA_PT );
				v.setTurma1( turma1 );			 // i1
				v.setDisciplina1( discPratica );  // dp
				v.setTurma2( turma2 );			 // i2
				v.setDisciplina2( discTeorica );  // dt				
				v.setCampus( campus );			 // cp

				it_v = vHash.find( v );
				if( it_v != vHash.end() )
				{
					row.insert( it_v->second, -2.0 );
				}

				// Insere restrição no Hash ---
				if ( row.getnnz() != 0 )
				{
					cHash[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}
        }
   }

	return restricoes;
}

int SolverMIP::cria_restricao_ativacao_var_ca( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;

   char name[ 100 ];   
   VariableHash::iterator it_v;
   Variable v;
   Constraint c;

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	   Aluno *aluno = *itAluno;

	   if ( aluno->getOferta()->getCampusId() != campusId )
	   {
			continue;
	   }

		GGroup< Aluno *, LessPtr< Aluno > > alunosCjtAtual = problemData->cjtAlunos[ cjtAlunosAtualId ];
		if ( alunosCjtAtual.find( aluno ) == alunosCjtAtual.end() )
		{
			if ( NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				continue;
		}

	   ITERA_GGROUP_N_PT( itDia, aluno->getOferta()->campus->diasLetivos, int )
	   {
		   int dia = *itDia;

			c.reset();
			c.setType( Constraint::C_ATIVA_CA );
			c.setAluno( aluno );
			c.setDia( dia );

			sprintf( name, "%s", c.toString().c_str() );
			if ( cHash.find( c ) != cHash.end() )
			{
				continue;
			}

			int nnz = aluno->getCombinaCredSLSize()[dia];
					
			OPT_ROW row( nnz, OPT_ROW::LESS , 1, name );

		    std::map< Trio< int/*dia*/, int /*k_id*/, Calendario* /*sl*/ >,
					  int/*nroCreds*/ >::iterator it_map = aluno->combinaCredSL.begin();

			for ( ; it_map != aluno->combinaCredSL.end(); it_map++ )
			{
				if ( it_map->first.first == dia )
				{
					Variable v;
					v.reset();
					v.setType( Variable::V_COMBINA_SL_ALUNO );
					v.setAluno( aluno );
					v.setDia( dia );
					v.setCombinaSLAluno( it_map->first.second );
					
					it_v = vHash.find( v );
					if( it_v != vHash.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHash[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
	    }
   }   

   return restricoes;
}

 
int SolverMIP::cria_restricao_aluno_unid_dif_dia( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   int nnz;
   char name[ 100 ];


	if ( ! problemData->parametros->minimizar_desloc_aluno )
	{
		return restricoes;
	}

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }

	   Campus* campus = *it_campus;
	     
	  GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

	  // Disciplina 1
      ITERA_GGROUP_N_PT( it_disc1, disciplinas, int )
      {
		  Disciplina * disciplina1 = problemData->refDisciplinas[ *it_disc1 ];
		  
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina1 ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( disciplina1 ) )
		 {
			continue;
		 }
		 #pragma endregion
		 		 
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina1->getId(), campusId ) )
			  continue;
		

		  map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		    itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina1 );

		  if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		  {
			  if ( itMapDiscCjt->second	!= cjtAlunosAtualId &&
				   NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
				  continue;
		  }
		  else
		  {
			  continue;
		  }

		 // Turma 1
         for ( int turma1 = 0; turma1< disciplina1->getNumTurmas(); turma1++ )
         {
			  Unidade *u1 = this->retornaUnidadeDeAtendimento( turma1, disciplina1, campus );
					   
			  if ( u1 == NULL )
			  {
				  continue;
			  }
			  
			  // Disciplina 2
			  ITERA_GGROUP_INIC_N_PT( it_disc2, it_disc1, disciplinas, int )
			  {
				  Disciplina * disciplina2 = problemData->refDisciplinas[ *it_disc2 ];
		  
				  #pragma region Equivalencias
				  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina2 ) !=
					     problemData->mapDiscSubstituidaPor.end() ) &&
					   !problemData->ehSubstituta( disciplina2 ) )
				  {
					  continue;
				  }
				  #pragma endregion
		 		 
				  if ( ! problemData->haDemandaDiscNoCampus( disciplina2->getId(), campusId ) )
					  continue;

				  // Turma 2
				  for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
				  {
					   Unidade *u2 = this->retornaUnidadeDeAtendimento( turma2, disciplina2, campus );

					   if ( u2 == NULL || u2 == u1 )
					   {
						   continue;
					   }

					    GGroup<Aluno*> alunosEmComum = 
							problemData->alunosEmComum( turma1, disciplina1, turma2, disciplina2, campus );

						if ( alunosEmComum.size() == 0 )
						{
							continue;
						}

						int nroAlunos = alunosEmComum.size();

						GGroup<int> dias = problemData->diasComunsEntreDisciplinas( disciplina1, disciplina2 );
						ITERA_GGROUP_N_PT( it_dias, dias, int )
						{
							int dia = *it_dias;

							// CONSTRAINT --------------------------------------

							c.reset();
							c.setType( Constraint::C_ALUNO_VARIAS_UNIDADES_DIA );

							c.setCampus( campus );
							c.setTurma1( turma1 );
							c.setTurma2( turma2 );
							c.setDisciplina1( disciplina1 );
							c.setDisciplina2( disciplina2 );
							c.setDia( dia );
							c.setCampus( campus );

							sprintf( name, "%s", c.toString().c_str() );

							if ( cHash.find( c ) != cHash.end() )
							{
								continue;
							}

							nnz = 3;

							OPT_ROW row( nnz + 1, OPT_ROW::LESS , 1 , name );

							// Insere variavel fu_{i1,d1,i2,d2,t,cp} -------------------------------------------------------
							Variable v;
							v.reset();
							v.setType( Variable::V_SLACK_ALUNO_VARIAS_UNID_DIA );
							v.setTurma1( turma1 );            // i1
							v.setDisciplina1( disciplina1 );  // d1
							v.setTurma2( turma2 );            // i2
							v.setDisciplina2( disciplina2 );  // d2
							v.setCampus( campus );			  // cp
							v.setDia( dia );				  // t

							it_v = vHash.find( v );
							if( it_v != vHash.end() )
							{
								row.insert( it_v->second, -1.0 );
							}

							// Insere variaveis o_{i,d,u,s,t} -------------------------------------------------------
							it_v = vHash.begin();

							for (; it_v != vHash.end(); it_v++ )
							{
								Variable v = it_v->first;

								if ( v.getType() != Variable::V_OFERECIMENTO )
								{
									continue;
								}

								// Insere variavel o_{i1,d1,u1,s1,t} ou o_{i2,d2,u2,s2,t}
								
								if ( ( v.getTurma() == turma1 &&
									   v.getDisciplina() == disciplina1 && 
									   v.getDia() == dia && 
									   v.getUnidade() == u1 ) 
									   ||
									 ( v.getTurma() == turma2 &&
									   v.getDisciplina() == disciplina2 && 
									   v.getDia() == dia && 
									   v.getUnidade() == u2 ) )
								{
									row.insert( it_v->second, 1.0 );
								}
							}

							// Insere restrição no Hash --------------------------------------------------------
							if ( row.getnnz() != 0 )
							{
								cHash[ c ] = lp->getNumRows();

								lp->addRow( row );
								restricoes++;
							}
						}
				  }
			  }
          }
      }
   }
	
	return restricoes;

}

//int SolverMIP::cria_restricao_evita_sobrepos_cliqueAlunos( int campusId, int cjtAlunosAtualId )
//{
//	int restricoes = 0;
//	int nnz;
//	char name[ 200 ];
//
//	Constraint c;
//	VariableHash::iterator vit;
//	ConstraintHash::iterator cit;
//
//	map<int, map< Disciplina *, map< int, map <int , set<  VariableHash::iterator > > >, LessPtr< Disciplina > > > mapVariaveis; 
//
//	for (vit = vHash.begin(); vit != vHash.end(); vit++ )
//	{
//		Variable v = vit->first;
//
//		if ( v.getType() != Variable::V_CREDITOS )
//		{
//			continue;
//		}
//
//		Disciplina *disciplina = v.getDisciplina();
//		int turma = v.getTurma();
//		int dia = v.getDia();
//
//		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
//			itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );
//
//		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
//		{
//			if ( itMapDiscCjt->second != cjtAlunosAtualId &&
//				NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
//			{
//				continue;
//			}
//		}
//		else
//		{
//			std::cout<<"\nERRO em SolverMIP::cria_restricao_evita_sobrepos_cliqueAlunos: disciplina "
//				<< disciplina->getId() << " nao encontrada em cjtDisciplinas\n";
//			continue;
//		}
//
//		mapVariaveis[turma][disciplina][campusId][dia].insert(vit);
//	}
//
//	for(map<int, map< Disciplina *, map< int, map <int , set<  VariableHash::iterator > > > , LessPtr< Disciplina > > >::iterator itMV = mapVariaveis.begin();
//		itMV != mapVariaveis.end();
//		itMV++)
//	{
//		int turma = itMV->first;
//
//		for(map< Disciplina *, map< int, map <int , set<  VariableHash::iterator > > > , LessPtr< Disciplina > >::iterator itMV2 = itMV->second.begin();
//			itMV2 != itMV->second.end();
//			itMV2++)
//		{
//			Disciplina *disciplina = itMV2->first;
//
//			for(map< int, map <int , set<  VariableHash::iterator > > >::iterator itMV3 = itMV2->second.begin();
//				itMV3 != itMV2->second.end();
//				itMV3++)
//			{
//				int campusId = itMV3->first;
//
//				GGroup< int > clique = retornaCliques( turma, disciplina, campusId );
//
//				ITERA_GGROUP_N_PT( itClique, clique, int )
//				{
//					int clique = *itClique;
//
//					for(map <int , set<  VariableHash::iterator > >::iterator itMV4 = itMV3->second.begin();
//						itMV4 != itMV3->second.end();
//						itMV4++)
//					{
//						int dia = itMV4->first;
//
//						c.reset();
//						c.setType( Constraint::C_EVITA_SOBREPOS_CLIQUE );
//						c.setDia( dia );
//						c.setClique( clique );
//
//						cit = cHash.find(c);
//						if ( cit == cHash.end() )
//						{
//							double rhs = disciplina->getCalendario()->getTempoTotal( dia );
//
//							cHash[ c ] = lp->getNumRows();
//
//							sprintf( name, "%s", c.toString().c_str() );
//							OPT_ROW row( 100, OPT_ROW::LESS, rhs, name );
//
//							for(set<  VariableHash::iterator >::iterator itMV5 = itMV4->second.begin();
//								itMV5 != itMV4->second.end();
//								itMV5++)
//							{
//								VariableHash::iterator vit = *itMV5;
//								row.insert( vit->second, disciplina->getTempoCredSemanaLetiva() );
//							}
//
//
//							lp->addRow( row );
//							restricoes++;
//						}
//						else
//						{
//							double rhs = disciplina->getCalendario()->getTempoTotal( dia );
//							lp->updateLP();
//							double atualRhs = lp->getRHS( cit->second );
//							if ( rhs - atualRhs > 1e-5 )
//							{
//								lp->chgRHS( cit->second, rhs );
//							}
//
//							for(set<  VariableHash::iterator >::iterator itMV5 = itMV4->second.begin();
//								itMV5 != itMV4->second.end();
//								itMV5++)
//							{
//								VariableHash::iterator vit = *itMV5;
//								lp->chgCoef( cit->second, vit->second, disciplina->getTempoCredSemanaLetiva() );
//							}
//						}	
//					}
//				}
//			}
//		}
//	}
//
//	return restricoes;
//}


int SolverMIP::cria_restricao_evita_sobrepos_cliqueAlunos( int campusId, int cjtAlunosAtualId )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   Constraint c;
   VariableHash::iterator vit;
   ConstraintHash::iterator cit;

   std::map<Trio< int, int, Disciplina* >,std::list<VariableHash::iterator> > varsTrio;
   
   for (vit = vHash.begin(); vit != vHash.end(); vit++ )
   {
	   Variable v = vit->first;
	   
	   if ( v.getType() != Variable::V_CREDITOS )
	   {
		   continue;
	   }

	   Disciplina *disciplina = v.getDisciplina();
	   int turma = v.getTurma();
	   int dia = v.getDia();

		map< Disciplina *, int /* cjtAlunosId */, LessPtr< Disciplina > >::iterator 
		itMapDiscCjt = problemData->cjtDisciplinas.find( disciplina );

		if ( itMapDiscCjt != problemData->cjtDisciplinas.end() )
		{
			if ( itMapDiscCjt->second != cjtAlunosAtualId &&
				 NAO_CRIAR_RESTRICOES_CJT_ANTERIORES )
			{
				continue;
			}
		}
		else
		{
			std::cout<<"\nERRO em SolverMIP::cria_restricao_evita_sobrepos_cliqueAlunos: disciplina "
				<< disciplina->getId() << " nao encontrada em cjtDisciplinas\n";
			continue;
		}

      Trio< int, int, Disciplina* > trio;
	   trio.set( campusId, turma, disciplina );

      varsTrio[trio].push_back(vit);
   }

	std::map< int, std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > >::iterator 
		itMapCliques = this->cliques.begin();

   int rInicial = lp->getNumRows();
   double *rhsVec = new double[cliques.size()*7];
   int *rhsIdx = new int[cliques.size()*7];

	for ( ; itMapCliques != this->cliques.end(); itMapCliques++ )
	{
		int id = itMapCliques->first;

		std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > ggroupDiscTurma = itMapCliques->second;

      for (std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > >::iterator itTrio = itMapCliques->second.begin();
         itTrio != itMapCliques->second.end();
         itTrio++)
      {
         std::list<VariableHash::iterator> auxList = varsTrio[*itTrio];

         for (std::list<VariableHash::iterator>::iterator itL = auxList.begin();
            itL != auxList.end();
            itL++)
         {
            Variable v = (*(*itL)).first;

            c.reset();
            c.setType( Constraint::C_EVITA_SOBREPOS_CLIQUE );
            c.setDia( v.getDia() );
            c.setClique( id );

            cit = cHash.find(c);
            if ( cit == cHash.end() )
            {
               double rhs = v.getDisciplina()->getCalendario()->getTempoTotal( v.getDia() );

               cHash[ c ] = lp->getNumRows();

               sprintf( name, "%s", c.toString().c_str() );
               OPT_ROW row( 100, OPT_ROW::LESS, rhs, name );

               rhsIdx[restricoes] = lp->getNumRows();
               rhsVec[restricoes] = rhs;

               row.insert( (*(*itL)).second, v.getDisciplina()->getTempoCredSemanaLetiva() );

               lp->addRow( row );
               restricoes++;
            }
            else
            {
               double rhs = v.getDisciplina()->getCalendario()->getTempoTotal( v.getDia() );
               lp->updateLP();
               double atualRhs = rhsVec[cit->second - rInicial];//lp->getRHS( cit->second );
               if ( rhs - atualRhs > 1e-5 )
               {
                  rhsVec[cit->second - rInicial] = rhs;
               }

               lp->chgCoef( cit->second, (*(*itL)).second, v.getDisciplina()->getTempoCredSemanaLetiva() );
            }
         }
      }
	}

   lp->chgRHS(restricoes,rhsIdx,rhsVec);
   
   delete[] rhsIdx;
   delete[] rhsVec;

   return restricoes;
}


#endif


   /********************************************************************
   **    CRIAÇÃO DE VARIAVEIS E RESTRIÇÕES DO TATICO COM HORARIOS     **
   *********************************************************************/ 

#ifdef TATICO_COM_HORARIOS

/* ----------------------------------------------------------------------------------
							VARIAVEIS TATICO POR ALUNO COM HORARIOS
 ---------------------------------------------------------------------------------- */

int SolverMIP::criaVariaveisTatico( int campusId, int P, int r, int tatico )
{
	int num_vars = 0;
	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_variaveis
	int numVarsAnterior = 0;
#endif

	// Se é tático 2, então estamos reaproveitando as variaveis, e só temos que criar as variaveis fa, fad e f,
	// e fixar algumas atendidas.
	if ( tatico==2 )
	{
		num_vars = lp->getNumCols();
		numVarsAnterior = num_vars;

		timer.start();
		num_vars += criaVariavelTaticoDesalocaAluno( campusId, P, tatico ); // fa_{i,d,a}
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fa\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif

		timer.start();
		num_vars += criaVariavelTaticoDesalocaAlunoDiaHor( campusId, P, tatico ); // fad_{i,d,a,t,h}
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fad\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif

		timer.start();
		num_vars += criaVariavelTaticoFormandosNaTurma( campusId, P, r, tatico ); // f_{i,d,cp}
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"f\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif
		

		fixaAtendimentosVariaveisCreditosAnterior();
		liberaAtendimentosVariaveisFFD();

		return num_vars;
	}

	timer.start();
	num_vars += criaVariavelTaticoCreditos( campusId, P, r ); // x
	timer.stop();
	dif = timer.getCronoCurrSecs();
	
#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"x\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += criaVariavelTaticoAbertura( campusId, P, r ); // z
	timer.stop();
	dif = timer.getCronoCurrSecs();
	
#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"z\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += criaVariavelTaticoConsecutivos( campusId, P ); // c
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"c\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	/*
	timer.start();
	num_vars += criaVariavelTaticoMinCreds( campusId, P ); // h
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"h\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	

	timer.start();
	num_vars += criaVariavelTaticoMaxCreds( campusId, P ); // H
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"H\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	*/

	timer.start();
	num_vars += criaVariavelTaticoCombinacaoDivisaoCredito( campusId, P ); // m_{i,d,k}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"m\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

				
	timer.start();
	num_vars += criaVariavelTaticoFolgaCombinacaoDivisaoCredito( campusId, P ); // fk_{i,d,k}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fkp e fkm\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += criaVariavelTaticoFolgaDistCredDiaSuperior( campusId, P ); // fcp_{d,t}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fcp\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
   		

	timer.start();
	num_vars += criaVariavelTaticoFolgaDistCredDiaInferior( campusId, P ); // fcm_{d,t}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fcm\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	

	timer.start();
	num_vars += criaVariavelTaticoAberturaCompativel( campusId, P ); // zc
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"zc\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += criaVariavelTaticoFolgaDemandaDisc( campusId, P, r ); // fd
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
		
	/*
	timer.start();
	num_vars += criaVariavelTaticoAlunoUnidDia( campusId ); // y_{a,u,t} 
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"y\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
		

	timer.start();
	num_vars += criaVariavelTaticoAlunoUnidadesDifDia( campusId ); // w_{a,t}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"w\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	*/

	timer.start();
	num_vars += criaVariavelTaticoFolgaAlunoUnidDifDia( campusId, P ); // fu_{i1,d1,i2,d2,t,cp}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fu\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += criaVariavelTaticoFolgaFolgaDemandaPT( campusId, P ); // ffd_{i1,-d,i2,d,cp}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"ffd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += criaVariavelTaticoDiaUsadoPeloAluno( campusId, P ); // du_{a,t}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"du\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
		


	return num_vars;

}

// x_{i,d,u,s,hi,hf,t}
int SolverMIP::criaVariavelTaticoCreditos( int campusId, int P, int r )
{
	int numVars = 0;
    
	Disciplina * disciplina = NULL;

    ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
    {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			 if ( itCjtSala->salas.size() > 1 )
			 {
				std::cout<<"\nATENCAO em criaVariavelTaticoCreditos: conjunto sala deve ter somente 1 sala! \n";
			 }

			 int salaId = itCjtSala->salas.begin()->first;

            ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );
			   
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion
				
			    if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
					continue;

			   std::pair< int, int > parDiscSala = std::make_pair( disciplina->getId(), salaId );

			   std::map< std::pair< int /*idDisc*/, int /*idSala*/ >, 
						 std::map< int /*Dia*/, GGroup< HorarioAula *, LessPtr< HorarioAula > > > >::iterator

			   it_Disc_Sala_Dias_HorariosAula = problemData->disc_Salas_Dias_HorariosAula.find( parDiscSala );

			   if ( it_Disc_Sala_Dias_HorariosAula == 
				    problemData->disc_Salas_Dias_HorariosAula.end() )
			   {
				   continue;
			   }

			   for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
				    std::map< int /*Dia*/, GGroup< HorarioAula *, LessPtr< HorarioAula > > >::iterator
						it_Dia_HorarioAula = it_Disc_Sala_Dias_HorariosAula->second.begin();
					
					for ( ; it_Dia_HorarioAula != it_Disc_Sala_Dias_HorariosAula->second.end(); it_Dia_HorarioAula++ )
					{
						int dia = it_Dia_HorarioAula->first;
					  
						ITERA_GGROUP_LESSPTR( itHorario, it_Dia_HorarioAula->second, HorarioAula )
						{
							HorarioAula *hi = *itHorario;

							ITERA_GGROUP_LESSPTR( itHorario, it_Dia_HorarioAula->second, HorarioAula )
							{
								 HorarioAula *hf = *itHorario;

								 if ( ! disciplina->inicioTerminoValidos( hi, hf ) )
									 continue;								 						 

								 VariableTatico v;
								 v.reset();
								 v.setType( VariableTatico::V_CREDITOS );

								 v.setTurma( turma );            // i
								 v.setDisciplina( disciplina );  // d
								 v.setUnidade( *itUnidade );     // u
								 v.setSubCjtSala( *itCjtSala );  // tps  
								 v.setDia( dia );				 // t
								 v.setHorarioAulaInicial( hi );	 // hi
								 v.setHorarioAulaFinal( hf );	 // hf

								 if ( vHashTatico.find( v ) == vHashTatico.end() )
								 {
									if ( !criaVariavelTatico( &v ) )
										continue;

									if ( P==1 && r>1 )
									if ( !criaVariavelTatico_Anterior( &v ) )
										continue;

									vHashTatico[ v ] = lp->getNumCols();
									
									double lowerBound = 0.0;
									double upperBound = 1.0;

									if ( ( P > 1 && FIXAR_TATICO_P1 ) ||
										 ( P==1 && r > 1 ) )
									{
										bool found = false;
										double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
										if ( found ) // fixa!
										{
											lowerBound = value;
											upperBound = lowerBound;
										}
									}

									OPT_COL col( OPT_COL::VAR_BINARY, 0.0, lowerBound, upperBound,
									   ( char * )v.toString().c_str());

									lp->newCol( col );
									numVars++;
								 }
							}
						}
					}
               }
            }
         }
      }
    }

	return numVars;
}
      
// z_{i,d,cp}
int SolverMIP::criaVariavelTaticoAbertura( int campusId, int P, int r )
{
	int numVars = 0;
   
   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }
	     
	  GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

      ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
      {
		  Disciplina * disciplina = problemData->refDisciplinas[ *it_disciplina ];

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			   !problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion

		 if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			continue;

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            VariableTatico v;
            v.reset();
            v.setType( VariableTatico::V_ABERTURA );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( *it_campus );	    // cp

            std::pair< int, int > dc
               = std::make_pair( disciplina->getId(), it_campus->getId() );

            if ( problemData->demandas_campus.find( dc )
               == problemData->demandas_campus.end() )
            {
               problemData->demandas_campus[ dc ] = 0;
            }

            if ( vHashTatico.find(v) == vHashTatico.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               lp->getNumCols();
               vHashTatico[v] = lp->getNumCols();

			   double coef = 0.0;

               if ( problemData->parametros->funcao_objetivo == 0 )
               {
				   coef = -10 * it_campus->getCusto() * disciplina->getTotalCreditos();
               }
               else if ( problemData->parametros->funcao_objetivo == 1 )
               {
				   coef = it_campus->getCusto() * disciplina->getTotalCreditos();
               }
                  
				double lowerBound = 0.0;
				double upperBound = 1.0;

				if ( ( P > 1 && FIXAR_TATICO_P1 ) ||
					 ( P==1 && r > 1 ) )
				{
					bool found = false;
					double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
					if ( found ) // fixa!
					{
						lowerBound = value;
						upperBound = lowerBound;
					}
				}

			   OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

               lp->newCol( col );

               numVars++;
            }
         }
      }
   }
	
	return numVars;
}
   
/*   
// b_{i,d,c,cp}
int SolverMIP::criaVariavelTaticoCursoAlunos( int campusId )
{
	int numVars = 0;
   
	Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_Oferta, problemData->ofertas, Oferta )
   {
       Campus * pt_Campus = it_Oferta->campus;
       Curso * pt_Curso = it_Oferta->curso;

	   if ( pt_Campus->getId() != campusId )
	   {
		   continue;
	   }

       map < Disciplina*, int, LessPtr< Disciplina > >::iterator it_Prd_Disc = 
         it_Oferta->curriculo->disciplinas_periodo.begin();
      for(; it_Prd_Disc != it_Oferta->curriculo->disciplinas_periodo.end();
         it_Prd_Disc++ )
      {
		  disciplina = it_Prd_Disc->first;

		  #pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		  {
			  continue;
		  }
		  #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            VariableTatico v;
            v.reset();
            v.setType( VariableTatico::V_ALOC_ALUNO );

            v.setTurma( turma );           // i
            v.setDisciplina( disciplina ); // d
            v.setCurso( pt_Curso );        // c
            v.setCampus( pt_Campus );	    // cp

            if ( vHashTatico.find( v ) == vHashTatico.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               vHashTatico[v] = lp->getNumCols();
				
			   double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					coef = -1.0;
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 1.0;
				}

               OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0,
                  ( char * )v.toString().c_str() );

               lp->newCol( col );
               numVars++;
            }
         }
      }
   }
	
	return numVars;
}
   
*/

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var c_{i,d,t} 

%Desc 
indica se houve abertura de turma $i$ da disciplina $d$ em dias consecutivos.

%ObjCoef
\delta \cdot \sum\limits_{d \in D} 
\sum\limits_{i \in I_{d}} \sum\limits_{t \in T-{1}} c_{i,d,t}

%Data \delta
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/
int SolverMIP::criaVariavelTaticoConsecutivos( int campusId, int P )
{
	int numVars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	  if ( it_campus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( it_unidade, it_campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_conjunto_sala, it_unidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, it_conjunto_sala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

			    if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
					continue;

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos
                     = it_conjunto_sala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     VariableTatico v;
                     v.reset();
                     v.setType( VariableTatico::V_DIAS_CONSECUTIVOS );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );     // t
					 v.setCampus( *it_campus );		 // cp

                     if ( vHashTatico.find( v ) == vHashTatico.end() )
                     {
						if ( !criaVariavelTatico( &v ) )
							continue;

                        vHashTatico[v] = lp->getNumCols();
					    
						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{
							coef = -1.0;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{
							coef = 1.0;
						}
                           
						double lowerBound = 0.0;
						double upperBound = 1.0;

						if ( P > 1 && FIXAR_TATICO_P1 )
						{
							bool found = false;
							double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
							if ( found ) // fixa!
							{
								lowerBound = value;
								upperBound = lowerBound;
							}
						}

						OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );
						                           
						lp->newCol( col );

                        numVars++;
                     }
                  }
               }
            }
         }
      }
   }

	return numVars;
}

// h_{a}
int SolverMIP::criaVariavelTaticoMinCreds( int campusId, int P )
{
   int numVars = 0;
   
   if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE )
   {
		return numVars;
   }

   Campus *cp = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	    Aluno *aluno = *itAluno;

	    if ( aluno->getOferta()->getCampusId() != campusId )
	    {
			continue;
	    }

		VariableTatico v;
		v.reset();
		v.setType( VariableTatico::V_MIN_CRED_SEMANA );
		v.setAluno( aluno );	// a

		if ( vHashTatico.find( v ) == vHashTatico.end() )
		{
			if ( !criaVariavelTatico( &v ) )
				continue;

			vHashTatico[ v ] = lp->getNumCols();

			double obj = 0.0;

            if ( problemData->parametros->funcao_objetivo == 0 )
            {
                if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
                {
					obj = cp->getCusto()/4;
                }
                else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
                {
                    obj = cp->getCusto()/4;
                }
            }
            else if ( problemData->parametros->funcao_objetivo == 1 )
            {
                if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
                {
                    obj = cp->getCusto()/4;
                }
                else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
                {
                    obj = cp->getCusto()/4;
                }
            }
               
			double lowerBound = 0.0;
			double upperBound = 1000.0;

			if ( P > 1 && FIXAR_TATICO_P1 )
			{
				bool found = false;
				double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
				if ( found ) // fixa!
				{
					lowerBound = value;
				}
			}

			OPT_COL col( OPT_COL::VAR_INTEGRAL, obj, lowerBound, upperBound, ( char * )v.toString().c_str() );

			lp->newCol( col );
			numVars++;
		}
	}

    return numVars;
}

// H_{a}
int SolverMIP::criaVariavelTaticoMaxCreds( int campusId, int P )
{
   int numVars = 0;
   
   if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE )
   {
		return numVars;
   }

   Campus *cp = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	    Aluno *aluno = *itAluno;

	    if ( aluno->getOferta()->getCampusId() != campusId )
	    {
			continue;
	    }

		VariableTatico v;
		v.reset();
		v.setType( VariableTatico::V_MAX_CRED_SEMANA );

		v.setAluno( aluno );	// a

		if ( vHashTatico.find( v ) == vHashTatico.end() )
		{
			if ( !criaVariavelTatico( &v ) )
				continue;

			vHashTatico[ v ] = lp->getNumCols();

			double obj = 0.0;

            if ( problemData->parametros->funcao_objetivo == 0 )
            {
                if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
                {
					obj = - cp->getCusto()/4;
                }
                else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
                {
                    obj = 0.0;
                }
            }
            else if ( problemData->parametros->funcao_objetivo == 1 )
            {
                if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
                {
                    obj = - cp->getCusto()/4;
                }
                else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
                {
                    obj = 0.0;
                }
            }

			double lowerBound = 0.0;
			double upperBound = 1000.0;

			if ( P > 1 && FIXAR_TATICO_P1 )
			{
				bool found = false;
				double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
				if ( found ) // fixa!
				{
					lowerBound = value;
				}
			}
               
			OPT_COL col( OPT_COL::VAR_INTEGRAL, obj, lowerBound, upperBound, ( char * )v.toString().c_str() );

			lp->newCol( col );
			numVars++;
		}
	}

    return numVars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var m_{d,i,k} 

%Desc 
variável binária que indica se a combinação de divisão de créditos 
$k$ foi escolhida para a turma $i$ da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::criaVariavelTaticoCombinacaoDivisaoCredito( int campusId, int P )
{
   int numVars = 0;

   Disciplina * disciplina = NULL;
  
   GGroup<int> disciplinas = problemData->cp_discs[campusId];

   ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
   {
	   disciplina = problemData->refDisciplinas[ *it_disciplina ];

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion

	  if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
		  continue;

      for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
      {
         for ( unsigned k = 0; k < disciplina->combinacao_divisao_creditos.size(); k++ )
         { 
            VariableTatico v;
            v.reset();
            v.setType( VariableTatico::V_COMBINACAO_DIVISAO_CREDITO );

            v.setTurma( turma );           // i
            v.setDisciplina( disciplina ); // d
            v.setK( k );	                // k

            if ( vHashTatico.find( v ) == vHashTatico.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               vHashTatico[ v ] = lp->getNumCols();

				double lowerBound = 0.0;
				double upperBound = 1.0;

				if ( P > 1 && FIXAR_TATICO_P1 )
				{
					bool found = false;
					double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
					if ( found ) // fixa!
					{
						lowerBound = value;
						upperBound = lowerBound;
					}
				}

               OPT_COL col( OPT_COL::VAR_BINARY, 0.0, lowerBound, upperBound, ( char * )v.toString().c_str() );

               lp->newCol( col );
               numVars++;
            }
         }
      }
   }

   return numVars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fkp_{d,i,t} 

%Desc 
variável de folga superior para a restrição de combinação de divisão de créditos.

%ObjCoef
\psi \cdot \sum\limits_{d \in D} 
\sum\limits_{t \in T} \sum\limits_{i \in I_{d}} fkp_{d,i,k}

%Data \psi
%Desc
peso associado a função objetivo.

%Var fkm_{d,i,t} 

%Desc 
variável de folga inferior para a restrição de combinação de divisão de créditos.

%ObjCoef
\psi \cdot \sum\limits_{d \in D} 
\sum\limits_{t \in T} \sum\limits_{i \in I_{d}} fkm_{d,i,k}

%Data \psi
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::criaVariavelTaticoFolgaCombinacaoDivisaoCredito( int campusId, int P )
{
   int numVars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_unidade, it_campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_conjunto_sala, it_unidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, it_conjunto_sala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

			   if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
					continue;

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
					if ( ! problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId ) )
						continue;

                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos =
                     it_conjunto_sala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     VariableTatico v;
                     v.reset();
                     v.setType( VariableTatico::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );	    // t

                     if ( vHashTatico.find( v ) == vHashTatico.end() )
                     {
						if ( criaVariavelTatico( &v ) )
						{
							vHashTatico[v] = lp->getNumCols();

							double coef = 0.0;

							if ( problemData->parametros->funcao_objetivo == 0 )
							{
								coef = -2*it_campus->getCusto();
							}
							else if ( problemData->parametros->funcao_objetivo == 1 )
							{
								coef = 2*it_campus->getCusto();
							}
                           
							OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, 10000.0,
								  ( char * )v.toString().c_str() );

							lp->newCol( col );

							numVars++;
						}
                     }

                     v.reset();
                     v.setType( VariableTatico::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );	    // t

                     if ( vHashTatico.find( v ) == vHashTatico.end() )
                     {
						if ( criaVariavelTatico( &v ) )
						{
							vHashTatico[v] = lp->getNumCols();

							double coef = 0.0;

							if ( problemData->parametros->funcao_objetivo == 0 )
							{
								coef = -2*it_campus->getCusto();
							}
							else if ( problemData->parametros->funcao_objetivo == 1 )
							{
								coef = 2*it_campus->getCusto();
							}
                           
							OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, 10000.0,
								  ( char * )v.toString().c_str() );
						                           
							lp->newCol( col );

							numVars++;
						}
                     }
                  }
               }
            }
         }
      }
   }

   return numVars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fcp_{d,t}

%Desc 
variável de folga superior para a restrição de fixação da distribuição de créditos por dia.
%ObjCoef
\xi \cdot \sum\limits_{d \in D} \sum\limits_{t \in T} fcp_{d,t}

%Data \xi
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::criaVariavelTaticoFolgaDistCredDiaSuperior( int campusId, int P )
{
   int numVars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  if ( itCampus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				// A disciplina deve ser ofertada no campus especificado
				if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
					 problemData->cp_discs[campusId].end() )
				{
					continue;
				}

			   #pragma region Equivalencias
			   if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				 	  problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
			   {
				   continue;
			   }
			   #pragma endregion

			   if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
					continue;

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos
                     = itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() 
                           && it_fix->getDiaSemana() == ( *itDiasLetDisc ) )
                        {
                           VariableTatico v;
                           v.reset();
                           v.setType( VariableTatico::V_SLACK_DIST_CRED_DIA_SUPERIOR );

                           v.setTurma( turma );
                           v.setDisciplina( disciplina );
                           v.setDia( *itDiasLetDisc );
                           v.setSubCjtSala( *itCjtSala );

                           if ( vHashTatico.find( v ) == vHashTatico.end() )
                           {
							    if ( !criaVariavelTatico( &v ) )
									continue;

                                vHashTatico[v] = lp->getNumCols();
                                int cred_disc_dia = it_fix->disciplina->getMaxCreds();

								double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{
									coef = -itCampus->getCusto()/2;
								}
								else if ( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = itCampus->getCusto()/2;
								}
               
								OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, cred_disc_dia,
										( char * )v.toString().c_str() );
			                 
								lp->newCol( col );

                                numVars++;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return numVars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fcm_{d,t}  

%Desc 
variável de folga inferior para a restrição de fixação da distribuição de créditos por dia.

%ObjCoef
\xi \cdot \sum\limits_{d \in D} \sum\limits_{t \in T} fcm_{d,t}

%DocEnd
/====================================================================*/

int SolverMIP::criaVariavelTaticoFolgaDistCredDiaInferior( int campusId, int P )
{
   int numVars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				// A disciplina deve ser ofertada no campus especificado
				if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
					 problemData->cp_discs[campusId].end() )
				{
					continue;
				}

			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
			   {
				  continue;
			   }
			   #pragma endregion

			   if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
				   continue;

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos =
                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() 
                           && it_fix->getDiaSemana() == ( *itDiasLetDisc ) )
                        {
                           VariableTatico v;
                           v.reset();
                           v.setType( VariableTatico::V_SLACK_DIST_CRED_DIA_INFERIOR );

                           v.setTurma( turma );
                           v.setDisciplina( disciplina );
                           v.setDia( *itDiasLetDisc );
                           v.setSubCjtSala( *itCjtSala );

                           if ( vHashTatico.find( v ) == vHashTatico.end() )
                           {
							    if ( !criaVariavelTatico( &v ) )
									continue;

                                vHashTatico[v] = lp->getNumCols();
                                int cred_disc_dia = it_fix->disciplina->getMinCreds();

							    double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{
									coef = -itCampus->getCusto()/2;
								}
								else if ( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = itCampus->getCusto()/2;
								}               

								OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, cred_disc_dia,
											( char* )v.toString().c_str() );

								lp->newCol( col );

                                numVars += 1;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return numVars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var zc_{d,t} 

%Desc 
indica se houve abertura da disciplina $d$ no dia $t$.

%DocEnd
/====================================================================*/
int SolverMIP::criaVariavelTaticoAberturaCompativel( int campusId, int P )
{
   int numVars = 0;

   Disciplina *disciplina = NULL;

   Campus *campus = problemData->refCampus[ campusId ];

   ITERA_GGROUP_N_PT( it_disciplina, problemData->cp_discs[campusId], int )
   {
	    disciplina = problemData->refDisciplinas[ *it_disciplina ];

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion

		if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			 continue;

        ITERA_GGROUP_N_PT( itDiasLetDisc, disciplina->diasLetivos, int )
        {
            VariableTatico v;
            v.reset();
            v.setType( VariableTatico::V_ABERTURA_COMPATIVEL );

            v.setDisciplina( disciplina );  // d
            v.setDia( *itDiasLetDisc );     // t
			v.setCampus( campus );			// cp

            if ( vHashTatico.find( v ) == vHashTatico.end() )
            {
				if ( !criaVariavelTatico( &v ) )
					continue;

                vHashTatico[ v ] = lp->getNumCols();

				double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					coef = -1.0;
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 1.0;
			 	}

				double lowerBound = 0.0;
				double upperBound = 1.0;

				if ( P > 1 && FIXAR_TATICO_P1 )
				{
					bool found = false;
					double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
					if ( found ) // fixa!
					{
						lowerBound = value;
					}
				}

                OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound,
                ( char * )v.toString().c_str() );

                lp->newCol( col );
                numVars++;
            }
        }
   }

   return numVars;
}

/*
// fd_{d,a}
int SolverMIP::criaVariavelTaticoFolgaDemandaDiscAluno( int campusId )
{
   int numVars = 0;
   
   Campus *cp = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	    Aluno *aluno = *itAluno;

	    if ( aluno->getOferta()->getCampusId() != campusId )
	    {
		    continue;
	    }

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = itAlDemanda->demanda->disciplina;

			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
			{
				continue;
			}
			#pragma endregion

			VariableTatico v;
			v.reset();
			v.setType( VariableTatico::V_SLACK_DEMANDA );

			v.setDisciplina( disciplina );  // d
			v.setAluno( aluno );			// a

			if ( vHashTatico.find( v ) == vHashTatico.end() )
			{
				if ( !criaVariavelTatico( &v ) )
					continue;

				vHashTatico[ v ] = lp->getNumCols();

				double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					coef = - 50 * disciplina->getTotalCreditos() * aluno->getOferta()->getReceita();
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 10 * disciplina->getTotalCreditos() * cp->getCusto();
			 	}

				double ub = 1.0;

				OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, ub,
				( char * )v.toString().c_str() );

				lp->newCol( col );
				numVars++;
			}
        }
   }

   return numVars;
}
*/

// fd_{i,d,cp}
int SolverMIP::criaVariavelTaticoFolgaDemandaDisc( int campusId, int P, int r )
{
	int numVars = 0;
   
   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }
	     
	  GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

      ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
      {
		  Disciplina * disciplina = problemData->refDisciplinas[ *it_disciplina ];
		  
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion
		 		 
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			  continue;

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            VariableTatico v;
            v.reset();
            v.setType( VariableTatico::V_SLACK_DEMANDA );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( *it_campus );	    // cp

            std::pair< int, int > dc
               = std::make_pair( disciplina->getId(), it_campus->getId() );

            if ( problemData->demandas_campus.find( dc )
               == problemData->demandas_campus.end() )
            {
               problemData->demandas_campus[ dc ] = 0;
            }

            if ( vHashTatico.find(v) == vHashTatico.end() )
            {
			    if ( !criaVariavelTatico( &v ) )
					continue;

                lp->getNumCols();
                vHashTatico[v] = lp->getNumCols();

			    double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					// Numero de aluno alocados para a turma
					int nroAlunos = problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId );
					int receitaMedia = problemData->receitaMediaTurmaDiscCampus( turma, disciplina->getId(), campusId );

					coef = - 100 * nroAlunos * disciplina->getTotalCreditos() * receitaMedia;
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 10 * disciplina->getTotalCreditos() * it_campus->getCusto();
			 	}
								
				double lowerBound = 0.0;
				double upperBound = 1.0;

				if ( ( P > 1 && FIXAR_TATICO_P1 ) ||
					 ( P==1 && r > 1 ) )
				{
					bool found = false;
					double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
					if ( found ) // fixa!
					{
						lowerBound = value;
						upperBound = lowerBound;
					}
				}

			    OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

                lp->newCol( col );
				 
                numVars++;
            }
         }
      }
   }
	
	return numVars;
	
}

// y_{a,u,t}
int SolverMIP::criaVariavelTaticoAlunoUnidDia( int campusId, int P )
{
   int numVars = 0;
   
   Campus *cp = problemData->refCampus[campusId];
   
   ITERA_GGROUP_LESSPTR( itUnid, cp->unidades, Unidade )
   {
	   Unidade *unid = *itUnid;

	   ITERA_GGROUP_N_PT( itDia, unid->dias_letivos, int )
	   {
			int dia = *itDia;

		   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
		   {
				Aluno *aluno = *itAluno;

				if ( aluno->getOferta()->getCampusId() != campusId )
					continue;

				VariableTatico v;
				v.reset();
				v.setType( VariableTatico::V_ALUNO_UNID_DIA );

				v.setUnidade( unid ); // u
				v.setAluno( aluno );  // a
				v.setDia( dia );	  // t

				if ( vHashTatico.find( v ) == vHashTatico.end() )
				{
					if ( !criaVariavelTatico( &v ) )
						continue;

					vHashTatico[ v ] = lp->getNumCols();

					double coef = 0.0;

					if ( problemData->parametros->funcao_objetivo == 0 )
					{
						coef = -1.0;
					}
					else if ( problemData->parametros->funcao_objetivo == 1 )
					{
						coef = 1.0;
			 		}

					OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0,
					( char * )v.toString().c_str() );

					lp->newCol( col );
					numVars++;
				}
			}
	   }
   }

   return numVars;
}


// w_{a,t}
int SolverMIP::criaVariavelTaticoAlunoUnidadesDifDia( int campusId, int P )
{
   int numVars = 0;
   
   Campus *cp = problemData->refCampus[campusId];
   
   ITERA_GGROUP_N_PT( itDia, cp->diasLetivos, int )
   {
		int dia = *itDia;
		ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
		{
			Aluno *aluno = *itAluno;
			
			if ( aluno->getOferta()->getCampusId() != campusId )
				continue;

			VariableTatico v;
			v.reset();
			v.setType( VariableTatico::V_ALUNO_VARIAS_UNID_DIA );

			v.setAluno( aluno );  // a
			v.setDia( dia );	  // t

			if ( vHashTatico.find( v ) == vHashTatico.end() )
			{
				if ( !criaVariavelTatico( &v ) )
					continue;

				vHashTatico[ v ] = lp->getNumCols();

				double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					coef = -100.0;
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 100.0;
			 	}

				OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0,
				( char * )v.toString().c_str() );

				lp->newCol( col );
				numVars++;
			}
		}
   }

   return numVars;
}


// fu_{i1,d1,i2,d2,t,cp}
int SolverMIP::criaVariavelTaticoFolgaAlunoUnidDifDia( int campusId, int P )
{
	int numVars = 0;
   
   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   Campus * campus = *it_campus;

	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }
	     
	  GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

	  // Disciplina 1
      ITERA_GGROUP_N_PT( it_disc1, disciplinas, int )
      {
		  Disciplina * disciplina1 = problemData->refDisciplinas[ *it_disc1 ];
		  
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina1 ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina1 ) )
		 {
			continue;
		 }
		 #pragma endregion
		 		 
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina1->getId(), campusId ) )
			  continue;
		
		 // Turma 1
         for ( int turma1 = 0; turma1< disciplina1->getNumTurmas(); turma1++ )
         {
			 Unidade * u1 = this->retornaUnidadeDeAtendimento( turma1, disciplina1, campus );

			 if ( u1 == NULL )
				 continue;

			  // Disciplina 2
			  ITERA_GGROUP_INIC_N_PT( it_disc2, it_disc1, disciplinas, int )
			  {
				  Disciplina * disciplina2 = problemData->refDisciplinas[ *it_disc2 ];
		  
				  #pragma region Equivalencias
				  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina2 ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina2 ) )
				  {
					  continue;
				  }
				  #pragma endregion
		 		 
				  if ( ! problemData->haDemandaDiscNoCampus( disciplina2->getId(), campusId ) )
					  continue;

				  // Turma 2
				  for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
				  {
					   Unidade * u2 = this->retornaUnidadeDeAtendimento( turma2, disciplina2, campus );

					   if ( u2 == NULL || u1 == u2 )
							continue;

					    GGroup<Aluno*> alunosEmComum = 
							problemData->alunosEmComum( turma1, disciplina1, turma2, disciplina2, campus );

						if ( alunosEmComum.size() == 0 )
							continue;

						int nroAlunos = alunosEmComum.size();

						GGroup<int> dias = problemData->diasComunsEntreDisciplinas( disciplina1, disciplina2 );

						ITERA_GGROUP_N_PT( it_dias, dias, int )
						{
							VariableTatico v;
							v.reset();
							v.setType( VariableTatico::V_SLACK_ALUNO_VARIAS_UNID_DIA );

							v.setTurma1( turma1 );            // i1
							v.setDisciplina1( disciplina1 );  // d1
							v.setTurma2( turma2 );            // i2
							v.setDisciplina2( disciplina2 );  // d2
							v.setCampus( campus );		      // cp
							v.setDia( *it_dias );			  // t

							if ( vHashTatico.find(v) == vHashTatico.end() )
							{
								if ( !criaVariavelTatico( &v ) )
									continue;

								lp->getNumCols();
								vHashTatico[v] = lp->getNumCols();

								double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{					
									coef = - 10 * nroAlunos;
								}
								else if ( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = 10 * nroAlunos;
			 					}

								double lowerBound = 0.0;
								double upperBound = 1.0;

								if ( P > 1 && FIXAR_TATICO_P1 )
								{
									bool found = false;
									double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
									if ( found ) // fixa!
									{
										lowerBound = value;
										upperBound = lowerBound;
									}
								}
                  
								OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

								lp->newCol( col );
				 
								numVars++;
							}
						}
				  }
			  }
          }
      }
   }
	
	return numVars;

}


// ffd_{i1,-d,i2,d,cp}
int SolverMIP::criaVariavelTaticoFolgaFolgaDemandaPT( int campusId, int P )
{
	int numVars = 0;
     
    Campus* campus = problemData->refCampus[ campusId ];
	     
	GGroup< int > disciplinas = problemData->cp_discs.find( campusId )->second;

	ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
	{
		Disciplina * discPratica = problemData->refDisciplinas[ *it_disciplina ];

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( discPratica ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( discPratica ) )
		{
			continue;
		}
		#pragma endregion

		if ( discPratica->getId() > 0 )
		{
			continue;
		}
		
		std::map< int, Disciplina * >::iterator itMapDisc =
			problemData->refDisciplinas.find( - discPratica->getId() );
				
		if ( itMapDisc == problemData->refDisciplinas.end() )
		{
			continue;
		}
		
		Disciplina *discTeorica = itMapDisc->second;

		if ( ! problemData->haDemandaDiscNoCampus( discPratica->getId(), campusId ) )
		{
			continue;
		}

		for ( int turma1 = 0; turma1 < discPratica->getNumTurmas(); turma1++ )
		{
			for ( int turma2 = 0; turma2 < discTeorica->getNumTurmas(); turma2++ )
			{		
				GGroup<Aluno*> alunos = problemData->alunosEmComum( turma1, discPratica, turma2, discTeorica, campus );
				
				if ( alunos.size() == 0 )
				{
					continue;
				}

				VariableTatico v;
				v.reset();
				v.setType( VariableTatico::V_SLACK_SLACKDEMANDA_PT );

				v.setTurma1( turma1 );            // i1
				v.setDisciplina1( discPratica );  // -d
				v.setTurma2( turma2 );            // i2
				v.setDisciplina2( discTeorica );  // d
				v.setCampus( campus );	     // cp

				if ( vHashTatico.find(v) == vHashTatico.end() )
				{
					if ( !criaVariavelTatico( &v ) )
						continue;

					lp->getNumCols();
					vHashTatico[v] = lp->getNumCols();

					double coef = 0.0;
						
					if ( problemData->parametros->funcao_objetivo == 0 )
					{
						coef = - 100.0 * alunos.size() * 
							( discPratica->getTotalCreditos() + discTeorica->getTotalCreditos() ); // TODO
					}
					else if ( problemData->parametros->funcao_objetivo == 1 )
					{						
						coef = 500 * campus->getCusto() * alunos.size() * 
							( discPratica->getTotalCreditos() + discTeorica->getTotalCreditos() ); // TODO
			 		}

					double lowerBound = 0.0;
					double upperBound = 1.0;
                  
					OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

					lp->newCol( col );
				 
					numVars++;
				}
			}
		}
   }
	
	return numVars;
	
}
  
// du_{a,t}
int SolverMIP::criaVariavelTaticoDiaUsadoPeloAluno( int campusId, int P )
{
   int numVars = 0;
   
   if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE )
   {
		return numVars;
   }

   Campus *cp = problemData->refCampus[campusId];

   ITERA_GGROUP_N_PT( itDia, cp->diasLetivos, int )
   {
	   int dia = *itDia;
	   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	   {
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			VariableTatico v;
			v.reset();
			v.setType( VariableTatico::V_ALUNO_DIA );
			v.setAluno( aluno );	// a
			v.setDia( dia );		// t

			if ( vHashTatico.find( v ) == vHashTatico.end() )
			{
				if ( !criaVariavelTatico( &v ) )
					continue;

				vHashTatico[ v ] = lp->getNumCols();

				double obj = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 ) // MAX
				{
					if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
					{
						obj = cp->getCusto()/4;
					}
					else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
					{
						obj = -cp->getCusto()/4;
					}
				}
				else if ( problemData->parametros->funcao_objetivo == 1 ) // MIN
				{
					if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
					{
						obj = -cp->getCusto()/4;
					}
					else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
					{
						obj = cp->getCusto()/4;
					}
				}
               
				double lowerBound = 0.0;
				double upperBound = 1.0;

				if ( P > 1 && FIXAR_TATICO_P1 )
				{
					bool found = false;
					double value = fixaLimitesVariavelTaticoComHorAnterior( &v, found );
					if ( found ) // fixa!
					{
						lowerBound = value;
					}
				}

				OPT_COL col( OPT_COL::VAR_BINARY, obj, lowerBound, upperBound, ( char * )v.toString().c_str() );

				lp->newCol( col );
				numVars++;
			}
		}
   }

    return numVars;
}

// fad_{i,d,a,t,h}
// É criada a partir da variavel x. Logo, só deve ser chamada após esta ser toda criada.
int SolverMIP::criaVariavelTaticoDesalocaAlunoDiaHor( int campusId, int P, int tatico )
{
    int numVars = 0;

    if ( tatico<=1 ) return numVars;
	
    char name[ 100 ];
    VariableTatico v;
    VariableTaticoHash::iterator vit;
	
	GGroup< VariableTatico*, LessPtr<VariableTatico> > auxVariables;
	
	vit = vHashTatico.begin();
	while( vit != vHashTatico.end() )
	{
		// x_{i,d,s,t,hi,hf}
		if( vit->first.getType() == VariableTatico::V_CREDITOS )
		{
			VariableTatico v = vit->first;
						
			int dia = v.getDia();
			HorarioAula *hi = v.getHorarioAulaInicial();
			HorarioAula *hf = v.getHorarioAulaFinal();
			Disciplina *disciplina = v.getDisciplina();
			int turma = v.getTurma();
			int campusId = v.getUnidade()->getIdCampus();
			Campus *campus = problemData->refCampus[campusId];
			
			Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
			trio.set( campusId, turma, disciplina );

			std::map< Trio< int, int, Disciplina* >, 
						GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator 
				itMap = problemData->mapSlackCampusTurmaDisc_AlunosDemanda.find( trio );
							
			if ( itMap != problemData->mapSlackCampusTurmaDisc_AlunosDemanda.end() )
			{
				ITERA_GGROUP_LESSPTR( itAlDem, itMap->second, AlunoDemanda )
				{
					Aluno *aluno = problemData->retornaAluno( (*itAlDem)->getAlunoId() );

					if ( aluno->getOferta()->getCampusId() != campusId )
					{
						continue;
					}

					VariableTatico *v = new VariableTatico();
					v->reset();
					v->setType( VariableTatico::V_DESALOCA_ALUNO_DIA );
					v->setAluno( aluno );			// a
					v->setTurma( turma );			// i
					v->setDisciplina( disciplina );	// d
					v->setDia( dia );				// t
					v->setHorarioAulaInicial( hi );	// hi
					v->setHorarioAulaFinal( hf );	// hf

					if ( auxVariables.find( v ) == auxVariables.end() )
					{
						auxVariables.add( v );				
					}
				}
			}
		}

		vit++;
	}
	
	ITERA_GGROUP_LESSPTR( itVar, auxVariables, VariableTatico )
	{
		VariableTatico v = **itVar;

		vHashTatico[v] = lp->getNumCols();
		
		double obj = 0.0;               
		double lowerBound = 0.0;
		double upperBound = 1.0;

		OPT_COL col( OPT_COL::VAR_BINARY, obj, lowerBound, upperBound, ( char * )v.toString().c_str() );

		lp->newCol( col );		
		numVars++;	

		delete (*itVar);
	}
	
	return numVars;
}

// fa_{i,d,a}
int SolverMIP::criaVariavelTaticoDesalocaAluno( int campusId, int P, int r )
{
    int numVars = 0;

    if ( r<=1 ) return numVars;
	
	std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator
		it = problemData->mapSlackAluno_CampusTurmaDisc.begin();

	for ( ; it != problemData->mapSlackAluno_CampusTurmaDisc.end(); it++ )
	{
		Aluno *aluno = (*it).first;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		GGroup< Trio< int, int, Disciplina* > > trios = (*it).second;

		GGroup< Trio< int, int, Disciplina* > >::iterator itGGroup = trios.begin();
		for ( ; itGGroup != trios.end(); itGGroup++ )
		{
			int turma = (*itGGroup).second;
			Disciplina *disciplina = (*itGGroup).third;

			VariableTatico v;
			v.reset();
			v.setType( VariableTatico::V_DESALOCA_ALUNO );
			v.setAluno( aluno );			// a
			v.setTurma( turma );			// i
			v.setDisciplina( disciplina );	// d

			if ( vHashTatico.find( v ) == vHashTatico.end() )
			{
				vHashTatico[ v ] = lp->getNumCols();

				double obj = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 ) // MAX
				{
					obj = -disciplina->getTotalCreditos()*aluno->getOferta()->getReceita();
				}
				else if ( problemData->parametros->funcao_objetivo == 1 ) // MIN
				{
					obj = disciplina->getTotalCreditos()*aluno->getOferta()->getReceita();
				}
               
				double lowerBound = 0.0;
				double upperBound = 1.0;

				OPT_COL col( OPT_COL::VAR_BINARY, obj, lowerBound, upperBound, ( char * )v.toString().c_str() );

				lp->newCol( col );
				numVars++;
			}
		}
   }

   return numVars;
}

// f_{i,d,cp} -> indica se há alunos formandos na turma
int SolverMIP::criaVariavelTaticoFormandosNaTurma( int campusId, int P_ATUAL, int r, int tatico )
{
	int numVars = 0;
	
	if ( !problemData->parametros->violar_min_alunos_turmas_formandos )
		return numVars;

	if ( tatico!=2 )
		return numVars;

	if ( P_ATUAL==1 && r==1 ) // r1 não considera formandos
		return numVars;

	std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_disciplina, it_CpDisc->second, int )
      {
		 Disciplina *disciplina = problemData->refDisciplinas[ *it_disciplina ];
		 		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
		 	continue;
		 }
		 #pragma endregion
		 
         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
			 // como o tático não permite inserção de aluno, nem cria variavel caso já não exista formando.
			 // se existir, cria livre já que é possível a desalocação de alunos para tatico=2.
			 if ( ! problemData->possuiAlunoFormando( turma, disciplina, cp ) )
				 continue;

			 VariableTatico v;
			 v.reset();
			 v.setType( VariableTatico::V_FORMANDOS_NA_TURMA );
			 v.setTurma( turma );            // i
			 v.setDisciplina( disciplina );  // d
			 v.setCampus( cp );				// cp

			 if ( vHashTatico.find(v) == vHashTatico.end() )
			 {
			    if ( !criaVariavelTatico( &v ) )
					continue;

                lp->getNumCols();
                vHashTatico[v] = lp->getNumCols();

			    double coef = 0.0;
						 
				double lowerBound = 0.0;
				double upperBound = 1.0;

				OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, upperBound,
                     ( char * )v.toString().c_str() );

                lp->newCol( col ); 
                
				numVars++;
            }
         }
      }
   }

	return numVars;
}



/* ----------------------------------------------------------------------------------
	
							RESTRICOES TATICO POR ALUNO COM HORARIOS
 ---------------------------------------------------------------------------------- */


int SolverMIP::criaRestricoesTatico( int campusId, int prioridade, int r, int tatico )
{
	int restricoes = 0;

	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_restricoes
	int numRestAnterior = 0;
#endif

	timer.start();
	restricoes += criaRestricaoTaticoCargaHoraria( campusId, prioridade, r, tatico );				// Restricao 1.2.2
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.2\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += criaRestricaoTaticoUsoDeSalaParaCadaHorario( campusId, prioridade, r, tatico );				// Restricao 1.2.3
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.3\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += criaRestricaoTaticoAtendimentoUnicoTurmaDiscDia( campusId, prioridade, r, tatico );				// Restricao 1.2.4
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.4\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += criaRestricaoTaticoAtendeDemanda( campusId, prioridade, r, tatico );						// Restricao 1.2.5
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += criaRestricaoTaticoTurmaDiscDiasConsec( campusId, prioridade, r, tatico );				// Restricao 1.2.6
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.6\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	/*
	timer.start();
	restricoes += criaRestricaoTaticoLimitaAberturaTurmas( campusId, prioridade );			// Restricao 1.2.7
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.7\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
	*/


	timer.start();
	restricoes += criaRestricaoTaticoDivisaoCredito( campusId, prioridade, r, tatico );			// Restricao 1.2.8
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.8\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += criaRestricaoTaticoCombinacaoDivisaoCredito( campusId, prioridade, r, tatico );			// Restricao 1.2.9
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.9\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
      

	timer.start();
	restricoes += criaRestricaoTaticoAtivacaoVarZC( campusId, prioridade, r, tatico );			// Restricao 1.2.10
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.10\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


  	timer.start();
	restricoes += criaRestricaoTaticoDisciplinasIncompativeis( campusId, prioridade, r, tatico );			// Restricao 1.2.11
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.11\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	if ( tatico==1 )
	{
  		timer.start();
		restricoes += criaRestricaoTaticoAlunoHorario( campusId, prioridade, r, tatico );					// Restricao 1.2.12
		//restricoes += criaRestricaoTaticoEvitaSobreposicaoAulaAluno( campusId );	// Restricao 1.2.12	
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.2.12\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
		#endif
	}
	else
	{
  		timer.start();
		restricoes += criaRestricaoTaticoDesalocaAlunoTurmaHorario( campusId, prioridade, r, tatico );			// Restricao 1.2.13.1
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.2.13.1\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
		#endif
		
  		timer.start();
		restricoes += criaRestricaoTaticoDesalocaAlunoHorario( campusId, prioridade, r, tatico );			// Restricao 1.2.13.2
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.2.13.2\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
		#endif
		
  		timer.start();
		restricoes += criaRestricaoTaticoSumDesalocaAlunoFolgaDemanda( campusId, prioridade, r, tatico );			// Restricao 1.2.13.3
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.2.13.3\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
		#endif

  		timer.start();
		restricoes += criaRestricaoTaticoSumDesalocaAluno( campusId, prioridade, r, tatico );			// Restricao 1.2.13.4
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.2.13.4\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
		#endif
	

  		timer.start();
		restricoes += criaRestricaoTaticoGaranteMinAlunosTurma( campusId, prioridade, r, tatico );			// Restricao 1.2.13.5
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.2.13.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
		#endif


  		timer.start();
		restricoes += criaRestricaoTaticoDesalocaPT( campusId, prioridade, r, tatico );			// Restricao 1.2.13.6
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.2.13.6\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
		#endif

		
  		timer.start();
		restricoes += criaRestricaoTaticoFormandos( campusId, prioridade, r, tatico );			// Restricao 1.2.13.7
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.2.13.7\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
		#endif
			
	}

/*	// substituidas por criaRestricaoTaticoAlunoUnidDifDia()

  	timer.start();
	restricoes += criaRestricaoTaticoAtivaY( campusId );						// Restricao 1.2.13
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.13\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


  	timer.start();
	restricoes += criaRestricaoTaticoAlunoUnidadesDifDia( campusId );			// Restricao 1.2.14
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.14\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
*/


  	timer.start();
	restricoes += criaRestricaoTaticoAlunoUnidDifDia( campusId, prioridade, r, tatico );			// Restricao 1.2.14
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.14\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
	
	/* // RESTRIÇÕES ERRADAS, FORAM SUBSTITUIDAS POR criaRestricaoTaticoMinDiasAluno e criaRestricaoTaticoMaxDiasAluno
	   // DELETAR
  	timer.start();
	restricoes += criaRestricaoTaticoMinCreds( campusId );			// Restricao 1.2.15
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.15\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


  	timer.start();
	restricoes += criaRestricaoTaticoMaxCreds( campusId );			// Restricao 1.2.16
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.16\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
	*/

  	timer.start();
	restricoes += criaRestricaoTaticoDiscPraticaTeorica( campusId, prioridade, r, tatico );	// Restricao 1.2.17
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.17\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


  	timer.start();
	restricoes += criaRestricaoTaticoMinDiasAluno( campusId, prioridade, r, tatico );	// Restricao 1.2.18
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.18\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


  	timer.start();
	restricoes += criaRestricaoTaticoMaxDiasAluno( campusId, prioridade, r, tatico );	// Restricao 1.2.19
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.19\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
			   
	return restricoes;

}

int SolverMIP::criaRestricaoTaticoCargaHoraria( int campusId, int prioridade, int r, int tatico )
{
	int restricoes = 0;

	int nnz;
	char name[ 100 ];

	VariableTatico v;
	ConstraintTatico c;

	VariableTaticoHash::iterator vit;
	ConstraintTaticoHash::iterator cit;

	Campus *campus = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
			continue;

		campus = *itCampus;
		break;
	}

	if(!campus)
		return 0;

   std::vector<int> idxC;
   std::vector<int> idxR;
   std::vector<double> valC;

	vit = vHashTatico.begin();
	while(vit != vHashTatico.end())
	{
		if(vit->first.getType() != VariableTatico::V_CREDITOS && vit->first.getType() != VariableTatico::V_ABERTURA)
		{
			vit++;
			continue;
		}

		VariableTatico v = vit->first;

		if(v.getType() == VariableTatico::V_CREDITOS)
		{
			if ( problemData->cp_discs[campusId].find( v.getDisciplina()->getId() ) ==
				problemData->cp_discs[campusId].end() )
			{
				vit++;
				continue;
			}

			if ( ! problemData->haDemandaDiscNoCampus( v.getDisciplina()->getId(), campusId ) )
			    continue;

			HorarioAula *hi = v.getHorarioAulaInicial();
			HorarioAula *hf = v.getHorarioAulaFinal();
			Sala *sala = v.getSubCjtSala()->salas.begin()->second;
			Disciplina *disciplina = v.getDisciplina();
			int dia = v.getDia();
			int turma = v.getTurma();

			c.reset();
			c.setType( ConstraintTatico::C_CARGA_HORARIA );
			c.setCampus( campus );
			c.setTurma( turma );
			c.setDisciplina( disciplina );

			cit = cHashTatico.find(c);
			
			if(cit == cHashTatico.end())
			{
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
				OPT_ROW row( 100, OPT_ROW::EQUAL , 0 , name );

				//int NCH = v.getDisciplina()->getCalendario()->retornaNroCreditosEntreHorarios( hi, hf );
				int NCH = problemData->retornaNroCreditos( hi, hf, sala, disciplina, dia );

				row.insert( vit->second, NCH );

				cHashTatico[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
			else
			{
				//int NCH = v.getDisciplina()->getCalendario()->retornaNroCreditosEntreHorarios( hi, hf );
				int NCH = problemData->retornaNroCreditos( hi, hf, sala, disciplina, dia );
								
				idxC.push_back(vit->second);
				idxR.push_back(cit->second);
				valC.push_back(NCH);
				//lp->chgCoef(cit->second, vit->second,  NCH);
			}
		}
		else
		{
			if(campus->getId() != v.getCampus()->getId())
			{
				vit++;
				continue;
			}

		    if ( ! problemData->haDemandaDiscNoCampus( v.getDisciplina()->getId(), campusId ) )
			    continue;

			c.reset();
			c.setType( ConstraintTatico::C_CARGA_HORARIA );
			c.setCampus( campus );
			c.setTurma( v.getTurma() );
			c.setDisciplina( v.getDisciplina() );

			cit = cHashTatico.find(c);
			if(cit == cHashTatico.end())
			{
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
				OPT_ROW row( 100, OPT_ROW::EQUAL , 0 , name );

				row.insert( vit->second, -( v.getDisciplina()->getCredPraticos() + v.getDisciplina()->getCredTeoricos() ) );

				cHashTatico[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
			else
			{
            idxC.push_back(vit->second);
            idxR.push_back(cit->second);
            valC.push_back(-( v.getDisciplina()->getCredPraticos() + v.getDisciplina()->getCredTeoricos() ));
				//lp->chgCoef(cit->second, vit->second,  -( v.getDisciplina()->getCredPraticos() + v.getDisciplina()->getCredTeoricos() ));
			}
		}


		vit++;
	}

   lp->updateLP();
   lp->chgCoefList(idxC.size(),idxR.data(),idxC.data(),valC.data());
   lp->updateLP();

   idxC.clear();
   idxR.clear();
   valC.clear();

	return restricoes;
}

int SolverMIP::criaRestricaoTaticoUsoDeSalaParaCadaHorario( int campusId, int prioridade, int r, int tatico )
{
	int restricoes = 0;

	int nnz;
	char name[ 100 ];

	VariableTatico v;
	ConstraintTatico c;

	VariableTaticoHash::iterator vit;
	ConstraintTaticoHash::iterator cit;

	Campus *campus = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
			continue;

		campus = *itCampus;
		break;
	}

	if(!campus)
		return 0;

   std::vector<int> idxC;
   std::vector<int> idxR;
   std::vector<double> valC;

	vit = vHashTatico.begin();
	while(vit != vHashTatico.end())
	{
		if(vit->first.getType() != VariableTatico::V_CREDITOS)
		{
			vit++;
			continue;
		}

		VariableTatico v = vit->first;

		if ( campus->unidades.find(v.getUnidade()) == campus->unidades.end())
		{
			vit++;
			continue;
		}

		Sala *sala = v.getSubCjtSala()->salas.begin()->second;
		ITERA_GGROUP( itHor, sala->horariosDia, HorarioDia )
		{
			HorarioAula* h = itHor->getHorarioAula();

			if ( itHor->getDia() != v.getDia() )					
				continue;

			DateTime fimF = v.getHorarioAulaFinal()->getInicio();
			fimF.addMinutes( v.getHorarioAulaFinal()->getTempoAula() );

			DateTime fimH = h->getInicio(); // controle
			fimH.addMinutes( h->getTempoAula() );
			
			if ( ( v.getHorarioAulaInicial()->getInicio() <= h->getInicio() ) && ( fimF >  h->getInicio() ) )
			{
				c.reset();
				c.setType( ConstraintTatico::C_SALA_HORARIO );
				c.setCampus( campus );
				c.setUnidade( v.getUnidade() );
				c.setSubCjtSala( v.getSubCjtSala() );
				c.setDia( v.getDia() );
				c.setHorarioAula( h );

				cit = cHashTatico.find(c);

				cit = cHashTatico.find(c);
				if(cit == cHashTatico.end())
				{
					sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
					OPT_ROW row( 100, OPT_ROW::LESS , 1 , name );

					row.insert( vit->second, 1.0);

					cHashTatico[ c ] = lp->getNumRows();
					lp->addRow( row );
					restricoes++;
				}
				else
				{
               idxC.push_back(vit->second);
               idxR.push_back(cit->second);
               valC.push_back(1.0);
					//lp->chgCoef(cit->second, vit->second,  1.0);
				}
			}
		}

		vit++;
	}

   lp->updateLP();
   lp->chgCoefList(idxC.size(),idxR.data(),idxC.data(),valC.data());
   lp->updateLP();

   idxC.clear();
   idxR.clear();
   valC.clear();

	return restricoes;

}

int SolverMIP::criaRestricaoTaticoAtendimentoUnicoTurmaDiscDia( int campusId, int prioridade, int r, int tatico )
{
	int restricoes = 0;

	int nnz;
	char name[ 100 ];

	VariableTatico v;
	ConstraintTatico c;

	VariableTaticoHash::iterator vit;
	ConstraintTaticoHash::iterator cit;

	Campus *campus = NULL;
   std::vector<int> idxC;
   std::vector<int> idxR;
   std::vector<double> valC;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
			continue;

		campus = *itCampus;
		break;
	}

	if(!campus)
		return 0;

	vit = vHashTatico.begin();
	while(vit != vHashTatico.end())
	{
		if(vit->first.getType() != VariableTatico::V_CREDITOS)
		{
			vit++;
			continue;
		}

		VariableTatico v = vit->first;

		if ( problemData->cp_discs[campusId].find( v.getDisciplina()->getId() ) ==
			 problemData->cp_discs[campusId].end() )
		{
			vit++;
			continue;
		}

		 if ( ! problemData->haDemandaDiscNoCampus( v.getDisciplina()->getId(), campusId ) )
			 continue;
		 
		c.reset();
		c.setType( ConstraintTatico::C_UNICO_ATEND_TURMA_DISC_DIA );
		c.setCampus( campus );
		c.setTurma( v.getTurma() );
		c.setDisciplina( v.getDisciplina() );
		c.setDia( v.getDia() );

		cit = cHashTatico.find(c);

		if(cit == cHashTatico.end())
		{
			sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
			OPT_ROW row( 100, OPT_ROW::LESS , 1.0 , name );

			row.insert( vit->second, 1.0);

			cHashTatico[ c ] = lp->getNumRows();
			lp->addRow( row );
			restricoes++;
		}
		else
		{
         idxC.push_back(vit->second);
         idxR.push_back(cit->second);
         valC.push_back(1.0);

			//lp->chgCoef(cit->second, vit->second,  1.0);
		}

		vit++;
	}

   lp->updateLP();
   lp->chgCoefList(idxC.size(),idxR.data(),idxC.data(),valC.data());
   lp->updateLP();

   idxC.clear();
   idxR.clear();
   valC.clear();

	return restricoes;
}

int SolverMIP::criaRestricaoTaticoAtendeDemanda( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   Campus* cp = problemData->refCampus[ campusId ];

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
       disciplina = ( *it_disciplina );

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion	

		if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			 continue;

      for ( int i = 0; i < disciplina->getNumTurmas(); ++i )
      {
         c.reset();
         c.setType( ConstraintTatico::C_DEMANDA_DISC );
		 c.setCampus( cp );
         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 
         if ( cHashTatico.find( c ) != cHashTatico.end() )
         {
            continue;
         }

		 nnz = 2;
         OPT_ROW row( nnz, OPT_ROW::EQUAL , 1.0, name );

		 v.reset();
		 v.setType( VariableTatico::V_ABERTURA );
		 v.setTurma( i );
		 v.setDisciplina( disciplina );
		 v.setCampus( cp );

		 it_v = vHashTatico.find( v );
		 if( it_v != vHashTatico.end() )
		 {
			row.insert( it_v->second, 1.0 );
		 }

		 v.reset();
		 v.setType( VariableTatico::V_SLACK_DEMANDA );
		 v.setTurma( i );
		 v.setDisciplina( disciplina );
		 v.setCampus( cp );

		 it_v = vHashTatico.find( v );
		 if( it_v != vHashTatico.end() )
		 {
			row.insert( it_v->second, 1.0 );
		 }         

         if ( row.getnnz() != 0 )
         {
            cHashTatico[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Evitar alocação de turmas da mesma disciplina em campus diferentes
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{cp \in CP} z_{i,d,cp}  \leq  1  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/
/*
int SolverMIP::criaRestricaoTaticoEvitaTurmaDiscCampiDif()
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
       disciplina = ( *it_disciplina );

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			 !problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion	

      for ( int i = 0; i < disciplina->getNumTurmas(); ++i )
      {
         c.reset();
         c.setType( ConstraintTatico::C_EVITA_TURMA_DISC_CAMP_D );

         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHashTatico.find( c ) != cHashTatico.end() )
         {
            continue;
         }

		 nnz = problemData->campi.size();
         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

         ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
         {
            v.reset();
            v.setType( VariableTatico::V_ABERTURA );

            v.setTurma( i );
            v.setDisciplina( disciplina );

            v.setCampus( *it_campus );

            it_v = vHashTatico.find( v );
            if( it_v != vHashTatico.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         if ( row.getnnz() != 0 )
         {
            cHashTatico[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}
*/



// Restricao 1.2.8
/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Contabiliza se há turmas da mesma disciplina em dias consecutivos (*)
%Desc 

%MatExp

\begin{eqnarray}
c_{i,d,t}  \geq \sum\limits_{u \in U_{cp}} \sum\limits_{s \in S_{u}}(x_{i,d,u,s,hi,hf,t} - x_{i,d,u,s,hi,hf,t-1}) - 1  \nonumber \qquad 
\forall cp \in CP \quad
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall (t \geq 2) \in T
\end{eqnarray}

%DocEnd
/====================================================================*/
int SolverMIP::criaRestricaoTaticoTurmaDiscDiasConsec( int campusId, int prioridade, int r, int tatico )
{	
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }
	   
	   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
	   {
		  disciplina = ( *it_disciplina );

		  #pragma region Equivalencias
		  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				 problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		  {
			  continue;
		  }
		  #pragma endregion	

		  // A disciplina deve ser ofertada no campus especificado
		  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			   problemData->cp_discs[campusId].end() )
		  {
			  continue;
		  }

		  if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			  continue;
		 
		  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
		  {
			 GGroup< int, std::less<int> >::iterator itDiasLetDisc = disciplina->diasLetivos.begin();
			 
			 // Só cria as restrições a partir do segundo dia
			 // Já que a estrutura é ordenada, pula o primeiro.
			 if ( itDiasLetDisc != disciplina->diasLetivos.end() )
				itDiasLetDisc++;

			 for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
			 {
				 int dia = *itDiasLetDisc;

				c.reset();
				c.setType( ConstraintTatico::C_TURMA_DISC_DIAS_CONSEC );

				c.setCampus( *itCampus );
				c.setDisciplina( disciplina );
				c.setTurma( turma );
				c.setDia( dia );

				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 

				if ( cHashTatico.find( c ) != cHashTatico.end() )
				{
				   continue;
				}

				nnz = ( problemData->totalSalas * 2 + 1 );
				OPT_ROW row( nnz, OPT_ROW::GREATER , -1.0 , name );

				v.reset();
				v.setType( VariableTatico::V_DIAS_CONSECUTIVOS );
				v.setTurma( turma );
				v.setDisciplina( disciplina );
				v.setDia( dia );
				v.setCampus( *itCampus );	

				it_v = vHashTatico.find( v );
				if ( it_v != vHashTatico.end() )
				{
				   row.insert( it_v->second, 1.0 );
				}

				ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{
						int salaId = itCjtSala->salas.begin()->first;

						GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
							problemData->retornaHorariosEmComum( salaId, disciplina->getId(), dia );

						ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
						{
							HorarioAula *hi = *itHorario;

							ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
							{
								HorarioAula *hf = *itHorario;

								if ( hf < hi )
								{
							 		continue;
								}

								v.reset();
								v.setType( VariableTatico::V_CREDITOS );

								v.setTurma( turma );
								v.setDisciplina( disciplina );
								v.setUnidade( *itUnidade );
								v.setSubCjtSala( *itCjtSala );
								v.setHorarioAulaInicial( hi );
								v.setHorarioAulaFinal( hf );
								v.setDia( dia );

								it_v = vHashTatico.find( v );
								if ( it_v != vHashTatico.end() )
								{
									row.insert( it_v->second, -1.0 );
								}

								v.setDia( dia - 1 );

								it_v = vHashTatico.find( v );
								if ( it_v != vHashTatico.end() )
								{
									row.insert( it_v->second, -1.0 );
								}
							}
						}
					}
				}

				if ( row.getnnz() != 0 )
				{
				   cHashTatico[ c ] = lp->getNumRows();

				   lp->addRow( row );
				   restricoes++;
				}
			 }
		  }
	   }
	}
 
	return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Não permitir que alunos de cursos diferentes incompatíveis compartilhem turmas (*)
%Desc 

%MatExp

\begin{eqnarray} 
b_{i,d,c,cp} + b_{i,d,c',cp} \leq 1 \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall c,c' \notin CC \quad
\forall cp \in CP
\end{eqnarray}

%DocEnd
/====================================================================*/

/*
int SolverMIP::criaRestricaoTaticoCursosIncompat( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( it1Cursos, problemData->cursos, Curso )
		{
			Curso* c1 = *it1Cursos;
			
			if ( itCampus->cursos.find( c1 ) == itCampus->cursos.end() )
			{
				continue;
			}

			ITERA_GGROUP_INIC_LESSPTR( it2Cursos, it1Cursos, problemData->cursos, Curso )
			{
				Curso* c2 = *it2Cursos;
			    
				if ( itCampus->cursos.find( c2 ) == itCampus->cursos.end() )
				{
					continue;
				}
				if ( problemData->cursosCompativeis(c1, c2) )
				{
					continue;
				}

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					// A disciplina deve ser ofertada no campus especificado
					if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
						 problemData->cp_discs[campusId].end() )
					{
						continue;
					}

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion	
										
					if ( !c1->possuiDisciplina(disciplina) || !c2->possuiDisciplina(disciplina) )
						continue;
					

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						c.reset();
						c.setType( ConstraintTatico::C_ALUNOS_CURSOS_INCOMP );
						c.setCampus( *itCampus );
						c.setParCursos( std::make_pair( c1, c2 ) );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHashTatico.find( c ) != cHashTatico.end() )
						{
							continue;
						}

						nnz = 3;

						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

						v.reset();
						v.setType( VariableTatico::V_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c1 );
						v.setCampus( *itCampus );

						it_v = vHashTatico.find( v );
						if( it_v != vHashTatico.end() )
						{
							row.insert( it_v->second, 1 );
						}

						v.reset();
						v.setType( VariableTatico::V_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c2 );
						v.setCampus( *itCampus );

						it_v = vHashTatico.find( v );
						if( it_v != vHashTatico.end() )
						{
							row.insert(it_v->second, 1);
						}

						if ( row.getnnz() != 0 )
						{
							cHashTatico[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}
   }

   return restricoes;
}
*/

// Restricao 1.2.11
/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Não permitir que alunos de cursos diferentes (mesmo que compativeis) compartilhem turmas.
%Desc 

%MatExp

\begin{eqnarray} 
b_{i,d,c,cp} + b_{i,d,c',cp} - fc_{i,d,c,c',cp} \leq 1 \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall c,c' C \quad
\forall cp \in CP
\end{eqnarray}

%DocEnd

/====================================================================*/
/*
int SolverMIP::criaRestricaoTaticoProibeCompartilhamento( int campusId )
{
   int restricoes = 0;

   if ( problemData->parametros->permite_compartilhamento_turma_sel )
   {
	   return restricoes;
   }

   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

	   std::map< std::pair< Curso *, Curso * >, std::vector< int > >::iterator
               it_cursoComp_disc = problemData->cursosComp_disc.begin();

        for (; it_cursoComp_disc != problemData->cursosComp_disc.end(); it_cursoComp_disc++ )
        {
			Curso *c1 = it_cursoComp_disc->first.first;
			Curso *c2 = it_cursoComp_disc->first.second;

			if ( itCampus->cursos.find( c1 ) == itCampus->cursos.end() ||
				 itCampus->cursos.find( c2 ) == itCampus->cursos.end() )
			{
				continue;
			}

            std::vector< int >::iterator it_disc = it_cursoComp_disc->second.begin();

            for (; it_disc != it_cursoComp_disc->second.end(); ++it_disc )
            {
				int discId = *it_disc;
				Disciplina * disciplina = problemData->retornaDisciplina(discId);
				  
				if (disciplina == NULL) continue;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
					c.reset();
					c.setType( ConstraintTatico::C_PROIBE_COMPARTILHAMENTO );
					c.setCampus( *itCampus );
					c.setParCursos( std::make_pair( c1, c2 ) );
					c.setDisciplina( disciplina );
					c.setTurma( turma );

					sprintf( name, "%s", c.toString().c_str() ); 

					if ( cHash.find( c ) != cHash.end() )
					{
						continue;
					}

					nnz = 3;

					OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

					v.reset();
					v.setType( VariableTatico::V_ALOC_ALUNO );
					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setCurso( c1 );
					v.setCampus( *itCampus );

					it_v = vHashTatico.find( v );
					if( it_v != vHashTatico.end() )
					{
						row.insert( it_v->second, 1 );
					}

					v.reset();
					v.setType( VariableTatico::V_ALOC_ALUNO );
					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setCurso( c2 );
					v.setCampus( *itCampus );

					it_v = vHashTatico.find( v );
					if( it_v != vHashTatico.end() )
					{
						row.insert(it_v->second, 1);
					}

					v.reset();
					v.setType( VariableTatico::V_SLACK_COMPARTILHAMENTO );
					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setParCursos( std::make_pair( c1, c2 ) );
					v.setCampus( *itCampus );

					it_v = vHashTatico.find( v );
					if ( it_v != vHashTatico.end() )
					{
						row.insert( it_v->second, -1 );
					}

					if ( row.getnnz() != 0 )
					{
						cHashTatico[ c ] = lp->getNumRows();
						lp->addRow( row );
						restricoes++;
					}
				}
			}
		}
   }

   return restricoes;
}
*/

// Restricao 1.2.12
int SolverMIP::criaRestricaoTaticoLimitaAberturaTurmas( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
	
   int nnz;
   char name[ 100 ];

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   int minAlunos;
   if ( problemData->parametros->min_alunos_abertura_turmas )
   {
	    minAlunos = problemData->parametros->min_alunos_abertura_turmas_value;
		if ( minAlunos <= 0 ) minAlunos = 1;
   }
   else
   {
	   minAlunos = 1;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			 continue;
		 }
		
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			 continue;
		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( ConstraintTatico::C_LIMITA_ABERTURA_TURMAS );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );

            if ( cHashTatico.find( c ) != cHashTatico.end() )
            {
               continue;
            }

            nnz = ( itCampus->getTotalSalas() * 7 );

            OPT_ROW row( nnz + 1, OPT_ROW::LESS , 0 , name );

            v.reset();
            v.setType( VariableTatico::V_CREDITOS );

            // Insere variaveis Credito (x) ---

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
				   if ( itCjtSala->disciplinas_associadas.find( disciplina) ==
					    itCjtSala->disciplinas_associadas.end() )
				   {
					   continue;
				   }
				   
				   int salaId = itCjtSala->salas.begin()->first;
					
				   ITERA_GGROUP_N_PT ( it_Dia, itCjtSala->dias_letivos_disciplinas[disciplina], int )
				   {
						int dia = *it_Dia;

						GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
							problemData->retornaHorariosEmComum( salaId, disciplina->getId(), dia );
					  
						ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
						{
							HorarioAula *hi = *itHorario;

							ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
							{
									HorarioAula *hf = *itHorario;

									if ( hf < hi )
									{
							 			continue;
									}
																		
									v.setTurma( turma );
									v.setDisciplina( disciplina );
									v.setUnidade( *itUnidade );
									v.setSubCjtSala( *itCjtSala );
									v.setDia( dia );                   
									v.setHorarioAulaInicial( hi );	 // hi
									v.setHorarioAulaFinal( hf );	 // hf

									it_v = vHashTatico.find( v );
									if( it_v != vHashTatico.end() )
									{
										row.insert( it_v->second, -1.0 );
									}
							}
						}
					}                  
                }
            }

            // Insere variaveis Abertura (z) ---

            v.reset();
            v.setType( VariableTatico::V_ABERTURA );

            v.setCampus( *itCampus );
            v.setDisciplina( disciplina );
            v.setTurma( turma );

            it_v = vHashTatico.find( v );
            if( it_v != vHashTatico.end() )
            {
               row.insert( it_v->second, minAlunos );
            }

            // Insere restrição no Hash ---

            if ( row.getnnz() != 0 )
            {
               cHashTatico[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

	return restricoes;
}


// Restricao 1.2.12
/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Abertura sequencial de turmas
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{u \in U_{cp}} \sum\limits_{s \in S_{u}} \sum\limits_{t \in T} \sum\limits_{hi \in H} \sum\limits_{hf \in H} x_{i,d,u,s,hi,hf,t} 
\geq \sum\limits_{u \in U_{cp}} \sum\limits_{s \in S_{u}} \sum\limits_{t \in T} \sum\limits_{hi \in H} \sum\limits_{hf \in H} x_{i',d,u,s,hi,hf,t}
\nonumber \qquad 

\forall cp \in CP \quad
\forall d \in D \quad
\forall i,i' \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/
/*
int SolverMIP::criaRestricaoTaticoAbreTurmasEmSequencia( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

      if ( disciplina->getNumTurmas() > 1 )
      {
         for ( int turma = 0; turma < ( disciplina->getNumTurmas() - 1 ); turma++ )
         {
            c.reset();
            c.setType( ConstraintTatico::C_ABRE_TURMAS_EM_SEQUENCIA );

			c.setCampus( problemData->refCampus[campusId] );
            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() ); 
            if ( cHashTatico.find( c ) != cHashTatico.end() )
            {
               continue;
            }

            nnz = 9999;
            OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0, name );

            ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
            {
				if ( itCampus->getId() != campusId )
				{
					continue;
				}

                ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
                {
                    ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                    {
						  int salaId = itCjtSala->salas.begin()->first;
                      
						  GGroup< int > disc_sala_dias = problemData->disc_Conjutno_Salas__Dias[ std::make_pair<int,int>
																		( disciplina->getId(), itCjtSala->getId() ) ];

						  ITERA_GGROUP_N_PT( itDia, disc_sala_dias, int )
						  {
								int dia = *itDia;

								GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
									problemData->retornaHorariosEmComum( salaId, disciplina->getId(), dia );

								ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
								{
									HorarioAula *hi = *itHorario;

									ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
									{
										HorarioAula *hf = *itHorario;

										if ( hf < hi )
										{
							 				continue;
										}

										v.reset();
										v.setType( VariableTatico::V_CREDITOS );

										v.setTurma( turma );
										v.setDisciplina( disciplina );
										v.setUnidade( *itUnidade );
										v.setSubCjtSala( *itCjtSala );
										v.setHorarioAulaInicial( hi );
										v.setHorarioAulaFinal( hf );
										v.setDia( dia );

										it_v = vHashTatico.find( v );
										if ( it_v != vHashTatico.end() )
										{
											row.insert( it_v->second, 1.0 );
										}

										v.reset();
										v.setType( VariableTatico::V_CREDITOS );

										int proxTurma = turma + 1;
										v.setTurma(proxTurma);

										v.setDisciplina( disciplina );
										v.setUnidade( *itUnidade );
										v.setSubCjtSala( *itCjtSala );
										v.setHorarioAulaInicial( hi );
										v.setHorarioAulaFinal( hf );
										v.setDia( dia );

										it_v = vHashTatico.find( v );
										if ( it_v != vHashTatico.end() )
										{
											row.insert( it_v->second, -1.0 );
										}
									}
								}
							}
						}
				  }
            }

            if ( row.getnnz() != 0 )
            {
               cHashTatico[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

*/

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Regra de divisão de créditos
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{u \in U} \sum\limits_{s \in S_{u}} \sum\limits_{hi \in H} \sum\limits_{hf \in H} x_{i,d,u,s,hi,hf,t} = 
 \sum\limits_{k \in K_{d}}N_{d,k,t} \cdot m_{d,i,k} + fkp_{d,i,t} - fkm_{d,i,t} \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall t \in T
\end{eqnarray}

%Data N_{d,k,t}
%Desc
número de créditos determinados para a disciplina $d$ no dia $t$ na combinação de divisão de crédito $k$.

%DocEnd
/====================================================================*/

int SolverMIP::criaRestricaoTaticoDivisaoCredito( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );
	  
	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

	  if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
		  continue;
		 
	  if ( disciplina->divisao_creditos.size() != 0 )
      {
         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            ITERA_GGROUP_N_PT( itDiasLetDisc, disciplina->diasLetivos, int )
            {
				int dia = *itDiasLetDisc;

                c.reset();
                c.setType( ConstraintTatico::C_DIVISAO_CREDITO );

                c.setDisciplina( disciplina );
                c.setTurma( turma );
                c.setDia( dia );

                sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 

                if ( cHashTatico.find( c ) != cHashTatico.end() )
                {
                   continue;
                }

                nnz = ( problemData->totalSalas + ( (int)( disciplina->combinacao_divisao_creditos.size() ) * 2 ) );
                OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

                ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
                {
				   if ( itCampus->getId() != campusId )
				   {
					    continue;
				   }

                   ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
                   {
                       ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                       {
						   int salaId = itCjtSala->salas.begin()->first;

							GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
								problemData->retornaHorariosEmComum( salaId, disciplina->getId(), dia );

							ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
							{
								HorarioAula *hi = *itHorario;

								ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
								{
									HorarioAula *hf = *itHorario;

									if ( *hf < *hi )
									{
							 			continue;
									}

									v.reset();
									v.setType( VariableTatico::V_CREDITOS );

									v.setTurma( turma );
									v.setDisciplina( disciplina );
									v.setUnidade( *itUnidade );
									v.setSubCjtSala( *itCjtSala );
									v.setHorarioAulaInicial( hi );
									v.setHorarioAulaFinal( hf );
									v.setDia( *itDiasLetDisc );

									int nCreds = disciplina->getCalendario()->retornaNroCreditosEntreHorarios(hi,hf);
									
									it_v = vHashTatico.find( v );
									if ( it_v != vHashTatico.end() )
									{
									   row.insert( it_v->second, nCreds );
									}
								}
							}
                        }
                    }
                }

				for ( int k = 0; k < (int)disciplina->combinacao_divisao_creditos.size(); k++ )
				{	
					v.reset();
					v.setType( VariableTatico::V_COMBINACAO_DIVISAO_CREDITO );

					v.setDisciplina( disciplina );
					v.setTurma( turma );
					v.setK( k );
					
					// N{d,k,t}
					int numCreditos = ( disciplina->combinacao_divisao_creditos[ k ] )[ dia - 2 ].second;

					it_v = vHashTatico.find( v );
					if ( it_v != vHashTatico.end() )
					{
						row.insert( it_v->second, -numCreditos );
					}

					v.reset();
					v.setType( VariableTatico::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M );

					v.setDisciplina( disciplina );
					v.setTurma( turma );
					v.setDia( dia );

					it_v = vHashTatico.find( v );
					if( it_v != vHashTatico.end() )
					{
						row.insert( it_v->second, 1.0 );
					}

					v.reset();
					v.setType( VariableTatico::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P );

					v.setDisciplina( disciplina );
					v.setTurma( turma );
					v.setDia( dia );

					it_v = vHashTatico.find( v );
					if( it_v != vHashTatico.end() )
					{
						row.insert( it_v->second, -1.0 );
					}
				}

                if ( row.getnnz() != 0 )
                {
                   cHashTatico[ c ] = lp->getNumRows();

                   lp->addRow( row );
                   restricoes++;
                }
            }
         }
      }
   }

   return restricoes;
}


// Restricao 1.2.15
/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Somente uma combinação de regra de divisão de créditos pode ser escolhida
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{k \in K_{d}} m_{d,i,k} \leq 1 \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/
int SolverMIP::criaRestricaoTaticoCombinacaoDivisaoCredito( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

	  if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
		  continue;
		 

      for ( int i = 0; i < disciplina->getNumTurmas(); i++ )
      {
         c.reset();
         c.setType( ConstraintTatico::C_COMBINACAO_DIVISAO_CREDITO );

         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 

         if ( cHashTatico.find( c ) != cHashTatico.end() )
         {
            continue;
         }

         nnz = (int)( disciplina->combinacao_divisao_creditos.size() );
         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

         for ( int k = 0; k < (int)disciplina->combinacao_divisao_creditos.size(); k++ )
         {
            v.reset();
            v.setType( VariableTatico::V_COMBINACAO_DIVISAO_CREDITO );

            v.setTurma( i );
            v.setDisciplina( disciplina );
            v.setK( k );

            it_v = vHashTatico.find( v );

            if ( it_v != vHashTatico.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         if ( row.getnnz() != 0 )
         {
            cHashTatico[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}


// Restricao 1.2.16
/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável zc
%Desc

%MatExp
\begin{eqnarray}
\sum\limits_{i \in I} \sum\limits_{u \in U} \sum\limits_{s \in S_{u}} \sum\limits_{hi \in H} \sum\limits_{hf \in H}
  x_{i,d,u,s,hi,hf,t} \leq zc_{d,t} \cdot N \nonumber \qquad 
\forall cp \in CP \quad
\forall d \in D \quad
\forall t \in T
\end{eqnarray}


%DocEnd
/====================================================================*/
int SolverMIP::criaRestricaoTaticoAtivacaoVarZC( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

	   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
	   {
		  disciplina = ( *it_disciplina );
	  
		  // A disciplina deve ser ofertada no campus especificado
		  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
				problemData->cp_discs[campusId].end() )
 		  {
			  continue;
		  }

		  #pragma region Equivalencias
		  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				 problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		  {
			   continue;
		  }
		  #pragma endregion

		  if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			   continue;
		 
		  GGroup< int >::iterator itDiasLetDisc = disciplina->diasLetivos.begin();

		  for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
		  {
             int dia = *itDiasLetDisc;

			 c.reset();
			 c.setType( ConstraintTatico::C_VAR_ZC );

			 c.setCampus( *itCampus );
			 c.setDisciplina( disciplina );
			 c.setDia( dia );

			 sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 
			 if ( cHashTatico.find( c ) != cHashTatico.end() )
			 {
				continue;
			 }

			 nnz = 100;

			 OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );
 
			 ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
			 {
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{
					int salaId = itCjtSala->salas.begin()->first;

					GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
						problemData->retornaHorariosEmComum( salaId, disciplina->getId(), dia );

					ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
					{
						HorarioAula *hi = *itHorario;

						ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
						{
							HorarioAula *hf = *itHorario;

							if ( hf < hi )
							{
							 	continue;
							}

							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								v.reset();
								v.setType( VariableTatico::V_CREDITOS );

								v.setTurma( turma );
								v.setDisciplina( disciplina );
								v.setUnidade( *itUnidade );
								v.setSubCjtSala( *itCjtSala );
								v.setHorarioAulaInicial( hi );
								v.setHorarioAulaFinal( hf );
								v.setDia( dia );

								it_v = vHashTatico.find( v );
								if ( it_v != vHashTatico.end() )
								{
									row.insert( it_v->second, 1.0 );
								}
							}
						}
					}
				}
			 }

			 v.reset();
			 v.setType( VariableTatico::V_ABERTURA_COMPATIVEL );

			 v.setDisciplina( disciplina );
			 v.setDia( *itDiasLetDisc );
			 v.setCampus( *itCampus );

			 it_v = vHashTatico.find( v );
			 if ( it_v != vHashTatico.end() )
			 {
				 row.insert( it_v->second, - disciplina->getNumTurmas() );
			 }

			 if ( row.getnnz() != 0 )
			 {
				cHashTatico[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			 }
		  }
	   }
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Disciplinas incompatíveis
%Desc

%MatExp
\begin{eqnarray}
zc_{d_1,t} + zc_{d_2,t} \leq 1 \nonumber \qquad 
(d_1, d_2),
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::criaRestricaoTaticoDisciplinasIncompativeis( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus *campus = problemData->refCampus[campusId];
   
   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );
	  
	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		   continue;
	  }
	  #pragma endregion

	  if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			 continue;		

      ITERA_GGROUP_N_PT( itDiasLetDisc, disciplina->diasLetivos, int )
      {
         ITERA_GGROUP_N_PT( it_inc, disciplina->ids_disciplinas_incompativeis, int )
         {
			std::map< int, Disciplina* >::iterator it_Ref_Disc = problemData->refDisciplinas.find( *it_inc );
			if ( it_Ref_Disc == problemData->refDisciplinas.end() )
			{ 
				continue;
			}
			
			Disciplina * nova_disc = it_Ref_Disc->second;

			// A disciplina deve ser ofertada no campus especificado
			if ( problemData->cp_discs[campusId].find( nova_disc->getId() ) ==
				problemData->cp_discs[campusId].end() )
 			{
				continue;
			}

			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( nova_disc ) !=
				   problemData->mapDiscSubstituidaPor.end() ) &&
				  !problemData->ehSubstituta( nova_disc ) )
			{
				continue;
			}
			#pragma endregion

            c.reset();
            c.setType( ConstraintTatico::C_DISC_INCOMPATIVEIS );
			c.setParDisciplinas( std::make_pair( nova_disc, disciplina ) );
			c.setCampus( campus );
			c.setDia( *itDiasLetDisc );

            sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 

            if ( cHashTatico.find( c ) != cHashTatico.end() )
            {
               continue;
            }

            nnz = 2;
            OPT_ROW row( nnz, OPT_ROW::LESS, 1.0, name );

            v.reset();
            v.setType( VariableTatico::V_ABERTURA_COMPATIVEL );

            v.setDisciplina( disciplina );
            v.setDia( *itDiasLetDisc );
			v.setCampus( campus );

            it_v = vHashTatico.find( v );
            if ( it_v != vHashTatico.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            v.setDisciplina( nova_disc );

            it_v = vHashTatico.find( v );
			if ( it_v != vHashTatico.end() )
            {
               row.insert(it_v->second, 1.0);
            }

            if ( row.getnnz() != 0 )
            {
               cHashTatico[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }

         }
      }
   }

   return restricoes;
}

// Restricao 1.2.18
/*
int SolverMIP::criaRestricaoTaticoUnicaSalaParaTurmaDisc( int campusId )
{
   int restricoes = 0;

   int nnz;
   char name[ 100 ];

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			 continue;
		 }

		 #pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( ConstraintTatico::C_TURMA_SALA );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHashTatico.find( c ) != cHashTatico.end() )
            {
               continue;
            }

            nnz = ( itCampus->getTotalSalas() * 7 );

            OPT_ROW row( nnz, OPT_ROW::LESS, 1, name );

            v.reset();
            v.setType( VariableTatico::V_CREDITOS );

            // Insere variaveis Credito (x) ---

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
				   if ( itCjtSala->disciplinas_associadas.find( disciplina) ==
					    itCjtSala->disciplinas_associadas.end() )
				   {
					   continue;
				   }
				   
				   int salaId = itCjtSala->salas.begin()->first;
					
				   ITERA_GGROUP_N_PT ( it_Dia, itCjtSala->dias_letivos_disciplinas[disciplina], int )
				   {
						int dia = *it_Dia;

						GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
							problemData->retornaHorariosEmComum( salaId, disciplina->getId(), dia );
					  
						ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
						{
							HorarioAula *hi = *itHorario;

							ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
							{
								HorarioAula *hf = *itHorario;

								if ( hf < hi )
								{
							 		continue;
								}
																		
								v.setTurma( turma );
								v.setDisciplina( disciplina );
								v.setUnidade( *itUnidade );
								v.setSubCjtSala( *itCjtSala );
								v.setDia( dia );                   
								v.setHorarioAulaInicial( hi );	 // hi
								v.setHorarioAulaFinal( hf );	 // hf

								it_v = vHashTatico.find( v );
								if( it_v != vHashTatico.end() )
								{
									row.insert( it_v->second, 1.0 );
								}
							}
						}
					}                  
                }
            }

            // Insere restrição no Hash ---

            if ( row.getnnz() != 0 )
            {
               cHashTatico[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

	return restricoes;
}
*/


/*
	Impede a alocação de aulas que compartilham alunos em horários com sobreposição.
	Para cada dia t, horário h, e pares de turmas/disciplinas (i1,d1) e (i2,d2) que compartilham alunos:

	sum[u] sum[s] sum[hi] sum[hf] x_{i,d,u,s,hi,hf,t} <= 1

	sendo (i,d) = (i1,d1) ou (i,d) = (i2,d2)
	(hi,hf) sobrepõe o inicio de h
*/

int SolverMIP::criaRestricaoTaticoEvitaSobreposicaoAulaAluno( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintTatico c;
   ConstraintTaticoHash::iterator cit;
      
   Campus *campus = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	    if ( itCampus->getId() != campusId )
			continue;

		campus = *itCampus;
		break;
   }

   if(!campus)
	   return 0;

   std::map<Trio<int,Disciplina*,int>,std::list<VariableTaticoHash::iterator> > varsDiaDiscTurma;

   VariableTaticoHash::iterator vit;
   vit = vHashTatico.begin();
   while(vit != vHashTatico.end())
   {
      if(vit->first.getType() == VariableTatico::V_CREDITOS)
      {
         VariableTatico v = vit->first;

         Trio<int,Disciplina*,int> auxTrio(v.getDia(),v.getDisciplina(),v.getTurma());

         varsDiaDiscTurma[auxTrio].push_back(vit);
      }
      vit++;
   }

   GGroup< int > disciplinasIds = problemData->cp_discs[campusId];

   // Disciplina 1
   ITERA_GGROUP_N_PT( itDisc1, disciplinasIds, int )
   {
      Disciplina *disc1 = problemData->refDisciplinas[ *itDisc1 ];

      if ( ! problemData->haDemandaDiscNoCampus( disc1->getId(), campusId ) )
         continue;

      // Disciplina 2
      ITERA_GGROUP_INIC_N_PT( itDisc2, itDisc1, disciplinasIds, int )
      {
         if ( itDisc2 == itDisc1 )
            continue;

         Disciplina *disc2 = problemData->refDisciplinas[ *itDisc2 ];

         if ( ! problemData->haDemandaDiscNoCampus( disc2->getId(), campusId ) )
            continue;

         // Turma 1
         for ( int turma1 = 0; turma1 < disc1->getNumTurmas(); turma1++ )
         {
            // Turma 2
            for ( int turma2 = 0; turma2 < disc2->getNumTurmas(); turma2++ )
            {
				    // Restrição só para as turmas com alunos em comum
				    GGroup<Aluno*> alunosEmComum = problemData->alunosEmComum( turma1, disc1, turma2, disc2, campus );
					int nAlunosComuns = alunosEmComum.size();

				    if ( nAlunosComuns == 0 )
					{
					    continue;
					}

					// Para cada dia em comum das disciplinas
					ITERA_GGROUP_N_PT( itDia, disc1->diasLetivos, int )
					{
						int dia = *itDia;

						if ( disc2->diasLetivos.find( dia ) ==
							 disc2->diasLetivos.end() )			
						{
							continue;
						}

						// Acha a união dos horarios das duas disciplinas
						GGroup< HorarioAula* > horarios;
						ITERA_GGROUP( itHorDia1, disc1->horariosDia, HorarioDia )
						{
							if ( itHorDia1->getDia() == dia )
							{
								horarios.add( itHorDia1->getHorarioAula() );
							}
						}
						ITERA_GGROUP( itHorDia2, disc2->horariosDia, HorarioDia )
						{
							if ( itHorDia2->getDia() == dia )
							{
								horarios.add( itHorDia2->getHorarioAula() );			
							}
						}

						// Para cada horario
						ITERA_GGROUP( itHor, horarios, HorarioAula )
						{
							HorarioAula* h = *itHor;			
						
							// Seleciona variaveis
                     Trio<int,Disciplina*,int> auxTrio(dia,disc1,turma1);

							std::list<VariableTaticoHash::iterator>::iterator lit;
							lit = varsDiaDiscTurma[auxTrio].begin();
							while(lit != varsDiaDiscTurma[auxTrio].end())
							{
                        VariableTaticoHash::iterator vit = *lit;
                        VariableTatico v = vit->first;
								
                        HorarioAula *hi = v.getHorarioAulaInicial();
                        HorarioAula *hf = v.getHorarioAulaFinal();

                        DateTime inicio = hi->getInicio();
                        DateTime fim = hf->getInicio();
                        fim.addMinutes( hf->getTempoAula() );

                        // ---- Só insere variaveis com horarios (hi,hf) que possuem interseção com h

                        if ( ( inicio <= h->getInicio() ) && ( fim > h->getInicio() ) )
                        {
                           c.reset();
                           c.setType( ConstraintTatico::C_EVITA_SOBREPOSICAO_TURMA_DISC_ALUNO );
                           c.setCampus( campus );
                           c.setDia( dia );
                           c.setHorarioAula( h );
                           c.setDisciplina1( disc1 );
                           c.setDisciplina2( disc2 );
                           c.setTurma1( turma1 );
                           c.setTurma2( turma2 );

                           cit = cHashTatico.find(c);
                           if(cit == cHashTatico.end())
                           {
                              int nnz = 5; // estima numero de horarios

                              sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
                              OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

                              row.insert( vit->second, 1.0 );

                              cHashTatico[ c ] = lp->getNumRows();

                              lp->addRow( row );
                              restricoes++;
                           }
                           else
                           {
                              lp->chgCoef(cit->second, vit->second, 1.0);
                           }
                        }									

								lit++;
							}

                     // Seleciona variaveis
                     Trio<int,Disciplina*,int> auxTrio2(dia,disc2,turma2);

							lit = varsDiaDiscTurma[auxTrio2].begin();
							while(lit != varsDiaDiscTurma[auxTrio2].end())
							{
                        VariableTaticoHash::iterator vit = *lit;
                        VariableTatico v = vit->first;
								
                        HorarioAula *hi = v.getHorarioAulaInicial();
                        HorarioAula *hf = v.getHorarioAulaFinal();

                        DateTime inicio = hi->getInicio();
                        DateTime fim = hf->getInicio();
                        fim.addMinutes( hf->getTempoAula() );

                        // ---- Só insere variaveis com horarios (hi,hf) que possuem interseção com h

                        if ( ( inicio <= h->getInicio() ) && ( fim > h->getInicio() ) )
                        {
                           c.reset();
                           c.setType( ConstraintTatico::C_EVITA_SOBREPOSICAO_TURMA_DISC_ALUNO );
                           c.setCampus( campus );
                           c.setDia( dia );
                           c.setHorarioAula( h );
                           c.setDisciplina1( disc1 );
                           c.setDisciplina2( disc2 );
                           c.setTurma1( turma1 );
                           c.setTurma2( turma2 );

                           cit = cHashTatico.find(c);
                           if(cit == cHashTatico.end())
                           {
                              int nnz = 5; // estima numero de horarios

                              sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
                              OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

                              row.insert( vit->second, 1.0 );

                              cHashTatico[ c ] = lp->getNumRows();

                              lp->addRow( row );
                              restricoes++;
                           }
                           else
                           {
                              lp->chgCoef(cit->second, vit->second, 1.0);
                           }
                        }									

								lit++;
							}
						}
					}
			   }
		   }
	   }
   }

   return restricoes;

}

/*
	Impede a alocação de aulas de um aluno em horários com sobreposição.
	Para cada dia t, horário h, e aluno al:

	sum[u] sum[s] sum[hi] sum[hf] x_{i,d,u,s,hi,hf,t} <= 1

	sendo al alocado em (i,d) e	(hi,hf) sobrepõe o inicio de h
*/
int SolverMIP::criaRestricaoTaticoAlunoHorario( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintTatico c;
   VariableTaticoHash::iterator vit;
   ConstraintTaticoHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashTatico.begin();

   for (; vit != vHashTatico.end(); vit++ )
   {
		VariableTatico v = vit->first;

		if ( v.getType() != VariableTatico::V_CREDITOS )
		{
			continue;
		}

		Sala *sala = v.getSubCjtSala()->salas.begin()->second;
		ITERA_GGROUP_LESSPTRPTR( it_horario_dia, sala->horariosDia, HorarioDia )
		{
			HorarioDia * horario_dia = ( *it_horario_dia );

			int dia = horario_dia->getDia();

			if ( v.getDia() != dia )
				continue;

			HorarioAula * horario_aula = horario_dia->getHorarioAula();
			DateTime inicio = horario_aula->getInicio();
		
			DateTime vInicio = v.getHorarioAulaInicial()->getInicio();
			HorarioAula *horarioAulaFim = v.getHorarioAulaFinal();
			DateTime vFim = horarioAulaFim->getFinal();

			if ( !( ( vInicio <= inicio ) && ( vFim > inicio ) ) )
			{
				continue;
			}       
			
			int campusId = v.getUnidade()->getIdCampus();
			int turma = v.getTurma();
			Disciplina* disc = v.getDisciplina();
      
			std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator itMapAtend;

			Trio< int, int, Disciplina* > trio;
			trio.set( campusId, turma, disc );

			itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
			if ( itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
			{
				GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = (*itMapAtend).second;

				// Para cada aluno alocado na aula
				ITERA_GGROUP_LESSPTR( itAlunoDem, alunosDemanda, AlunoDemanda )
				{
					int alunoId = ( *itAlunoDem )->getAlunoId();
					Aluno *aluno = problemData->retornaAluno( alunoId );
					
					c.reset();
					c.setType( ConstraintTatico::C_ALUNO_HORARIO );
					c.setAluno( aluno );
					c.setDia( dia );
					c.setHorarioAula( horario_aula );

					cit = cHashTatico.find( c );

					if ( cit != cHashTatico.end() )
					{
						auxCoef.first = cit->second;
						auxCoef.second = vit->second;

						coeffList.push_back( auxCoef );
						coeffListVal.push_back( 1.0 );
					}
					else
					{
						sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
						nnz = 100;

						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

						row.insert( vit->second, 1.0 );
						cHashTatico[ c ] = lp->getNumRows();

						lp->addRow( row );
						restricoes++;
					}   
				} 
			}
       }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}


/*
	Impede a alocação de aulas de um aluno em horários com sobreposição.
	Para cada dia t, horários (hi,hf), aluno al e par (i,d) contendo o aluno al
	não atendido no tático anterior:

	sum[u] sum[s] x_{i,d,u,s,hi,hf,t} >= fad_{i,d,al,t,hi,hf}

*/
int SolverMIP::criaRestricaoTaticoDesalocaAlunoTurmaHorario( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintTatico c;
   VariableTaticoHash::iterator vit;
   ConstraintTaticoHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashTatico.begin();

   for (; vit != vHashTatico.end(); vit++ )
   {
		VariableTatico v = vit->first;

		if ( v.getType() != VariableTatico::V_CREDITOS )
		{
			continue;
		}

		int dia = v.getDia();	
		int campusId = v.getUnidade()->getIdCampus();
		int turma = v.getTurma();
		Disciplina* disc = v.getDisciplina();
		HorarioAula *hi = v.getHorarioAulaInicial();
		HorarioAula *hf = v.getHorarioAulaFinal();

		//DateTime vInicio = v.getHorarioAulaInicial()->getInicio();
		//DateTime vFim = horarioAulaFim->getFinal();

		Trio< int, int, Disciplina* > trio;
		trio.set( campusId, turma, disc );

		// FILTRANDO: SOMENTE AS TURMAS NÃO ATENDIDAS

		std::map< Trio< int, int, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator 
			itMapAtend = problemData->mapSlackCampusTurmaDisc_AlunosDemanda.find( trio );
		if ( itMapAtend == problemData->mapSlackCampusTurmaDisc_AlunosDemanda.end() )
		{
			continue;
		}

		//Sala *sala = v.getSubCjtSala()->salas.begin()->second;
		//ITERA_GGROUP_LESSPTRPTR( it_horario_dia, sala->horariosDia, HorarioDia )
		//{
		//	HorarioDia * horario_dia = ( *it_horario_dia );

		//	int dia = horario_dia->getDia();

		//	if ( v.getDia() != dia )
		//		continue;

		//	HorarioAula * horario_aula = horario_dia->getHorarioAula();
		//	DateTime inicio = horario_aula->getInicio();
		//	
		//	if ( !( ( vInicio <= inicio ) && ( vFim > inicio ) ) )
		//	{
		//		continue;
		//	} 
      						
			itMapAtend = problemData->mapSlackCampusTurmaDisc_AlunosDemanda.find( trio );
			if ( itMapAtend != problemData->mapSlackCampusTurmaDisc_AlunosDemanda.end() )
			{
				GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = (*itMapAtend).second;

				// Para cada aluno alocado na aula, não atendido
				ITERA_GGROUP_LESSPTR( itAlunoDem, alunosDemanda, AlunoDemanda )
				{
					int alunoId = ( *itAlunoDem )->getAlunoId();
					Aluno *aluno = problemData->retornaAluno( alunoId );
					
					c.reset();
					c.setType( ConstraintTatico::C_DESALOCA_ALUNO_TURMA );
					c.setAluno( aluno );
					c.setDia( dia );
					c.setHorarioAulaInicial( hi );
					c.setHorarioAulaFinal( hf );
					c.setTurma( turma );
					c.setDisciplina( disc );

					cit = cHashTatico.find( c );

					if ( cit != cHashTatico.end() )
					{
						auxCoef.first = cit->second;
						auxCoef.second = vit->second;

						coeffList.push_back( auxCoef );
						coeffListVal.push_back( 1.0 );
					}
					else
					{
						sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
						nnz = 100;
						OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0, name );
						
						// insere x
						row.insert( vit->second, 1.0 );

						// insere folga fad_{i,d,a,t,hi,hf} para permitir desalocar o aluno
						VariableTatico v_fa;
						v_fa.reset();
						v_fa.setType( VariableTatico::V_DESALOCA_ALUNO_DIA );
						v_fa.setAluno( aluno );
						v_fa.setTurma( turma );
						v_fa.setDisciplina( disc );
						v_fa.setDia( dia );
						v_fa.setHorarioAulaInicial( hi );
						v_fa.setHorarioAulaFinal( hf );

						VariableTaticoHash::iterator it_v;
						it_v = vHashTatico.find( v_fa );
						if( it_v != vHashTatico.end() )
						{
							row.insert( it_v->second, -1.0 ); // insere fad_{i,d,a,t,hi,hf}
						}
						else
							std::cout<<"\nErro! Algo estranho aqui, acho que a variavel fad deveria existir.\n";

						// Insere restrição
						cHashTatico[ c ] = lp->getNumRows();
						lp->addRow( row );
						restricoes++;
					}   
				} 
			}
       //}
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

/*
	Impede a alocação de aulas de um aluno em horários com sobreposição.
	Para cada dia t, horário h, e aluno al:

	sum[i]sum[d]sum[u]sum[s]sum[hi]sum[hf] x_{i,d,u,s,hi,hf,t} 
	- sum[i']sum[d']sum[hi]sum[hf] fad_{i',d',al,t,hi,hf} <= 1

	sendo (hi,hf) sobrepõe o inicio de h; (i,d) contendo o aluno al; e 
	(i',d') contendo o aluno al não atendido no tático anterior.
*/
int SolverMIP::criaRestricaoTaticoDesalocaAlunoHorario( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintTatico c;
   VariableTaticoHash::iterator vit;
   ConstraintTaticoHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashTatico.begin();

   for (; vit != vHashTatico.end(); vit++ )
   {
		VariableTatico v = vit->first;

		if ( v.getType() != VariableTatico::V_CREDITOS )
		{
			continue;
		}
			
		int campusId = v.getUnidade()->getIdCampus();
		int turma = v.getTurma();
		Disciplina* disc = v.getDisciplina();

		Trio< int, int, Disciplina* > trio;
		trio.set( campusId, turma, disc );

		HorarioAula *hi = v.getHorarioAulaInicial();
		DateTime vInicio = hi->getInicio();
		HorarioAula *hf = v.getHorarioAulaFinal();
		DateTime vFim = hf->getFinal();

		Sala *sala = v.getSubCjtSala()->salas.begin()->second;
		ITERA_GGROUP_LESSPTRPTR( it_horario_dia, sala->horariosDia, HorarioDia )
		{
			HorarioDia * horario_dia = ( *it_horario_dia );

			int dia = horario_dia->getDia();

			if ( v.getDia() != dia )
				continue;

			HorarioAula * horario_aula = horario_dia->getHorarioAula();
			DateTime inicio = horario_aula->getInicio();		

			if ( !( ( vInicio <= inicio ) && ( vFim > inicio ) ) )
			{
				continue;
			}
      
			std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, 
					  GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator itMapAtend;
						
			itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
			if ( itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
			{
				GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = (*itMapAtend).second;

				// Para cada aluno alocado na aula (atendida ou não)
				ITERA_GGROUP_LESSPTR( itAlunoDem, alunosDemanda, AlunoDemanda )
				{
					int alunoId = ( *itAlunoDem )->getAlunoId();
					Aluno *aluno = problemData->retornaAluno( alunoId );
					
					if ( !problemData->possuiNaoAtend(aluno) )
						continue;

					c.reset();
					c.setType( ConstraintTatico::C_DESALOCA_ALUNO_HORARIO );
					c.setAluno( aluno );
					c.setDia( dia );
					c.setHorarioAula( horario_aula );

					// variavel de folga fad_{i,d,a,t,hi,hf} para permitir desalocar o aluno
					VariableTatico v_fa;
					v_fa.reset();
					v_fa.setType( VariableTatico::V_DESALOCA_ALUNO_DIA );
					v_fa.setAluno( aluno );
					v_fa.setTurma( turma );
					v_fa.setDisciplina( disc );
					v_fa.setDia( dia );
					v_fa.setHorarioAulaInicial( hi );
					v_fa.setHorarioAulaFinal( hf );

					cit = cHashTatico.find( c );
					if ( cit != cHashTatico.end() )
					{
						// insere x
						auxCoef.first = cit->second;
						auxCoef.second = vit->second;
						coeffList.push_back( auxCoef );
						coeffListVal.push_back( 1.0 );

						// insere fad_{i,d,a,t,hi,hf}
						VariableTaticoHash::iterator it_v;
						it_v = vHashTatico.find( v_fa );
						if( it_v != vHashTatico.end() )
						{
							auxCoef.first = cit->second;
							auxCoef.second = it_v->second;
							coeffList.push_back( auxCoef );
							coeffListVal.push_back( -1.0 );						
						}
					}
					else
					{
						sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
						nnz = 100;
						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
						
						// insere x
						row.insert( vit->second, 1.0 );

						// insere fad_{i,d,a,t,hi,hf}
						VariableTaticoHash::iterator it_v;
						it_v = vHashTatico.find( v_fa );
						if( it_v != vHashTatico.end() )
						{
							row.insert( it_v->second, -1.0 );
						}

						// Insere restrição
						cHashTatico[ c ] = lp->getNumRows();
						lp->addRow( row );
						restricoes++;
					}   
				} 
			}
       }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

/*
	Para turma i, disciplina d, campus cp

	sum[a] fa_{i,d,a} <= ( nAlunos_{i,d,cp} - 1 ) * ( 1-fd_{i,d,cp} )

*/
int SolverMIP::criaRestricaoTaticoSumDesalocaAlunoFolgaDemanda( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintTatico c;
   VariableTaticoHash::iterator vit;
   ConstraintTaticoHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashTatico.begin();

   for (; vit != vHashTatico.end(); vit++ )
   {
		VariableTatico v = vit->first;

		if ( v.getType() != VariableTatico::V_DESALOCA_ALUNO &&
			 v.getType() != VariableTatico::V_SLACK_DEMANDA )
		{
			continue;
		}
		
		Campus *campus=NULL;

		if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO )
			campus = v.getAluno()->getOferta()->campus;
		else if ( v.getType() == VariableTatico::V_SLACK_DEMANDA )
			campus = v.getCampus();

		int turma = v.getTurma();
		Disciplina* disc = v.getDisciplina();
									
		c.reset();
		c.setType( ConstraintTatico::C_SUM_DESALOCA_ALUNOS_FOLGA_DEMANDA );
		c.setTurma( turma );
		c.setDisciplina( disc );
		c.setCampus( campus );

		cit = cHashTatico.find( c );

		if ( cit != cHashTatico.end() )
		{
			double coef;

			// insere folga fa_{i,d,a} para permitir desalocar o aluno
			if ( v.getType() == VariableTatico::V_SLACK_DEMANDA )
			{
				int nAlunos = problemData->existeTurmaDiscCampus( turma, disc->getId(), campus->getId() );
				coef = nAlunos-1;
			}

			// insere fd
			if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO )
				coef = 1.0;

			auxCoef.first = cit->second;
			auxCoef.second = vit->second;

			coeffList.push_back( auxCoef );
			coeffListVal.push_back( coef );
		}
		else
		{			
			int nAlunos = problemData->existeTurmaDiscCampus( turma, disc->getId(), campus->getId() );

			sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
			nnz = nAlunos+1;

			OPT_ROW row( nnz, OPT_ROW::LESS , nAlunos - 1, name );
						
			// insere fd
			if ( v.getType() == VariableTatico::V_SLACK_DEMANDA )
				row.insert( vit->second, nAlunos-1 );

			// insere folga fa_{i,d,a} para permitir desalocar o aluno
			if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO )
				row.insert( vit->second, 1.0 );

			// Insere restrição
			cHashTatico[ c ] = lp->getNumRows();
			lp->addRow( row );
			restricoes++;
		}
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

/*
	Para turma i, disciplina d, aluno a

	sum[hi]sum[hf]sum[t] fad_{i,d,a,t,hi,hf} <= 7*fa_{i,d,a}

*/
int SolverMIP::criaRestricaoTaticoSumDesalocaAluno( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintTatico c;
   VariableTaticoHash::iterator vit;
   ConstraintTaticoHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashTatico.begin();

   for (; vit != vHashTatico.end(); vit++ )
   {
		VariableTatico v = vit->first;

		if ( v.getType() != VariableTatico::V_DESALOCA_ALUNO &&
			 v.getType() != VariableTatico::V_DESALOCA_ALUNO_DIA )
		{
			continue;
		}
				
		int turma = v.getTurma();
		Disciplina* disc = v.getDisciplina();
		Aluno *aluno = v.getAluno();

		c.reset();
		c.setType( ConstraintTatico::C_SUM_DESALOCA_ALUNO );
		c.setTurma( turma );
		c.setDisciplina( disc );
		c.setAluno( aluno );

		cit = cHashTatico.find( c );

		if ( cit != cHashTatico.end() )
		{
			double coef;

			// insere fad
			if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO_DIA )
				coef = 1.0;

			// insere folga fa_{i,d,a} para permitir desalocar o aluno
			if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO )
			{
				int nAlunos = problemData->existeTurmaDiscCampus( turma, disc->getId(), aluno->getOferta()->getCampusId() );
				coef = -7.0;
			}

			auxCoef.first = cit->second;
			auxCoef.second = vit->second;

			coeffList.push_back( auxCoef );
			coeffListVal.push_back( coef );
		}
		else
		{			
			int nAlunos = problemData->existeTurmaDiscCampus( turma, disc->getId(), aluno->getOferta()->getCampusId() );

			sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
			nnz = nAlunos+1;

			OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );
						
			// insere fad
			if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO_DIA )
				row.insert( vit->second, 1.0 );

			// insere folga fa_{i,d,a} para permitir desalocar o aluno
			if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO )
				row.insert( vit->second, -7.0 );

			// Insere restrição
			cHashTatico[ c ] = lp->getNumRows();
			lp->addRow( row );
			restricoes++;
		}
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

/*
	Caso p==1 e r==1 (Não é permitido turmas violando min de alunos): 
	
		nAlunos_{i,d,cp} - sum[a] fa_{i,d,a} >= MinAlunos * z_{i,d,cp}	Para toda turma i, disciplina d, campus cp

	Caso p==1 e r==2 (É permitido turmas com formando violando min de alunos) e
	caso p==2 e r==1 (É permitido turmas com formando violando min de alunos) :

		nAlunos_{i,d,cp} - sum[a] fa_{i,d,a} >= MinAlunos * (z_{i,d,cp} - f_{i,d,cp})	Para toda turma i, disciplina d, campus cp

*/
int SolverMIP::criaRestricaoTaticoGaranteMinAlunosTurma( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   
   if ( !problemData->parametros->min_alunos_abertura_turmas )
   {
	   return restricoes;
   }

   int MinAlunos = problemData->parametros->min_alunos_abertura_turmas_value;
   if (MinAlunos<=0) MinAlunos=1;

   int nnz;
   char name[ 200 ];

   ConstraintTatico c;
   VariableTaticoHash::iterator vit;
   ConstraintTaticoHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashTatico.begin();

   for (; vit != vHashTatico.end(); vit++ )
   {
		VariableTatico v = vit->first;

		if ( v.getType() != VariableTatico::V_DESALOCA_ALUNO &&
			 v.getType() != VariableTatico::V_FORMANDOS_NA_TURMA &&
			 v.getType() != VariableTatico::V_ABERTURA )
		{
			continue;
		}

		Campus *campus;
		int turma = v.getTurma();
		Disciplina* disc = v.getDisciplina();

		if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO )
			campus = v.getAluno()->getOferta()->campus;
		else if ( v.getType() == VariableTatico::V_FORMANDOS_NA_TURMA )
			campus = v.getCampus();
		else if ( v.getType() == VariableTatico::V_ABERTURA )
			campus = v.getCampus();

		//if ( r==2 && problemData->parametros->violar_min_alunos_turmas_formandos )
		//if ( problemData->possuiAlunoFormando(turma,disc,campus) && fixada )
		//	continue;

		double coef=0;
		if ( v.getType() == VariableTatico::V_DESALOCA_ALUNO )
			coef = -1;
		else if ( v.getType() == VariableTatico::V_FORMANDOS_NA_TURMA )
			coef = MinAlunos;
		else if ( v.getType() == VariableTatico::V_ABERTURA )
			coef = -MinAlunos;

		c.reset();
		c.setType( ConstraintTatico::C_MIN_ALUNOS_TURMA );
		c.setTurma( turma );
		c.setDisciplina( disc );
		c.setCampus( campus );

		cit = cHashTatico.find( c );
		if ( cit != cHashTatico.end() )
		{
			auxCoef.first = cit->second;
			auxCoef.second = vit->second;

			coeffList.push_back( auxCoef );
			coeffListVal.push_back( coef );
		}
		else
		{			
			int nAlunosNaTurma = problemData->existeTurmaDiscCampus( turma, disc->getId(), campus->getId() );

			sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
			nnz = nAlunosNaTurma + 2;

			OPT_ROW row( nnz, OPT_ROW::GREATER , -nAlunosNaTurma, name );
						
			row.insert( vit->second, coef );

			// Insere restrição
			cHashTatico[ c ] = lp->getNumRows();
			lp->addRow( row );
			restricoes++;
		}
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

int SolverMIP::criaRestricaoTaticoDesalocaPT( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintTatico c;
   VariableTaticoHash::iterator vit;
   ConstraintTaticoHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashTatico.begin();

   for (; vit != vHashTatico.end(); vit++ )
   {
		VariableTatico v = vit->first;

		if ( v.getType() != VariableTatico::V_DESALOCA_ALUNO )
		{
			continue;
		}
		
		Aluno *aluno = v.getAluno();
		int turma = v.getTurma();
		Disciplina* disc = v.getDisciplina();

		int id_oposto = - disc->getId();

		if ( problemData->refDisciplinas.find(id_oposto) == problemData->refDisciplinas.end() )
			continue;

		Disciplina *discTeor;
		if ( id_oposto < 0 )
			discTeor = v.getDisciplina();
		else
			discTeor = problemData->refDisciplinas[id_oposto];

		double coef;
		if ( disc->getId() < 0 )
			coef = 1.0;
		else
			coef = -1.0;

		c.reset();
		c.setType( ConstraintTatico::C_DESALOCA_PT );		
		c.setDisciplina( discTeor );
		c.setAluno( aluno );

		cit = cHashTatico.find( c );
		if ( cit != cHashTatico.end() )
		{
			auxCoef.first = cit->second;
			auxCoef.second = vit->second;

			coeffList.push_back( auxCoef );
			coeffListVal.push_back( coef );
		}
		else
		{	
			sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
			nnz = 2;

			OPT_ROW row( nnz, OPT_ROW::EQUAL, 0, name );
						
			row.insert( vit->second, coef );

			// Insere restrição
			cHashTatico[ c ] = lp->getNumRows();
			lp->addRow( row );
			restricoes++;
		}
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

/*
	Seta a variavel f_{i,d,cp}, que indica se uma turma possui aluno formando. Só está sendo necessária em rodada 2
	(só a partir de r=2 pode ser permitida a violação do min de alunos por turma caso haja formando) do tatico 2 (aonde pode
	haver desalocações de alunos).

	Restrição 1: 
	
		M * f_{i,d,cp} >= nFormandos_{i,d,cp} * z_{i,d,cp} - sum[a] fa_{i,d,a}		Para cada turma i, disc d, campus cp

	Restrição 2: 
	
		f_{i,d,cp} <= nFormandos_{i,d,cp} * z_{i,d,cp} - sum[a] fa_{i,d,a}		Para cada turma i, disc d, campus cp
*/
int SolverMIP::criaRestricaoTaticoFormandos( int campusId, int prioridade, int r, int tatico )
{
    int restricoes = 0;

	if ( !problemData->parametros->min_alunos_abertura_turmas )
		return restricoes;	
	if ( !problemData->parametros->violar_min_alunos_turmas_formandos )
		return restricoes;		

	if ( !tatico==2 ) // só no tático 2 é que existe restrição de formandos
		return restricoes;
	if ( prioridade==1 && r==1 ) // só considera formandos a partir da segunda rodada
		return restricoes;
	
    char name[ 100 ];

    ConstraintTatico c;
	ConstraintTaticoHash::iterator cit;
    VariableTatico v;
    VariableTaticoHash::iterator vit;

	vit = vHashTatico.begin();

	for ( ; vit != vHashTatico.end(); vit++ )
	{
		// fa_{i,d,a}
		if( vit->first.getType() == VariableTatico::V_DESALOCA_ALUNO )
		{			
			VariableTatico v = vit->first;

			Aluno *aluno = v.getAluno();
			Disciplina *disciplina = v.getDisciplina();
			int turma = v.getTurma();
			Campus *campus = problemData->refCampus[ aluno->getCampusId() ];

			if ( !aluno->ehFormando() )
				continue;

			// -----------------------------------------
			// Constraint 1
		
			c.reset();
			c.setType( ConstraintTatico::C_FORMANDOS1 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashTatico.find(c);

			if(cit != cHashTatico.end())
			{
				lp->chgCoef(cit->second, vit->second, -1.0);
			}
			else
			{
				int nnz=20;
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::GREATER, 0.0, name );

				row.insert(vit->second, -1.0);

				cHashTatico[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}						
		
			// -----------------------------------------
			// Constraint 2
			
			c.reset();
			c.setType( ConstraintTatico::C_FORMANDOS2 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashTatico.find(c);

			if(cit != cHashTatico.end())
			{
				lp->chgCoef(cit->second, vit->second, -1.0);
			}
			else
			{
				int nnz=20;
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );

				row.insert(vit->second, -1.0);

				cHashTatico[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}
		}

		// f_{i,d,cp}
		else if( vit->first.getType() == VariableTatico::V_FORMANDOS_NA_TURMA )
		{			
			VariableTatico v = vit->first;

			Campus *campus = v.getCampus();
			Disciplina *disciplina = v.getDisciplina();
			int turma = v.getTurma();

			// -----------------------------------------
			// Constraint 1

			double M = problemData->getNroDemandaPorFormandos( disciplina, campus, prioridade );

			c.reset();
			c.setType( ConstraintTatico::C_FORMANDOS1 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashTatico.find(c);
			if(cit != cHashTatico.end())
			{
				lp->chgCoef(cit->second, vit->second, M);
			}
			else
			{
				int nnz=20;
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::GREATER, 0.0, name );

				row.insert(vit->second, M);

				cHashTatico[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}						
		
			// -----------------------------------------
			// Constraint 2
						
			c.reset();
			c.setType( ConstraintTatico::C_FORMANDOS2 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashTatico.find(c);

			if(cit != cHashTatico.end())
			{
				lp->chgCoef(cit->second, vit->second, 1.0);
			}
			else
			{
				int nnz=20;
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );

				row.insert(vit->second, 1.0);

				cHashTatico[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}		
		}
		// z_{i,d,cp}
		else if( vit->first.getType() == VariableTatico::V_ABERTURA )
		{			
			VariableTatico v = vit->first;

			Campus *campus = v.getCampus();
			Disciplina *disciplina = v.getDisciplina();
			int turma = v.getTurma();

			// -----------------------------------------
			// Constraint 1

			double nFormandos = problemData->getNroFormandos(turma,disciplina,campus);

			c.reset();
			c.setType( ConstraintTatico::C_FORMANDOS1 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashTatico.find(c);
			if(cit != cHashTatico.end())
			{
				lp->chgCoef(cit->second, vit->second, -nFormandos);
			}
			else
			{
				int nnz=20;
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::GREATER, 0.0, name );

				row.insert(vit->second, -nFormandos);

				cHashTatico[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}						
		
			// -----------------------------------------
			// Constraint 2
						
			c.reset();
			c.setType( ConstraintTatico::C_FORMANDOS2 );
			c.setDisciplina(disciplina);
			c.setTurma(turma);
			c.setCampus(campus);

			cit = cHashTatico.find(c);

			if(cit != cHashTatico.end())
			{
				lp->chgCoef(cit->second, vit->second, -nFormandos);
			}
			else
			{
				int nnz=20;
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() ); 
				OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );

				row.insert(vit->second, -nFormandos);

				cHashTatico[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}		
		}	
	}
	
	return restricoes;
}

int SolverMIP::criaRestricaoTaticoAtivaY( int campusId, int prioridade, int r, int tatico )
{
	int restricoes = 0;
	int nnz;
	char name[ 100 ];

	//VariableTatico v;
	ConstraintTatico c;
	//VariableTaticoHash::iterator it_v;
	ConstraintTaticoHash::iterator cit;

	//Disciplina * disciplina = NULL;

	Campus *campus = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
			continue;

		campus = *itCampus;
		break;
	}

	if(!campus)
		return 0;

	map< int, map< Disciplina*, set< Aluno *, LessPtr< Aluno > >, LessPtr< Disciplina > > > mapAlunos;

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;
		GGroup< Trio< int, int, Disciplina* > >::iterator itT = problemData->mapAluno_CampusTurmaDisc[ aluno ].begin();
		for(; itT != problemData->mapAluno_CampusTurmaDisc[ aluno ].end(); itT++)
		{
			Trio< int, int, Disciplina* > trio = *itT;
			if(trio.first != campusId)
				continue;

			mapAlunos[trio.second][trio.third].insert(aluno);
		}
	}


	VariableTaticoHash::iterator vit;

	vit = vHashTatico.begin();
	while(vit != vHashTatico.end())
	{
		if(vit->first.getType() != VariableTatico::V_CREDITOS && vit->first.getType() != VariableTatico::V_ALUNO_UNID_DIA)
		{
			vit++;
			continue;
		}

		VariableTatico v = vit->first;

		if(vit->first.getType() == VariableTatico::V_CREDITOS)
		{
			if(campus->unidades.find(v.getUnidade()) == campus->unidades.end())
			{
				vit++;
				continue;
			}

			set< Aluno *, LessPtr< Aluno > >::iterator itA = mapAlunos[v.getTurma()][v.getDisciplina()].begin();
			for(; itA != mapAlunos[v.getTurma()][v.getDisciplina()].end(); itA++)
			{
				Aluno *aluno = *itA;

				c.reset();
				c.setType( ConstraintTatico::C_ATIVA_Y );
				c.setCampus( campus );
				c.setAluno( aluno );
				c.setDia( v.getDia() );
				c.setUnidade( v.getUnidade() );

				cit = cHashTatico.find(c);
				if(cit == cHashTatico.end())
				{
					sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
					OPT_ROW row( 100, OPT_ROW::GREATER , 0 , name );

					row.insert( vit->second, -1.0 );

					cHashTatico[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
				else
				{
					lp->chgCoef(cit->second, vit->second, -1.0);
				}

			}
		}
		else
		{
			if(campus->unidades.find(v.getUnidade()) == campus->unidades.end())
			{
				vit++;
				continue;
			}

			c.reset();
			c.setType( ConstraintTatico::C_ATIVA_Y );
			c.setCampus( campus );
			c.setAluno( v.getAluno() );
			c.setDia( v.getDia() );
			c.setUnidade( v.getUnidade() );

			cit = cHashTatico.find(c);
			if(cit == cHashTatico.end())
			{
				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );
				OPT_ROW row( 100, OPT_ROW::GREATER , 0 , name );

				row.insert( vit->second, v.getAluno()->demandas.size() );

				cHashTatico[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}
			else
			{
				lp->chgCoef(cit->second, vit->second, v.getAluno()->demandas.size());
			}

		}

		vit++;
	}

	return restricoes;
}

   
int SolverMIP::criaRestricaoTaticoAlunoUnidadesDifDia( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 100 ];

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	    if ( itCampus->getId() != campusId )
	    {
			continue;
	    }

		ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
		{
			Aluno *aluno = *itAluno;
			
			ITERA_GGROUP_N_PT( itDia, itCampus->diasLetivos, int )
			{
				int dia = *itDia;

				// CONSTRAINT --------------------------------------

				c.reset();
				c.setType( ConstraintTatico::C_ALUNO_VARIAS_UNIDADES_DIA );

				c.setCampus( *itCampus );
				c.setAluno( aluno );
				c.setDia( dia );

				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );

				if ( cHashTatico.find( c ) != cHashTatico.end() )
				{
					continue;
				}

				nnz = ( itCampus->unidades.size() + 1 );

				OPT_ROW row( nnz, OPT_ROW::GREATER , -1.0 , name );

				ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				{
					// Insere variavel y_{a,u,t} -------------------------------------------------------								
					v.reset();
					v.setType( VariableTatico::V_ALUNO_UNID_DIA );

					v.setUnidade( *itUnidade ); // u
					v.setAluno( aluno );  // a
					v.setDia( dia );	  // t

					it_v = vHashTatico.find( v );
					if( it_v != vHashTatico.end() )
					{
						row.insert( it_v->second, -1.0 );
					}
				}

				// Insere variavel w_{a,t} -------------------------------------------------------								
				v.reset();
				v.setType( VariableTatico::V_ALUNO_VARIAS_UNID_DIA );

				v.setAluno( aluno );  // a
				v.setDia( dia );	  // t

				it_v = vHashTatico.find( v );
				if( it_v != vHashTatico.end() )
				{
					row.insert( it_v->second, itCampus->unidades.size() );
				}

				// Insere restrição no Hash --------------------------------------------------------
				if ( row.getnnz() != 0 )
				{
					cHashTatico[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}
		}
   }

   return restricoes;
}   

int SolverMIP::criaRestricaoTaticoMinCreds( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;

   if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE )
   {
		return restricoes;
   }

   int nnz;
   char name[ 100 ];

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	    if ( itCampus->getId() != campusId )
	    {
			continue;
	    }

		ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
		{
			Aluno *aluno = *itAluno;
			
			ITERA_GGROUP_N_PT( itDia, itCampus->diasLetivos, int )
			{
				int dia = *itDia;

				// CONSTRAINT --------------------------------------

				c.reset();
				c.setType( ConstraintTatico::C_MIN_CREDS_ALUNO );

				c.setCampus( *itCampus );
				c.setAluno( aluno );
				c.setDia( dia );

				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );

				if ( cHashTatico.find( c ) != cHashTatico.end() )
				{
					continue;
				}

				nnz = ( aluno->demandas.size() * itCampus->horarios.size() * 2 );

				OPT_ROW row( nnz + 1, OPT_ROW::LESS , 0 , name );

				// Insere variaveis Credito (x) ------------------------------------------------------

				ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{				   
						Sala *sala = itCjtSala->salas.begin()->second;
						
						ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
						{
							disciplina = ( *it_disciplina );
							
							#pragma region Equivalencias
							if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
								   problemData->mapDiscSubstituidaPor.end() ) &&
								 !problemData->ehSubstituta( disciplina ) )
							{
								continue;
							}
							#pragma endregion

							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								// Para cada trio <campus, turma, disciplina> no qual o aluno está alocado
								Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
								trio.set( campusId, turma, disciplina );

								if ( problemData->mapAluno_CampusTurmaDisc[ aluno ].find( trio ) ==
									 problemData->mapAluno_CampusTurmaDisc[ aluno ].end() )
								{
									continue;
								}

								GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
									problemData->retornaHorariosEmComum( sala->getId(), disciplina->getId(), dia );
					
								ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
								{
									HorarioAula *hi = *itHorario;

									ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
									{
											HorarioAula *hf = *itHorario;

											if ( hf < hi )
											{
							 					continue;
											}	

											int NCH = disciplina->getCalendario()->retornaNroCreditosEntreHorarios(hi,hf);

											v.reset();
											v.setType( VariableTatico::V_CREDITOS );									
											v.setTurma( turma );
											v.setDisciplina( disciplina );
											v.setUnidade( *itUnidade );
											v.setSubCjtSala( *itCjtSala );
											v.setDia( dia );                   
											v.setHorarioAulaInicial( hi );	 // hi
											v.setHorarioAulaFinal( hf );	 // hf

											it_v = vHashTatico.find( v );
											if( it_v != vHashTatico.end() )
											{
												row.insert( it_v->second, -NCH );
											}
									}
								}
							}
						}
					}
				}

				// Insere variavel h_{a} -------------------------------------------------------								
				v.reset();
				v.setType( VariableTatico::V_MIN_CRED_SEMANA );

				v.setAluno( aluno );  // a
					
				it_v = vHashTatico.find( v );
				if( it_v != vHashTatico.end() )
				{
					row.insert( it_v->second, 1.0 );
				}

				// Insere restrição no Hash --------------------------------------------------------
				if ( row.getnnz() != 0 )
				{
					cHashTatico[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}  
		}
   }

   return restricoes;
}

int SolverMIP::criaRestricaoTaticoMaxCreds( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;

   if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::INDIFERENTE )
   {
		return restricoes;
   }

   int nnz;
   char name[ 100 ];

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	    if ( itCampus->getId() != campusId )
	    {
			continue;
	    }

		ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
		{
			Aluno *aluno = *itAluno;
			
			ITERA_GGROUP_N_PT( itDia, itCampus->diasLetivos, int )
			{
				int dia = *itDia;

				// CONSTRAINT --------------------------------------

				c.reset();
				c.setType( ConstraintTatico::C_MAX_CREDS_ALUNO );

				c.setCampus( *itCampus );
				c.setAluno( aluno );
				c.setDia( dia );

				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );

				if ( cHashTatico.find( c ) != cHashTatico.end() )
				{
					continue;
				}

				nnz = ( aluno->demandas.size() * itCampus->horarios.size() * 2 );

				OPT_ROW row( nnz + 1, OPT_ROW::GREATER , 0 , name );

				// Insere variaveis Credito (x) ------------------------------------------------------

				ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{				   
						Sala *sala = itCjtSala->salas.begin()->second;
						
						ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
						{
							disciplina = ( *it_disciplina );
							
							#pragma region Equivalencias
							if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
								   problemData->mapDiscSubstituidaPor.end() ) &&
								 !problemData->ehSubstituta( disciplina ) )
							{
								continue;
							}
							#pragma endregion

							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								// Para cada trio <campus, turma, disciplina> no qual o aluno está alocado
								Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
								trio.set( campusId, turma, disciplina );

								if ( problemData->mapAluno_CampusTurmaDisc[ aluno ].find( trio ) ==
									 problemData->mapAluno_CampusTurmaDisc[ aluno ].end() )
								{
									continue;
								}

								GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
									problemData->retornaHorariosEmComum( sala->getId(), disciplina->getId(), dia );
					
								ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
								{
									HorarioAula *hi = *itHorario;

									ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
									{
											HorarioAula *hf = *itHorario;

											if ( hf < hi )
											{
							 					continue;
											}	

											int NCH = disciplina->getCalendario()->retornaNroCreditosEntreHorarios(hi,hf);

											v.reset();
											v.setType( VariableTatico::V_CREDITOS );									
											v.setTurma( turma );
											v.setDisciplina( disciplina );
											v.setUnidade( *itUnidade );
											v.setSubCjtSala( *itCjtSala );
											v.setDia( dia );                   
											v.setHorarioAulaInicial( hi );	 // hi
											v.setHorarioAulaFinal( hf );	 // hf

											it_v = vHashTatico.find( v );
											if( it_v != vHashTatico.end() )
											{
												row.insert( it_v->second, -NCH );
											}
									}
								}
							}
						}
					}
				}

				// Insere variavel h_{a} -------------------------------------------------------								
				v.reset();
				v.setType( VariableTatico::V_MAX_CRED_SEMANA );

				v.setAluno( aluno );  // a
					
				it_v = vHashTatico.find( v );
				if( it_v != vHashTatico.end() )
				{
					row.insert( it_v->second, 1.0 );
				}

				// Insere restrição no Hash --------------------------------------------------------
				if ( row.getnnz() != 0 )
				{
					cHashTatico[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}  
		}
   }

   return restricoes;
}


// fu_{i1,d1,i2,d2,t,cp}
int SolverMIP::criaRestricaoTaticoAlunoUnidDifDia( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }

	   Campus* campus = *it_campus;
	     
	  GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

	  // Disciplina 1
      ITERA_GGROUP_N_PT( it_disc1, disciplinas, int )
      {
		  Disciplina * disciplina1 = problemData->refDisciplinas[ *it_disc1 ];
		  
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina1 ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina1 ) )
		 {
			continue;
		 }
		 #pragma endregion
		 		 
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina1->getId(), campusId ) )
			  continue;
		
		 // Turma 1
         for ( int turma1 = 0; turma1< disciplina1->getNumTurmas(); turma1++ )
         {
			  Unidade *u1 = this->retornaUnidadeDeAtendimento( turma1, disciplina1, campus );
					   
			  if ( u1 == NULL )
			  {
				  continue;
			  }
			  
			  // Disciplina 2
			  ITERA_GGROUP_INIC_N_PT( it_disc2, it_disc1, disciplinas, int )
			  {
				  Disciplina * disciplina2 = problemData->refDisciplinas[ *it_disc2 ];
		  
				  #pragma region Equivalencias
				  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina2 ) !=
					     problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina2 ) )
				  {
					  continue;
				  }
				  #pragma endregion
		 		 
				  if ( ! problemData->haDemandaDiscNoCampus( disciplina2->getId(), campusId ) )
					  continue;

				  // Turma 2
				  for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
				  {
					   Unidade *u2 = this->retornaUnidadeDeAtendimento( turma2, disciplina2, campus );

					   if ( u2 == NULL || u2 == u1 )
					   {
						   continue;
					   }

					    GGroup<Aluno*> alunosEmComum = 
							problemData->alunosEmComum( turma1, disciplina1, turma2, disciplina2, campus );

						if ( alunosEmComum.size() == 0 )
						{
							continue;
						}

						int nroAlunos = alunosEmComum.size();

						GGroup<int> dias = problemData->diasComunsEntreDisciplinas( disciplina1, disciplina2 );
						ITERA_GGROUP_N_PT( it_dias, dias, int )
						{
							int dia = *it_dias;

							// CONSTRAINT --------------------------------------

							c.reset();
							c.setType( ConstraintTatico::C_ALUNO_VARIAS_UNIDADES_DIA );

							c.setCampus( campus );
							c.setTurma1( turma1 );
							c.setTurma2( turma2 );
							c.setDisciplina1( disciplina1 );
							c.setDisciplina2( disciplina2 );
							c.setDia( dia );
							c.setCampus( campus );

							sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );

							if ( cHashTatico.find( c ) != cHashTatico.end() )
							{
								continue;
							}

							nnz = 100;

							OPT_ROW row( nnz + 1, OPT_ROW::LESS , 1 , name );

							// Insere variavel fu_{i1,d1,i2,d2,t,cp} -------------------------------------------------------
							VariableTatico v;
							v.reset();
							v.setType( VariableTatico::V_SLACK_ALUNO_VARIAS_UNID_DIA );
							v.setTurma1( turma1 );            // i1
							v.setDisciplina1( disciplina1 );  // d1
							v.setTurma2( turma2 );            // i2
							v.setDisciplina2( disciplina2 );  // d2
							v.setCampus( campus );			  // cp
							v.setDia( dia );				  // t

							it_v = vHashTatico.find( v );
							if( it_v != vHashTatico.end() )
							{
								row.insert( it_v->second, -1.0 );
							}

							// Insere variaveis x_{i,d,u,s,hi,hf,t} -------------------------------------------------------
							it_v = vHashTatico.begin();

							for (; it_v != vHashTatico.end(); it_v++ )
							{
								VariableTatico v = it_v->first;

								if ( v.getType() != VariableTatico::V_CREDITOS )
								{
									continue;
								}

								// Insere variavel x_{i1,d1,u1,s1,hi,hf,t} ou x_{i2,d2,u2,s2,hi,hf,t}
								
								if ( ( v.getTurma() == turma1 &&
									   v.getDisciplina() == disciplina1 && 
									   v.getDia() == dia && 
									   v.getUnidade() == u1 ) 
									   ||
									 ( v.getTurma() == turma2 &&
									   v.getDisciplina() == disciplina2 && 
									   v.getDia() == dia && 
									   v.getUnidade() == u2 ) )
								{
									row.insert( it_v->second, 1.0 );
								}
							}

							// Insere restrição no Hash --------------------------------------------------------
							if ( row.getnnz() != 0 )
							{
								cHashTatico[ c ] = lp->getNumRows();

								lp->addRow( row );
								restricoes++;
							}
						}
				  }
			  }
          }
      }
   }
	
	return restricoes;

}

/*
	Evita os atendimentos parciais, ou seja, para um par de disciplinas
	(i1,-d) e (i2,d), aonde -d é a disciplina pratica e d a teorica correspondente,
	que possuam alunos em comum, tenta atender a as duas!

	fd_{i1,-d,cp} + fd_{i2,d,cp} - ffd_{i1,-d,i2,d,cp} = 0

	ffd é folga da folga de demanda, podendo assumir os valores {0,1,2}.
*/
int SolverMIP::criaRestricaoTaticoDiscPraticaTeorica( int campusId, int prioridade, int r, int tatico )
{
    int restricoes = 0;
    int nnz;
    char name[ 100 ];

    VariableTatico v;
    ConstraintTatico c;
    VariableTaticoHash::iterator it_v;
   
    Campus* campus = problemData->refCampus[ campusId ];
	     
	GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

	ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
	{
		Disciplina * discPratica = problemData->refDisciplinas[ *it_disciplina ];

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( discPratica ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( discPratica ) )
		{
			continue;
		}
		#pragma endregion

		if ( discPratica->getId() > 0 )
		{
			continue;
		}
		
		std::map< int, Disciplina * >::iterator itMapDisc =
			problemData->refDisciplinas.find( - discPratica->getId() );
				
		if ( itMapDisc == problemData->refDisciplinas.end() )
		{
			continue;
		}
		
		Disciplina *discTeorica = itMapDisc->second;

		if ( ! problemData->haDemandaDiscNoCampus( discPratica->getId(), campusId ) )
		{
			continue;
		}

		for ( int turma1 = 0; turma1 < discPratica->getNumTurmas(); turma1++ )
		{
			for ( int turma2 = 0; turma2 < discTeorica->getNumTurmas(); turma2++ )
			{		
				GGroup<Aluno*> alunos = problemData->alunosEmComum( turma1, discPratica, turma2, discTeorica, campus );
				
				if ( alunos.size() == 0 )
				{
					continue;
				}

				c.reset();
				c.setType( ConstraintTatico::C_DISC_PRATICA_TEORICA );
				c.setCampus( campus );
				c.setDisciplina1( discPratica );
				c.setTurma1( turma1 );
				c.setDisciplina2( discTeorica );
				c.setTurma2( turma2 );

				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );

				if ( cHashTatico.find( c ) != cHashTatico.end() )
				{
					continue;
				}
			
				nnz = 3;
				OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

				// Variavel de folga fd_{dp,i1,cp}
				v.reset();
				v.setType( VariableTatico::V_SLACK_DEMANDA );
				v.setDisciplina( discPratica );  // dp
				v.setTurma( turma1 );			 // i1
				v.setCampus( campus );			 // cp

				it_v = vHashTatico.find( v );
				if( it_v != vHashTatico.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			
				// Variavel de folga fd_{dt,i2,cp}
				v.reset();
				v.setType( VariableTatico::V_SLACK_DEMANDA );
				v.setDisciplina( discTeorica );  // dt
				v.setTurma( turma2 );			 // i2
				v.setCampus( campus );			 // cp

				it_v = vHashTatico.find( v );
				if( it_v != vHashTatico.end() )
				{
					row.insert( it_v->second, 1.0 );
				}

				// Variavel de folga ffd_{i1,dp,i2,dt,cp}
				v.reset();
				v.setType( VariableTatico::V_SLACK_SLACKDEMANDA_PT );
				v.setTurma1( turma1 );			 // i1
				v.setDisciplina1( discPratica );  // dp
				v.setTurma2( turma2 );			 // i2
				v.setDisciplina2( discTeorica );  // dt				
				v.setCampus( campus );			 // cp

				it_v = vHashTatico.find( v );
				if( it_v != vHashTatico.end() )
				{
					row.insert( it_v->second, -2.0 );
				}

				// Insere restrição no Hash ---
				if ( row.getnnz() != 0 )
				{
					cHashTatico[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}
        }
   }

	return restricoes;
}

int SolverMIP::criaRestricaoTaticoMinDiasAluno( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;

   if ( problemData->parametros->carga_horaria_semanal_aluno != ParametrosPlanejamento::MINIMIZAR_DIAS )
   {
		return restricoes;
   }

   int nnz;
   char name[ 100 ];

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	    if ( itCampus->getId() != campusId )
	    {
			continue;
	    }

		ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
		{
			Aluno *aluno = *itAluno;
			
			ITERA_GGROUP_N_PT( itDia, itCampus->diasLetivos, int )
			{
				int dia = *itDia;

				// CONSTRAINT --------------------------------------

				c.reset();
				c.setType( ConstraintTatico::C_MIN_DIAS_ALUNO );

				c.setCampus( *itCampus );
				c.setAluno( aluno );
				c.setDia( dia );

				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );

				if ( cHashTatico.find( c ) != cHashTatico.end() )
				{
					continue;
				}

				nnz = ( aluno->demandas.size() * itCampus->horarios.size() * 2 );

				OPT_ROW row( nnz + 1, OPT_ROW::GREATER , 0 , name );

				// Insere variaveis Credito (x) ------------------------------------------------------

				ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{				   
						Sala *sala = itCjtSala->salas.begin()->second;
						
						ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
						{
							disciplina = ( *it_disciplina );
							
							#pragma region Equivalencias
							if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
								   problemData->mapDiscSubstituidaPor.end() ) &&
								 !problemData->ehSubstituta( disciplina ) )
							{
								continue;
							}
							#pragma endregion

							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								// Para cada trio <campus, turma, disciplina> no qual o aluno está alocado
								Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
								trio.set( campusId, turma, disciplina );

								if ( problemData->mapAluno_CampusTurmaDisc[ aluno ].find( trio ) ==
									 problemData->mapAluno_CampusTurmaDisc[ aluno ].end() )
								{
									continue;
								}

								GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
									problemData->retornaHorariosEmComum( sala->getId(), disciplina->getId(), dia );
					
								ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
								{
									HorarioAula *hi = *itHorario;

									ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
									{
											HorarioAula *hf = *itHorario;

											if ( hf < hi )
											{
							 					continue;
											}	
											
											v.reset();
											v.setType( VariableTatico::V_CREDITOS );									
											v.setTurma( turma );
											v.setDisciplina( disciplina );
											v.setUnidade( *itUnidade );
											v.setSubCjtSala( *itCjtSala );
											v.setDia( dia );                   
											v.setHorarioAulaInicial( hi );	 // hi
											v.setHorarioAulaFinal( hf );	 // hf

											it_v = vHashTatico.find( v );
											if( it_v != vHashTatico.end() )
											{
												row.insert( it_v->second, -1.0 );
											}
									}
								}
							}
						}
					}
				}

				// Insere variavel du_{a,t} -------------------------------------------------------								
				v.reset();
				v.setType( VariableTatico::V_ALUNO_DIA );
				v.setAluno( aluno );
				v.setDia( dia );

				it_v = vHashTatico.find( v );
				if( it_v != vHashTatico.end() )
				{
					row.insert( it_v->second, 15.0 );
				}

				// Insere restrição no Hash --------------------------------------------------------
				if ( row.getnnz() != 0 )
				{
					cHashTatico[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}  
		}
   }

   return restricoes;

}

int SolverMIP::criaRestricaoTaticoMaxDiasAluno( int campusId, int prioridade, int r, int tatico )
{
   int restricoes = 0;

   if ( problemData->parametros->carga_horaria_semanal_aluno != ParametrosPlanejamento::EQUILIBRAR )
   {
		return restricoes;
   }

   int nnz;
   char name[ 100 ];

   VariableTatico v;
   ConstraintTatico c;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	    if ( itCampus->getId() != campusId )
	    {
			continue;
	    }

		ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
		{
			Aluno *aluno = *itAluno;
			
			ITERA_GGROUP_N_PT( itDia, itCampus->diasLetivos, int )
			{
				int dia = *itDia;

				// CONSTRAINT --------------------------------------

				c.reset();
				c.setType( ConstraintTatico::C_MAX_DIAS_ALUNO );

				c.setCampus( *itCampus );
				c.setAluno( aluno );
				c.setDia( dia );

				sprintf( name, "%s", c.toString( prioridade,r,tatico ).c_str() );

				if ( cHashTatico.find( c ) != cHashTatico.end() )
				{
					continue;
				}

				nnz = ( aluno->demandas.size() * itCampus->horarios.size() * 2 );

				OPT_ROW row( nnz + 1, OPT_ROW::LESS , 0 , name );

				// Insere variaveis Credito (x) ------------------------------------------------------

				ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{				   
						Sala *sala = itCjtSala->salas.begin()->second;
						
						ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
						{
							disciplina = ( *it_disciplina );
							
							#pragma region Equivalencias
							if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
								   problemData->mapDiscSubstituidaPor.end() ) &&
								 !problemData->ehSubstituta( disciplina ) )
							{
								continue;
							}
							#pragma endregion

							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								// Para cada trio <campus, turma, disciplina> no qual o aluno está alocado
								Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
								trio.set( campusId, turma, disciplina );

								if ( problemData->mapAluno_CampusTurmaDisc[ aluno ].find( trio ) ==
									 problemData->mapAluno_CampusTurmaDisc[ aluno ].end() )
								{
									continue;
								}

								GGroup< HorarioAula *, LessPtr< HorarioAula > > horariosEmComum = 
									problemData->retornaHorariosEmComum( sala->getId(), disciplina->getId(), dia );
					
								ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
								{
									HorarioAula *hi = *itHorario;

									ITERA_GGROUP_LESSPTR( itHorario, horariosEmComum, HorarioAula )
									{
											HorarioAula *hf = *itHorario;

											if ( hf < hi )
											{
							 					continue;
											}	
											
											v.reset();
											v.setType( VariableTatico::V_CREDITOS );									
											v.setTurma( turma );
											v.setDisciplina( disciplina );
											v.setUnidade( *itUnidade );
											v.setSubCjtSala( *itCjtSala );
											v.setDia( dia );                   
											v.setHorarioAulaInicial( hi );	 // hi
											v.setHorarioAulaFinal( hf );	 // hf

											it_v = vHashTatico.find( v );
											if( it_v != vHashTatico.end() )
											{
												row.insert( it_v->second, -1.0 );
											}
									}
								}
							}
						}
					}
				}

				// Insere variavel du_{a,t} -------------------------------------------------------								
				v.reset();
				v.setType( VariableTatico::V_ALUNO_DIA );
				v.setAluno( aluno );
				v.setDia( dia );

				it_v = vHashTatico.find( v );
				if( it_v != vHashTatico.end() )
				{
					row.insert( it_v->second, 1.0 );
				}

				// Insere restrição no Hash --------------------------------------------------------
				if ( row.getnnz() != 0 )
				{
					cHashTatico[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}  
		}
   }

   return restricoes;

}



// Restricao 1.2.12
/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Fixação da distribuição de créditos por dia (*)
%Desc 

%MatExp

\begin{eqnarray}
x_{i,d,u,s,t} + fcp_{i,d,s,t} - fcm_{i,d,s,t} = FC_{d,s,t} \cdot z_{i,d,cp}  \nonumber \qquad 
\forall cp \in CP
\forall s \in S_{u} \quad
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-395
/*
int SolverMIP::criaRestricaoTaticoFixaDistribCredDia( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   ConstraintTatico c;
   VariableTatico v;
   VariableTaticoHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		    continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			 ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  GGroup< int >::iterator itDiasLetDisc = disciplina->diasLetivos.begin();

                  for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() &&
                             it_fix->getDiaSemana() == ( *itDiasLetDisc ) &&
						     it_fix->sala != NULL )
                        {
						   Sala *s = (*itCjtSala)->salas.begin()->second;
						   if ( s->getId() != it_fix->sala->getId() )
						   {
							   continue;
						   }

                           c.reset();
                           c.setType( ConstraintTatico::C_FIXA_DISTRIB_CRED_DIA );

                           c.setTurma( turma );
                           c.setDisciplina( disciplina );
                           c.setDia( *itDiasLetDisc );
                           c.setSubCjtSala( *itCjtSala );

                           sprintf( name, "%s", c.toString().c_str() );
                           if ( cHashTatico.find( c ) != cHashTatico.end() )
                           {
                              continue;
                           }

                           if ( disciplina->getNumTurmas() < 0 )
                           {
                              continue;
                           }

						   nnz = problemData->horariosDia.size(); //estimativa

                           OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

							v.reset();
							v.setType( VariableTatico::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setHorarioAulaInicial(  );
							v.setHorarioAulaFinal(  );
							v.setDia( *itDiasLetDisc );

							it_v = vHashTatico.find(v);
							if( it_v != vHashTatico.end() )
							{
								row.insert( it_v->second, 1.0 );
							}

							v.reset();
							v.setType( VariableTatico::V_SLACK_DIST_CRED_DIA_SUPERIOR );
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setDia( *itDiasLetDisc );

							it_v = vHashTatico.find( v );
							if ( it_v != vHashTatico.end() )
							{
								row.insert( it_v->second, 1.0 );
							}

							v.reset();
							v.setType( VariableTatico::V_SLACK_DIST_CRED_DIA_INFERIOR );
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setDia( *itDiasLetDisc );

							it_v = vHashTatico.find( v );
							if ( it_v != vHashTatico.end() )
							{
								row.insert( it_v->second, -1.0 );
							}

							v.reset();
							v.setType( VariableTatico::V_ABERTURA );

							v.setCampus( *itCampus );
							v.setDisciplina( disciplina );
							v.setTurma( turma );

							it_v = vHashTatico.find( v );
							if ( it_v != vHashTatico.end() )
							{
								row.insert( it_v->second,
									-( it_fix->disciplina->getMaxCreds() ) ); // TODO!!!! coeficiente..
							}

							if ( row.getnnz() != 0 )
							{
								cHashTatico[ c ] = lp->getNumRows();

								lp->addRow( row );
								restricoes++;
							}						  
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return restricoes;
}

*/

#endif


#endif


/*
	-------------------------------------------------------------------------------
				SEM CONJUNTO DE ALUNOS
*/

#ifndef TATICO_CJT_ALUNOS

/*----------------------------------------------------------------------------------
**							PRE-MODELO										       **
----------------------------------------------------------------------------------*/

#pragma region PRE-TATICO

/********************************************************************
**                      Variaveis do pre-tatico                    **
*********************************************************************/

int SolverMIP::cria_preVariaveis(  int campusId, int prioridade )
{
	int num_vars = 0;
	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_variaveis
	int numVarsAnterior = 0;
#endif

	timer.start();
	num_vars += cria_preVariavel_creditos( campusId );   // x_{i,d,s}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"x\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_oferecimentos( campusId ); // o_{i,d,s}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"o\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_abertura( campusId );   // z_{i,d}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"z\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_alunos( campusId );  // a_{i,d,oft,s}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"a\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_aloc_alunos( campusId );   // b_{i,d,c}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"a\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_folga_compartilhamento_incomp( campusId ); // bs_{d,oft}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"bs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_folga_proibe_compartilhamento( campusId ); // fc_{d,oft}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fc\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_folga_turma_mesma_disc_oft_sala_dif( campusId ); // fs_{d,s}
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_limite_sup_creds_sala( campusId ); // Hs
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"Hs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_preVariavel_aloca_alunos_oferta( campusId ); // c
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"c\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif	


   if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
   {
		timer.start();
		num_vars += cria_preVariavel_folga_demanda_disciplina_oft( campusId ); // fd_{d,oft}
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif
   }

   else if ( problemData->parametros->otimizarPor == "ALUNO" )
   {
		timer.start();
		num_vars += cria_preVariavel_folga_demanda_disciplina_aluno( campusId ); // fd_{d,a}
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif

		timer.start();
		num_vars += cria_preVariavel_aloca_aluno_turma_disc( campusId ); // s
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"s\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif

		timer.start();
		num_vars += cria_preVariavel_folga_prioridade_inf( campusId, prioridade ); // fpi
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fpi\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif
		

		timer.start();
		num_vars += cria_preVariavel_folga_prioridade_sup( campusId, prioridade ); // fps
		timer.stop();
		dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
		std::cout << "numVars \"fps\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
		numVarsAnterior = num_vars;
	#endif
		

   }	

	return num_vars;
}

// x_{i,d,u,s}
int SolverMIP::cria_preVariavel_creditos( int campusId )
{
	int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  Campus *cp = *itCampus;

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disc );

			   #pragma region Equivalencias
			   if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					  problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
			   {
				   continue;
			   }
			   #pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                     VariablePre v;
                     v.reset();
                     v.setType( VariablePre::V_PRE_CREDITOS );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setUnidade( *itUnidade );     // u
                     v.setSubCjtSala( *itCjtSala );  // tps

                     if ( vHashPre.find( v ) == vHashPre.end() )
                     {
						 double coef = 0.0;

						 if ( problemData->parametros->funcao_objetivo == 0 )
                         {							 
							 coef = -1.0;
						 }
						 else if ( problemData->parametros->funcao_objetivo == 1 )
                         {
							 coef = 1.0;
						 }
						 
						 int upperBound = disciplina->getCredTeoricos() + disciplina->getCredPraticos();
						 
						 double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

                         vHashPre[ v ] = lp->getNumCols();
						   						 
                         OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );
                          
						 lp->newCol( col );						 

						 num_vars++;						  
                     }
                }
            }
         }
      }
   }

	return num_vars;
}

// o_{i,d,s}
int SolverMIP::cria_preVariavel_oferecimentos( int campusId )
{
	int num_vars = 0;

   Disciplina * disciplina = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  Campus *cp = *itCampus;

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disc );

			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
			   {
				   continue;
			   }
			   #pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                    // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                    GGroup< int > dias_letivos = itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                    GGroup< int >::iterator itDiscSala_Dias = dias_letivos.begin();

                     VariablePre v;
                     v.reset();
                     v.setType( VariablePre::V_PRE_OFERECIMENTO );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setUnidade( *itUnidade );     // u
                     v.setSubCjtSala( *itCjtSala );  // tps

                     if ( vHashPre.find( v ) == vHashPre.end() )
                     {
                        double custo = 0.0;

                        vHashPre[ v ] = lp->getNumCols();
						 
						double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

                        OPT_COL col( OPT_COL::VAR_BINARY, custo, lowerBound, 1.0, ( char* )v.toString().c_str() );
                          
						lp->newCol( col );

						num_vars++;						  
                     }
                }
            }
         }
      }
   }

	return num_vars;
}

// z_{i,d,cp}
int SolverMIP::cria_preVariavel_abertura( int campusId )
{
	int num_vars = 0;
	
   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_disciplina, it_CpDisc->second, int )
      {
		 Disciplina *disciplina = problemData->refDisciplinas[ *it_disciplina ];
		 
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( disciplina ) )
		 {
		 	continue;
		 }
		 #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            VariablePre v;
            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( cp );	    // cp

            std::pair< int, int > dc
               = std::make_pair( disciplina->getId(), cp->getId() );

            if ( problemData->demandas_campus.find( dc )
               == problemData->demandas_campus.end() )
            {
               problemData->demandas_campus[ dc ] = 0;
            }

			/*
            double ratioDem = ( disciplina->getDemandaTotal() - 
               problemData->demandas_campus[ dc ] ) 
               / (1.0 * disciplina->getDemandaTotal() );

            double coeff = alpha + gamma * ratioDem;

            int numCreditos = ( disciplina->getCredTeoricos() + disciplina->getCredPraticos() );
            double valorCredito = 1600.0;
            double coef_FO_1_2 = ( numCreditos * valorCredito );
			*/
            if ( vHashPre.find(v) == vHashPre.end() )
            {
               lp->getNumCols();
               vHashPre[v] = lp->getNumCols();

			   /*
               if ( problemData->parametros->funcao_objetivo == 0 )
               {
                  OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
                     ( char * )v.toString().c_str() );

                  lp->newCol( col );
               }
               else if ( problemData->parametros->funcao_objetivo == 1 )
               {
                  OPT_COL col( OPT_COL::VAR_BINARY, -coef_FO_1_2, 0.0, 1.0,
                     ( char * )v.toString().c_str() );

                  lp->newCol( col );
               }
               else if ( problemData->parametros->funcao_objetivo == 2 )
               {
                  OPT_COL col( OPT_COL::VAR_BINARY, coef_FO_1_2, 0.0, 1.0,
                     ( char * )v.toString().c_str() );

                  lp->newCol( col );
               }*/

			    double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					double custo = cp->getCusto();
							 
					coef = -10 * custo * disciplina->getTotalCreditos();
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					double custo = cp->getCusto();

					coef = custo * disciplina->getTotalCreditos();
				}
						                
				double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

				OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, 1.0,
                     ( char * )v.toString().c_str() );

                lp->newCol( col ); 
                
				num_vars++;
            }
         }
      }
   }

	return num_vars;
}

// a_{i,d,oft,s}
int SolverMIP::cria_preVariavel_alunos( int campusId )
{
	int num_vars = 0;
	
    Curso * curso = NULL;
    Curriculo * curriculo = NULL;
	
	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
	  
	    if ( cp->getId() != campusId )
	    {
		    continue;
	    }

		ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *it_disc;

				    #pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
				    {
					    continue;
				    }
				    #pragma endregion

					// Listando todas as ofertas que contêm uma disciplina especificada.
					GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ it_disc->getId() ];

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{
							 Oferta* oft = *itOferta;

							 if ( oft->campus != cp )
								 continue;

							 // Calculando P_{d,o}
							 int qtdDem = 0;
							 ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
							 {
								if ( itDem->disciplina->getId() == disciplina->getId() &&
								   itDem->getOfertaId() == itOferta->getId() )
								{
								   qtdDem += itDem->getQuantidade();
								}
							 }

							 if ( qtdDem <= 0 )
							 {
								continue;
							 }

							 for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							 {
								VariablePre v;
								v.reset();
								v.setType( VariablePre::V_PRE_ALUNOS );

								v.setTurma( turma );               // i
								v.setDisciplina( disciplina );     // d
								v.setOferta( *itOferta );          // oft
								v.setUnidade( *itUnidade );		   // u
								v.setSubCjtSala( *itCjtSala );	   // s
								
								if ( vHashPre.find(v) == vHashPre.end() )
								{
									vHashPre[v] = lp->getNumCols();
									
									double coef = 0.0;

									if ( problemData->parametros->funcao_objetivo == 0 )
									{
										double valorCredito = itOferta->getReceita();
										int numCreditos = ( disciplina->getCredTeoricos() + disciplina->getCredPraticos() );
				
										coef = 100 * numCreditos * valorCredito;
									}
									else if ( problemData->parametros->funcao_objetivo == 1 )
									{
										coef = 0.0;
									}

									double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

									OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, qtdDem,
										( char * )v.toString().c_str() );

									lp->newCol( col );

									num_vars += 1;
								}
							}
				      }
				}
			}
		}
   }

	return num_vars;
}

// b_{i,d,c}
int SolverMIP::cria_preVariavel_aloc_alunos( int campusId )
{
	int num_vars = 0;
		
	ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
	{		
		Disciplina* disciplina = *itDisc;

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			 !problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion

		if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			 problemData->cp_discs[campusId].end() )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
		{
			Curso *curso = *itCurso;

			if ( !curso->possuiDisciplina( disciplina ) )
				continue;

			// Calculando P_{d,o}
			int qtdDem = 0;
			ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
			{
				if ( itDem->disciplina->getId() == disciplina->getId() &&
					 itDem->oferta->getCursoId() == curso->getId() &&
					 itDem->oferta->getCampusId() == campusId )
				{
					qtdDem += itDem->getQuantidade();
				}
			}

			if ( qtdDem <= 0 )
			{
				continue;
			}

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOC_ALUNO );

				v.setTurma( turma );               // i
				v.setDisciplina( disciplina );     // d
				v.setCurso( curso );			   // c
				
				if ( vHashPre.find(v) == vHashPre.end() )
				{
					double coef = 0.0;
					
					vHashPre[v] = lp->getNumCols();

					if ( problemData->parametros->funcao_objetivo == 0 )
					{
						coef = -1.0;
					}
					else if ( problemData->parametros->funcao_objetivo == 1 )
					{						
						coef = 1.0;
					}
													
					double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;
					
					OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, 1.0, ( char * )v.toString().c_str() );
												
					lp->newCol( col );
					
					num_vars += 1;
				}
			}
		}
   }

	return num_vars;
}

// fd_{d,a}
int SolverMIP::cria_preVariavel_folga_demanda_disciplina_aluno( int campusId )
{
   int num_vars = 0;

	Campus *cp = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;

			VariablePre v;
			v.reset();
			v.setType( VariablePre::V_PRE_SLACK_DEMANDA );
			v.setAluno( aluno );
			v.setDisciplina( disciplina );

			// Coeficiente na funcao objetivo
			double coef = 0.0;
			if ( itAlDemanda->getPrioridade() > 1 )
			{
				coef = 0.0;
			}
			else
			{
				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					coef = 0.0;
				}
				else if( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 10.0 * cp->getCusto() * disciplina->getTotalCreditos();
				}
			}

			// Limite superior da variavel
			double ub = 1.0;

			GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > > atendimentosAluno =
					problemData->mapAluno_CampusTurmaDisc[aluno];

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				Trio< int, int, Disciplina* > trio;
				trio.set( campusId, turma, disciplina);

				if ( atendimentosAluno.find( trio ) != atendimentosAluno.end() )
					ub = 0.0;
			}

			// Limite inferior da variavel
			double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

			if ( vHashPre.find( v ) == vHashPre.end() )
			{
				vHashPre[v] = lp->getNumCols();

				OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, ub, ( char * )v.toString().c_str() );
				lp->newCol(col);
				
				num_vars++;
			}
		}
	}

	return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fd_{d,oft} 

%Desc 
variável de folga para a restrição "Capacidade alocada tem que 
permitir atender demanda da disciplina".

%ObjCoef
\omega \cdot \sum\limits_{oft \in O} \sum\limits_{d \in D_{oft}} fd_{d,oft}

%DocEnd
/====================================================================*/

int SolverMIP::cria_preVariavel_folga_demanda_disciplina_oft( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( itOferta, problemData->ofertas, Oferta )
   {
	   if ( itOferta->getCampusId() != campusId )
	   {
		   continue;
	   }

      map < Disciplina*, int, LessPtr< Disciplina > >::iterator itPrdDisc = 
         itOferta->curriculo->disciplinas_periodo.begin();

      for (; itPrdDisc != itOferta->curriculo->disciplinas_periodo.end(); itPrdDisc++ )
      {
         // Calculando P_{d,o}
         int qtdDem = 0;

		 disciplina = itPrdDisc->first;

         ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
         {
            if ( itDem->disciplina->getId() == disciplina->getId() &&
                 itDem->getOfertaId() == itOferta->getId() )
            {
               qtdDem += itDem->getQuantidade();
            }
         }

         if ( qtdDem <= 0 )
         {
            continue;
         }

         VariablePre v;
         v.reset();
         v.setType( VariablePre::V_PRE_SLACK_DEMANDA );

         v.setDisciplina( disciplina ); // d
         v.setOferta( *itOferta );      // o

         if ( vHashPre.find( v ) == vHashPre.end() )
         {
            vHashPre[ v ] = lp->getNumCols();

            double ub = qtdDem;

			double coef = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				coef = 0.0;
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				coef = 10 * itOferta->campus->getCusto() * disciplina->getTotalCreditos();
			}

			OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, ub, ( char * )v.toString().c_str() );

            lp->newCol( col );

            num_vars++;
         }
      }
   }

   return num_vars;
}



// bs_{i,d,c1,c2}
int SolverMIP::cria_preVariavel_folga_compartilhamento_incomp( int campusId )
{
	int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
		Campus* cp = *itCampus;
	  
	    if ( cp->getId() != campusId )
	    {
		    continue;
	    }

	   ITERA_GGROUP_LESSPTR( itCurso1, cp->cursos, Curso )
	   {
		   Curso* c1 = *itCurso1;
		   
		   ITERA_GGROUP_INIC_LESSPTR( itCurso2, itCurso1, cp->cursos, Curso )
		   {
				Curso* c2 = *itCurso2;
			    
			    if ( problemData->cursosCompativeis(c1, c2) || c1 == c2 )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion

					// A disciplina deve ser ofertada no campus especificado
					if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
						 problemData->cp_discs[campusId].end() )
					{
						continue;
					}

					// A disciplina deve pertencer aos dois cursos c1 e c2
					if ( !c1->possuiDisciplina(disciplina) || !c2->possuiDisciplina(disciplina) )
						continue;

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
					   VariablePre v;
					   v.reset();
					   v.setType( VariablePre::V_PRE_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT );
					   v.setTurma( turma );							// i
					   v.setDisciplina( disciplina );   			// d
					   v.setParCursos( std::make_pair(c1, c2) );	// c1 c2

					   if ( vHashPre.find( v ) == vHashPre.end() )
					   {
						  vHashPre[v] = lp->getNumCols();
						  
						  double coef = 0.0;

						  if ( problemData->parametros->funcao_objetivo == 0 )
						  {
							  coef = -cp->getCusto();
						  }
						  else if( problemData->parametros->funcao_objetivo == 1 )
						  {
							  coef = cp->getCusto();
						  }
						  
						  double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

						  OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, 1.0, ( char * )v.toString().c_str() );

						  lp->newCol( col );
						  num_vars++;
					   }
					}
				}
		    }
		}
   }

	return num_vars;
}


// fc_{i,d,c1,c2}
int SolverMIP::cria_preVariavel_folga_proibe_compartilhamento( int campusId )
{
	int num_vars = 0;

   if ( problemData->parametros->permite_compartilhamento_turma_sel )
   {
		return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus* cp = *itCampus;
	  
	   if ( cp->getId() != campusId )
	   {
		   continue;
	   }

	   ITERA_GGROUP_LESSPTR( itCurso1, cp->cursos, Curso )
	   {
		   Curso* c1 = *itCurso1;
		   
		   ITERA_GGROUP_INIC_LESSPTR( itCurso2, itCurso1, cp->cursos, Curso )
		   {
				Curso* c2 = *itCurso2;
			    
				// A variavel de folga só é criada para cursos compativeis e diferentes entre si
				// Ofertas para mesmo curso sempre poderão compartilhar
				// Ofertas de cursos distintos só poderão compartilhar se forem compativeis e o compartilhamento estiver permitido
			    if ( c1 == c2 || !problemData->cursosCompativeis(c1, c2) )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion
					
					// A disciplina deve ser ofertada no campus especificado
					if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
						 problemData->cp_discs[campusId].end() )
					{
						continue;
					}

					// A disciplina deve pertencer aos dois cursos c1 e c2
					if ( !c1->possuiDisciplina(disciplina) || !c2->possuiDisciplina(disciplina) )
						continue;

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
					   VariablePre v;
					   v.reset();
					   v.setType( VariablePre::V_PRE_SLACK_COMPARTILHAMENTO );
					   v.setTurma( turma );							// i
					   v.setDisciplina( disciplina );   			// d
					   v.setParCursos( std::make_pair(c1, c2) );	// c1 c2

					   if ( vHashPre.find( v ) == vHashPre.end() )
					   {
						  vHashPre[v] = lp->getNumCols();
						  
						  double coef = 0.0;

						  if ( problemData->parametros->funcao_objetivo == 0 )
						  {
							  coef = -cp->getCusto()/4;
						  }
						  else if( problemData->parametros->funcao_objetivo == 1 )
						  {
							  coef = cp->getCusto()/4;
						  }

						  double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;
						  
						  OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, 1.0, ( char * )v.toString().c_str() );

						  lp->newCol( col );
						  num_vars++;
					   }
					}
				}
		    }
		}
   }

	return num_vars;
}


// fs_{d,s,oft}
int SolverMIP::cria_preVariavel_folga_turma_mesma_disc_oft_sala_dif( int campusId )
{
	int num_vars = 0;

    Disciplina * disciplina_equivalente = NULL;

    Curso * curso = NULL;
    Curriculo * curriculo = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;

		if ( cp->getId() != campusId )
	    {
		    continue;
	    }
		
		ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *itDisc;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion

					// Listando todas as ofertas que contem uma disciplina especificada.
					GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ itDisc->getId() ];

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{
						Oferta* oft = *itOferta;

						if ( oft->campus != cp )
							continue;

						// Calculando P_{d,o}
						int qtdDem = 0;
						ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
						{
							if ( itDem->disciplina->getId() == disciplina->getId() &&
								 itDem->getOfertaId() == oft->getId() )
							{
								qtdDem += itDem->getQuantidade();
							}
						}

						if ( qtdDem <= 0 )
						{
							continue;
						}

						if ( itDisc->getNumTurmas() > 1 )
						{
							VariablePre v;
							v.reset();
							v.setType( VariablePre::V_PRE_SLACK_SALA);
							v.setDisciplina( *itDisc );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setOferta( oft );

							if ( vHashPre.find( v ) == vHashPre.end() )
							{
								vHashPre[v] = lp->getNumCols();

								double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{
									coef = -cp->getCusto()/2;
								}
								else if( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = cp->getCusto()/2;
								}
						  
								double upperbound = itDisc->getNumTurmas();
								double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

								OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperbound, ( char * )v.toString().c_str() );

								lp->newCol( col );
								num_vars++;
							}
						}
					}
				}
			}
		}
	}
	return num_vars;
}


// Hs_{cp}
int SolverMIP::cria_preVariavel_limite_sup_creds_sala( int campusId )
{
	int num_vars = 0;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus *cp = *itCampus;

	    if ( cp->getId() != campusId )
	    {
		   continue;
	    }

		VariablePre v;
		v.reset();
		v.setType( VariablePre::V_PRE_LIM_SUP_CREDS_SALA);
		v.setCampus( cp );

		if ( vHashPre.find( v ) == vHashPre.end() )
		{
			vHashPre[v] = lp->getNumCols();

			double upperbound = 0;

			ITERA_GGROUP_N_PT( itDisc, problemData->cp_discs[ cp->getId() ], int )
			{
				Disciplina* disciplina = problemData->refDisciplinas[ *itDisc ];
			
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				int nCreds = disciplina->getCredTeoricos() + disciplina->getCredPraticos();

				upperbound += nCreds * disciplina->getNumTurmas();				
			}

			double coef = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				coef = -cp->getCusto()/2;
			}
			else if( problemData->parametros->funcao_objetivo == 1 )
			{
				coef = cp->getCusto()/2;
			}
			
			double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

			OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperbound, ( char * )v.toString().c_str() );

			lp->newCol( col );
			num_vars++;
		}
	}

	return num_vars;
}


// c_{i,d,s,oft}
int SolverMIP::cria_preVariavel_aloca_alunos_oferta( int campusId )
{
	int num_vars = 0;
	
	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
	    
		if ( cp->getId() != campusId )
	    {
		   continue;
	    }

		ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *it_disc;
					
					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion

					// Listando todas as ofertas que contem uma disciplina especificada.
					GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ disciplina->getId() ];

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{
							 Oferta* oft = *itOferta;

							 if ( oft->campus != cp )
								 continue;

							 // Calculando P_{d,o}
							 int qtdDem = 0;
							 ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
							 {
								if ( itDem->disciplina->getId() == disciplina->getId() &&
								   itDem->getOfertaId() == itOferta->getId() )
								{
								   qtdDem += itDem->getQuantidade();
								}
							 }

							 if ( qtdDem <= 0 )
							 {
								continue;
							 }

							 for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							 {
								VariablePre v;
								v.reset();
								v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT );

								v.setTurma( turma );               // i
								v.setDisciplina( disciplina );     // d
								v.setOferta( *itOferta );          // oft
								v.setUnidade( *itUnidade );		   // u
								v.setSubCjtSala( *itCjtSala );	   // s
								
								if ( vHashPre.find(v) == vHashPre.end() )
								{
									vHashPre[v] = lp->getNumCols();
									
									double coef = 0.0;
									if ( problemData->parametros->funcao_objetivo == 0 )
									{
										coef = -1.0;
									}
									else if ( problemData->parametros->funcao_objetivo == 1 )
									{
										coef = 1.0;
									}
									
									double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;
									
									OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, 1.0,
										( char * )v.toString().c_str() );

									lp->newCol( col );

									num_vars += 1;
								}
							}
				     }
				}
			}
		}
   }

	return num_vars;
}

// s_{i,d,a,cp}
int SolverMIP::cria_preVariavel_aloca_aluno_turma_disc( int campusId )
{
	int num_vars = 0;

	Campus *cp = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( disciplina );
				v.setTurma( turma );
				v.setCampus( cp );

				if ( vHashPre.find( v ) == vHashPre.end() )
				{
					vHashPre[v] = lp->getNumCols();

					double coef = 0.0;
					double lowerBound = this->fixaLimiteInferiorVariavelPre( &v ) - 0.001;

					OPT_COL col( OPT_COL::VAR_BINARY, coef, lowerBound, 1.0, ( char * )v.toString().c_str() );

					lp->newCol( col );
					num_vars++;
				}
			}
		}
	}

	return num_vars;
}



// fpi_{a}
int SolverMIP::cria_preVariavel_folga_prioridade_inf( int campusId, int prior )
{
	int num_vars = 0;

	if ( prior < 2 )
	   return num_vars;

	Campus *cp = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		VariablePre v;
		v.reset();
		v.setType( VariablePre::V_PRE_SLACK_PRIOR_INF );
		v.setAluno( aluno );
		v.setCampus( cp );

		if ( vHashPre.find( v ) == vHashPre.end() )
		{
			vHashPre[v] = lp->getNumCols();					

			double lowerBound = 0.0;
			double upperBound = 0.0;
			int totalCreditos = 0;

			ITERA_GGROUP_LESSPTR( itAlunoDem, aluno->demandas, AlunoDemanda )
			{
				if ( itAlunoDem->getPrioridade() != prior )
					continue;

				int nCreds = itAlunoDem->demanda->disciplina->getTotalCreditos();
				int tempo = itAlunoDem->demanda->disciplina->getTempoCredSemanaLetiva();
				totalCreditos += nCreds;

				upperBound += nCreds*tempo;
			}
			
			double coef = 0.0;
			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				double custo = cp->getCusto();
							 
				coef = -50 * custo * totalCreditos;
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				double custo = cp->getCusto();

				coef = 5 * custo * totalCreditos;
			}	

			OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

			lp->newCol( col );
			num_vars++;
		}
	}

	return num_vars;
}

// fps_{a}
int SolverMIP::cria_preVariavel_folga_prioridade_sup( int campusId, int prior )
{
	int num_vars = 0;
	
	if ( prior < 2 )
	   return num_vars;

	Campus *cp = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		VariablePre v;
		v.reset();
		v.setType( VariablePre::V_PRE_SLACK_PRIOR_SUP );
		v.setAluno( aluno );
		v.setCampus( cp );

		if ( vHashPre.find( v ) == vHashPre.end() )
		{
			vHashPre[v] = lp->getNumCols();
				
			double lowerBound = 0.0;
			double upperBound = 0.0;
			int totalCreditos = 0;

			double cargaHorariaNaoAtendida = 0.0;
			ITERA_GGROUP_LESSPTR( itAlDemanda, problemData->listSlackDemandaAluno, AlunoDemanda )
			{
				if ( itAlDemanda->getAlunoId() == aluno->getAlunoId() &&
					 itAlDemanda->getPrioridade() == prior-1 )
				{
					int nCreds = itAlDemanda->demanda->disciplina->getTotalCreditos();
					int duracaoCred = itAlDemanda->demanda->disciplina->getTempoCredSemanaLetiva();
					totalCreditos += nCreds;

					cargaHorariaNaoAtendida += nCreds*duracaoCred;
				}
			}
						
			double coef = 0.0;
			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				double custo = cp->getCusto();
							 
				coef = -100 * custo * totalCreditos;
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				double custo = cp->getCusto();

				coef = 10 * custo * totalCreditos;
			}	

			upperBound = cargaHorariaNaoAtendida;

			OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, lowerBound, upperBound, ( char * )v.toString().c_str() );

			lp->newCol( col );
			num_vars++;
		}
	}

	return num_vars;
}

/********************************************************************
**                    Restrições do pre-Tatico                     **
*********************************************************************/

int SolverMIP::cria_preRestricoes( int campusId, int prioridade )
{
	int restricoes = 0;
	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_restricoes
	int numRestAnterior = 0;
#endif

	timer.start();
	restricoes += cria_preRestricao_carga_horaria( campusId );					// Restrição 1.1
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.1\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_max_cred_sala_sl( campusId );				// Restrição 1.2
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_ativacao_var_o( campusId );				// Restrição 1.3
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.3\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_evita_mudanca_de_sala( campusId );			// Restrição 1.4
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.4\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_aluno_curso_disc( campusId );				// Restrição 1.6
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.6\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_cap_sala( campusId );						// Restrição 1.7
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.7\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_compartilhamento_incompat( campusId );		// Restrição 1.8
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.8\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif    

	timer.start();
	restricoes += cria_preRestricao_proibe_compartilhamento( campusId );		// Restrição 1.9
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.9\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_ativacao_var_z( campusId );				// Restrição 1.10
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.10\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_evita_turma_disc_camp_d( campusId );		// Restrição 1.11
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.11\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_limita_abertura_turmas( campusId );		// Restrição 1.12
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.12\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_abre_turmas_em_sequencia( campusId );		// Restrição 1.13
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.13\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_turma_mesma_disc_oft_sala_dif( campusId );		// Restrição 1.14
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.14\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_preRestricao_limite_sup_creds_sala( campusId );		// Restrição 1.15
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.15\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

	timer.start();
	restricoes += cria_preRestricao_ativa_var_aloc_aluno_oft( campusId );		// Restrição 1.16
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.16\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif   

   if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
   {
		timer.start();
		restricoes += cria_preRestricao_cap_aloc_dem_disc_oft( campusId );				// Restrição 1.5
		timer.stop();
		dif = timer.getCronoCurrSecs();

	   #ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
	   #endif


		timer.start();
		restricoes += cria_preRestricao_fixa_nao_compartilhamento( campusId );				// Restrição 1.17
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.17\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif   
   }

   else if ( problemData->parametros->otimizarPor == "ALUNO" )
   {
		timer.start();
		restricoes += cria_preRestricao_cap_aloc_dem_disc_aluno( campusId );				// Restrição 1.5
		timer.stop();
		dif = timer.getCronoCurrSecs();

	   #ifdef PRINT_cria_restricoes
		std::cout << "numRest \"1.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
		numRestAnterior = restricoes;
	   #endif

		timer.start();
		restricoes += cria_preRestricao_atendimento_aluno( campusId );				// Restrição 1.18
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.18\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif   

	   /*
	   restricoes += cria_preRestricao_aluno_unica_turma_disc( campusId );		// Restrição 1.19

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.19\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif
		*/

		timer.start();
		restricoes += cria_preRestricao_aluno_discPraticaTeorica( campusId );		// Restrição 1.20
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.20\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif	   


		timer.start();
		restricoes += cria_preRestricao_prioridadesDemanda( campusId, prioridade );		// Restrição 1.21
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
	   std::cout << "numRest \"1.21\": " << (restricoes - numRestAnterior) << std::endl;
	   numRestAnterior = restricoes;
		#endif
	   

   }

	return restricoes;
}

// Restrição 1.1
int SolverMIP::cria_preRestricao_carga_horaria( int campusId )
{
   int restricoes = 0;
   int nnz;
   char name[ 100 ];

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( disciplina ) )
		 {
			 continue;
		 }
		 #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( ConstraintPre::C_PRE_CARGA_HORARIA );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHashPre.find( c ) != cHashPre.end() )
            {
               continue;
            }

			nnz = disciplina->getNSalasAptas();

            OPT_ROW row( nnz + 1, OPT_ROW::EQUAL , 0 , name );

            // ---

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
				    if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
					     itCjtSala->disciplinas_associadas.end() )
					{
						continue;
				    }

					v.reset();
					v.setType( VariablePre::V_PRE_CREDITOS );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );             

					it_v = vHashPre.find( v );
					if ( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
               }
            }

            // ---

            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );

            v.setCampus( *itCampus );
            v.setDisciplina( disciplina );
            v.setTurma( turma );

            it_v = vHashPre.find( v );
            if( it_v != vHashPre.end() )
            {
               row.insert( it_v->second, -( disciplina->getCredPraticos() + 
											disciplina->getCredTeoricos() ) );
            }

            // ---

            if ( row.getnnz() != 0 )
            {
               cHashPre[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

	return restricoes;
}

// Restrição 1.2
int SolverMIP::cria_preRestricao_max_cred_sala_sl( int campusId )
{
   int restricoes = 0;
   int nnz;
   char name[ 100 ];

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			ConstraintPre c;
			c.reset();
			c.setType( ConstraintPre::C_PRE_MAX_CRED_SALA );
			
			c.setUnidade( *itUnidade );
			c.setSubCjtSala( *itCjtSala );

			sprintf( name, "%s", c.toString().c_str() ); 
			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			double htps = itCjtSala->maxTempoPermitidoNaSemana( problemData->mapDiscSubstituidaPor ); 

			nnz = itCjtSala->disciplinas_associadas.size() * 5; // estimando em media 5 turmas por disciplina

			OPT_ROW row( nnz, OPT_ROW::LESS , htps, name );

            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disc );
			   
			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
			   {
					continue;
			   }
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                     VariablePre v;
                     v.reset();
                     v.setType( VariablePre::V_PRE_CREDITOS );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setUnidade( *itUnidade );     // u
                     v.setSubCjtSala( *itCjtSala );  // tps

					 it_v = vHashPre.find( v );
					 if ( it_v != vHashPre.end() )
					 {
						 row.insert( it_v->second, disciplina->getTempoCredSemanaLetiva() );
					 }       
                }
            }

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}
         }
      }
   }

	return restricoes;
}

// Restrição 1.3
int SolverMIP::cria_preRestricao_ativacao_var_o( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disc );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

                for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                {
					c.reset();
					c.setType( ConstraintPre::C_PRE_VAR_O );

					c.setUnidade( *itUnidade );
					c.setSubCjtSala( *itCjtSala );
					c.setDisciplina( disciplina );
					c.setTurma( turma );

					sprintf( name, "%s", c.toString().c_str() ); 
					if ( cHashPre.find( c ) != cHashPre.end() )
					{
						continue;
					}

					nnz = 2;

					OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

					v.reset();
					v.setType( VariablePre::V_PRE_OFERECIMENTO );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );

					it_v = vHashPre.find( v );
					if( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, - ( disciplina->getCredPraticos() + 
													  disciplina->getCredTeoricos() ) );
					}

					v.reset();
					v.setType( VariablePre::V_PRE_CREDITOS );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );

					it_v = vHashPre.find( v );
					if ( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, 1.0 );
					}

					if ( row.getnnz() != 0 )
					{
						cHashPre[ c ] = lp->getNumRows();

						lp->addRow( row );
						restricoes++;
					}
				}
            }
         }
      }
   }

	return restricoes;
}

// Restrição 1.4
int SolverMIP::cria_preRestricao_evita_mudanca_de_sala( int campusId )
{
   int restricoes = 0;
   int nnz;
   char name[ 100 ];

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( disciplina ) )
		 {
		 	 continue;
		 }
		 #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( ConstraintPre::C_EVITA_MUDANCA_DE_SALA );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHashPre.find( c ) != cHashPre.end() )
            {
               continue;
            }

			nnz = disciplina->getNSalasAptas();

            OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );
			
            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
				    if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
					     itCjtSala->disciplinas_associadas.end() )
					{
						continue;
				    }

					v.reset();
					v.setType( VariablePre::V_PRE_OFERECIMENTO );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );             

					it_v = vHashPre.find( v );
					if ( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
               }
            }
			
            if ( row.getnnz() != 0 )
            {
               cHashPre[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

// Restrição 1.5
/*
	Alocação de demanda por oferta
*/
int SolverMIP::cria_preRestricao_cap_aloc_dem_disc_oft( int campusId )
{
    int restricoes = 0;
    char name[ 100 ];
    int nnz = 0;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itOferta, problemData->ofertas, Oferta )
   {
	   if ( itOferta->getCampusId() != campusId )
	   {
			continue;
	   }

      map < Disciplina*, int, LessPtr< Disciplina > >::iterator itPrdDisc = 
         itOferta->curriculo->disciplinas_periodo.begin();

      for (; itPrdDisc != itOferta->curriculo->disciplinas_periodo.end(); itPrdDisc++ )
      {
		  disciplina = itPrdDisc->first;

         c.reset();
         c.setType( ConstraintPre::C_PRE_CAP_ALOC_DEM_DISC );

         c.setOferta( *itOferta );
         c.setDisciplina( disciplina );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHashPre.find( c ) != cHashPre.end() )
         {
            continue;
         }

         if ( disciplina->getNumTurmas() <= 0 )
         {
            continue;
         }

         nnz = disciplina->getNumTurmas();
         int rhs = 0;

         // Calculando P_{d,o}
         ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
         {
            if ( itDem->disciplina->getId() == disciplina->getId()
               && itDem->getOfertaId() == itOferta->getId() )
            {
               rhs += itDem->getQuantidade();
            }
         }

         OPT_ROW row( nnz , OPT_ROW::EQUAL, rhs , name );

		 ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
		 {
			if ( itCampus->getId() != campusId )
			{
				continue;
			}

			Campus* cp = *itCampus;
		
			ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
			{
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{
				    if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
					     itCjtSala->disciplinas_associadas.end() )
					{
						continue;
				    }
					
					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						v.reset();
						v.setType( VariablePre::V_PRE_ALUNOS );

						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setOferta( *itOferta );
						v.setUnidade( *itUnidade );
						v.setSubCjtSala( *itCjtSala );

						it_v = vHashPre.find( v );
						if ( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1.0 );
						}
					}
				}
			}
		 }

         v.reset();
         v.setType( VariablePre::V_PRE_SLACK_DEMANDA );
         v.setDisciplina( disciplina );
         v.setOferta( *itOferta );

         it_v = vHashPre.find( v );
         if( it_v != vHashPre.end() )
         {
            row.insert( it_v->second, 1.0 );
         }

         if ( row.getnnz() != 0 )
         {
            cHashPre[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

	return restricoes;
}

/*
	Alocação de demanda por aluno
*/
int SolverMIP::cria_preRestricao_cap_aloc_dem_disc_aluno( int campusId )
{
   int restricoes = 0;
      
   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;   

   Campus *campus = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = itAlDemanda->demanda->disciplina;

			c.reset();
			c.setType( ConstraintPre::C_PRE_CAP_ALOC_DEM_DISC );
			c.setAluno( aluno );
			c.setDisciplina( disciplina );
			c.setCampus( campus );

			sprintf( name, "%s", c.toString().c_str() ); 

			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			nnz = disciplina->getNumTurmas() + 1;

			OPT_ROW row( nnz, OPT_ROW::EQUAL , 1.0 , name );

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( disciplina );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			}

			v.reset();
			v.setType( VariablePre::V_PRE_SLACK_DEMANDA );
			v.setDisciplina( disciplina );
			v.setAluno( aluno );

			it_v = vHashPre.find( v );
			if( it_v != vHashPre.end() )
			{
				row.insert( it_v->second, 1.0 );
			}

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
	}

	return restricoes;
}


// Restrição 1.6
int SolverMIP::cria_preRestricao_aluno_curso_disc( int campusId )
{
	int restricoes = 0;

    char name[ 100 ];
    int nnz = 0;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
	{		
		Disciplina* disciplina = *itDisc;

		if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
			 problemData->cp_discs[ campusId ].end() )
		{
			continue;
		}

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion
										
		ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
		{
			Curso *curso = *itCurso;

			if ( !curso->possuiDisciplina( disciplina ) )
				continue;

			// Calculando P_{d,o}
			int qtdDem = 0;
			ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
			{
				if ( itDem->disciplina->getId() == disciplina->getId() &&
					 itDem->oferta->getCursoId() == curso->getId() &&
					 itDem->oferta->getCampusId() == campusId )
				{
					qtdDem += itDem->getQuantidade();
				}
			}

			if ( qtdDem <= 0 )
			{
				continue;
			}

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				// -------------------------------------------------
				c.reset();
				c.setType( ConstraintPre::C_ALUNO_OFT_DISC );

				c.setCurso( curso );
				c.setDisciplina( disciplina );
				c.setTurma( turma );

				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHashPre.find( c ) != cHashPre.end() )
				{
					continue;
				}
						 
				nnz = 100;

				OPT_ROW row( nnz , OPT_ROW::LESS, 0.0 , name );

				v.reset();
				v.setType( VariablePre::V_PRE_ALOC_ALUNO ); // b_{i,d,c}
				v.setTurma( turma );
				v.setDisciplina( disciplina );
				v.setCurso( curso );

				it_v = vHashPre.find(v);
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -qtdDem );
				}

				GGroup< Oferta*, LessPtr<Oferta> > ofertas = problemData->ofertasDisc[ disciplina->getId() ];

				ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
				{
					if ( itOferta->getCursoId() != curso->getId() )
						continue;

					if ( itOferta->campus->getId() != campusId )
						continue;

					ITERA_GGROUP_LESSPTR( itUnidade, itOferta->campus->unidades, Unidade )
					{
						ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
						{
							 if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
							 	  itCjtSala->disciplinas_associadas.end() )
							 {
								 continue;
							 }
						 
							 v.reset();
							 v.setType( VariablePre::V_PRE_ALUNOS ); // a_{i,d,oft,s}
							 v.setTurma( turma );
							 v.setDisciplina( disciplina );
							 v.setOferta( *itOferta );
							 v.setUnidade( *itUnidade );
							 v.setSubCjtSala( *itCjtSala );

							 it_v = vHashPre.find( v );
							 if ( it_v != vHashPre.end() )
							 {
						 		 row.insert( it_v->second, 1.0 );
							 }
						}
					}
				}

				if ( row.getnnz() != 0 )
				{
					cHashPre[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}				
				// -------------------------------------------------
		   }
       }
   }

	return restricoes;
}

// Restrição 1.7
int SolverMIP::cria_preRestricao_cap_sala( int campusId )
{
	int restricoes = 0;

    char name[ 100 ];
    int nnz = 0;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
			
		if ( cp->getId() != campusId )
		{
			continue;
		}

		GGroup< int > disciplinas = problemData->cp_discs[ cp->getId() ];
		
		// Para cada disciplina do campus
		ITERA_GGROUP_N_PT( itDisc, disciplinas, int )
		{
			 Disciplina *disciplina = problemData->refDisciplinas[ *itDisc ];

			 #pragma region Equivalencias
			 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
				  !problemData->ehSubstituta( disciplina ) )
			 {
			 	 continue;
			 }
			 #pragma endregion

			 ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
			 {
				// Para cada sala associada à disciplina
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{
					if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
						itCjtSala->disciplinas_associadas.end() )
					{
						continue;
					}

					// Para cada turma da disciplina
					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						c.reset();
						c.setType( ConstraintPre::C_CAP_SALA );

						c.setDisciplina( disciplina );
						c.setTurma( turma );
						c.setUnidade( *itUnidade );
						c.setSubCjtSala( *itCjtSala );

						sprintf( name, "%s", c.toString().c_str() ); 
						if ( cHashPre.find( c ) != cHashPre.end() )
						{
							continue;
						}
						 
						nnz = disciplina->getNumTurmas();

						OPT_ROW row( nnz , OPT_ROW::LESS, 0.0 , name );

						// Para cada oferta que contém a disciplina
						GGroup< Oferta*, LessPtr<Oferta> > ofertas = problemData->ofertasDisc[ disciplina->getId() ];

						ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
						{							
							 v.reset();
							 v.setType( VariablePre::V_PRE_ALUNOS );

							 v.setTurma( turma );
							 v.setDisciplina( disciplina );
							 v.setOferta( *itOferta );
							 v.setUnidade( *itUnidade );
							 v.setSubCjtSala( *itCjtSala );

							 it_v = vHashPre.find( v );
							 if ( it_v != vHashPre.end() )
							 {
						 		 row.insert( it_v->second, 1.0 );
							 }

						}						

						v.reset();
						v.setType( VariablePre::V_PRE_OFERECIMENTO );

						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setSubCjtSala( *itCjtSala );
						v.setUnidade( *itUnidade ); 

						it_v = vHashPre.find(v);
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, -itCjtSala->capTotalSalas() );
						}

						if ( row.getnnz() != 0 )
						{
							cHashPre[ c ] = lp->getNumRows();

							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}
   }

	return restricoes;
}

// Restrição 1.8
int SolverMIP::cria_preRestricao_compartilhamento_incompat( int campusId )
{
       int restricoes = 0;
       char name[ 100 ];
       int nnz;

	   ConstraintPre c;
	   VariablePre v;
	   VariablePreHash::iterator it_v;	
	   Campus *cp = NULL;

	   cp = problemData->refCampus[ campusId ];

	   if ( cp==NULL )
	   {
		   std::cout<<"\nATENCAO: SolverMIP::cria_preRestricao_compartilhamento_incompat( int campusId ): ";
		   std::cout<<"\nCampus" << campusId << "nao encontrado.\n";
		   return restricoes;
	   }

	   ITERA_GGROUP_LESSPTR( itCurso1, cp->cursos, Curso )
	   {
		   Curso* c1 = *itCurso1;

		   ITERA_GGROUP_INIC_LESSPTR( itCurso2, itCurso1, cp->cursos, Curso )
		   {
				Curso* c2 = *itCurso2;
				
			    if ( problemData->cursosCompativeis(c1, c2) || c1 == c2 )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
						 problemData->cp_discs[ campusId ].end() )
					{
						continue;
					}

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion
										
					if ( !c1->possuiDisciplina( disciplina ) ||
						 !c2->possuiDisciplina( disciplina ) )
						continue;

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						c.reset();
						c.setType( ConstraintPre::C_PRE_ALUNOS_CURSOS_INCOMP );
						c.setParCursos( std::make_pair( c1, c2 ) );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHashPre.find( c ) != cHashPre.end() )
						{
							continue;
						}

						nnz = 3;

						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

						v.reset();
						v.setType( VariablePre::V_PRE_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c1 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1 );
						}

						v.reset();
						v.setType( VariablePre::V_PRE_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c2 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert(it_v->second, 1);
						}

						VariablePre v;
						v.reset();
						v.setType( VariablePre::V_PRE_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT );
						v.setTurma( turma );				
						v.setDisciplina( disciplina );  
						v.setParCursos( std::make_pair(c1, c2) );	

						it_v = vHashPre.find( v );
						if ( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, -1 );
						}

						if ( row.getnnz() != 0 )
						{
							cHashPre[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}

		return restricoes;
}

// Restrição 1.9
int SolverMIP::cria_preRestricao_proibe_compartilhamento( int campusId )
{
	int restricoes = 0;

    if ( problemData->parametros->permite_compartilhamento_turma_sel )
    {
	 	return restricoes;
    }

    char name[ 100 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;
	   
	Campus *cp = NULL;

	cp = problemData->refCampus[ campusId ];

	if ( cp==NULL )
	{
		 std::cout<<"\nATENCAO: SolverMIP::cria_preRestricao_compartilhamento_incompat( int campusId ): ";
		 std::cout<<"\nCampus" << campusId << "nao encontrado.\n";
		 return restricoes;
	}
	
	   ITERA_GGROUP_LESSPTR( itCurso1, cp->cursos, Curso )
	   {
		   Curso* c1 = *itCurso1;
		   
		   ITERA_GGROUP_INIC_LESSPTR( itCurso2, itCurso1, cp->cursos, Curso )
		   {
				Curso* c2 = *itCurso2;
			    
			    if ( !problemData->cursosCompativeis(c1, c2) || c1 == c2 )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
						 problemData->cp_discs[ campusId ].end() )
					{
						continue;
					}

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion
										
					if ( !c1->possuiDisciplina( disciplina ) ||
						 !c2->possuiDisciplina( disciplina ) )
						continue;
							
					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						c.reset();
						c.setType( ConstraintPre::C_PRE_PROIBE_COMPARTILHAMENTO );
						c.setParCursos( std::make_pair( c1, c2 ) );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHashPre.find( c ) != cHashPre.end() )
						{
							continue;
						}

						nnz = 3;

						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

						v.reset();
						v.setType( VariablePre::V_PRE_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c1 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, 1 );
						}

						v.reset();
						v.setType( VariablePre::V_PRE_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c2 );

						it_v = vHashPre.find( v );
						if( it_v != vHashPre.end() )
						{
							row.insert(it_v->second, 1);
						}

						VariablePre v;
						v.reset();
						v.setType( VariablePre::V_PRE_SLACK_COMPARTILHAMENTO );
						v.setTurma( turma );				
						v.setDisciplina( disciplina );  
						v.setParCursos( std::make_pair(c1, c2) );	

						it_v = vHashPre.find( v );
						if ( it_v != vHashPre.end() )
						{
							row.insert( it_v->second, -1 );
						}

						if ( row.getnnz() != 0 )
						{
							cHashPre[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}

		return restricoes;
}

// Restricao 1.10
int SolverMIP::cria_preRestricao_ativacao_var_z( int campusId )
{
	int restricoes = 0;
    char name[ 100 ];
    int nnz;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

   std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator it_CpDisc = problemData->cp_discs.begin();

   for ( ; it_CpDisc != problemData->cp_discs.end(); it_CpDisc++ )
   {
	  Campus *cp = problemData->refCampus[ it_CpDisc->first ];

	  if ( cp->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_disciplina, it_CpDisc->second, int )
      {
		 Disciplina *disciplina = problemData->refDisciplinas[ *it_disciplina ];

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
			  !problemData->ehSubstituta( disciplina ) )
		 {
		 	 continue;
		 }
		 #pragma endregion
		
		 double bigM = disciplina->getNSalasAptas();

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
			c.reset();
			c.setType( ConstraintPre::C_PRE_ATIVA_Z );
			c.setCampus( cp );
			c.setDisciplina( disciplina );
			c.setTurma( turma );

			sprintf( name, "%s", c.toString().c_str() ); 

			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			nnz = disciplina->getNSalasAptas() + 1;

			OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

            VariablePre v;
            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );
            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( cp );				// cp

			it_v = vHashPre.find( v );
			if ( it_v != vHashPre.end() )
			{
				row.insert( it_v->second, -bigM );
			}
			
			ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
			{
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{							
					if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
						itCjtSala->disciplinas_associadas.end() )
					{
						continue;
					}

                    VariablePre v;
                    v.reset();
                    v.setType( VariablePre::V_PRE_OFERECIMENTO );
                    v.setTurma( turma );            // i
                    v.setDisciplina( disciplina );  // d
                    v.setUnidade( *itUnidade );     // u
                    v.setSubCjtSala( *itCjtSala );  // tps

					it_v = vHashPre.find( v );
					if ( it_v != vHashPre.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
            
         }
      }
   }

   return restricoes;

}
   

// Restricao 1.11
int SolverMIP::cria_preRestricao_evita_turma_disc_camp_d( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
		   problemData->cp_discs[ campusId ].end() )
	  {
		  continue;
 	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion

      for ( int i = 0; i < disciplina->getNumTurmas(); ++i )
      {
         c.reset();
         c.setType( ConstraintPre::C_PRE_EVITA_TURMA_DISC_CAMP_D );

         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHashPre.find( c ) != cHashPre.end() )
         {
            continue;
         }

         nnz = problemData->totalSalas;
         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

         ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
         {
			if ( it_campus->getId() != campusId )
			{
				continue;
			}

            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );

            v.setTurma( i );
            v.setDisciplina( disciplina );
            v.setCampus( *it_campus );

            it_v = vHashPre.find( v );
            if( it_v != vHashPre.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         if ( row.getnnz() != 0 )
         {
            cHashPre[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}   
   
// Restricao 1.12
int SolverMIP::cria_preRestricao_limita_abertura_turmas( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;
   int min;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   if ( problemData->parametros->min_alunos_abertura_turmas )
   {
		min = problemData->parametros->min_alunos_abertura_turmas_value;
		if ( min <= 0 ) min = 1;
   }
   else
   {
	   min = 1;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  if ( itCampus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );
	  
		 if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
			  problemData->cp_discs[ campusId ].end() )
		 {
			 continue;
 		 }

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			  continue;
		 }
		 #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( ConstraintPre::C_PRE_LIMITA_ABERTURA_TURMAS );

            c.setCampus( *itCampus );
            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHashPre.find( c ) != cHashPre.end() )
            {
               continue;
            }

			nnz = 1 + disciplina->getNSalasAptas() * problemData->ofertasDisc[ disciplina->getId() ].size();
            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

            v.reset();
            v.setType( VariablePre::V_PRE_ABERTURA );

            v.setTurma( turma );
            v.setDisciplina( disciplina );
            v.setCampus( *itCampus );

            it_v = vHashPre.find( v );
            if ( it_v != vHashPre.end() )
            {
               row.insert( it_v->second, min );
            }

            // ---

			ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
			{
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
				{							
					if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
						itCjtSala->disciplinas_associadas.end() )
					{
						continue;
					}

					GGroup< Oferta *, LessPtr< Oferta > > ofertas =
					problemData->ofertasDisc[ disciplina->getId() ];
					
					ITERA_GGROUP_LESSPTR( itOft, ofertas, Oferta )
					{
					   if ( itOft->campus->getId() == itCampus->getId() )
					   {            
						  v.reset();
						  v.setType( VariablePre::V_PRE_ALUNOS );

						  v.setTurma( turma );
						  v.setDisciplina( disciplina );
						  v.setOferta( *itOft );
						  v.setUnidade( *itUnidade );
						  v.setSubCjtSala( *itCjtSala );

						  it_v = vHashPre.find( v );
						  if ( it_v != vHashPre.end() )
						  {
							 row.insert( it_v->second, -1.0 );
						  }
					   }
					}
				}
			}

            if ( row.getnnz() != 0 )
            {
               cHashPre[ c ] = lp->getNumRows();
               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}
   
// Restricao 1.13
int SolverMIP::cria_preRestricao_abre_turmas_em_sequencia( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  if ( problemData->cp_discs[ campusId ].find( disciplina->getId() ) ==
		   problemData->cp_discs[ campusId ].end() )
	  {
		  continue;
 	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion

      if ( disciplina->getNumTurmas() > 1 )
      {
         for ( int turma = 0; turma < ( disciplina->getNumTurmas() - 1 ); turma++ )
         {
            c.reset();
            c.setType( ConstraintPre::C_PRE_ABRE_TURMAS_EM_SEQUENCIA );

            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() ); 
            if ( cHashPre.find( c ) != cHashPre.end() )
            {
               continue;
            }

			nnz = 2*disciplina->getNSalasAptas();
            OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0, name );

            ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
            {
				if ( itCampus->getId() != campusId )
				{
					continue;
				}

               ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                        v.reset();
                        v.setType( VariablePre::V_PRE_OFERECIMENTO );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );

                        it_v = vHashPre.find( v );
                        if ( it_v != vHashPre.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        v.reset();
                        v.setType( VariablePre::V_PRE_OFERECIMENTO );

                        int turmaSuc = turma + 1;
                        v.setTurma(turmaSuc);
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );

                        it_v = vHashPre.find( v );
                        if ( it_v != vHashPre.end() )
                        {
                           row.insert( it_v->second, -1.0 );
                        }
                  }
               }
            }

            if ( row.getnnz() != 0 )
            {
               cHashPre[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}


// Restrição 1.14
int SolverMIP::cria_preRestricao_turma_mesma_disc_oft_sala_dif( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;
				
		if ( cp->getId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					  Disciplina* disciplina = ( *itDisc );
					  
					  #pragma region Equivalencias
					  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						     problemData->mapDiscSubstituidaPor.end() ) &&
						   !problemData->ehSubstituta( disciplina ) )
					  {
						  continue;
					  }
					  #pragma endregion
					  
					  if ( disciplina->getNumTurmas() > 1 )
					  {
							// Listando todas as ofertas que contem uma disciplina especificada.
							GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ disciplina->getId() ];

							ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
							{
								  Oferta* oft = *itOferta;

								  if ( oft->campus != cp )
									  continue;

								  // Calculando P_{d,o}
								  int qtdDem = 0;
								  ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
								  {
										if ( itDem->disciplina->getId() == disciplina->getId() &&
											 itDem->getOfertaId() == itOferta->getId() )
										{
											qtdDem += itDem->getQuantidade();
										}
								  }

								  if ( qtdDem <= 0 )
								  {
										continue;
								  }

								  c.reset();
								  c.setType( ConstraintPre::C_PRE_TURMA_MESMA_DISC_OFT_SALA_DIF );

								  c.setDisciplina( disciplina );
								  c.setUnidade( *itUnidade );
								  c.setSubCjtSala( *itCjtSala );
								  c.setOferta( oft );

								  sprintf( name, "%s", c.toString().c_str() ); 
								  if ( cHashPre.find( c ) != cHashPre.end() )
								  {
									  continue;
								  }

								  nnz = disciplina->getNumTurmas() + 1;

								  OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
						  
								  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
								  {
										v.reset();
										v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT);
										v.setTurma( turma );
										v.setDisciplina( *itDisc );
										v.setUnidade( *itUnidade );
										v.setSubCjtSala( *itCjtSala );
										v.setOferta( oft );

										it_v = vHashPre.find( v );
										if ( it_v != vHashPre.end() )
										{
										   row.insert( it_v->second, 1.0 );
										}
								  }

								  v.reset();
								  v.setType( VariablePre::V_PRE_SLACK_SALA);
								  v.setDisciplina( *itDisc );
								  v.setUnidade( *itUnidade );
								  v.setSubCjtSala( *itCjtSala );
								  v.setOferta( oft );

								  it_v = vHashPre.find( v );
								  if ( it_v != vHashPre.end() )
								  {
									  row.insert( it_v->second, -1.0 );
								  }

								  if ( row.getnnz() != 0 )
								  {
									 cHashPre[ c ] = lp->getNumRows();

  									 lp->addRow( row );
									 restricoes++;
								  }
							  }
					  }
				}
			}
		}
	}

	return restricoes;
}

// Restrição 1.15
int SolverMIP::cria_preRestricao_limite_sup_creds_sala( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   VariablePre v;
   ConstraintPre c;
   VariablePreHash::iterator it_v;

   Disciplina * disciplina = NULL;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				// --------------------------------------------------------
				c.reset();
				c.setType( ConstraintPre::C_PRE_LIM_SUP_CREDS_SALA );
				c.setCampus( *itCampus );
				c.setUnidade( *itUnidade );
				c.setSubCjtSala( *itCjtSala );

				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHashPre.find( c ) != cHashPre.end() )
				{
					continue;
				}

				nnz = 100 + 1;

				OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );
						  
				v.reset();
				v.setType( VariablePre::V_PRE_LIM_SUP_CREDS_SALA);
				v.setCampus( *itCampus );

				it_v = vHashPre.find( v );
				if ( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -1.0 );
				}

				ITERA_GGROUP_LESSPTR( itDisc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					  Disciplina* disciplina = ( *itDisc );
					  
					  #pragma region Equivalencias
					  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						     problemData->mapDiscSubstituidaPor.end() ) &&
						   !problemData->ehSubstituta( disciplina ) )
					  {
							continue;
					  }
					  #pragma endregion
					  
					  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					  {
						  v.reset();
						  v.setType( VariablePre::V_PRE_CREDITOS);
						  v.setUnidade( *itUnidade );
						  v.setSubCjtSala( *itCjtSala );
						  v.setDisciplina( disciplina );
						  v.setTurma( turma );

						  it_v = vHashPre.find( v );
						  if ( it_v != vHashPre.end() )
						  {
							  row.insert( it_v->second, 1.0 );
						  }
					  }
				}

				if ( row.getnnz() != 0 )
				{
					cHashPre[ c ] = lp->getNumRows();

  					lp->addRow( row );
					restricoes++;
				}
				// --------------------------------------------------------
			}
		}
	}

	return restricoes;
}

// Restricao 1.16
int SolverMIP::cria_preRestricao_ativa_var_aloc_aluno_oft( int campusId )
{
    int restricoes = 0;
    char name[ 100 ];
    int nnz;

    VariablePre v;
    ConstraintPre c;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;
    
	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus* cp = *itCampus;

		if ( cp->getId() != campusId )
		{
			continue;
		}
		
		ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
		{
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
				{
					Disciplina* disciplina = *it_disc;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						   problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion

					// Listando todas as ofertas que contem uma disciplina especificada.
					GGroup< Oferta *, LessPtr< Oferta > > ofertas = problemData->ofertasDisc[ it_disc->getId() ];

					ITERA_GGROUP_LESSPTR( itOferta, ofertas, Oferta )
					{
							 Oferta* oft = *itOferta;

							 if ( oft->campus != cp )
								 continue;

							 // Calculando P_{d,o}
							 int qtdDem = 0;
							 ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
							 {
								if ( itDem->disciplina->getId() == disciplina->getId() &&
								   itDem->getOfertaId() == itOferta->getId() )
								{
								   qtdDem += itDem->getQuantidade();
								}
							 }

							 if ( qtdDem <= 0 )
							 {
								continue;
							 }

							 for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							 {
								// --------------------------------------------------------
								c.reset();
								c.setType( ConstraintPre::C_PRE_ATIVA_C );
								c.setCampus( *itCampus );
								c.setTurma( turma );
								c.setDisciplina( disciplina );
								c.setUnidade( *itUnidade );
								c.setSubCjtSala( *itCjtSala );
								c.setOferta( oft );

								sprintf( name, "%s", c.toString().c_str() ); 
								if ( cHashPre.find( c ) != cHashPre.end() )
								{
									continue;
								}

								nnz = 2;

								OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

								// variavel a_{i,d,oft,s}
								v.reset();
								v.setType( VariablePre::V_PRE_ALUNOS );
								v.setTurma( turma );               // i
								v.setDisciplina( disciplina );     // d
								v.setOferta( *itOferta );          // oft
								v.setUnidade( *itUnidade );		   // u
								v.setSubCjtSala( *itCjtSala );	   // s
								
								it_v = vHashPre.find( v );
								if ( it_v != vHashPre.end() )
								{
									row.insert( it_v->second, 1.0 );
								}

								// variavel c_{i,d,oft,s}
								v.reset();
								v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT );
								v.setTurma( turma );               // i
								v.setDisciplina( disciplina );     // d
								v.setOferta( *itOferta );          // oft
								v.setUnidade( *itUnidade );		   // u
								v.setSubCjtSala( *itCjtSala );	   // s
								
								it_v = vHashPre.find( v );
								if ( it_v != vHashPre.end() )
								{
									row.insert( it_v->second, -qtdDem );
								}

								// insere constraint
								if ( row.getnnz() != 0 )
								{
									cHashPre[ c ] = lp->getNumRows();

  									lp->addRow( row );
									restricoes++;
								}
								// --------------------------------------------------------
							}
				     }
				}
			}
		}
   }

	return restricoes;
}


// Restricao 1.17
int SolverMIP::cria_preRestricao_fixa_nao_compartilhamento( int campusId )
{
   int restricoes = 0;

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() < 2 )
   {
	   return restricoes;
   }   
   
   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;
   
   // para cada campus
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus *cp = *itCampus;

	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

	   // para cada par de cursos compativeis
	   std::map< std::pair< Curso *, Curso * >, std::vector< int > >::iterator
               it_cursoComp_disc = problemData->cursosComp_disc.begin();
        for (; it_cursoComp_disc != problemData->cursosComp_disc.end(); it_cursoComp_disc++ )
        {
			Curso* c1 = it_cursoComp_disc->first.first;
			Curso* c2 = it_cursoComp_disc->first.second;
			
			// para cada disciplina em comum (possivel de ser compartilhada) ao par de cursos
            std::vector< int >::iterator it_discComum = it_cursoComp_disc->second.begin();
            for (; it_discComum != it_cursoComp_disc->second.end(); ++it_discComum )
            {
				Disciplina * discComum = problemData->retornaDisciplina( *it_discComum );
				  
				if (discComum == NULL) continue;

				#pragma region Equivalência de disciplinas
				if ( ( problemData->mapDiscSubstituidaPor.find( discComum ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( discComum ) )
				{
					continue;
				}
				#pragma endregion
				
				GGroup<Oferta*, LessPtr<Oferta>> ofts1 = cp->retornaOfertasComCursoDisc( c1->getId(), discComum );
				GGroup<Oferta*, LessPtr<Oferta>> ofts2 = cp->retornaOfertasComCursoDisc( c2->getId(), discComum );

				// para cada oferta contendo discComum do curso c1
				ITERA_GGROUP_LESSPTR( itOft1, ofts1, Oferta )
				{
					Oferta *oft1 = *itOft1;
					int periodo1 = oft1->periodoDisciplina( discComum );

					if ( oft1->getCampusId() != campusId )
					{
						continue;
					}

					// para cada oferta contendo discComum do curso c2
					ITERA_GGROUP_LESSPTR( itOft2, ofts2, Oferta )
					{
						Oferta *oft2 = *itOft2;
						int periodo2 = oft2->periodoDisciplina( discComum );

						if ( oft2->getId() == oft1->getId() )
						{
							continue;
						}
						if ( oft2->getCampusId() != campusId )
						{
							continue;
						}

						// Cria a restrição somente para períodos que possuem mais de uma semana letiva, ou sl's diferentes
						if ( oft1->curriculo->retornaSemanasLetivasNoPeriodo( periodo1 ).size() == 1 &&
							 oft2->curriculo->retornaSemanasLetivasNoPeriodo( periodo2 ).size() == 1 &&
							 oft1->curriculo->retornaSemanasLetivasNoPeriodo( periodo1 ).begin()->getId() ==
							 oft2->curriculo->retornaSemanasLetivasNoPeriodo( periodo2 ).begin()->getId() )
						{
							continue;
						}

						// para cada turma da disciplina em comum
						for ( int turma = 0; turma < discComum->getNumTurmas(); turma++ )
						{
							c.reset();
							c.setType( ConstraintPre::C_PRE_FIXA_NAO_COMPARTILHAMENTO );
							c.setParOfertas( std::make_pair(oft1, oft2) );
							c.setDisciplina( discComum );
							c.setTurma( turma );

							sprintf( name, "%s", c.toString().c_str() ); 

							if ( cHashPre.find( c ) != cHashPre.end() )
							{
								continue;
							}

							nnz = 300;

							OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

							ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
							{
								ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
								{
									if ( itCjtSala->disciplinas_associadas.find( discComum ) ==
										 itCjtSala->disciplinas_associadas.end() )
										continue;

									v.reset();
									v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT );
									v.setTurma( turma );
									v.setDisciplina( discComum );
									v.setOferta( oft1 );
									v.setSubCjtSala( *itCjtSala );
									v.setUnidade( *itUnidade );

									it_v = vHashPre.find( v );
									if( it_v != vHashPre.end() )
									{
										row.insert( it_v->second, 1 );
									}

									v.reset();
									v.setType( VariablePre::V_PRE_ALOC_ALUNO_OFT );
									v.setTurma( turma );
									v.setDisciplina( discComum );
									v.setOferta( oft2 );
									v.setSubCjtSala( *itCjtSala );
									v.setUnidade( *itUnidade );

									it_v = vHashPre.find( v );
									if( it_v != vHashPre.end() )
									{
										row.insert( it_v->second, 1 );
									}
								}
							}
								
							if ( row.getnnz() != 0 )
							{
								cHashPre[ c ] = lp->getNumRows();
								lp->addRow( row );
								restricoes++;
							}
						}
					}
				}
			}
		}
   }

   return restricoes;

}


// Restricao 1.18
/*
    Metodo somente utilizado para o modelo Tatico_Aluno

	Define qual aluno foi atendido em cada atendimento feito.
*/
int SolverMIP::cria_preRestricao_atendimento_aluno( int campusId )
{
    int restricoes = 0;
   
    char name[ 100 ];
    int nnz = 0;

    ConstraintPre c;
    VariablePre v;
    VariablePreHash::iterator it_v;

    Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itOferta, problemData->ofertas, Oferta )
   {
	   Oferta *oferta = *itOferta;

	   if ( oferta->getCampusId() != campusId )
	   {
			continue;
	   }

       map < Disciplina*, int, LessPtr< Disciplina > >::iterator itPrdDisc = 
         oferta->curriculo->disciplinas_periodo.begin();

      for (; itPrdDisc != oferta->curriculo->disciplinas_periodo.end(); itPrdDisc++ )
      {
		  disciplina = itPrdDisc->first;

		  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
		  {
				 c.reset();
				 c.setType( ConstraintPre::C_ATENDIMENTO_ALUNO );

				 c.setOferta( oferta );
				 c.setDisciplina( disciplina );
				 c.setTurma( turma );

				 sprintf( name, "%s", c.toString().c_str() ); 
				 if ( cHashPre.find( c ) != cHashPre.end() )
				 {
					continue;
				 }
				 
				 nnz = 50;
				 
				 OPT_ROW row( nnz , OPT_ROW::EQUAL, 0.0 , name );

				 ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
				 {
					 Aluno *aluno = *itAluno;

					 if ( aluno->getOferta() != oferta )
					 {
						continue;
					 }

					 if ( !aluno->demandaDisciplina( disciplina->getId() ) )
					 {
						continue;
					 }

					 v.reset();
					 v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
					 v.setTurma( turma );
					 v.setDisciplina( disciplina );
					 v.setAluno( aluno );
					 v.setCampus( oferta->campus );

					 it_v = vHashPre.find( v );
					 if ( it_v != vHashPre.end() )
					 {
						 row.insert( it_v->second, -1.0 );
					 }
				 }

				 ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
				 {
					if ( itCampus->getId() != campusId )
					{
						continue;
					}
							
					ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
					{
						ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
						{
							if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
								 itCjtSala->disciplinas_associadas.end() )
							{
								continue;
							}
			
							v.reset();
							v.setType( VariablePre::V_PRE_ALUNOS );
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setOferta( oferta );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );

							it_v = vHashPre.find( v );
							if ( it_v != vHashPre.end() )
							{
								row.insert( it_v->second, 1.0 );
							}
						}
					}
				 }

				 if ( row.getnnz() != 0 )
				 {
					cHashPre[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				 }
		  }
      }
   }

	return restricoes;
}


// Restricao 1.19
/*
    Metodo somente utilizado para o modelo Tatico_Aluno
   
	Garante que cada aluno esteja em apenas 1 turma de uma disciplina
*/
int SolverMIP::cria_preRestricao_aluno_unica_turma_disc( int campusId )
{
   int restricoes = 0;
      
   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;   

   Campus *campus = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = itAlDemanda->demanda->disciplina;

			c.reset();
			c.setType( ConstraintPre::C_ALUNO_UNICA_TURMA_DISC );
			c.setAluno( aluno );
			c.setDisciplina( disciplina );
			c.setCampus( campus );

			sprintf( name, "%s", c.toString().c_str() ); 

			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			nnz = disciplina->getNumTurmas();

			OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( disciplina );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
	}

	return restricoes;
}


// Restricao 1.20
int SolverMIP::cria_preRestricao_aluno_discPraticaTeorica( int campusId )
{
   int restricoes = 0;
      
   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;   

   Campus *campus = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *discPratica = itAlDemanda->demanda->disciplina;
			
			// Pula disciplina teorica
			if ( discPratica->getId() > 0 )
				continue;

			Disciplina *discTeorica = problemData->refDisciplinas[ - discPratica->getId() ];

			if ( discTeorica == NULL )
			{
				std::cout<<"\nErro em cria_preRestricao_aluno_discPraticaTeorica: disciplina teorica nao encontrada.\n";
				continue;
			}
			
			c.reset();
			c.setType( ConstraintPre::C_ALUNO_DISC_PRATICA_TEORICA );
			c.setAluno( aluno );
			c.setDisciplina( discPratica );
			c.setCampus( campus );

			sprintf( name, "%s", c.toString().c_str() ); 

			if ( cHashPre.find( c ) != cHashPre.end() )
			{
				continue;
			}

			nnz = discPratica->getNumTurmas() + discTeorica->getNumTurmas() + 1;

			OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

			for ( int turma = 0; turma < discPratica->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( discPratica );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			}

			for ( int turma = 0; turma < discTeorica->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( discTeorica );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					row.insert( it_v->second, -1.0 );
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHashPre[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
	}

	return restricoes;

}

// Restricao 1.21
int SolverMIP::cria_preRestricao_prioridadesDemanda( int campusId, int prior )
{
   int restricoes = 0;

   if ( prior < 2 )
	   return restricoes;

   char name[ 200 ];
   int nnz;

   ConstraintPre c;
   VariablePre v;
   VariablePreHash::iterator it_v;   

   Campus *campus = problemData->refCampus[campusId];

	ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
	{
		Aluno *aluno = *itAluno;

		if ( aluno->getOferta()->getCampusId() != campusId )
		{
			continue;
		}
			
		c.reset();
		c.setType( ConstraintPre::C_ALUNO_PRIORIDADES_DEMANDA );
		c.setAluno( aluno );
		c.setCampus( campus );

		sprintf( name, "%s", c.toString().c_str() ); 

		if ( cHashPre.find( c ) != cHashPre.end() )
		{
			continue;
		}

		nnz = aluno->demandas.size()*3 + 2;
		
		double cargaHorariaNaoAtendida = 0.0;
		ITERA_GGROUP_LESSPTR( itAlDemanda, problemData->listSlackDemandaAluno, AlunoDemanda )
		{
			if ( itAlDemanda->getPrioridade() != prior-1 )
				continue;

			if ( itAlDemanda->getAlunoId() == aluno->getAlunoId() )
			{
				int nCreds = itAlDemanda->demanda->disciplina->getTotalCreditos();
				int duracaoCred = itAlDemanda->demanda->disciplina->getTempoCredSemanaLetiva();

				cargaHorariaNaoAtendida += nCreds*duracaoCred;
			}
		}

		OPT_ROW row( nnz, OPT_ROW::EQUAL , cargaHorariaNaoAtendida, name );
		
		ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
		{
			Disciplina *disciplina = itAlDemanda->demanda->disciplina;

			if ( itAlDemanda->getPrioridade() != prior )
				continue;

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				VariablePre v;
				v.reset();
				v.setType( VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC );
				v.setAluno( aluno );
				v.setDisciplina( disciplina );
				v.setTurma( turma );
				v.setCampus( campus );

				it_v = vHashPre.find( v );
				if( it_v != vHashPre.end() )
				{
					double tempo = disciplina->getTotalCreditos() * disciplina->getTempoCredSemanaLetiva();

					row.insert( it_v->second, tempo );
				}
			}
		}

		VariablePre v;
		v.reset();
		v.setType( VariablePre::V_PRE_SLACK_PRIOR_INF );
		v.setAluno( aluno );
		v.setCampus( campus );
		it_v = vHashPre.find( v );
		if( it_v != vHashPre.end() )
		{
			row.insert( it_v->second, -1.0 );
		}

		v.reset();
		v.setType( VariablePre::V_PRE_SLACK_PRIOR_SUP );
		v.setAluno( aluno );
		v.setCampus( campus );
		it_v = vHashPre.find( v );
		if( it_v != vHashPre.end() )
		{
			row.insert( it_v->second, 1.0 );
		}


		if ( row.getnnz() >= 3 )
		{
			cHashPre[ c ] = lp->getNumRows();
			lp->addRow( row );
			restricoes++;
		}
	}

	return restricoes;

}

#pragma endregion PRE-TATICO



/*----------------------------------------------------------------------------------
**					TATICO POR BLOCO OU
					TATICO POR ALUNO SEM HORARIOS						          **
----------------------------------------------------------------------------------*/

#pragma region TATICO POR BLOCO OU POR ALUNO SEM HORARIOS
/*
		VARIAVEIS TATICO POR BLOCO CURRICULAR
*/

int SolverMIP::cria_variaveis( int campusId )
{
	int num_vars = 0;
	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_variaveis
	int numVarsAnterior = 0;
#endif

	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_oferecimentos( campusId ); // variável 'o'
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_oferecimentos_permitir_alunos_varios_campi(); // variavel o

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"o\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	//if (!problemData->parametros->permitir_alunos_em_varios_campi)
	//{
	timer.start();
	num_vars += cria_variavel_creditos( campusId ); // x
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//}
	//else
	//{
	//   num_vars += cria_variavel_creditos_permitir_alunos_varios_campi(); // x
	//}

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"x\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_abertura( campusId ); // z
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_abertura_permitir_alunos_varios_campi(); // z

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"z\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_alunos( campusId ); // a
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"a\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_consecutivos( campusId ); // c
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"c\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif



	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_aloc_disciplina( campusId ); // y
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_aloc_disciplina_permitir_alunos_varios_campi(); // y

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"y\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	//if (!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_aloc_alunos( campusId ); // b
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_aloc_alunos_permitir_alunos_varios_campi(); // b

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"b\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_de_folga_dist_cred_dia_superior( campusId ); // fcp
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_de_folga_dist_cred_dia_superior_permitir_alunos_varios_campi(); // fcp

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fcp\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_de_folga_dist_cred_dia_inferior( campusId ); // fcm
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_de_folga_dist_cred_dia_inferior_permitir_alunos_varios_campi(); // fcm

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fcm\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_de_folga_aloc_alunos_curso_incompat( campusId ); // bs
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_de_folga_aloc_alunos_curso_incompat_permitir_alunos_varios_campi(); // bs

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"bs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_de_folga_demanda_disciplina( campusId ); // fd
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_combinacao_divisao_credito( campusId ); // m
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"m\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_de_folga_combinacao_divisao_credito( campusId ); // fk
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fk\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	/*
	//if(problemData->parametros->permitir_alunos_em_varios_campi)
	num_vars += cria_variavel_creditos_modificada(); // xm
	//else
	//   num_vars += cria_variavel_creditos_modificada_permitir_alunos_varios_campi(); // xm


	#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"xm\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
	#endif
	*/
	timer.start();
	num_vars += cria_variavel_abertura_compativel( campusId ); // zc
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"zc\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	/* // "n" não está sendo usado.
	//  A restrição que a usaria tem uma msg de erro de modelagem. Pode ser que tenha sido consertado. 
	timer.start();
	num_vars += cria_variavel_abertura_bloco_mesmoTPS(); // n
	timer.stop();
	dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"n\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
	#endif

	*/
	/*
	timer.start();
	num_vars += cria_variavel_de_folga_abertura_bloco_mesmoTPS(); // fn
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fn\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	*/
	timer.start();
	num_vars += cria_variavel_de_folga_compartilhamento( campusId ); // fc
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fn\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_maxCreds_combina_sl_sala( campusId ); // cs
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"cs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif   

	timer.start();
	num_vars += cria_variavel_max_creds( campusId ); // H
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"H\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_min_creds( campusId ); // h
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"h\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_num_subblocos( campusId ); // w
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"w\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_num_abertura_turma_bloco( campusId ); // v
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"v\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_abertura_subbloco_de_blc_dia_campus( campusId ); // r
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"r\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_aloc_alunos_oft( campusId ); // e
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"e\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_creditos_oferta( campusId ); // q
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"q\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_aloc_alunos_parOft( campusId ); // of
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"of\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_creditos_parOferta( campusId ); // p
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"p\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_min_hor_disc_oft_dia( campusId ); // g
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"g\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_maxCreds_combina_Sl_bloco( campusId ); // cbc
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"cbc\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	return num_vars;
}


/*
	Novo modelo tatico - aluno - sem horarios

	VARIAVEIS TATICO POR ALUNO E SEM HORARIOS
*/
int SolverMIP::cria_variaveis_aluno_sh( int campusId )
{
	int num_vars = 0;
	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_variaveis
	int numVarsAnterior = 0;
#endif

	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_oferecimentos( campusId ); // variável 'o'
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_oferecimentos_permitir_alunos_varios_campi(); // variavel o

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"o\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	//if (!problemData->parametros->permitir_alunos_em_varios_campi)
	//{
	timer.start();
	num_vars += cria_variavel_creditos( campusId ); // x
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//}
	//else
	//{
	//   num_vars += cria_variavel_creditos_permitir_alunos_varios_campi(); // x
	//}

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"x\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_abertura( campusId ); // z
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_abertura_permitir_alunos_varios_campi(); // z

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"z\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_consecutivos( campusId ); // c
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"c\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif
	

	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_de_folga_dist_cred_dia_superior( campusId ); // fcp
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_de_folga_dist_cred_dia_superior_permitir_alunos_varios_campi(); // fcp

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fcp\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	//if(!problemData->parametros->permitir_alunos_em_varios_campi)
	timer.start();
	num_vars += cria_variavel_de_folga_dist_cred_dia_inferior( campusId ); // fcm
	timer.stop();
	dif = timer.getCronoCurrSecs();
	//else
	//   num_vars += cria_variavel_de_folga_dist_cred_dia_inferior_permitir_alunos_varios_campi(); // fcm

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fcm\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif


	timer.start();
	num_vars += cria_variavel_de_folga_demanda_disciplina_aluno( campusId ); // fd
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_combinacao_divisao_credito( campusId ); // m
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"m\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_de_folga_combinacao_divisao_credito( campusId ); // fk
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"fk\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_abertura_compativel( campusId ); // zc
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"zc\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_maxCreds_combina_sl_sala( campusId ); // cs
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"cs\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif   

	timer.start();
	num_vars += cria_variavel_maxCreds_combina_Sl_aluno( campusId ); // ca
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"ca\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_max_creds_aluno( campusId ); // H
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"H\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_min_creds_aluno( campusId ); // h
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"h\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	timer.start();
	num_vars += cria_variavel_folgafolga_demanda_p_t( campusId ); // ffd
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_variaveis
	std::cout << "numVars \"ffd\": " << (num_vars - numVarsAnterior)  <<" "<<dif <<" sec" << std::endl;
	numVarsAnterior = num_vars;
#endif

	return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var x_{i,d,u,tps,t}

%Desc 
número de créditos da turma $i$ da disciplina $d$ na unidade $u$ 
em salas do tipo (capacidade) $tps$ no dia $t$. 

%ObjCoef
\theta \cdot \sum\limits_{u \in U}\sum\limits_{tps \in SCAP_{u}} 
\sum\limits_{d \in D}\sum\limits_{t \in T}
\sum\limits_{i \in I_{d}} x_{i,d,u,tps,t}

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_creditos( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disc );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos
                     = itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiscSala_Dias = dias_letivos.begin();

                  for (; itDiscSala_Dias != dias_letivos.end(); itDiscSala_Dias++ )
                  {
                     Variable v;
                     v.reset();
                     v.setType( Variable::V_CREDITOS );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setUnidade( *itUnidade );     // u
                     v.setSubCjtSala( *itCjtSala );  // tps  
                     v.setDia( *itDiscSala_Dias );   // t

                     if ( problemData->parametros->modo_otimizacao == "OPERACIONAL" )
                     {
                        double custo = 0.0;

                        if ( problemData->usarProfDispDiscTatico )
                        {
                           if ( problemData->disc_Dias_Prof_Tatico[ v.getDisciplina()->getId() ].find( v.getDia() )
                                 == problemData->disc_Dias_Prof_Tatico[ v.getDisciplina()->getId() ].end() )
                           {
                              custo = 100.0;
                           }
                        }

                        if ( vHash.find( v ) == vHash.end() )
                        {
                           vHash[ v ] = lp->getNumCols();

                           if ( problemData->parametros->funcao_objetivo == 0 )
                           {
                              OPT_COL col( OPT_COL::VAR_INTEGRAL, custo, 0.0,
								  itCjtSala->maxCredsDiaPorSL( *itDiscSala_Dias, v.getDisciplina()->getCalendario() ),
                                 ( char * )v.toString().c_str() );

                              lp->newCol( col );
                           }
                           else if ( problemData->parametros->funcao_objetivo == 1
                              || problemData->parametros->funcao_objetivo == 2 )
                           {
                              OPT_COL col( OPT_COL::VAR_INTEGRAL, 0.0, 0.0,
								  itCjtSala->maxCredsDiaPorSL( *itDiscSala_Dias, v.getDisciplina()->getCalendario() ),
                                 ( char * )v.toString().c_str() );

                              lp->newCol( col );
                           }

                           num_vars++;
                        }
                     }
                     else
                     {
                        if ( vHash.find( v ) == vHash.end() )
                        {
						   if ( !criaVariavelTatico( &v ) )
								continue;

                           double custo = 0.0;

                           if ( problemData->usarProfDispDiscTatico )
                           {
                              if ( problemData->disc_Dias_Prof_Tatico[ v.getDisciplina()->getId() ].find( v.getDia() )
                                    == problemData->disc_Dias_Prof_Tatico[ v.getDisciplina()->getId() ].end() )
                              {
                                 custo = 100.0;
                              }
                           }

                           vHash[ v ] = lp->getNumCols();
						   
						   double coef = 0.0;

						   if ( problemData->parametros->funcao_objetivo == 0 )
						   {							
								coef = -1.0;
						   }
						   else if ( problemData->parametros->funcao_objetivo == 1 )
						   {
								coef = 1.0;
						   }

                           OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0,
                                        itCjtSala->maxCredsDiaPorSL( *itDiscSala_Dias, v.getDisciplina()->getCalendario() ),
                                        ( char * )v.toString().c_str() );
                          
						   lp->newCol( col );						 
						  
                        }

                        num_vars++;
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}



//int SolverMIP::cria_variavel_creditos_permitir_alunos_varios_campi(void)
//{
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
//   {
//      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
//      {
//         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
//         {
//            ITERA_GGROUP_LESSPTR( it_discisciplina, itCjtSala->disciplinas_associadas, Disciplina )
//            {
//               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//               {
//                  disciplina = ( *it_discisciplina );
//
//                  int idDisc = disciplina->getId();
//
//                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
//                  GGroup< int > dias_letivos =
//                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];
//
//                  GGroup< int >::iterator itDiscSala_Dias = dias_letivos.begin();
//                  for (; itDiscSala_Dias != dias_letivos.end(); itDiscSala_Dias++ )
//                  {
//                     std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator itCPDiscs =
//                        problemData->cp_discs.begin();
//                     for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//                     {
//                        GGroup< int >::iterator it_disc = itCPDiscs->second.begin();
//                        for (; it_disc != itCPDiscs->second.end(); it_disc++ )
//                        {
//                           if ( ( itCampus->getId() == itCPDiscs->first )
//                              && ( disciplina->getId() == ( *it_disc ) ) )
//                           {
//                              Variable v;
//                              v.reset();
//                              v.setType( Variable::V_CREDITOS );
//
//                              v.setTurma( turma );            // i
//                              v.setDisciplina( disciplina );  // d
//                              v.setUnidade( *itUnidade );     // u
//                              v.setSubCjtSala( *itCjtSala );  // tps  
//                              v.setDia( *itDiscSala_Dias );   // t
//
//                              if ( problemData->parametros->modo_otimizacao == "OPERACIONAL" )
//                              {
//                                 ITERA_GGROUP_LESSPTR( it_prof, itCampus->professores, Professor )
//                                 {
//                                    std::pair< int /*idProf*/ , int /*idDisc*/ > prof_Disc 
//                                       ( it_prof->getId(), disciplina->getId() );
//
//                                    if ( problemData->prof_Disc_Dias.find( prof_Disc )
//                                       != problemData->prof_Disc_Dias.end() )
//                                    {
//                                       eta = 0;
//                                    }
//                                    else
//                                    {
//                                       eta = 10;
//                                    }
//
//                                    if ( vHash.find( v ) == vHash.end() )
//                                    {
//                                       vHash[ v ] = lp->getNumCols();
//
//                                       if ( problemData->parametros->funcao_objetivo == 0 )
//                                       {
//                                          OPT_COL col( OPT_COL::VAR_INTEGRAL, eta, 0.0,
//                                             itCjtSala->maxCredsDia( *itDiscSala_Dias ),
//                                             ( char * )v.toString().c_str() );
//
//                                          lp->newCol( col );
//                                       }
//                                       else if ( problemData->parametros->funcao_objetivo == 1 ||
//                                          problemData->parametros->funcao_objetivo == 2 )
//                                       {
//                                          OPT_COL col( OPT_COL::VAR_INTEGRAL,0.0,0.0,
//                                             itCjtSala->maxCredsDia( *itDiscSala_Dias ),
//                                             ( char * )v.toString().c_str() );
//
//                                          lp->newCol( col );
//                                       }
//
//                                       num_vars += 1;
//                                    }
//                                 }
//                              }
//                              else
//                              {
//                                 if ( vHash.find(v) == vHash.end() )
//                                 {
//                                    vHash[v] = lp->getNumCols();
//
//                                    OPT_COL col( OPT_COL::VAR_INTEGRAL,0.0,0.0,
//                                       itCjtSala->maxCredsDia( *itDiscSala_Dias ),
//                                       ( char* )v.toString().c_str() );
//
//                                    lp->newCol( col );
//                                 }
//
//                                 num_vars += 1;
//                              }
//                           }
//                        }
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var o_{i,d,u,tps,t} 

%Desc 
indica se a turma $i$ da disciplina $d$ foi alocada na unidade $u$ 
para alguma sala do tipo (capacidade) $tps$ no dia $t$.

%DocEnd
/====================================================================*/


int SolverMIP::cria_variavel_oferecimentos( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos =
                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiscSala_Dias = dias_letivos.begin();

                  for (; itDiscSala_Dias != dias_letivos.end(); itDiscSala_Dias++ )
                  {
                     Variable v;
                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setUnidade( *itUnidade );     // u
                     v.setSubCjtSala( *itCjtSala );  // tps  
                     v.setDia( *itDiscSala_Dias );   // t

                     if ( vHash.find( v ) == vHash.end() )
                     {
						if ( !criaVariavelTatico( &v ) )
							continue;

                        vHash[ v ] = lp->getNumCols();

                        OPT_COL col( OPT_COL::VAR_BINARY, 0.0, 0.0, 1.0,
                           ( char * )v.toString().c_str());

                        lp->newCol( col );
                        num_vars++;
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

//int SolverMIP::cria_variavel_oferecimentos_permitir_alunos_varios_campi(void)
//{
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
//   {
//      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
//      {
//         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
//         {
//            ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
//            {
//               disciplina = ( *it_disciplina );
//
//               std::pair< Curso *, Curriculo * > curso_curriculo
//                  = problemData->map_Disc_CursoCurriculo[ disciplina ];
//               curso = curso_curriculo.first;
//               curriculo = curso_curriculo.second;
//
//               disciplina_equivalente = problemData->retornaDisciplinaSubstituta( curso, curriculo, disciplina );
//               if ( disciplina_equivalente != NULL )
//               {
//                  disciplina = disciplina_equivalente;
//               }
//
//               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//               {
//                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
//                  GGroup< int > dias_letivos =
//                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];
//
//                  GGroup< int >::iterator itDiscSala_Dias = dias_letivos.begin();
//
//                  for (; itDiscSala_Dias != dias_letivos.end(); itDiscSala_Dias++ )
//                  {
//                     std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator
//                        itCPDiscs = problemData->cp_discs.begin();
//                     for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//                     {
//                        GGroup< int >::iterator it_disc
//                           = itCPDiscs->second.begin();
//                        for (; it_disc != itCPDiscs->second.end(); it_disc++ )
//                        {
//                           if ( ( itCampus->getId() == itCPDiscs->first )
//                              && ( disciplina->getId() == ( *it_disc ) ) )
//                           {
//                              Variable v;
//                              v.reset();
//                              v.setType( Variable::V_OFERECIMENTO );
//
//                              v.setTurma( turma );            // i
//                              v.setDisciplina( disciplina );  // d
//                              v.setUnidade( *itUnidade );     // u
//                              v.setSubCjtSala( *itCjtSala );  // tps  
//                              v.setDia( *itDiscSala_Dias );   // t
//
//                              if ( vHash.find(v) == vHash.end() )
//                              {
//                                 vHash[v] = lp->getNumCols();
//
//                                 OPT_COL col( OPT_COL::VAR_BINARY, 0.0, 0.0, 1.0,
//                                    ( char* )v.toString().c_str() );
//
//                                 lp->newCol( col );
//
//                                 num_vars += 1;
//                              }								 
//                           }
//                        }
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var z_{i,d,cp} 

%Desc 
indica se houve abertura da $i$-ésima turma da disciplina $d$ no campus $cp$.

%ObjCoef

\alpha \cdot \sum\limits_{d \in D} \sum\limits_{cp \in CP}\sum\limits_{i \in I_{d}}z_{i,d,cp}
+ \gamma \cdot \sum\limits_{d \in D} \sum\limits_{cp \in CP}\sum\limits_{i \in I_{d}}
\left(\frac{Pmax_{d} - \sum\limits_{c \in C}P_{d,c,cp}}{Pmax_{d}} \right) \cdot z_{i,d,cp}

%Data Pmax_{d} 
%Desc
maior demanda da disciplina $d$.

%Data P_{d,c,cp} 
%Desc
demanda da disciplina $d$ no campus $cp$ para o curso $c$.

%Data \alpha
%Desc
peso associado a função objetivo.

%Data \gamma
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_abertura( int campusId )
{
   int num_vars = 0;

   // Pode ser implementado de uma maneira melhor, listando
   // apenas as disciplinas que podem ser abertas em um campus
   // (atraves do OFERTACURSO) e criando as suas respectivas
   // variaveis. Desse modo, variaveis desnecessárias (relacionadas
   // à disciplinas que não existem em outros campus) seriam evitadas.
   // VER <demandas_campus> em <ProblemData>

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			continue;
		 }

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_ABERTURA );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( *it_campus );	    // cp

            std::pair< int, int > dc
               = std::make_pair( disciplina->getId(), it_campus->getId() );

            if ( problemData->demandas_campus.find( dc )
               == problemData->demandas_campus.end() )
            {
               problemData->demandas_campus[ dc ] = 0;
            }
			/*
            double ratioDem = ( disciplina->getDemandaTotal() - 
               problemData->demandas_campus[ dc ] ) 
               / (1.0 * disciplina->getDemandaTotal() );

            double coeff = alpha + gamma * ratioDem;

            int numCreditos = ( disciplina->getCredTeoricos() + disciplina->getCredPraticos() );
            double valorCredito = 1600.0;
            double coef_FO_1_2 = ( numCreditos * valorCredito );
			*/
            if ( vHash.find(v) == vHash.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               lp->getNumCols();
               vHash[v] = lp->getNumCols();
			   /*
               if ( problemData->parametros->funcao_objetivo == 0 )
               {
                  OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
                     ( char * )v.toString().c_str() );

                  lp->newCol( col );
               }
               else if ( problemData->parametros->funcao_objetivo == 1 )
               {
                  OPT_COL col( OPT_COL::VAR_BINARY, -coef_FO_1_2, 0.0, 1.0,
                     ( char * )v.toString().c_str() );

                  lp->newCol( col );
               }
               else if ( problemData->parametros->funcao_objetivo == 2 )
               {
                  OPT_COL col( OPT_COL::VAR_BINARY, coef_FO_1_2, 0.0, 1.0,
                     ( char * )v.toString().c_str() );

                  lp->newCol( col );
               }*/

			   double coef = 0.0;

			   OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0, ( char * )v.toString().c_str() );

               lp->newCol( col );

               num_vars++;
            }
         }
      }
   }

   return num_vars;
}

//int SolverMIP::cria_variavel_abertura_permitir_alunos_varios_campi()
//{
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
//   {
//      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
//      {
//         disciplina = ( *it_disciplina );
//
//         std::pair< Curso *, Curriculo * > curso_curriculo
//            = problemData->map_Disc_CursoCurriculo[ disciplina ];
//         curso = curso_curriculo.first;
//         curriculo = curso_curriculo.second;
//
//         disciplina_equivalente = problemData->retornaDisciplinaSubstituta( curso, curriculo, disciplina );
//         if ( disciplina_equivalente != NULL )
//         {
//            disciplina = disciplina_equivalente;
//         }
//
//         std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator itCPDiscs =
//            problemData->cp_discs.begin();
//         for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//         {
//            GGroup< int >::iterator itDisc = itCPDiscs->second.begin();
//            for (; itDisc != itCPDiscs->second.end(); itDisc++ )
//            {
//               if( ( it_campus->getId() == itCPDiscs->first )
//                  && ( disciplina->getId() == ( *itDisc ) ) )
//               {
//                  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//                  {
//                     Variable v;
//                     v.reset();
//                     v.setType( Variable::V_ABERTURA );
//
//                     v.setTurma( turma );            // i
//                     v.setDisciplina( disciplina );  // d
//                     v.setCampus( *it_campus );	    // cp
//
//                     std::pair< int, int > dc = std::make_pair
//                        ( disciplina->getId(), it_campus->getId() );
//
//                     if ( problemData->demandas_campus.find( dc )
//                        == problemData->demandas_campus.end() )
//                     {
//                        problemData->demandas_campus[ dc ] = 0;
//                     }
//
//                     double ratioDem = ( disciplina->getDemandaTotal() -
//                        problemData->demandas_campus[ dc ] )
//                        / (1.0 * disciplina->getDemandaTotal() );
//
//                     double coeff = alpha + gamma * ratioDem;
//
//                     int numCreditos = ( disciplina->getCredTeoricos() + disciplina->getCredPraticos() );
//                     double valorCredito = 1600.0;
//                     double coef_FO_1_2 = numCreditos * valorCredito;
//
//                     if ( vHash.find(v) == vHash.end() )
//                     {
//                        lp->getNumCols();
//                        vHash[v] = lp->getNumCols();
//
//                        if ( problemData->parametros->funcao_objetivo == 0 )
//                        {
//                           OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
//                              ( char* )v.toString().c_str() );
//
//                           lp->newCol( col );
//                        }
//                        else if( problemData->parametros->funcao_objetivo == 1 )
//                        {
//                           OPT_COL col( OPT_COL::VAR_BINARY, -coef_FO_1_2, 0.0, 1.0,
//                              ( char* )v.toString().c_str() );
//
//                           lp->newCol( col );
//                        }
//                        else if( problemData->parametros->funcao_objetivo == 2 )
//                        {
//                           OPT_COL col( OPT_COL::VAR_BINARY, coef_FO_1_2, 0.0, 1.0,
//                              ( char* )v.toString().c_str() );
//
//                           lp->newCol( col );
//                        }
//
//                        num_vars += 1;
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var a_{i,d,oft}

%Desc 
número de alunos de uma oferta $oft$ alocados para a $i$-ésima turma da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_alunos( int campusId )
{
   int total_Vars = 0;
   int num_vars = 0;
   
   ITERA_GGROUP_LESSPTR( itOferta, problemData->ofertas, Oferta )
   {
	   if ( itOferta->getCampusId() != campusId )
	   {
		   continue;
	   }

      map < Disciplina*, int, LessPtr< Disciplina > >::iterator itPrdDisc = 
         itOferta->curriculo->disciplinas_periodo.begin();
      for(; itPrdDisc != itOferta->curriculo->disciplinas_periodo.end();
         itPrdDisc++ )
      {
		  Disciplina * ptDisc = itPrdDisc->first;

		  #pragma region Equivalencias
		  if ( ( problemData->mapDiscSubstituidaPor.find( ptDisc ) !=
				 problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( ptDisc ) )
		  {
			  continue;
		  }
		  #pragma endregion

         // Calculando P_{d,o}
         int qtdDem = 0;
         ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
         {
            if ( itDem->disciplina->getId() == ptDisc->getId() &&
               itDem->getOfertaId() == itOferta->getId() )
            {
               qtdDem += itDem->getQuantidade();
            }
         }

         if ( qtdDem <= 0 )
         {
            continue;
         }

         for ( int turma = 0; turma < ptDisc->getNumTurmas(); turma++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_ALUNOS );

            v.setTurma( turma );               // i
            v.setDisciplina( ptDisc );         // d
            v.setOferta( *itOferta );          // oft

            if ( vHash.find(v) == vHash.end() )
            {
			    if ( !criaVariavelTatico( &v ) )
					continue;

                vHash[v] = lp->getNumCols();

				double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					double valorCredito = itOferta->getReceita();
					int numCreditos = ptDisc->getTotalCreditos();
				
					coef = 10.0 * numCreditos * valorCredito;
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 0.0;
				}

                OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, qtdDem,
                     ( char * )v.toString().c_str() );

                lp->newCol( col );

                num_vars += 1;
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var b_{i,d,c,cp} 

%Desc 
indica se algum aluno do curso $c$ foi alocado para a $i$-ésima turma da disciplina $d$ no campus $cp$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_aloc_alunos( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_Oferta, problemData->ofertas, Oferta )
   {
      Campus * pt_Campus = it_Oferta->campus;
      Curso * pt_Curso = it_Oferta->curso;

	   if ( pt_Campus->getId() != campusId )
	   {
		   continue;
	   }

      map < Disciplina*, int, LessPtr< Disciplina > >::iterator it_Prd_Disc = 
         it_Oferta->curriculo->disciplinas_periodo.begin();
      for(; it_Prd_Disc != it_Oferta->curriculo->disciplinas_periodo.end();
         it_Prd_Disc++ )
      {
		  disciplina = it_Prd_Disc->first;

		  #pragma region Equivalencias
		  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				 problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		  {
			  continue;
		  }
		  #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_ALOC_ALUNO );

            v.setTurma( turma );           // i
            v.setDisciplina( disciplina ); // d
            v.setCurso( pt_Curso );        // c
            v.setCampus( pt_Campus );	    // cp

            if ( vHash.find( v ) == vHash.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               vHash[v] = lp->getNumCols();
				
			   double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					coef = -1.0;
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 1.0;
				}

               OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0,
                  ( char * )v.toString().c_str() );

               lp->newCol( col );
               num_vars++;
            }
         }
      }
   }

   return num_vars;
}

//int SolverMIP::cria_variavel_aloc_alunos_permitir_alunos_varios_campi( void )
//{
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( it_Oferta, problemData->ofertas, Oferta )
//   {
//      Campus * pt_Campus = it_Oferta->campus;
//      Curso * pt_Curso = it_Oferta->curso;
//
//      GGroup< std::pair< int, Disciplina * > >::iterator it_Prd_Disc = 
//         it_Oferta->curriculo->disciplinas_periodo.begin();
//
//      for (; it_Prd_Disc != it_Oferta->curriculo->disciplinas_periodo.end();
//         it_Prd_Disc++ )
//      {
//         disciplina = ( *it_Prd_Disc ).second;
//
//         std::pair< Curso *, Curriculo * > curso_curriculo
//            = problemData->map_Disc_CursoCurriculo[ disciplina ];
//
//         curso = curso_curriculo.first;
//         curriculo = curso_curriculo.second;
//
//         disciplina_equivalente = problemData->retornaDisciplinaSubstituta( curso, curriculo, disciplina );
//         if ( disciplina_equivalente != NULL )
//         {
//            disciplina = disciplina_equivalente;
//         }
//
//         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//         {
//            // Id do Campus --> Ids das Disciplinas
//            std::map< int , GGroup< int >  >::iterator itCPDiscs =
//               problemData->cp_discs.begin();
//
//            for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//            {
//               GGroup< int >::iterator it_disc
//                  = itCPDiscs->second.begin();
//
//               for (; it_disc != itCPDiscs->second.end(); it_disc++ )
//               {
//                  if( ( pt_Campus->getId() == itCPDiscs->first )
//                     && ( disciplina->getId() == ( *it_disc ) ) )
//                  {
//                     Variable v;
//                     v.reset();
//                     v.setType( Variable::V_ALOC_ALUNO );
//
//                     v.setTurma( turma );           // i
//                     v.setDisciplina( disciplina ); // d
//                     v.setCurso( pt_Curso );        // c
//                     v.setCampus( pt_Campus );	   // cp
//
//                     if ( vHash.find( v ) == vHash.end() )
//                     {
//                        vHash[ v ] = lp->getNumCols();
//
//                        OPT_COL col( OPT_COL::VAR_BINARY, 0, 0.0, 1.0,
//                           ( char * )v.toString().c_str() );
//
//                        lp->newCol( col );
//                        num_vars += 1;
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var c_{i,d,t} 

%Desc 
indica se houve abertura de turma $i$ da disciplina $d$ em dias consecutivos.

%ObjCoef
\delta \cdot \sum\limits_{d \in D} 
\sum\limits_{i \in I_{d}} \sum\limits_{t \in T-{1}} c_{i,d,t}

%Data \delta
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_consecutivos( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	  if ( it_campus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( it_unidade, it_campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_conjunto_sala, it_unidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, it_conjunto_sala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos
                     = it_conjunto_sala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     Variable v;
                     v.reset();
                     v.setType( Variable::V_DIAS_CONSECUTIVOS );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );     // t
					 v.setCampus( *it_campus );		 // cp

                     if ( vHash.find( v ) == vHash.end() )
                     {
						if ( !criaVariavelTatico( &v ) )
							continue;

                        vHash[v] = lp->getNumCols();
					    
						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{
							coef = -1.0;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{
							coef = 1.0;
						}
                           
						OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0, ( char * )v.toString().c_str() );
						                           
						lp->newCol( col );

                        num_vars++;
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var \underline{h}_{bc,i} 

%Desc 
mínimo de créditos alocados na semana na $i$-ésima turma do bloco $bc$.
%ObjCoef
\lambda \cdot \sum\limits_{bc \in B} 
\sum\limits_{i \in I_{d}, d \in D_{bc}} \left( \overline{h}_{bc,i} - \underline{h}_{bc,i} \right)

%Data \underline{H_{d}} 
%Desc
mínimo de créditos diários da disciplina $d$.

%Data \lambda
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_min_creds( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	  if ( it_bloco->campus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( it_disciplina, it_bloco->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );
		
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			  continue;
		 }
		 #pragma endregion

         for ( int i = 0; i < disciplina->getNumTurmas(); i++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_MIN_CRED_SEMANA );

            v.setBloco( *it_bloco );
            v.setTurma( i );

            if ( vHash.find( v ) == vHash.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               vHash[ v ] = lp->getNumCols();
                  
			   double obj = 0.0;

               if ( problemData->parametros->funcao_objetivo == 0 )
               {
                  if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
                  {
					  obj = it_bloco->campus->getCusto()/4;
                  }
                  else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
                  {
                     obj = it_bloco->campus->getCusto()/4;
                  }
               }
               else if ( problemData->parametros->funcao_objetivo == 1 )
               {
                  if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
                  {
                     obj = it_bloco->campus->getCusto()/4;
                  }
                  else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
                  {
                     obj = it_bloco->campus->getCusto()/4;
                  }
               }
               
			   OPT_COL col( OPT_COL::VAR_INTEGRAL, obj, 0.0, 1000.0, ( char * )v.toString().c_str() );

               lp->newCol( col );

               num_vars++;
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var \overline{h}_{bc,i} 

%Desc 
máximo de créditos alocados na semana na $i$-ésima turma do bloco $bc$.

%Data \overline{H_{d}} 
%Desc
máximo de créditos diários da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_max_creds( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	  if ( it_bloco->campus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( it_disciplina, it_bloco->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		  #pragma region Equivalencias
		  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				 problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		  {
			  continue;
		  }
		  #pragma endregion

         for ( int i = 0; i < disciplina->getNumTurmas(); i++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_MAX_CRED_SEMANA );

            v.setBloco( *it_bloco );
            v.setTurma( i );

            if ( vHash.find( v ) == vHash.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               vHash[v] = lp->getNumCols();

			   double obj = 0.0;

               if ( problemData->parametros->funcao_objetivo == 0 )
               {
                  if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
                  {
					  obj = -it_bloco->campus->getCusto()/4;
                  }
                  else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
                  {
                      obj = 0.0;
                  }
               }
               else if ( problemData->parametros->funcao_objetivo == 1 )
               {
                  if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
                  {
                      obj = -it_bloco->campus->getCusto()/4;
                  }
                  else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
                  {
                      obj = 0.0;
                  }
               }
               
			   OPT_COL col( OPT_COL::VAR_INTEGRAL, obj, 0.0, 1000.0, ( char * )v.toString().c_str() );

               lp->newCol( col );

               num_vars++;
            }
         }
      }
   }
   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var y_{i,d,tps,u} 

%Desc 
indica que a turma $i$ da disciplina $d$ foi alocada em alguma sala do tipo $tps$ da unidade $u$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_aloc_disciplina( int campusId )
{
   // Poderia criar as variaveis apenas qdo a
   // disciplina for compativel com a sala. Por
   // exemplo, não criar uma variável qdo a disciplina
   // demanda horarios que a sala não dispõe.

   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  if ( itCampus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  Variable v;
                  v.reset();
                  v.setType( Variable::V_ALOC_DISCIPLINA );

                  v.setTurma( turma );            // i
                  v.setDisciplina( disciplina );  // d
                  v.setSubCjtSala( *itCjtSala );  // tps
                  v.setUnidade( *itUnidade );     // u

                  if ( vHash.find( v ) == vHash.end() )
                  {
					 if ( !criaVariavelTatico( &v ) )
						continue;

                     vHash[v] = lp->getNumCols();

                     OPT_COL col( OPT_COL::VAR_BINARY, 0.0, 0.0, 1.0,
                        ( char * )v.toString().c_str() );

                     lp->newCol( col );
                     num_vars++;
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

//int SolverMIP::cria_variavel_aloc_disciplina_permitir_alunos_varios_campi( void )
//{
//   // Poderia criar as variaveis apenas qdo a disciplina
//   // for compativel com a sala. Por exemplo, não criar
//   // uma variável qdo a disciplia demanda horarios que a sala não dispõe.
//
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
//   {
//      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
//      {
//         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
//         {
//            ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
//            {
//               disciplina = ( *it_disciplina );
//
//               std::pair< Curso *, Curriculo * > curso_curriculo
//                  = problemData->map_Disc_CursoCurriculo[ disciplina ];
//               curso = curso_curriculo.first;
//               curriculo = curso_curriculo.second;
//
//               disciplina_equivalente = problemData->retornaDisciplinaSubstituta( curso, curriculo, disciplina );
//               if ( disciplina_equivalente != NULL )
//               {
//                  disciplina = disciplina_equivalente;
//               }
//
//               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//               {
//                  std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator
//                     itCPDiscs = problemData->cp_discs.begin();
//
//                  for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//                  {
//                     GGroup< int >::iterator it_disc = itCPDiscs->second.begin();
//
//                     for (; it_disc != itCPDiscs->second.end(); it_disc++ )
//                     {
//                        if ( ( itCampus->getId() == itCPDiscs->first )
//                           && ( disciplina->getId() == ( *it_disc ) ) )
//                        {
//                           Variable v;
//                           v.reset();
//                           v.setType( Variable::V_ALOC_DISCIPLINA );
//
//                           v.setTurma( turma );            // i
//                           v.setDisciplina( disciplina );  // d
//                           v.setSubCjtSala( *itCjtSala );  // tps
//                           v.setUnidade( *itUnidade );     // u
//
//                           if ( vHash.find( v ) == vHash.end() )
//                           {
//                              vHash[v] = lp->getNumCols();
//
//                              OPT_COL col( OPT_COL::VAR_BINARY, 0.0, 0.0, 1.0,
//                                 ( char * )v.toString().c_str() );
//
//                              lp->newCol( col );
//                              num_vars++;
//                           }
//                        }
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var w_{bc,t,cp}  

%Desc 
indica o número sub-blocos abertos do bloco curricular $bc$ no dia $t$ no campus $cp$.
%ObjCoef
\rho \cdot \sum\limits_{bc \in B}\sum\limits_{t \in T} (\sum\limits_{cp \in CP} w_{bc,t,cp})

%Data \rho
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_num_subblocos( int campusId )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
      Campus * campus = it_bloco->campus;
	  
	  if ( campus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_N_PT( it_Dias_Letivos, problemData->bloco_Campus_Dias
         [ std::make_pair( it_bloco->getId(), campus->getId() ) ], int )
      {
         Variable v;
         v.reset();
         v.setType( Variable::V_N_SUBBLOCOS );

         v.setBloco( *it_bloco );
         v.setDia( *it_Dias_Letivos );
         v.setCampus( campus );

         if ( vHash.find( v ) == vHash.end() )
         {
			if ( !criaVariavelTatico( &v ) )
				continue;

            vHash[ v ] = lp->getNumCols();
			
			double coef = 0.0;

            if ( problemData->parametros->funcao_objetivo == 0 )
            {
				coef = -1.0;
            }
            else if ( problemData->parametros->funcao_objetivo == 1 )
            {
				coef = 1.0;
            }
            
			OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, 10,
               ( char * )v.toString().c_str() );
			               
			lp->newCol( col );

            num_vars++;
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var v_{bc,t} 

%Desc 
contabiliza a abertura do mesmo bloco curricular $bc$, no mesmo dia $t$, em campus distintos.
%ObjCoef
\beta \cdot \sum\limits_{bc \in B} \sum\limits_{t \in T} v_{b,t}

%Data \beta
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_num_abertura_turma_bloco( int campusId )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	  if ( it_bloco->campus->getId() != campusId )
	  {
		  continue;
	  }

      GGroup< int >::iterator itDiasLetBloco =
         it_bloco->diasLetivos.begin();

      for (; itDiasLetBloco != it_bloco->diasLetivos.end();
             itDiasLetBloco++ )
      {
         Variable v;
         v.reset();
         v.setType( Variable::V_N_ABERT_TURMA_BLOCO );

         v.setBloco( *it_bloco );
         v.setDia( *itDiasLetBloco );

         if ( vHash.find( v ) == vHash.end() )
         {
			if ( !criaVariavelTatico( &v ) )
				continue;

            vHash[v] = lp->getNumCols();
			
			double coef = 0.0;

            if ( problemData->parametros->funcao_objetivo == 0 )
            {
				coef = -1.0;
            }
            else if ( problemData->parametros->funcao_objetivo == 1 )
            {
				coef = 1.0;
            }
               
			OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0,
                 ( char * )v.toString().c_str() );
			                 
			lp->newCol( col );
			
            num_vars++;
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fcp_{d,t}

%Desc 
variável de folga superior para a restrição de fixação da distribuição de créditos por dia.
%ObjCoef
\xi \cdot \sum\limits_{d \in D} \sum\limits_{t \in T} fcp_{d,t}

%Data \xi
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_dist_cred_dia_superior( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	  if ( itCampus->getId() != campusId )
	  {
		  continue;
	  }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				// A disciplina deve ser ofertada no campus especificado
				if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
					 problemData->cp_discs[campusId].end() )
				{
					continue;
				}

			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
			   {
				   continue;
			   }
			   #pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos
                     = itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() 
                           && it_fix->getDiaSemana() == ( *itDiasLetDisc ) )
                        {
                           Variable v;
                           v.reset();
                           v.setType( Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR );

                           v.setTurma( turma );
                           v.setDisciplina( disciplina );
                           v.setDia( *itDiasLetDisc );
                           v.setSubCjtSala( *itCjtSala );

                           if ( vHash.find( v ) == vHash.end() )
                           {
							    if ( !criaVariavelTatico( &v ) )
									continue;

                                vHash[v] = lp->getNumCols();
                                int cred_disc_dia = it_fix->disciplina->getMaxCreds();

								double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{
									coef = -itCampus->getCusto()/2;
								}
								else if ( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = itCampus->getCusto()/2;
								}
               
								OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, cred_disc_dia,
										( char * )v.toString().c_str() );
			                 
								lp->newCol( col );

                                num_vars++;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

//int SolverMIP::cria_variavel_de_folga_dist_cred_dia_superior_permitir_alunos_varios_campi( void )
//{
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
//   {
//      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
//      {
//         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
//         {
//            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
//            {
//               disciplina = ( *it_disciplina );
//
//               std::pair< Curso *, Curriculo * > curso_curriculo
//                  = problemData->map_Disc_CursoCurriculo[ disciplina ];
//               curso = curso_curriculo.first;
//               curriculo = curso_curriculo.second;
//
//               disciplina_equivalente = problemData->retornaDisciplinaSubstituta( curso, curriculo, disciplina );
//               if ( disciplina_equivalente != NULL )
//               {
//                  disciplina = disciplina_equivalente;
//               }
//
//               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//               {
//                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
//                  GGroup< int > dias_letivos =
//                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];
//
//                  ITERA_GGROUP_N_PT( itDiasLetDisc, dias_letivos, int )
//                  {
//                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
//                     {
//                        if ( it_fix->getDisciplinaId() == disciplina->getId()
//                           && it_fix->getDiaSemana() == ( *itDiasLetDisc ) )
//                        {
//                           std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator
//                              itCPDiscs = problemData->cp_discs.begin();
//
//                           for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//                           {
//                              GGroup< int >::iterator itDisc = itCPDiscs->second.begin();
//
//                              for (; itDisc != itCPDiscs->second.end(); itDisc++)
//                              {
//                                 if ( ( itCampus->getId() == itCPDiscs->first )
//                                    && ( disciplina->getId() == ( *itDisc ) ) )
//                                 {
//                                    Variable v;
//                                    v.reset();
//                                    v.setType( Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR );
//
//                                    v.setTurma( turma );
//                                    v.setDisciplina( disciplina );
//                                    v.setDia( *itDiasLetDisc );
//                                    v.setSubCjtSala( *itCjtSala );
//
//                                    int idDisc = disciplina->getId();
//
//                                    if ( vHash.find( v ) == vHash.end() )
//                                    {
//                                       vHash[ v ] = lp->getNumCols();
//                                       int cred_disc_dia = ( it_fix->disciplina->getMaxCreds() );
//
//                                       OPT_COL col( OPT_COL::VAR_INTEGRAL,
//                                          epsilon, 0.0, cred_disc_dia,
//                                          ( char* )v.toString().c_str() );
//
//                                       if ( problemData->parametros->funcao_objetivo == 0 )
//                                       {
//                                          OPT_COL col( OPT_COL::VAR_INTEGRAL,
//                                             epsilon, 0.0, cred_disc_dia,
//                                             ( char* )v.toString().c_str() );
//
//                                          lp->newCol( col );
//                                       }
//                                       else if( problemData->parametros->funcao_objetivo == 1
//                                          || problemData->parametros->funcao_objetivo == 2 )
//                                       {
//                                          OPT_COL col( OPT_COL::VAR_INTEGRAL,
//                                             100.0, 0.0, cred_disc_dia,
//                                             ( char* )v.toString().c_str() );
//
//                                          lp->newCol( col );
//                                       }
//
//                                       num_vars += 1;
//                                    }
//                                 }
//                              }
//                           }
//                        }
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fcm_{d,t}  

%Desc 
variável de folga inferior para a restrição de fixação da distribuição de créditos por dia.

%ObjCoef
\xi \cdot \sum\limits_{d \in D} \sum\limits_{t \in T} fcm_{d,t}

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_dist_cred_dia_inferior( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				// A disciplina deve ser ofertada no campus especificado
				if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
					 problemData->cp_discs[campusId].end() )
				{
					continue;
				}

			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
			   {
				  continue;
			   }
			   #pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos =
                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() 
                           && it_fix->getDiaSemana() == ( *itDiasLetDisc ) )
                        {
                           Variable v;
                           v.reset();
                           v.setType( Variable::V_SLACK_DIST_CRED_DIA_INFERIOR );

                           v.setTurma( turma );
                           v.setDisciplina( disciplina );
                           v.setDia( *itDiasLetDisc );
                           v.setSubCjtSala( *itCjtSala );

                           if ( vHash.find( v ) == vHash.end() )
                           {
							    if ( !criaVariavelTatico( &v ) )
									continue;

                                vHash[v] = lp->getNumCols();
                                int cred_disc_dia = it_fix->disciplina->getMinCreds();

							    double coef = 0.0;

								if ( problemData->parametros->funcao_objetivo == 0 )
								{
									coef = -itCampus->getCusto()/2;
								}
								else if ( problemData->parametros->funcao_objetivo == 1 )
								{
									coef = itCampus->getCusto()/2;
								}               

								OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, cred_disc_dia,
											( char* )v.toString().c_str() );

								lp->newCol( col );

                                num_vars += 1;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

//int SolverMIP::cria_variavel_de_folga_dist_cred_dia_inferior_permitir_alunos_varios_campi(void)
//{
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
//   {
//      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
//      {
//         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
//         {
//            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
//            {
//               disciplina = ( *it_disciplina );
//
//               std::pair< Curso *, Curriculo * > curso_curriculo
//                  = problemData->map_Disc_CursoCurriculo[ disciplina ];
//               curso = curso_curriculo.first;
//               curriculo = curso_curriculo.second;
//
//               disciplina_equivalente = problemData->retornaDisciplinaSubstituta( curso, curriculo, disciplina );
//               if ( disciplina_equivalente != NULL )
//               {
//                  disciplina = disciplina_equivalente;
//               }
//
//               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//               {
//                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
//                  GGroup< int > dias_letivos =
//                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];
//
//                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();
//
//                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
//                  {
//                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
//                     {
//                        if ( it_fix->getDisciplinaId() == disciplina->getId() 
//                           && it_fix->getDiaSemana() == ( *itDiasLetDisc ) ) 
//                        {
//                           std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator
//                              itCPDiscs = problemData->cp_discs.begin();
//
//                           for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//                           {
//                              ITERA_GGROUP_N_PT( itDisc, itCPDiscs->second, int )
//                              {
//                                 if ( ( itCampus->getId() == itCPDiscs->first )
//                                    && ( disciplina->getId() == ( *itDisc ) ) )
//                                 {
//                                    Variable v;
//                                    v.reset();
//                                    v.setType( Variable::V_SLACK_DIST_CRED_DIA_INFERIOR );
//
//                                    v.setTurma( turma );
//                                    v.setDisciplina( disciplina );
//                                    v.setDia( *itDiasLetDisc );
//                                    v.setSubCjtSala( *itCjtSala );
//
//                                    if ( vHash.find( v ) == vHash.end() )
//                                    {
//                                       vHash[v] = lp->getNumCols();
//                                       int cred_disc_dia = it_fix->disciplina->getMinCreds();
//
//                                       OPT_COL col( OPT_COL::VAR_INTEGRAL,
//                                          epsilon, 0.0, cred_disc_dia,
//                                          ( char * )v.toString().c_str() );
//
//                                       if ( problemData->parametros->funcao_objetivo == 0 )
//                                       {
//                                          OPT_COL col( OPT_COL::VAR_INTEGRAL,
//                                             epsilon,0.0, cred_disc_dia,
//                                             ( char * )v.toString().c_str() );
//
//                                          lp->newCol( col );
//                                       }
//                                       else if( problemData->parametros->funcao_objetivo == 1 ||
//                                          problemData->parametros->funcao_objetivo == 2 )
//                                       {
//                                          OPT_COL col( OPT_COL::VAR_INTEGRAL,
//                                             100.0, 0.0, cred_disc_dia,
//                                             ( char * )v.toString().c_str() );
//
//                                          lp->newCol( col );
//                                       }
//
//                                       num_vars += 1;
//                                    }
//                                 }
//                              }
//                           }
//                        }
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var r_{bc,t,cp}  

%Desc 
indica se algum sub-bloco foi aberto do bloco curricular $bc$ no dia $t$ no campus $cp$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_abertura_subbloco_de_blc_dia_campus( int campusId )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	   if ( it_bloco->campus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_N_PT( itDia, it_bloco->campus->diasLetivos, int )
      {
         Variable v;
         v.reset();
         v.setType( Variable::V_ABERTURA_SUBBLOCO_DE_BLC_DIA_CAMPUS );

         v.setBloco( *it_bloco );
         v.setDia( *itDia );
         v.setCampus( it_bloco->campus );

         if ( vHash.find( v ) == vHash.end() )
         {
			if ( !criaVariavelTatico( &v ) )
				continue;

            vHash[ v ] = lp->getNumCols();

			double coef = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				coef = -1.0;
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				coef = 1.0;
			}  

            OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0,
               ( char * )v.toString().c_str( ));

            lp->newCol( col );
            num_vars++;
         }
      }
   }

   return num_vars;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var bs_{i,d,c,c',cp}

%Desc 
variável de folga para a restrição em que o compartilhamento de turmas 
de alunos de cursos incompativeis é proibido.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_aloc_alunos_curso_incompat( int campusId )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus *cp = *itCampus;

	   if ( cp->getId() != campusId )
	   {
		   continue;
	   }

	   ITERA_GGROUP_LESSPTR( it1Cursos, cp->cursos, Curso )
	   {
		   Curso* c1 = *it1Cursos;
			
		   ITERA_GGROUP_LESSPTR( it2Cursos, cp->cursos, Curso )
		   {
			    Curso* c2 = *it2Cursos;
			    
			    if ( problemData->cursosCompativeis(c1, c2) )
				    continue;

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					 // A disciplina deve ser ofertada no campus especificado
					 if ( problemData->cp_discs[campusId].find( itDisc->getId() ) ==
						  problemData->cp_discs[campusId].end() )
					 {
						continue;
					 }

					 #pragma region Equivalencias
					 if ( ( problemData->mapDiscSubstituidaPor.find( *itDisc ) !=
						    problemData->mapDiscSubstituidaPor.end() ) &&
						  !problemData->ehSubstituta( *itDisc ) )
					 {
						  continue;
					 }
					 #pragma endregion

					if ( !c1->possuiDisciplina(*itDisc) || !c2->possuiDisciplina(*itDisc) )
						continue;

					for ( int turma = 0; turma < itDisc->getNumTurmas(); turma++ )
					{
					   Variable v;
					   v.reset();
					   v.setType( Variable::V_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT );
					   v.setTurma( turma );						// i
					   v.setDisciplina( *itDisc );   			// d
					   v.setCurso( c1 );					    // c1
					   v.setCursoIncompat( c2 );				// c2
					   v.setCampus( *itCampus );				// cp

					   if ( vHash.find( v ) == vHash.end() )
					   {
						  if ( !criaVariavelTatico( &v ) )
							  continue;

						  vHash[v] = lp->getNumCols();

						  double coef = 0.0;

							if ( problemData->parametros->funcao_objetivo == 0 )
							{
								coef = -itCampus->getCusto();
							}
							else if ( problemData->parametros->funcao_objetivo == 1 )
							{
								coef = itCampus->getCusto();
							}  

						  OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0, ( char * )v.toString().c_str() );

						  lp->newCol( col );
						  num_vars++;
					   }
					}
				}
		    }
		}
   }

   return num_vars;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fc_{i,d,c,c',cp}

%Desc 
variável de folga para a restrição em que o compartilhamento de turmas 
de alunos de cursos compativeis é proibido.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_compartilhamento( int campusId )
{
   int num_vars = 0;

   if ( problemData->parametros->permite_compartilhamento_turma_sel )
   {
		return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

	   std::map< std::pair< Curso *, Curso * >, std::vector< int > >::iterator
               it_cursoComp_disc = problemData->cursosComp_disc.begin();

        for (; it_cursoComp_disc != problemData->cursosComp_disc.end(); it_cursoComp_disc++ )
        {
			Curso* c1 = it_cursoComp_disc->first.first;
			Curso* c2 = it_cursoComp_disc->first.second;

			if ( itCampus->cursos.find( c1 ) == itCampus->cursos.end() ||
				 itCampus->cursos.find( c2 ) == itCampus->cursos.end() )
			{
				continue;
			}
         
			std::vector< int >::iterator it_disc = it_cursoComp_disc->second.begin();

            for (; it_disc != it_cursoComp_disc->second.end(); ++it_disc )
            {
				int discId = *it_disc;
				Disciplina * disciplina = problemData->retornaDisciplina(discId);
				
				if (disciplina == NULL) continue;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
				   Variable v;
				   v.reset();
				   v.setType( Variable::V_SLACK_COMPARTILHAMENTO );
				   v.setTurma( turma );								// i
				   v.setDisciplina( disciplina );   				// d
				   v.setParCursos( std::make_pair( c1, c2 ) );		// (c, c)
				   v.setCampus( *itCampus );						// cp

				   if ( vHash.find( v ) == vHash.end() )
				   {
					  if ( !criaVariavelTatico( &v ) )
						  continue;

					  vHash[v] = lp->getNumCols();

						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{
							coef = -itCampus->getCusto()/4;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{
							coef = itCampus->getCusto()/4;
						}  

					  OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0, ( char * )v.toString().c_str() );

					  lp->newCol( col );
					  num_vars++;
				   }
				}
			}
		}
   }

   return num_vars;
}

//int SolverMIP::cria_variavel_de_folga_aloc_alunos_curso_incompat_permitir_alunos_varios_campi()
//{
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( it_Oferta_Incompat, problemData->ofertas, Oferta )
//   {
//      Curso * pt_Curso_Incompat = it_Oferta_Incompat->curso;
//      ITERA_GGROUP_LESSPTR( it_Oferta, problemData->ofertas, Oferta )
//      {
//         Campus * pt_Campus = it_Oferta->campus;
//         Curso * pt_Curso = it_Oferta->curso;
//
//         GGroup< std::pair< int, Disciplina * > >::iterator it_Prd_Disc = 
//            it_Oferta->curriculo->disciplinas_periodo.begin();
//
//         for (; it_Prd_Disc != it_Oferta->curriculo->disciplinas_periodo.end(); it_Prd_Disc++ )
//         {
//            disciplina = ( *it_Prd_Disc ).second;
//
//            std::pair< Curso *, Curriculo * > curso_curriculo
//               = problemData->map_Disc_CursoCurriculo[ disciplina ];
//            curso = curso_curriculo.first;
//            curriculo = curso_curriculo.second;
//
//            disciplina_equivalente = problemData->retornaDisciplinaSubstituta( curso, curriculo, disciplina );
//            if ( disciplina_equivalente != NULL )
//            {
//               disciplina = disciplina_equivalente;
//            }
//
//            for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//            {
//               std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator
//                  itCPDiscs = problemData->cp_discs.begin();
//
//               for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//               {
//                  GGroup< int >::iterator itDisc = itCPDiscs->second.begin();
//                  for (; itDisc != itCPDiscs->second.end(); itDisc++ )
//                  {
//                     if ( ( pt_Campus->getId() == itCPDiscs->first )
//                        && ( disciplina->getId() == ( *itDisc ) ) )
//                     {
//                        Variable v;
//                        v.reset();
//                        v.setType( Variable::V_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT );
//
//                        v.setTurma( turma );                     // i
//                        v.setDisciplina( disciplina );			     // d
//                        v.setCurso( pt_Curso );					 // c
//                        v.setCursoIncompat( pt_Curso_Incompat );
//                        v.setCampus( pt_Campus );				 // cp
//
//                        if ( vHash.find( v ) == vHash.end() )
//                        {
//                           vHash[ v ] = lp->getNumCols();
//
//                           OPT_COL col( OPT_COL::VAR_BINARY,
//                              0, 0.0, 1.0,
//                              ( char * )v.toString().c_str() );
//
//                           lp->newCol( col );
//                           num_vars++;
//                        }
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fd_{d,oft} 

%Desc 
variável de folga para a restrição "Capacidade alocada tem que 
permitir atender demanda da disciplina".

%ObjCoef
\omega \cdot \sum\limits_{oft \in O} \sum\limits_{d \in D_{oft}} fd_{d,oft}

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_demanda_disciplina( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( itOferta, problemData->ofertas, Oferta )
   {
	   if ( itOferta->getCampusId() != campusId )
	   {
		   continue;
	   }

      map < Disciplina*, int, LessPtr< Disciplina > >::iterator itPrdDisc = 
         itOferta->curriculo->disciplinas_periodo.begin();

      for (; itPrdDisc != itOferta->curriculo->disciplinas_periodo.end(); itPrdDisc++ )
      {
         // Calculando P_{d,o}
         int qtdDem = 0;

		 disciplina = itPrdDisc->first;

         ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
         {
            if ( itDem->disciplina->getId() == disciplina->getId() &&
               itDem->getOfertaId() == itOferta->getId() )
            {
               qtdDem += itDem->getQuantidade();
            }
         }

         if ( qtdDem <= 0 )
         {
            continue;
         }

         Variable v;
         v.reset();
         v.setType( Variable::V_SLACK_DEMANDA );

         v.setDisciplina( disciplina ); // d
         v.setOferta( *itOferta );      // o

         if ( vHash.find( v ) == vHash.end() )
         {
			if ( !criaVariavelTatico( &v ) )
				continue;
			
            vHash[ v ] = lp->getNumCols();

            double ub = qtdDem;

			double coef = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				coef = 0.0;
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				coef = 10 * itOferta->campus->getCusto() * disciplina->getTotalCreditos();
			}

			OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, ub, ( char * )v.toString().c_str() );

            lp->newCol( col );

            num_vars++;
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var m_{d,i,k} 

%Desc 
variável binária que indica se a combinação de divisão de créditos 
$k$ foi escolhida para a turma $i$ da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_combinacao_divisao_credito( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
		   problemData->cp_discs[campusId].end() )
	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion

      for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
      {
         for ( unsigned k = 0; k < disciplina->combinacao_divisao_creditos.size(); k++ )
         { 
            Variable v;
            v.reset();
            v.setType( Variable::V_COMBINACAO_DIVISAO_CREDITO );

            v.setTurma( turma );           // i
            v.setDisciplina( disciplina ); // d
            v.setK( k );	                // k

            if ( vHash.find( v ) == vHash.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               vHash[ v ] = lp->getNumCols();

               OPT_COL col( OPT_COL::VAR_BINARY,
                            0.0, 0.0, 1.0,
                            ( char * )v.toString().c_str() );

               lp->newCol( col );
               num_vars++;
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fkp_{d,i,t} 

%Desc 
variável de folga superior para a restrição de combinação de divisão de créditos.

%ObjCoef
\psi \cdot \sum\limits_{d \in D} 
\sum\limits_{t \in T} \sum\limits_{i \in I_{d}} fkp_{d,i,k}

%Data \psi
%Desc
peso associado a função objetivo.

%Var fkm_{d,i,t} 

%Desc 
variável de folga inferior para a restrição de combinação de divisão de créditos.

%ObjCoef
\psi \cdot \sum\limits_{d \in D} 
\sum\limits_{t \in T} \sum\limits_{i \in I_{d}} fkm_{d,i,k}

%Data \psi
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_combinacao_divisao_credito( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_unidade, it_campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_conjunto_sala, it_unidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, it_conjunto_sala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos =
                     it_conjunto_sala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiasLetDisc = dias_letivos.begin();

                  for (; itDiasLetDisc != dias_letivos.end(); itDiasLetDisc++ )
                  {
                     Variable v;
                     v.reset();
                     v.setType( Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );	    // t

                     if ( vHash.find( v ) == vHash.end() )
                     {
						if ( !criaVariavelTatico( &v ) )
							continue;

                        vHash[v] = lp->getNumCols();

						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{
							coef = -it_campus->getCusto()/2;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{
							coef = it_campus->getCusto()/2;
						}
                           
						OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, 10000.0,
                              ( char * )v.toString().c_str() );

                        lp->newCol( col );

                        num_vars++;
                     }

                     v.reset();
                     v.setType( Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M );

                     v.setTurma( turma );            // i
                     v.setDisciplina( disciplina );  // d
                     v.setDia( *itDiasLetDisc );	 // t

                     if ( vHash.find( v ) == vHash.end() )
                     {
						if ( !criaVariavelTatico( &v ) )
							continue;

                        vHash[v] = lp->getNumCols();

						double coef = 0.0;

						if ( problemData->parametros->funcao_objetivo == 0 )
						{
							coef = -it_campus->getCusto()/2;
						}
						else if ( problemData->parametros->funcao_objetivo == 1 )
						{
							coef = it_campus->getCusto()/2;
						}
                           
						OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, 10000.0,
                              ( char * )v.toString().c_str() );
						                           
						lp->newCol( col );

                        num_vars++;
                     }
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var xm_{bc,d,t}

%Desc
máximo de créditos alocados para qualquer turma da disciplina $d$ no bloco $bc$ no dia $t$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_creditos_modificada( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	   if ( it_bloco->campus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, it_bloco->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			 !problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion

         GGroup< int >::iterator itDiasLetBloco =
            it_bloco->diasLetivos.begin();

         for (; itDiasLetBloco != it_bloco->diasLetivos.end();
                itDiasLetBloco++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_CREDITOS_MODF );

            v.setDisciplina(disciplina);
            v.setBloco( *it_bloco );
            v.setDia( *itDiasLetBloco );

            if ( vHash.find( v ) == vHash.end() )
            {
			   if ( !criaVariavelTatico( &v ) )
					continue;

               vHash[v] = lp->getNumCols();

               OPT_COL col( OPT_COL::VAR_INTEGRAL,
                            0.0, 0.0, 50,
                            ( char * )v.toString().c_str() );

               lp->newCol( col );
               num_vars++;
            }
         }
      }
   }

   return num_vars;
}

//int SolverMIP::cria_variavel_creditos_modificada_permitir_alunos_varios_campi(void)
//{
//   int num_vars = 0;
//
//   Disciplina * disciplina = NULL;
//   Disciplina * disciplina_equivalente = NULL;
//
//   Curso * curso = NULL;
//   Curriculo * curriculo = NULL;
//
//   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
//   {
//      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
//      {
//         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
//         {
//            ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
//            {
//               disciplina = ( *it_disciplina );
//
//               std::pair< Curso *, Curriculo * > curso_curriculo
//                  = problemData->map_Disc_CursoCurriculo[ disciplina ];
//               curso = curso_curriculo.first;
//               curriculo = curso_curriculo.second;
//
//               disciplina_equivalente = problemData->retornaDisciplinaSubstituta( curso, curriculo, disciplina );
//               if ( disciplina_equivalente != NULL )
//               {
//                  disciplina = disciplina_equivalente;
//               }
//
//               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
//               {
//                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
//                  GGroup< int > dias_letivos =
//                     itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];
//
//                  ITERA_GGROUP_N_PT( itDiscSala_Dias, dias_letivos, int )
//                  {
//                     std::map< int /*Id Campus*/, GGroup< int > /*Id Discs*/ >::iterator
//                        itCPDiscs = problemData->cp_discs.begin();
//
//                     for (; itCPDiscs != problemData->cp_discs.end(); itCPDiscs++ )
//                     {
//                        GGroup< int >::iterator it_disc = itCPDiscs->second.begin();
//                        for (; it_disc != itCPDiscs->second.end(); it_disc++ )
//                        {
//                           if( ( itCampus->getId() == itCPDiscs->first )
//                              && ( disciplina->getId() == ( *it_disc ) ) )
//                           {
//                              Variable v;
//                              v.reset();
//                              v.setType( Variable::V_CREDITOS_MODF );
//
//                              v.setDisciplina( disciplina );     // d
//                              v.setDia( *itDiscSala_Dias );   // t
//
//                              if ( vHash.find(v) == vHash.end() )
//                              {
//                                 vHash[v] = lp->getNumCols();
//
//                                 OPT_COL col( OPT_COL::VAR_INTEGRAL, 0.0, 0.0, 50 /*FIX-ME*/,
//                                    ( char * )v.toString().c_str() );
//
//                                 // OPT_COL col(OPT_COL::VAR_INTEGRAL,0.0,0.0,itCjtSala->maxCredsDia(*itDiscSala_Dias),
//                                 // (char*)v.toString().c_str());
//
//                                 lp->newCol( col );
//                                 num_vars += 1;
//                              }
//                           }
//                        }
//                     }
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return num_vars;
//}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var zc_{d,t} 

%Desc 
indica se houve abertura da disciplina $d$ no dia $t$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_abertura_compativel( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_unidade, it_campus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( it_conjunto_sala, it_unidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, it_conjunto_sala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
               GGroup< int > dias_letivos =
                  it_conjunto_sala->dias_letivos_disciplinas[ ( disciplina ) ];

               ITERA_GGROUP_N_PT( itDiasLetDisc, dias_letivos, int )
               {
                  Variable v;
                  v.reset();
                  v.setType( Variable::V_ABERTURA_COMPATIVEL );

                  v.setDisciplina( disciplina );  // d
                  v.setDia( *itDiasLetDisc );     // t
				  v.setCampus( *it_campus );	  // cp

                  if ( vHash.find( v ) == vHash.end() )
                  {
					 if ( !criaVariavelTatico( &v ) )
						continue;

                     vHash[ v ] = lp->getNumCols();

					 double coef = 0.0;

					 if ( problemData->parametros->funcao_objetivo == 0 )
					 {
					 	coef = -1.0;
					 }
					 else if ( problemData->parametros->funcao_objetivo == 1 )
					 {
				 		coef = 1.0;
			 		 }

                     OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0,
                        ( char * )v.toString().c_str() );

                     lp->newCol( col );
                     num_vars++;
                  }
               }
            }
         }
      }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var n_{bc,tps} 

%Desc 
variável binária que indica se o bloco $bc$ foi alocado na sala $tps$. 

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_abertura_bloco_mesmoTPS( int campusId )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
   {
	     if ( itBloco->campus->getId() != campusId )
	     {
			  continue;
	     }

         ITERA_GGROUP_LESSPTR( itUnidade, itBloco->campus->unidades, Unidade )
         {
            ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
            {
               Variable v;
               v.reset();
               v.setType( Variable::V_ABERTURA_BLOCO_MESMO_TPS );

               v.setSubCjtSala( *itCjtSala );
               v.setBloco( *itBloco );

               if ( vHash.find( v ) == vHash.end() )
               {
				  if ( !criaVariavelTatico( &v ) )
					 continue;

                  vHash[v] = lp->getNumCols();

                  OPT_COL col( OPT_COL::VAR_BINARY,
                               0.0, 0.0, 1.0,
                               ( char * )v.toString().c_str() );

                  lp->newCol( col );
                  num_vars += 1;
               }
            }
        }
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var fn_{bc,tps} 

%Desc 
variável de folga para a restrição "Evitar alocação do mesmo 
bloco curricular em tipos de salas diferentes".

%ObjCoef
\tau \cdot \sum\limits_{bc \in B} \sum\limits_{tps \in SCAP_{u}} fn_{bc,tps}

%Data \tau
%Desc
peso associado a função objetivo.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_de_folga_abertura_bloco_mesmoTPS( int campusId )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
   {
	     if ( itBloco->campus->getId() != campusId )
	     {
			 continue;
	     }

         ITERA_GGROUP_LESSPTR( itUnidade, itBloco->campus->unidades, Unidade )
         {
            ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
            {
               Variable v;
               v.reset();
               v.setType( Variable::V_SLACK_ABERTURA_BLOCO_MESMO_TPS );

               v.setSubCjtSala( *itCjtSala );
               v.setBloco( *itBloco );

               if ( vHash.find( v ) == vHash.end() )
               {
				  if ( !criaVariavelTatico( &v ) )
					  continue;

                  vHash[v] = lp->getNumCols();

                  if ( problemData->parametros->funcao_objetivo == 0 )
                  {
                     OPT_COL col( OPT_COL::VAR_BINARY,
                                  tau, 0.0, 1.0,
                                  ( char * )v.toString().c_str() );

                     lp->newCol( col );
                  }
                  else if ( problemData->parametros->funcao_objetivo == 1
                     || problemData->parametros->funcao_objetivo == 2 )
                  {
                     OPT_COL col( OPT_COL::VAR_BINARY,
                                  0.0, 0.0, 1.0,
                                  ( char * )v.toString().c_str() );

                     lp->newCol( col );
                  }

                  num_vars++;
               }
            }
        }
   }

   return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var e_{i,d,oft} 

%Desc 
variável binaria, indica se houve alunos da oferta oft alocados
para a turma i da disciplina d.

%DocEnd
/====================================================================*/
int SolverMIP::cria_variavel_aloc_alunos_oft( int campusId )
{
   int num_vars = 0;
   
   ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
   {
	    Oferta *oft = *itOft;
	    
		if ( oft->getCampusId() != campusId )
	    {
			continue;
	    }

	    map < Disciplina*, int, LessPtr< Disciplina > >::iterator it_disc = oft->curriculo->disciplinas_periodo.begin();
	    for (; it_disc != oft->curriculo->disciplinas_periodo.end(); it_disc++ )
	    {
			Disciplina * d = it_disc->first;
			
		    for ( int turma = 0; turma < d->getNumTurmas(); turma++ )
		    {
               Variable v;
               v.reset();
               v.setType( Variable::V_ALOC_ALUNOS_OFT );
               v.setTurma(turma);
               v.setDisciplina(d);
			   v.setOferta(oft);

               if ( vHash.find( v ) == vHash.end() )
               {
				  if ( !criaVariavelTatico( &v ) )
					  continue;

                  vHash[v] = lp->getNumCols();

				  double coef = 0.0;

				  if ( problemData->parametros->funcao_objetivo == 0 )
			      {
					  coef = -1.0;
				  }
				  else if ( problemData->parametros->funcao_objetivo == 1 )
				  {
					  coef = 1.0;
				  }

                  OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0, (char*)v.toString().c_str() );

                  lp->newCol( col );
                  num_vars++;
			   }
			}
		}
   }

   return num_vars;
}




/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var q_{i,d,oft,u,tps,t}

%Desc 
número de créditos da turma $i$ da disciplina $d$ para a oferta $oft$
na unidade $u$ em salas do tipo (capacidade) $tps$ no dia $t$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_creditos_oferta( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
   {
	   Oferta *oft = *itOft;

	   Campus * cp = itOft->campus;

	   if ( cp->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disc, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disc );
			   
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

			   if ( ! oft->curriculo->possuiDisciplina( disciplina ) )
				   continue;


               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  // Dada uma disciplina, recupera os seus dias letivos, observando as fixações
                  GGroup< int > dias_letivos
                     = itCjtSala->dias_letivos_disciplinas[ ( disciplina ) ];

                  GGroup< int >::iterator itDiscSala_Dias = dias_letivos.begin();

                  for (; itDiscSala_Dias != dias_letivos.end(); itDiscSala_Dias++ )
                  {
						 Variable v;
						 v.reset();
						 v.setType( Variable::V_CREDITOS_OFT );

						 v.setTurma( turma );            // i
						 v.setDisciplina( disciplina );  // d
						 v.setUnidade( *itUnidade );     // u
						 v.setSubCjtSala( *itCjtSala );  // tps  
						 v.setDia( *itDiscSala_Dias );   // t
						 v.setOferta( oft );			 // oft

						if ( vHash.find( v ) == vHash.end() )
						{
						    if ( !criaVariavelTatico( &v ) )
								continue;

							vHash[ v ] = lp->getNumCols();

							OPT_COL col( OPT_COL::VAR_INTEGRAL, 0.0, 0.0,
										itCjtSala->maxCredsDiaPorSL( *itDiscSala_Dias, v.getDisciplina()->getCalendario() ),
										( char * )v.toString().c_str() );

							lp->newCol( col );
						}

						num_vars++;
                     
                  }
               }
            }
         }
      }
   }

   return num_vars;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var of_{i,d,oft1,oft2} 

%Desc 
variável binaria, indica se houve alunos das ofertas oft1 e oft2 alocados
para a turma i da disciplina d.

%DocEnd
/====================================================================*/
int SolverMIP::cria_variavel_aloc_alunos_parOft( int campusId )
{
    int num_vars = 0;

	// para cada par de ofertas compativeis
	std::map< std::pair< Oferta *, Oferta * >, std::vector< int > >::iterator
            it_oftsComp_disc = problemData->oftsComp_disc.begin();

    for (; it_oftsComp_disc != problemData->oftsComp_disc.end(); it_oftsComp_disc++ )
    {
		Oferta *oft1 = it_oftsComp_disc->first.first;
		Oferta *oft2 = it_oftsComp_disc->first.second;

		Curso *c1 = oft1->curso;
		Curso *c2 = oft2->curso;
		
		if ( oft1->getCampusId() != campusId || 
			 oft2->getCampusId() != campusId )
	    {
			continue;
	    }

		if ( c1->getId() != c2->getId() && !problemData->parametros->permite_compartilhamento_turma_sel )
			continue;

		// para cada disciplina em comum (possivel de ser compartilhada) ao par de ofertas
        std::vector< int >::iterator it_discComum = it_oftsComp_disc->second.begin();
        for (; it_discComum != it_oftsComp_disc->second.end(); ++it_discComum )
        {
			Disciplina * discComum = problemData->retornaDisciplina( *it_discComum );

			if (discComum == NULL)
				continue;

			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( discComum ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
				  !problemData->ehSubstituta( discComum ) )
			{
				continue;
			}
			#pragma endregion

			for ( int turma = 0; turma < discComum->getNumTurmas(); turma++ )
			{
				Variable v;
				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT );
				v.setTurma(turma);
				v.setDisciplina(discComum);
				v.setParOfertas(oft1, oft2);

				if ( vHash.find( v ) == vHash.end() )
				{
				    if ( !criaVariavelTatico( &v ) )
						continue;

					vHash[v] = lp->getNumCols();

					double coef = 0.0;

					if ( problemData->parametros->funcao_objetivo == 0 )
					{
					 	coef = -1.0;
					}
					else if ( problemData->parametros->funcao_objetivo == 1 )
					{
				 		coef = 1.0;
			 		}

					OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, 1.0, (char*)v.toString().c_str() );

					lp->newCol( col );
					num_vars++;
				}
			}
		}
	}
   
    return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var p_{i,d,oft1,oft2,u,s,t} 

%Desc 
indica quantos creditos alocados para a turma i
da disciplina d atendendo as ofertas oft1 e oft2.

%DocEnd
/====================================================================*/
int SolverMIP::cria_variavel_creditos_parOferta( int campusId )
{
	ofstream outTestFile;
	char outputTestFilename[] = "outTestVariableP.txt";
	outTestFile.open(outputTestFilename, ios::out);
	if (!outTestFile) {
		cerr << "Can't open output file " << outputTestFilename << endl;
		exit(1);
	}

   int num_vars = 0;

   // para cada campus
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus *cp = *itCampus;

	   if ( cp->getId() != campusId )
	   {
			continue;
	   }

	   // para cada par de ofertas compativeis
	   std::map< std::pair< Oferta *, Oferta * >, std::vector< int > >::iterator
               it_oftsComp_disc = problemData->oftsComp_disc.begin();

	   outTestFile << "\nNro de par ofertas: " << problemData->oftsComp_disc.size();

        for (; it_oftsComp_disc != problemData->oftsComp_disc.end(); it_oftsComp_disc++ )
        {
			Oferta *oft1 = it_oftsComp_disc->first.first;
			Oferta *oft2 = it_oftsComp_disc->first.second;

			if ( oft1->campus != cp || oft1->campus != cp )
				continue;

			Curso *c1 = oft1->curso;
			Curso *c2 = oft2->curso;

			if ( c1->getId() != c2->getId() && !problemData->parametros->permite_compartilhamento_turma_sel )
				continue;

			outTestFile << "\nOfts: " << it_oftsComp_disc->first.first->getId() <<", " << it_oftsComp_disc->first.second->getId();
			outTestFile << "\nNro de disciplinas comuns: " << it_oftsComp_disc->second.size();

			// para cada disciplina em comum (possivel de ser compartilhada) ao par de ofertas
            std::vector< int >::iterator it_discComum = it_oftsComp_disc->second.begin();
            for (; it_discComum != it_oftsComp_disc->second.end(); ++it_discComum )
            {
				Disciplina * discComum = problemData->retornaDisciplina( *it_discComum );
				  
				if (discComum == NULL)
					continue;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( discComum ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( discComum ) )
				{
					continue;
				}
				#pragma endregion

				outTestFile << "\nCapacidade media de sala: " << discComum->getCapacMediaSala( cp->getId() ) << endl;

				// para cada unidade do campus de discComum
				ITERA_GGROUP_LESSPTR( itUnid, cp->unidades, Unidade )
				{
					// para cada sala aonde poderá ser ministrada a disc compartilhada
					ITERA_GGROUP_LESSPTR( itCjtSalaCompart, itUnid->conjutoSalas, ConjuntoSala )
					{   
						if ( itCjtSalaCompart->disciplinas_associadas.find( discComum ) ==
								itCjtSalaCompart->disciplinas_associadas.end() )
							continue;

						Sala* salaCompart = itCjtSalaCompart->salas.begin()->second;
										
						GGroup< int > diasLetivos = itCjtSalaCompart->dias_letivos_disciplinas[ discComum ];
									
						// Para cada dia em que discComum pode ser ministrada na salaCompart
						GGroup< int >::iterator itDia = diasLetivos.begin();
						for (; itDia != diasLetivos.end(); itDia++ )
						{
							for ( int turma = 0; turma < discComum->getNumTurmas(); turma++ )
							{
								Variable v;
								v.setType( Variable::V_CREDITOS_PAR_OFT );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setParOfertas( oft1, oft2 );
								v.setUnidade( *itUnid );
								v.setSubCjtSala( *itCjtSalaCompart );
								v.setDia( *itDia );

								if ( vHash.find( v ) == vHash.end() )
								{
									if ( !criaVariavelTatico( &v ) )
										continue;

									outTestFile << "P" << num_vars
										  		<< "  i=" << v.getTurma()
												<< " d=" << v.getDisciplina()->getId()
												<< " ofts=" << v.getParOfertas().first->getId() << " " << v.getParOfertas().second->getId()
												<< " u=" << v.getUnidade()
												<< " s" << v.getSubCjtSala()
												<< " t=" << v.getDia() << endl;


									vHash[v] = lp->getNumCols();

									OPT_COL col( OPT_COL::VAR_INTEGRAL, 0.0, 0.0,
											   	itCjtSalaCompart->maxCredsDiaPorSL( *itDia, v.getDisciplina()->getCalendario() ),
												(char*)v.toString().c_str() );

									lp->newCol( col );
									num_vars++;
										  
								}
							}
						}
					}
				}
			}
		}
   }
   outTestFile.close();

   return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var g_{d,oft,t} 

%Desc 
Indica o numero minimo de creditos que a disciplina d da oferta oft
ocupa no dia t. Para isso, trata conta sobreposição ou não de salas
para turmas da disciplina

%DocEnd
/====================================================================*/
int SolverMIP::cria_variavel_min_hor_disc_oft_dia( int campusId )
{
   int num_vars = 0;
   
   ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
   {
	    Oferta *oft = *itOft;

		if ( oft->getCampusId() != campusId )
	    {
			continue;
	    }

	    map < Disciplina*, int, LessPtr< Disciplina > >::iterator it_disc = oft->curriculo->disciplinas_periodo.begin();
	    for (; it_disc != oft->curriculo->disciplinas_periodo.end(); it_disc++ )
	    {
			Disciplina * d = it_disc->first;
	
			GGroup< int >::iterator itDia = d->diasLetivos.begin();
			for (; itDia != d->diasLetivos.end(); itDia++ )
			{
               Variable v;
               v.reset();
               v.setType( Variable::V_MIN_HOR_DISC_OFT_DIA );
               v.setDisciplina(d);
			   v.setOferta(oft);
			   v.setDia(*itDia);

               if ( vHash.find( v ) == vHash.end() )
               {
				  if ( !criaVariavelTatico( &v ) )
					 continue;

                  vHash[v] = lp->getNumCols();
				  
				  int maxCredDia = oft->curriculo->getMaxCreds(*itDia);

				  double coef = 0.0;

				  if ( problemData->parametros->funcao_objetivo == 0 )
				  {
						coef = -1.0;
				  }
				  else if ( problemData->parametros->funcao_objetivo == 1 )
				  {
						coef = 1.0;
			 	  }

                  OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, maxCredDia, (char*)v.toString().c_str() );

                  lp->newCol( col );
                  num_vars++;
			   }
			}
		}
   }

   return num_vars;
}

// cs_{s,t,k}
int SolverMIP::cria_variavel_maxCreds_combina_sl_sala( int campusId )
{
   int num_vars = 0;

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() != 2 )
   {
	   return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			std::map< int, Sala * >::iterator itSala = itCjtSala->salas.begin();
			for( ; itSala != itCjtSala->salas.end(); itSala++ )
			{
				Sala *s = itSala->second;

				ITERA_GGROUP_N_PT( itDia, s->diasLetivos, int )
				{
					int dia = *itDia;

					std::map< Trio<int, int, Calendario*>, int >::iterator it_map = s->combinaCredSL.begin();
					for ( ; it_map != s->combinaCredSL.end(); it_map++ )
					{
						if ( it_map->first.first == dia )
						{
							Variable v;
							v.reset();
							v.setType( Variable::V_COMBINA_SL_SALA );
							v.setSala( s );
							v.setDia( dia );
							v.setCombinaSL( it_map->first.second );

							if ( vHash.find( v ) == vHash.end() )
							{
								if ( !criaVariavelTatico( &v ) )
									continue;

								vHash[v] = lp->getNumCols();
						   
								OPT_COL col( OPT_COL::VAR_BINARY, 0.0, 0.0, 1.0, (char*)v.toString().c_str() );

								lp->newCol( col );
								num_vars++;
							}
						}
					}
				}
			}
		 }
	  }
   }

   return num_vars;
}

// cbc_{bc,t,k}
int SolverMIP::cria_variavel_maxCreds_combina_Sl_bloco( int campusId )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
   {
	   if ( itBloco->campus->getId() != campusId )
	   {
			continue;
	   }

	   BlocoCurricular *bc = *itBloco;
		
	   ITERA_GGROUP_N_PT( itDia, bc->diasLetivos, int )
	   {
		   int dia = *itDia;

		   std::map< Trio< int/*dia*/, int /*k_id*/, Calendario* /*sl*/ >,
					  int/*nroCreds*/ >::iterator it_map = bc->combinaCredSL.begin();

			for ( ; it_map != bc->combinaCredSL.end(); it_map++ )
			{
				if ( it_map->first.first == dia )
				{
					Variable v;
					v.reset();
					v.setType( Variable::V_COMBINA_SL_BLOCO );

					v.setBloco( bc );
					v.setDia( dia );
					v.setCombinaSLBloco( it_map->first.second );

					if ( vHash.find( v ) == vHash.end() )
					{
						if ( !criaVariavelTatico( &v ) )
							continue;

						vHash[v] = lp->getNumCols();
						   
						OPT_COL col( OPT_COL::VAR_BINARY, 0.0, 0.0, 1.0, (char*)v.toString().c_str() );

						lp->newCol( col );
						num_vars++;
					}
				}
			}
	    }
   }

   return num_vars;
}


/*	
	VARIAVEIS SO PARA MODELO TATICO - ALUNO - SEM HORARIOS
*/

// ca_{a,t,k}
int SolverMIP::cria_variavel_maxCreds_combina_Sl_aluno( int campusId )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	   Aluno *aluno = *itAluno;

	   if ( aluno->getOferta()->getCampusId() != campusId )
	   {
			continue;
	   }

	   ITERA_GGROUP_N_PT( itDia, aluno->getOferta()->campus->diasLetivos, int )
	   {
		   int dia = *itDia;

		   std::map< Trio< int/*dia*/, int /*k_id*/, Calendario* /*sl*/ >,
					  int/*nroCreds*/ >::iterator it_map = aluno->combinaCredSL.begin();

			for ( ; it_map != aluno->combinaCredSL.end(); it_map++ )
			{
				if ( it_map->first.first == dia )
				{
					Variable v;
					v.reset();
					v.setType( Variable::V_COMBINA_SL_ALUNO);

					v.setAluno( aluno );
					v.setDia( dia );
					v.setCombinaSLAluno( it_map->first.second );

					if ( vHash.find( v ) == vHash.end() )
					{
						if ( !criaVariavelTatico( &v ) )
							continue;

						vHash[v] = lp->getNumCols();
						   
						OPT_COL col( OPT_COL::VAR_BINARY, 0.0, 0.0, 1.0, (char*)v.toString().c_str() );

						lp->newCol( col );
						num_vars++;
					}
				}
			}
	    }
   }

   return num_vars;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var \underline{h}_{a} 

%Desc 
mínimo de créditos alocados na semana para o aluno $a$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_min_creds_aluno( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   Campus* campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( it_aluno, problemData->alunos, Aluno )
   {
	   if ( it_aluno->getOferta()->campus->getId() != campusId )
	   {
		  continue;
	   }

		Variable v;
		v.reset();
		v.setType( Variable::V_MIN_CRED_SEMANA_ALUNO );

		v.setAluno( *it_aluno );

		if ( vHash.find( v ) == vHash.end() )
		{
			if ( !criaVariavelTatico( &v ) )
				continue;

			vHash[ v ] = lp->getNumCols();
                  
			double obj = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
				{
					obj = campus->getCusto()/4;
				}
				else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
				{
					obj = campus->getCusto()/4;
				}
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
				{
					obj = campus->getCusto()/4;
				}
				else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
				{
					obj = campus->getCusto()/4;
				}
			}
               
			OPT_COL col( OPT_COL::VAR_INTEGRAL, obj, 0.0, 1000.0, ( char * )v.toString().c_str() );

			lp->newCol( col );

			num_vars++;
		}
   }

   return num_vars;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Var \overline{h}_{a} 

%Desc 
máximo de créditos alocados na semana para o aluno $a$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_variavel_max_creds_aluno( int campusId )
{
   int num_vars = 0;

   Disciplina * disciplina = NULL;

   Campus* campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( it_aluno, problemData->alunos, Aluno )
   {
	   if ( it_aluno->getOferta()->campus->getId() != campusId )
	   {
		  continue;
	   }

		Variable v;
		v.reset();
		v.setType( Variable::V_MAX_CRED_SEMANA_ALUNO );

		v.setAluno( *it_aluno );

		if ( vHash.find( v ) == vHash.end() )
		{
			if ( !criaVariavelTatico( &v ) )
				continue;

			vHash[v] = lp->getNumCols();

			double obj = 0.0;

			if ( problemData->parametros->funcao_objetivo == 0 )
			{
				if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
				{
					obj = -campus->getCusto()/4;
				}
				else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
				{
					obj = 0.0;
				}
			}
			else if ( problemData->parametros->funcao_objetivo == 1 )
			{
				if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::EQUILIBRAR)
				{
					obj = -campus->getCusto()/4;
				}
				else if ( problemData->parametros->carga_horaria_semanal_aluno == ParametrosPlanejamento::MINIMIZAR_DIAS)
				{
					obj = 0.0;
				}
			}
               
			OPT_COL col( OPT_COL::VAR_INTEGRAL, obj, 0.0, 1000.0, ( char * )v.toString().c_str() );

			lp->newCol( col );

			num_vars++;
		}
   }

   return num_vars;
}


// fd_{i,d,cp}
int SolverMIP::cria_variavel_de_folga_demanda_disciplina_aluno( int campusId )
{
	int num_vars = 0;
   
   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
   {
	   if ( it_campus->getId() != campusId )
	   {
		   continue;
	   }
	     
	  GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

      ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
      {
		  Disciplina * disciplina = problemData->refDisciplinas[ *it_disciplina ];
		  
		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion
		 		 
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			  continue;

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            Variable v;
            v.reset();
            v.setType( Variable::V_SLACK_DEMANDA_ALUNO );

            v.setTurma( turma );            // i
            v.setDisciplina( disciplina );  // d
            v.setCampus( *it_campus );	    // cp

            std::pair< int, int > dc
               = std::make_pair( disciplina->getId(), it_campus->getId() );

            if ( problemData->demandas_campus.find( dc )
               == problemData->demandas_campus.end() )
            {
               problemData->demandas_campus[ dc ] = 0;
            }

            if ( vHash.find(v) == vHash.end() )
            {
			    if ( !criaVariavelTatico( &v ) )
					continue;

                lp->getNumCols();
                vHash[v] = lp->getNumCols();

			    double coef = 0.0;

				if ( problemData->parametros->funcao_objetivo == 0 )
				{
					// Numero de aluno alocados para a turma
					int nroAlunos = problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId );
					
					coef = - 50 * nroAlunos * disciplina->getTotalCreditos() * 50.0; // TODO: receita = 50.0? usar que valor?
				}
				else if ( problemData->parametros->funcao_objetivo == 1 )
				{
					coef = 10 * disciplina->getTotalCreditos() * it_campus->getCusto();
			 	}

				double ub = 1.0;
                  
			    OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, ub, ( char * )v.toString().c_str() );

                lp->newCol( col );
				 
                num_vars++;
            }
         }
      }
   }
	
	return num_vars;
	
}


// ffd_{i1,-d,i2,d,cp}
int SolverMIP::cria_variavel_folgafolga_demanda_p_t( int campusId )
{
	int num_vars = 0;
     
    Campus* campus = problemData->refCampus[ campusId ];
	     
	GGroup< int > disciplinas = problemData->cp_discs.find( campusId )->second;

	ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
	{
		Disciplina * discPratica = problemData->refDisciplinas[ *it_disciplina ];

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( discPratica ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			 !problemData->ehSubstituta( discPratica ) )
		{
			continue;
		}
		#pragma endregion

		if ( discPratica->getId() > 0 )
		{
			continue;
		}
		
		std::map< int, Disciplina * >::iterator itMapDisc =
			problemData->refDisciplinas.find( - discPratica->getId() );
				
		if ( itMapDisc == problemData->refDisciplinas.end() )
		{
			continue;
		}
		
		Disciplina *discTeorica = itMapDisc->second;

		if ( ! problemData->haDemandaDiscNoCampus( discPratica->getId(), campusId ) )
		{
			continue;
		}

		for ( int turma1 = 0; turma1 < discPratica->getNumTurmas(); turma1++ )
		{
			for ( int turma2 = 0; turma2 < discTeorica->getNumTurmas(); turma2++ )
			{		
				GGroup<Aluno*> alunos = problemData->alunosEmComum( turma1, discPratica, turma2, discTeorica, campus );
				
				if ( alunos.size() == 0 )
				{
					continue;
				}

				Variable v;
				v.reset();
				v.setType( Variable::V_SLACK_SLACKDEMANDA_PT );

				v.setTurma1( turma1 );            // i1
				v.setDisciplina1( discPratica );  // -d
				v.setTurma2( turma2 );            // i2
				v.setDisciplina2( discTeorica );  // d
				v.setCampus( campus );	     // cp

				if ( vHash.find(v) == vHash.end() )
				{
					if ( !criaVariavelTatico( &v ) )
						continue;

					lp->getNumCols();
					vHash[v] = lp->getNumCols();

					double coef = 0.0;
						
					if ( problemData->parametros->funcao_objetivo == 0 )
					{
						coef = - 500.0; // TODO
					}
					else if ( problemData->parametros->funcao_objetivo == 1 )
					{						
						coef = 5000 * campus->getCusto(); // TODO
			 		}

					double ub = 1.0;
                  
					OPT_COL col( OPT_COL::VAR_BINARY, coef, 0.0, ub, ( char * )v.toString().c_str() );

					lp->newCol( col );
				 
					num_vars++;
				}
			}
		}
   }
	
	return num_vars;
	
}


// ==============================================================
//							CONSTRAINTS
// ==============================================================

int SolverMIP::cria_restricoes( int campusId )
{
	int restricoes = 0;

	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_restricoes
	int numRestAnterior = 0;
#endif

	timer.start();
	restricoes += cria_restricao_carga_horaria( campusId );				// Restricao 1.2.2
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.2\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_tempo_sd( campusId );					// Restricao 1.2.3.a
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.3.a\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_tempo_s_t_SL( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

	timer.start();
	//   restricoes += cria_restricao_max_tempo_s_d_SL();				// Restricao 1.2.3.b
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.3.b\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_min_cred_dd( campusId );					// Restricao 1.2.4
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.4\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_ativacao_var_o( campusId );					// Restricao 1.2.5
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_evita_sobreposicao( campusId );			// Restricao 1.2.6
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.6\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_disciplina_sala( campusId );				// Restricao 1.2.7
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.7\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_turma_sala( campusId );					// Restricao 1.2.8
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.8\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
	/*
	timer.start();
	restricoes += cria_restricao_evita_turma_disc_camp_d();				// Restricao 1.2.9 Não é usada em Otimização Por Campus
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.9\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
	*/
	timer.start();
	restricoes += cria_restricao_turmas_bloco( campusId );				// Restricao 1.2.10
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.10\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
	
	timer.start();
	restricoes += cria_restricao_max_cred_disc_bloco( campusId );			// Restricao 1.2.11
	timer.stop();
	dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.11\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
	#endif
		
	timer.start();
	restricoes += cria_restricao_num_tur_bloc_dia_difunid( campusId );	// Restricao 1.2.12
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.12\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_lim_cred_diar_disc( campusId );			// Restricao 1.2.13
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.13\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_cap_aloc_dem_disc( campusId );			// Restricao 1.2.14
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.14\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_cap_sala_compativel_turma( campusId );	// Restricao 1.2.15
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.15\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_cap_sala_unidade( campusId );			// Restricao 1.2.16
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.16\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	//restricoes += cria_restricao_turma_disc_dias_consec();		// Restricao 1.2.17
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	//std::cout << "numRest \"1.2.17\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	std::cout << "numRest \"1.2.17\": NAO ESTA SENDO CRIADA DEVIDO A ERROS DE IMPLEMENTACAO - VER ToDo 12 (MARIO)"  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_min_creds_turm_bloco( campusId );		// Restricao 1.2.18
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.18\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_creds_turm_bloco( campusId );		// Restricao 1.2.19
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.19\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_aluno_curso_disc( campusId );			// Restricao 1.2.20
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.20\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_alunos_cursos_incompat( campusId );		// Restricao 1.2.21
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.21\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	//std::cout << "numVars \"1.2.21\": NAO ESTA SENDO CRIADA DEVIDO A ERROS DE IMPLEMENTACAO (A Inst. UNI-BH nao precisa dessa restricao implementada)."  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_de_folga_dist_cred_dia( campusId );		// Restricao 1.2.22
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.22\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	//std::cout << "numRest \"1.2.22\": NAO ESTA SENDO CRIADA DEVIDO A NOVA MODELAGEM QUE O MARCELO FEZ."  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_ativacao_var_r( campusId );						// Restricao 1.2.23
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.23\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_limita_abertura_turmas( campusId );						// Restricao 1.2.24
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.24\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_abre_turmas_em_sequencia( campusId );						// Restricao 1.2.25
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.25\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_divisao_credito( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.26\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_combinacao_divisao_credito( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.27\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_ativacao_var_y( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.28\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	/*
	timer.start();
	restricoes += cria_restricao_max_creds_disc_dia();
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

	#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.29\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
	#endif

	timer.start();
	restricoes += cria_restricao_max_creds_bloco_dia();
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

	#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.30\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
	#endif

	*/


	timer.start();
	restricoes += cria_restricao_ativacao_var_zc( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.31\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_disciplinas_incompativeis( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.32\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	//restricoes +=  cria_restricao_abertura_bloco_mesmoTPS();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	//std::cout << "numRest \"1.2.33\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	std::cout << "numRest \"1.2.33\": NAO ESTA SENDO CRIADA DEVIDO A ERRO DE MODELAGEM - (MARIO)"  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	//restricoes +=  cria_restricao_folga_abertura_bloco_mesmoTPS();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	//std::cout << "numRest \"1.2.34\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	std::cout << "numRest \"1.2.34\": NAO ESTA SENDO CRIADA DEVIDO A ERRO DE MODELAGEM DA RESTRICAO 1.2.33 - (MARIO)"  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_proibe_compartilhamento( campusId );			// Restricao 1.2.35
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.35\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes +=  cria_restricao_ativacao_var_e( campusId );				// Restricao 1.2.36
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.36\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes +=  cria_restricao_evita_sobrepos_sala_por_compartilhamento( campusId );	// Restricao 1.2.37
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.37\": " << (restricoes - numRestAnterior) <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_ativacao_var_of( campusId );	// Restricao 1.2.38, 1.2.39, 1.2.40
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.38, 1.2.39, 1.2.40\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_ativacao_var_p( campusId );	// Restrições 1.2.41, 1.2.42, 1.2.43
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.41, 1.2.42, 1.2.43\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_ativacao_var_g( campusId );	// Restricao 1.2.44
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.44\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_evita_sobrepos_sala_por_div_turmas( campusId );	// Restricao 1.2.45
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.45\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_ativacao_var_q( campusId );	// Restricoes 1.2.46, 1.2.47, 1.2.48
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.46, 1.2.47, 1.2.48\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_ativacao_var_cs( campusId ); // Restricao 1.2.49
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.49\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_fixa_nao_compartilhamento( campusId ); // Restricao 1.2.50
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.50\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_ativacao_var_cbc( campusId ); // Restricao 1.2.51
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.51\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	return restricoes;
}

int SolverMIP::cria_restricoes_aluno_sh( int campusId )
{
	int restricoes = 0;

	CPUTimer timer;
	double dif = 0.0;

#ifdef PRINT_cria_restricoes
	int numRestAnterior = 0;
#endif

	timer.start();
	restricoes += cria_restricao_carga_horaria( campusId );				// Restricao 1.2.2
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.2\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_tempo_sd( campusId );					// Restricao 1.2.3.a
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.3.a\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_tempo_s_t_SL( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

	timer.start();
	//   restricoes += cria_restricao_max_tempo_s_d_SL();				// Restricao 1.2.3.b
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.3.b\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_ativacao_var_o( campusId );					// Restricao 1.2.5
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.5\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_evita_sobreposicao( campusId );			// Restricao 1.2.6
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.6\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	
	timer.start();
	restricoes += cria_restricao_max_cred_disc_aluno( campusId );		// Restricao 1.2.11
	timer.stop();
	dif = timer.getCronoCurrSecs();

	#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.11\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
	#endif
	

	timer.start();
	restricoes += cria_restricao_lim_cred_diar_disc( campusId );			// Restricao 1.2.13
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.13\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_aloc_dem_disc( campusId );			// Restricao 1.2.14
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.14\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	//restricoes += cria_restricao_turma_disc_dias_consec();		// Restricao 1.2.17
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	//std::cout << "numRest \"1.2.17\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	std::cout << "numRest \"1.2.17\": NAO ESTA SENDO CRIADA DEVIDO A ERROS DE IMPLEMENTACAO - VER ToDo 12 (MARIO)"  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_min_creds_semana_aluno( campusId );		// Restricao 1.2.18
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.18\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_max_creds_semana_aluno( campusId );		// Restricao 1.2.19
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.19\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_de_folga_dist_cred_dia( campusId );		// Restricao 1.2.22
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.22\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_limita_abertura_turmas_aluno( campusId );			// Restricao 1.2.24
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.24\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_abre_turmas_em_sequencia( campusId );						// Restricao 1.2.25
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.25\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_divisao_credito( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.26\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_combinacao_divisao_credito( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.27\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_ativacao_var_zc( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.31\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes +=  cria_restricao_disciplinas_incompativeis( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();
	

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.32\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	
	timer.start();
	restricoes += cria_restricao_ativacao_var_cs( campusId ); // Restricao 1.2.49
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.49\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
		
	
	timer.start();
	restricoes += cria_restricao_evita_sobrepos_turmas_mesmos_alunos( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.50\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif

	timer.start();
	restricoes += cria_restricao_disc_pratica_teorica( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.51\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif


	timer.start();
	restricoes += cria_restricao_ativacao_var_ca( campusId );
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest \"1.2.52\": " << (restricoes - numRestAnterior)  <<" "<<dif <<" sec" << std::endl;
	numRestAnterior = restricoes;
#endif
		

	return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Carga horária de todas as turmas de cada disciplina

%MatExp 

\begin{eqnarray}
\sum\limits_{u \in U}\sum\limits_{tps \in SCAP_{u}}\sum\limits_{t \in T} x_{i,d,u,tps,t}  =  C_{d} \cdot z_{i,d,cp} \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad 
\forall cp \in CP 
\end{eqnarray}

%Data C_{d}
%Desc
Total de créditos da disciplina $d$.

%Data I_{d}
%Desc
Máximo de turmas que podem ser abertas da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_carga_horaria( int campusId )
{
   int restricoes = 0;

   int nnz;
   char name[ 100 ];

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			 continue;
		 }

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			 !problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( Constraint::C_CARGA_HORARIA );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = ( itCampus->getTotalSalas() * 7 );

            OPT_ROW row( nnz + 1, OPT_ROW::EQUAL , 0 , name );

            v.reset();
            v.setType( Variable::V_CREDITOS );

            // ---

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
                  GGroup< int /*dias*/ > disc_sala_dias
                     = problemData->disc_Conjutno_Salas__Dias
                     [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ];

                  ITERA_GGROUP_N_PT( itDiscSala_Dias, disc_sala_dias, int )
                  {
                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );                   

                     it_v = vHash.find( v );
                     if( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }
                  }
               }
            }

            // ---

            v.reset();
            v.setType( Variable::V_ABERTURA );

            v.setCampus( *itCampus );
            v.setDisciplina( disciplina );
            v.setTurma( turma );

            it_v = vHash.find( v );
            if( it_v != vHash.end() )
            {
               row.insert( it_v->second,
                  -( disciplina->getCredPraticos() + 
                  disciplina->getCredTeoricos() ) );
            }

            // ---

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Máximo de tempo por sala e dia
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{d \in D}\sum\limits_{i \in I_{d}} sl_{d} \cdot x_{i,d,u,tps,t} \leq  HTPS_{t,tps} \nonumber \qquad 
\forall u \in U \quad
\forall tps \in SCAP_{u} \quad
\forall t \in T
\end{eqnarray}

%Data HTPS_{t,tps}
%Desc
máximo de tempo permitido por dia $t$ para o conjunto de salas do tipo (capacidade) $tps$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_tempo_sd( int campusId )
{
   int restricoes = 0;

   // Metodo somente utilizado quando há 1 semana letiva
   if ( problemData->calendarios.size() != 1 )
   {
	   return restricoes;
   }

   int nnz;
   char name[ 100 ];

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;
   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            //////////////////////////////////////////////////////////////////////
            // Percorre cada disciplina do conjunto de salas
            std::map< Disciplina *, GGroup< int > >::iterator
               it_disc_dias = itCjtSala->dias_letivos_disciplinas.begin();

            for (; it_disc_dias != itCjtSala->dias_letivos_disciplinas.end(); it_disc_dias++ )
            {
               // Verifica se a disciplina foi substituída
               disciplina = it_disc_dias->first;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               GGroup< int >::iterator itDiasLetCjtSala =
                  it_disc_dias->second.begin();

               for (; itDiasLetCjtSala != it_disc_dias->second.end(); itDiasLetCjtSala++ )
               {
                  c.reset();
                  c.setType( Constraint::C_MAX_TEMPO_SD );

                  c.setUnidade( *itUnidade );
                  c.setSubCjtSala( *itCjtSala );
                  c.setDia( *itDiasLetCjtSala );

                  sprintf( name, "%s", c.toString().c_str() );
                  if ( cHash.find( c ) != cHash.end() )
                  {
                     continue;
                  }

                  nnz = 0;
                  ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
                  {
					 // A disciplina deve ser ofertada no campus especificado
					 if ( problemData->cp_discs[campusId].find( itDisc->getId() ) ==
						  problemData->cp_discs[campusId].end() )
					 {
						 continue;
					 }
                     if ( itDisc->getNumTurmas() >= 0 )
                     {
                        nnz += ( itDisc->getNumTurmas() );
                     }
                  }

                  int HTPS = itCjtSala->maxTempoPermitidoPorDia( *itDiasLetCjtSala );
                  OPT_ROW row( nnz, OPT_ROW::LESS , HTPS, name );

                  ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
                  {
					 #pragma region Equivalencias
					 if ( ( problemData->mapDiscSubstituidaPor.find( *itDisc ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						  !problemData->ehSubstituta( *itDisc ) )
					 {
						continue;
					 }
					 #pragma endregion

					 // A disciplina deve ser ofertada no campus especificado
					 if ( problemData->cp_discs[campusId].find( itDisc->getId() ) ==
						  problemData->cp_discs[campusId].end() )
					 {
						 continue;
					 }

                     for ( int turma = 0; turma < itDisc->getNumTurmas(); turma++ )
                     {
                        v.reset();
                        v.setType( Variable::V_CREDITOS );

                        v.setTurma( turma );
                        v.setUnidade( *itUnidade );
                        v.setDisciplina( *itDisc );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiasLetCjtSala );

                        it_v = vHash.find( v );
                        if( it_v != vHash.end() )
                        {
							row.insert( it_v->second, itDisc->getTempoCredSemanaLetiva() );
                        }
                     }
                  }

                  if ( row.getnnz() != 0 )
                  {
                     cHash[ c ] = lp->getNumRows();

                     lp->addRow( row );
                     restricoes++;
                  }
               }
            }
            //////////////////////////////////////////////////////////////////////
         }
      }
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Máximo de tempo por sala, dia e semana letiva, de acordo com a divisao
de horarios por semana letiva escolhida.
%Desc 

%MatExp

\begin{eqnarray}

\sum\limits_{d \in D_{sl}}\sum\limits_{i \in I_{d}} x_{i,d,u,s,t} \leq  \sum\limits_{k \in CS_{k}}( Q_{sl,k,s,t} \cdot cs_{s,t,k} ) \nonumber \qquad

\forall u \in U \quad
\forall s \in S_{u} \quad
\forall t \in T \quad
\forall sl \in SL
\end{eqnarray}

%Data Q_{sl,t,s,k}
%Desc
máximo de tempo da semana letiva $sl$ permitidos por dia $t$
para a sala $s$, na divisão de horarios k.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_tempo_s_t_SL( int campusId )
{
   int restricoes = 0;

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() != 2 )
   {
	   return restricoes;
   }

   char name[ 100 ];
   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			std::map< int, Sala * >::iterator itSala = itCjtSala->salas.begin();
			for( ; itSala != itCjtSala->salas.end(); itSala++ )
			{
				Sala *s = itSala->second;

				ITERA_GGROUP_N_PT( itDia, s->diasLetivos, int )
				{
					int dia = *itDia;
				
					ITERA_GGROUP_LESSPTR( it_Sl, problemData->calendarios, Calendario )
					{
						//  Cria restrição
						c.reset();
						c.setType( Constraint::C_MAX_TEMPO_S_D_SL );
						c.setUnidade( *itUnidade );
						c.setSubCjtSala( *itCjtSala );
						c.setDia( dia );
						c.setSemanaLetiva( *it_Sl );

						sprintf( name, "%s", c.toString().c_str() );
						if ( cHash.find( c ) != cHash.end() )
						{
							continue;
						}

						int nnz = 100;
					
						OPT_ROW row( nnz, OPT_ROW::LESS , 0, name );

						bool INSERIU = false;

						ITERA_GGROUP( itDisc, s->disciplinasAssociadas, Disciplina )
						{
							Disciplina *disciplina = *itDisc;

							// Verifica se é a semana letiva corrente
							if ( disciplina->getCalendario() != *it_Sl )
							{
								continue;
							}

							#pragma region Equivalencias
							if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
									problemData->mapDiscSubstituidaPor.end() ) &&
									!problemData->ehSubstituta( disciplina ) )
							{
								continue;
							}
							#pragma endregion		

							for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
							{
								v.reset();
								v.setType( Variable::V_CREDITOS );
								v.setTurma( turma );
								v.setUnidade( *itUnidade );
								v.setDisciplina( disciplina );
								v.setSubCjtSala( *itCjtSala );
								v.setDia( dia );

								it_v = vHash.find( v );
								if( it_v != vHash.end() )
								{
									row.insert( it_v->second, 1 );

									INSERIU = true;
								}
							}
						}
						std::map< Trio<int, int, Calendario*>, int >::iterator it_map = s->combinaCredSL.begin();
						for ( ; it_map != s->combinaCredSL.end(); it_map++  )
						{
							if ( it_map->first.first == dia && it_map->first.third == *it_Sl )
							{
								v.reset();
								v.setType( Variable::V_COMBINA_SL_SALA );
								v.setSala( s );
								v.setDia( dia );
								v.setCombinaSL( it_map->first.second );

								it_v = vHash.find( v );
								if( it_v != vHash.end() )
								{
									int coef = s->getNroCredCombinaSL( it_map->first.second, *it_Sl, dia );

									row.insert( it_v->second, -coef );
								}
							}
						}
					
						if ( row.getnnz() != 0 && INSERIU )
						{
							cHash[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
         }
      }
   }

   return restricoes;
}




/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Mínimo de créditos diários da disciplina (*)
%Desc

%MatExp

\begin{eqnarray}
\underline{H_{d}} \cdot o_{i,d,u,tps,t}  \leq  x_{i,d,u,tps,t}  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall u \in U \quad
\forall tps \in SCAP_{u} \quad
\forall t \in T
\end{eqnarray}

%Data \underline{H_{d}} 
%Desc
mínimo de créditos diários da disciplina $d$.

%DocEnd
/====================================================================*/

// TRIEDA-405 Cont-Mínimo de créditos diários da disciplina(*)
int SolverMIP::cria_restricao_min_cred_dd( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion		
				
               GGroup< int /*Dias*/ > disc_sala_dias =
                  problemData->disc_Conjutno_Salas__Dias[ std::make_pair< int, int >
                  ( disciplina->getId(), itCjtSala->getId() ) ];

               ITERA_GGROUP_N_PT( itDiscSala_Dias, disc_sala_dias, int )
               {
                  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                  {
                     c.reset();
                     c.setType( Constraint::C_MIN_CREDITOS_DD );

                     c.setUnidade( *itUnidade );
                     c.setSubCjtSala( *itCjtSala );
                     c.setDia( *itDiscSala_Dias );
                     c.setDisciplina( disciplina );
                     c.setTurma( turma	);

                     sprintf( name, "%s", c.toString().c_str() );
                     if ( cHash.find( c ) != cHash.end() )
                     {
                        continue;
                     }

                     nnz = 2;

                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );

                     // 1.2.4
                     // Mínimo de créditos diários da disciplina (*)
                     int min_creditos = disciplina->getMinCreds();
                     int min_creditos_fixacao
                        = problemData->creditosFixadosDisciplinaDia( disciplina, *itDiscSala_Dias, *itCjtSala );

                     // Quando existir uma fixação, o mínimo de créditos
                     // deverá ser exatamente a fixação. Caso contrário,
                     // continua sendo o mínimo de créditos da disciplina
                     OPT_ROW::ROWSENSE row_sense = OPT_ROW::LESS;
                     if ( min_creditos_fixacao != 0 )
                     {
                        min_creditos = min_creditos_fixacao;
                        row_sense = OPT_ROW::EQUAL;
                     }

                     OPT_ROW row( nnz, row_sense , 0.0, name );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, min_creditos );
                     }

                     v.reset();
                     v.setType( Variable::V_CREDITOS );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, -1.0 );
                     }

                     if ( row.getnnz() != 0 )
                     {
                        cHash[ c ] = lp->getNumRows();

                        lp->addRow( row );
                        restricoes++;
                     }
                  }
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável $o$
%Desc 

%MatExp

\begin{eqnarray}
C_{d} \cdot o_{i,d,u,tps,t}  \geq  x_{i,d,u,tps,t}  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall u \in U \quad
\forall tps \in SCAP_{u} \quad
\forall t \in T
\end{eqnarray}

%Data C_{d}
%Desc
Total de créditos da disciplina $d$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_ativacao_var_o( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );
			   
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               GGroup< int /*Dias*/ >::iterator itDiscSala_Dias = problemData->disc_Conjutno_Salas__Dias
                  [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].begin();

               for (; itDiscSala_Dias != problemData->disc_Conjutno_Salas__Dias[
                      std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].end();
                      itDiscSala_Dias++ )
                  {
                     for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                     {
                        c.reset();
                        c.setType( Constraint::C_VAR_O );

                        c.setUnidade( *itUnidade );
                        c.setSubCjtSala( *itCjtSala );
                        c.setDia( *itDiscSala_Dias );
                        c.setDisciplina( disciplina );
                        c.setTurma( turma );

                        sprintf( name, "%s", c.toString().c_str() ); 
                        if ( cHash.find( c ) != cHash.end() )
                        {
                           continue;
                        }

                        nnz = 2;

                        OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

                        v.reset();
                        v.setType(Variable::V_OFERECIMENTO);

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiscSala_Dias );

                        it_v = vHash.find( v );
                        if( it_v != vHash.end() )
                        {
                           row.insert( it_v->second,
                              -( disciplina->getCredPraticos() + 
                              disciplina->getCredTeoricos() ) );
                        }

                        v.reset();
                        v.setType( Variable::V_CREDITOS );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiscSala_Dias );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        if ( row.getnnz() != 0 )
                        {
                           cHash[ c ] = lp->getNumRows();

                           lp->addRow( row );
                           restricoes++;
                        }
                     }
                  }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Evitar sobreposição de turmas da mesma disciplina
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{tps \in SCAP_{u}} o_{i,d,u,tps,t}  \leq  1  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall u \in U \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_evita_sobreposicao( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         GGroup< int >::iterator itDiasLetUnid =
            itUnidade->dias_letivos.begin();

         for (; itDiasLetUnid != itUnidade->dias_letivos.end(); itDiasLetUnid++ )
         {
            ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
            {
                disciplina = ( *it_disciplina );
			   
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

				// A disciplina deve ser ofertada no campus especificado
				if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
					 problemData->cp_discs[campusId].end() )
				{
					continue;
				}

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  c.reset();
                  c.setType( Constraint::C_EVITA_SOBREPOSICAO_TD );

                  c.setUnidade( *itUnidade );
                  c.setDia( *itDiasLetUnid );
                  c.setDisciplina( disciplina );
                  c.setTurma( turma );

                  sprintf( name, "%s", c.toString().c_str() ); 
                  if ( cHash.find( c ) != cHash.end() )
                  {
                     continue;
                  }

                  nnz = itUnidade->salas.size();

                  OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiasLetUnid );

                     it_v = vHash.find( v );
                     if( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }
                  }

                  if ( row.getnnz() != 0 )
                  {
                     cHash[ c ] = lp->getNumRows();

                     lp->addRow( row );
                     restricoes++;
                  }
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Indicação de que uma turma de uma disciplina foi alocada 
em um determinado tipo de sala (*)
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{t \in T} o_{i,d,u,tps,t}  \leq  7 \cdot y_{i,d,tps,u}  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall u \in U \quad
\forall s \in S_{u}
\forall tps \in SCAP_{u}
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_disciplina_sala( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			 ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  c.reset();
                  c.setType( Constraint::C_TURMA_DISCIPLINA_SALA );

                  c.setUnidade( *itUnidade );
                  c.setSubCjtSala( *itCjtSala );
                  c.setDisciplina( disciplina );
                  c.setTurma( turma );

                  sprintf( name, "%s", c.toString().c_str() );
                  if ( cHash.find( c ) != cHash.end() )
                  {
                     continue;
                  }

                  nnz = 8;
                  OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

                  GGroup< int /*Dias*/>::iterator itDiscSala_Dias =
                     problemData->disc_Conjutno_Salas__Dias
                     [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].begin();

                  for(; itDiscSala_Dias != problemData->disc_Conjutno_Salas__Dias
                     [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].end(); itDiscSala_Dias++ )
                  {
                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }
                  }

                  v.reset();
                  v.setType( Variable::V_ALOC_DISCIPLINA );

                  v.setTurma( turma );
                  v.setDisciplina( disciplina );
                  v.setUnidade( *itUnidade );
                  v.setSubCjtSala( *itCjtSala );

                  it_v = vHash.find( v );
                  if ( it_v != vHash.end() )
                  {
                     row.insert( it_v->second, -7.0 );
                  }

                  if ( row.getnnz() != 0 )
                  {
                     cHash[ c ] = lp->getNumRows();

                     lp->addRow( row );
                     restricoes++;
                  }
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Uma turma só pode ser alocada a um tipo de sala
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} y_{i,d,tps,u}  \leq  1 \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-413 - Garante que a mesma turma tenha que ser alocada no mesmo tipo de sala em dias diferentes
int SolverMIP::cria_restricao_turma_sala( int campusId )
{
   int restricoes = 0;
   char name[100];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
		disciplina = ( *it_disciplina );

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			   problemData->mapDiscSubstituidaPor.end() ) &&
			 !problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion	

		// A disciplina deve ser ofertada no campus especificado
		if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			 problemData->cp_discs[campusId].end() )
		{
			continue;
		}

		for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
		{
			c.reset();
			c.setType( Constraint::C_TURMA_SALA );

			c.setDisciplina( disciplina );
			c.setTurma( turma );

			sprintf( name, "%s", c.toString().c_str() ); 
			if ( cHash.find( c ) != cHash.end() )
			{
				continue;
			}

			// Pode ser menor esse valor. Na verdade, ele
			// tem que ser igual ao total de conjuntos de salas.
			nnz = problemData->totalSalas;
			OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

			ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
			{
				if ( itCampus->getId() != campusId )
				{
					continue;
				}

				ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{
						v.reset();
						v.setType( Variable::V_ALOC_DISCIPLINA );

						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setUnidade( *itUnidade );
						v.setSubCjtSala( *itCjtSala );

						it_v = vHash.find( v );
						if ( it_v != vHash.end() )
						{
							row.insert( it_v->second, 1.0 );
						}
					}
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHash[ c ] = lp->getNumRows();

				lp->addRow( row );
				restricoes++;
			}
		}
	}

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Evitar alocação de turmas da mesma disciplina em campus diferentes
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{cp \in CP} z_{i,d,cp}  \leq  1  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_evita_turma_disc_camp_d()
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
       disciplina = ( *it_disciplina );

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion	

      for ( int i = 0; i < disciplina->getNumTurmas(); ++i )
      {
         c.reset();
         c.setType( Constraint::C_EVITA_TURMA_DISC_CAMP_D );

         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

         nnz = problemData->totalSalas;
         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

         ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
         {
            v.reset();
            v.setType( Variable::V_ABERTURA );

            v.setTurma( i );
            v.setDisciplina( disciplina );

            v.setCampus( *it_campus );

            it_v = vHash.find( v );
            if( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Abertura de turmas de um mesmo bloco curricular
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{d \in D_{b}} \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} \sum\limits_{i \in I_{d}} o_{i,d,u,tps,t}  \leq M \cdot w_{bc,t,cp} \nonumber \qquad 
\forall bc \in B \quad
\forall cp \in CP \quad
\forall t \in T
\end{eqnarray}

%Data M 
%Desc
big $M$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_turmas_bloco( int campusId )
{	
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      GGroup< int >::iterator itDiasLetCampus =
         itCampus->diasLetivos.begin();

      for(; itDiasLetCampus != itCampus->diasLetivos.end();
         itDiasLetCampus++ )
      {
         ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
         {
			if ( itBloco->campus->getId() != campusId )
			{
				continue;
			}

            c.reset();
            c.setType( Constraint::C_TURMAS_BLOCO );

            c.setBloco( *itBloco );
            c.setDia( *itDiasLetCampus );
            c.setCampus( *itCampus );

            sprintf( name, "%s", c.toString().c_str() ); 
            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            // FIX-ME
            nnz = 100;

            OPT_ROW row( ( nnz + 1 ), OPT_ROW::LESS , 0.0, name );

            ITERA_GGROUP_LESSPTR( it_disciplina, itBloco->disciplinas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

               ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                     {
                        v.reset();
                        v.setType( Variable::V_OFERECIMENTO );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiasLetCampus );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }
                     }
                  }
               }
            }

            v.reset();
            v.setType( Variable::V_N_SUBBLOCOS );

            v.setBloco( *itBloco );
            v.setDia( *itDiasLetCampus );
            v.setCampus( *itCampus );

            it_v = vHash.find( v );
            if( it_v != vHash.end() )
            {
               row.insert( it_v->second, -9999.0 );
            }
            // Provavelmente esta restrição é inútil

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Turmas de disciplinas de mesmo bloco não devem exceder máximo de créditos por dia
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{d \in D_{bc}} \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} \sum\limits_{i \in I_{d}} q_{i,d,oft,u,tps,t} 
			\leq \sum\limits_{k} ( Nh_{bc,t,sl,k} \cdot cbc_{bc,t,k} )  \nonumber \qquad 
\forall bc \in B \quad
\forall cp \in CP
\forall t \in T \quad
\end{eqnarray}

%Data H_{t}
%Desc
máximo de créditos permitidos por dia $t$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_cred_disc_bloco( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;
   
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      GGroup< int >::iterator itDiasLetCampus = itCampus->diasLetivos.begin();

      ITERA_GGROUP_N_PT( itDiasLetCampus, itCampus->diasLetivos, int )
      {
		 int dia = *itDiasLetCampus;

         ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
         {
			BlocoCurricular *bc = *itBloco;

			if ( bc->campus->getId() != campusId )
			{
				continue;
			}

			int periodo = bc->getPeriodo();
			
			Oferta* oft = bc->oferta;

			GGroup< Calendario*, LessPtr<Calendario> > calendarios = itBloco->curriculo->retornaSemanasLetivasNoPeriodo( periodo );

			ITERA_GGROUP_LESSPTR( itSL, calendarios, Calendario )
			{
				Calendario *sl = *itSL;

				c.reset();
				c.setType( Constraint::C_MAX_CRED_DISC_BLOCO );

				c.setBloco( bc );
				c.setDia( dia );
				c.setCampus( *itCampus );
				c.setSemanaLetiva( sl );

				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHash.find( c ) != cHash.end() )
				{
				   continue;
				}

				nnz =  100; /*FIX-ME*/

				OPT_ROW row( nnz + 1, OPT_ROW::LESS , 0.0, name );
			
				// Variavel responsavel por armazenar o maximo de
				// creditos disponiveis  dentre todas as salas para um dado dia.
				//int maxCredsSalaDia = 0;
				//int maxCredsProfDia = 0;
				ITERA_GGROUP_LESSPTR( it_disciplina, itBloco->disciplinas, Disciplina )
				{
				    disciplina = ( *it_disciplina );

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion	

				   // Só considera disciplinas da semana letiva corrente
				   if ( disciplina->getCalendario() != *itSL )
				   {
					   continue;
				   }

				   ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				   {
					  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					  {
						 if ( itCjtSala->disciplinas_associadas.find( disciplina ) == itCjtSala->disciplinas_associadas.end() )
							continue;

						 for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
						 {
							v.reset();
							v.setType( Variable::V_CREDITOS_OFT );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetCampus );
							v.setOferta( oft );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
							   row.insert( it_v->second, 1.0 );
							}
						 }
					  }
				   }
				}

				std::map< Trio<int, int, Calendario*>, int >::iterator it_map = bc->combinaCredSL.begin();
				for ( ; it_map != bc->combinaCredSL.end(); it_map++  )
				{
					if ( it_map->first.first == dia && it_map->first.third == sl )
					{
						int k = it_map->first.second;
						
						v.reset();
						v.setType( Variable::V_COMBINA_SL_BLOCO );
						v.setBloco( bc );
						v.setDia( dia );
						v.setCombinaSLBloco( k );

						it_v = vHash.find( v );
						if( it_v != vHash.end() )
						{
							int coef = bc->getNroMaxCredCombinaSL( k, sl, dia );

							row.insert( it_v->second, -coef );
						}
					}
				}

				if ( row.getnnz() != 0 )
				{
				   cHash[ c ] = lp->getNumRows();

				   lp->addRow( row );
				   restricoes++;
				}
			}
         }
      }
   }

   return restricoes;
}




/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Contabiliza se há turmas do mesmo bloco curricular abertas no mesmo 
dia em unidades distintas
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{cp \in CP} r_{bc,t,cp} - 1  \leq v_{bc,t} \nonumber \qquad 
\forall bc \in B \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_num_tur_bloc_dia_difunid( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	   if ( it_bloco->campus->getId() != campusId )
	   {
		   continue;
	   }

      GGroup< int >::iterator itDiasLetBloco =
         it_bloco->diasLetivos.begin();

      for (; itDiasLetBloco != it_bloco->diasLetivos.end(); itDiasLetBloco++ )
      {
         c.reset();
         c.setType( Constraint::C_NUM_TUR_BLOC_DIA_DIFUNID );

         c.setBloco( *it_bloco );
         c.setDia( *itDiasLetBloco );

         sprintf( name, "%s", c.toString().c_str() ); 
         cHash[ c ] = lp->getNumRows();
         nnz = problemData->campi.size();

         OPT_ROW row( nnz + 1, OPT_ROW::LESS , 1.0 , name );

         ITERA_GGROUP_LESSPTR( it_cp, problemData->campi, Campus )
         {
            v.reset();
            v.setType( Variable::V_ABERTURA_SUBBLOCO_DE_BLC_DIA_CAMPUS );

            v.setBloco( *it_bloco );
            v.setDia( *itDiasLetBloco );
            v.setCampus( *it_cp );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         v.reset();
         v.setType( Variable::V_N_ABERT_TURMA_BLOCO );

         v.setBloco( *it_bloco );
         v.setDia( *itDiasLetBloco );

         it_v = vHash.find( v );
         if ( it_v != vHash.end() )
         {
            row.insert( it_v->second, -1.0 );
         }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint
Limite de créditos diários de disciplina (*)
%Desc 

%MatExp

\begin{eqnarray}
x_{i,d,u,tps,t}  \leq \overline{H_{d}}  \nonumber \qquad 
\forall d \in D \quad
\forall u \in U \quad
\forall tps \in SCAP_{u} \quad
\forall t \in T \quad
\forall i \in I_{d}
\end{eqnarray}

%Data \overline{H_{d}}
%Desc
máximo de créditos diários da disciplina $d$.

%DocEnd
/====================================================================*/

// TRIEDA-406 Cont-Limite de créditos diários de disciplina
int SolverMIP::cria_restricao_lim_cred_diar_disc( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			 ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
             {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

               GGroup< int /*Dias*/ > disc_sala_dias
                  = problemData->disc_Conjutno_Salas__Dias
                  [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ];

               ITERA_GGROUP_N_PT( itDiscSala_Dias, disc_sala_dias, int )
               {
                  for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                  {
                     c.reset();
                     c.setType( Constraint::C_LIM_CRED_DIAR_DISC );

                     c.setTurma( turma );
                     c.setDisciplina( disciplina );
                     c.setUnidade( *itUnidade );
                     c.setSubCjtSala( *itCjtSala );
                     c.setDia( *itDiscSala_Dias );

                     sprintf( name, "%s", c.toString().c_str() );
                     if ( cHash.find( c ) != cHash.end() )
                     {
                        continue;
                     }

                     nnz = 1;

                     // 1.2.13
                     // Limite de créditos diários de disciplina (*)
                     int maximo_creditos = itCjtSala->maxCredsDiaPorSL( *itDiscSala_Dias, disciplina->getCalendario() );
                     int maximo_creditos_fixacao
                        = problemData->creditosFixadosDisciplinaDia( disciplina, *itDiscSala_Dias, *itCjtSala );

                     // Quando existir uma fixação, o máximo de créditos deverá
                     // ser exatamente a fixação. Caso contrário, continua sendo
                     // o máximo de créditos por dia do conjunto de salas
                     OPT_ROW::ROWSENSE row_sense = OPT_ROW::LESS;
                     if ( maximo_creditos_fixacao != 0 )
                     {
                        maximo_creditos = maximo_creditos_fixacao;
                        row_sense = OPT_ROW::EQUAL;
                     }

                     OPT_ROW row( 1, row_sense , maximo_creditos , name );

                     v.reset();
                     v.setType( Variable::V_CREDITOS );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );

                     it_v = vHash.find( v );
                     if( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }

                     if ( row.getnnz() != 0 )
                     {
                        cHash[ c ] = lp->getNumRows();

                        lp->addRow( row );
                        restricoes++;
                     }
                  }
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Capacidade alocada tem que permitir atender demanda da disciplina
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{i \in I_{d}} a_{i,d,oft} + fd_{d,oft} =  P_{d,oft}  \nonumber \qquad 
\forall oft \in O
\forall d \in D_{oft} \quad
\end{eqnarray}

%Data P_{d,oft}
%Desc
demanda da disciplina $d$ da oferta $oft$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_cap_aloc_dem_disc( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz = 0;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itOferta, problemData->ofertas, Oferta )
   {
	   if ( itOferta->getCampusId() != campusId )
	   {
		   continue;
	   }

       map < Disciplina*, int, LessPtr< Disciplina > >::iterator itPrdDisc = 
         itOferta->curriculo->disciplinas_periodo.begin();

      for (; itPrdDisc != itOferta->curriculo->disciplinas_periodo.end(); itPrdDisc++ )
      {
		  disciplina = itPrdDisc->first;

		  #pragma region Equivalencias
		  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				 problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		  {
			  continue;
		  }
		  #pragma endregion	

         c.reset();
         c.setType( Constraint::C_CAP_ALOC_DEM_DISC );

         c.setOferta( *itOferta );
         c.setDisciplina( disciplina );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

         if ( disciplina->getNumTurmas() <= 0 )
         {
            continue;
         }

         nnz = disciplina->getNumTurmas();
         int rhs = 0;

         // Calculando P_{d,o}
         ITERA_GGROUP_LESSPTR( itDem, problemData->demandas, Demanda )
         {
            if ( itDem->disciplina->getId() == disciplina->getId()
               && itDem->getOfertaId() == itOferta->getId() )
            {
               rhs += itDem->getQuantidade();
            }
         }

         OPT_ROW row( nnz , OPT_ROW::EQUAL, rhs , name );

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            v.reset();
            v.setType( Variable::V_ALUNOS );

            v.setTurma( turma );
            v.setDisciplina( disciplina );
            v.setOferta( *itOferta );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         v.reset();
         v.setType( Variable::V_SLACK_DEMANDA );
         v.setDisciplina( disciplina );
         v.setOferta( *itOferta );

         it_v = vHash.find( v );
         if( it_v != vHash.end() )
         {
            row.insert( it_v->second, 1.0 );
         }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Se alocar um conjunto de salas para uma turma, tem que respeitar 
capacidade total das salas pertencentes ao conjunto
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{c \in C} \sum\limits_{oft \in O_{d}} a_{i,d,oft}  \leq \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} \sum\limits_{t \in T} A_{u,tps} \cdot o_{i,d,u,tps,t} 
\nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall cp \in CP
\end{eqnarray}

%Data A_{u,s}
%Desc
capacidade da sala $s$ da unidade $u$.

%DocEnd
/====================================================================*/

// TRIEDA-390
int SolverMIP::cria_restricao_cap_sala_compativel_turma( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		    continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion	

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			 continue;
		 }

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( Constraint::C_CAP_SALA_COMPATIVEL_TURMA );

            c.setCampus( *itCampus );
            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() ); 
            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = problemData->ofertas.size() * problemData->cursos.size() +
               itCampus->getTotalSalas() * 7;

            OPT_ROW row( nnz , OPT_ROW::LESS , 0.0 , name );

            GGroup< Oferta *, LessPtr< Oferta > >::iterator itOferta = 
               problemData->ofertasDisc[ disciplina->getId() ].begin();

            for (; itOferta != problemData->ofertasDisc[ disciplina->getId() ].end();
                   itOferta++ )
            {
               v.reset();
               v.setType( Variable::V_ALUNOS );

               v.setTurma( turma );
               v.setDisciplina( disciplina );
               v.setOferta( *itOferta );

               it_v = vHash.find( v );
               if ( it_v != vHash.end() )
               {
                  row.insert( it_v->second, 1.0 );
               }
            }

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
                  GGroup< int /*Dias*/ >::iterator itDiscSala_Dias =
                     problemData->disc_Conjutno_Salas__Dias
                     [ std::make_pair< int, int >( disciplina->getId(), itCjtSala->getId() ) ].begin();

                  for (; itDiscSala_Dias != problemData->disc_Conjutno_Salas__Dias
                     [ std::make_pair< int, int >( disciplina->getId(), itCjtSala->getId() ) ].end();
                     itDiscSala_Dias++ )
                  { 
                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     { 
                        int tmp = ( itCjtSala->getCapacidadeRepr() > 0 ?
                           itCjtSala->getCapacidadeRepr() :
                        ( -itCjtSala->getCapacidadeRepr() ) );

                        row.insert( it_v->second, -tmp );
                     }
                  }
               }
            }

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   //ITERA_GGROUP(itCampus,problemData->campi,Campus)
   //{
   //   ITERA_GGROUP(itDisc,problemData->disciplinas,Disciplina)
   //   {
   //      for(int turma = 0; turma < itDisc->num_turmas; turma++)
   //      {
   //         c.reset();
   //         c.setType(Constraint::C_CAP_SALA_COMPATIVEL_TURMA);
   //         c.setCampus(*itCampus);
   //         c.setDisciplina(*itDisc);
   //         c.setTurma(turma);

   //         // >>>
   //         std::string auxCons = c.toString().c_str();
   //         auxCons += "_";
   //         auxCons += lp->getNumRows();

   //         sprintf( name, "%s", auxCons.c_str() ); 

   //         //if (cHash.find(c) != c.toString().end()) continue;
   //         if (cHash.find(c) != cHash.end()) continue;
   //         // <<<

   //         //cHash[ c ] = lp->getNumRows();

   //         nnz = problemData->ofertas.size() * problemData->cursos.size() +
   //            itCampus->totalSalas * 7;

   //         OPT_ROW row( nnz , OPT_ROW::LESS , 0.0 , name );

   //         GGroup<Oferta*>::iterator itOferta = 
   //            problemData->ofertasDisc[itDisc->getId()].begin();

   //         for(; itOferta != problemData->ofertasDisc[itDisc->getId()].end(); itOferta++)
   //         {
   //            v.reset();
   //            v.setType(Variable::V_ALUNOS);
   //            v.setTurma(turma);
   //            v.setDisciplina(*itDisc);
   //            v.setOferta(*itOferta);

   //            it_v = vHash.find(v);
   //            if( it_v != vHash.end() )
   //            { row.insert(it_v->second, 1.0); }
   //         }

   //         ITERA_GGROUP(itUnidade,itCampus->unidades,Unidade)
   //         {
   //            ITERA_GGROUP(itCjtSala,itUnidade->conjutoSalas,ConjuntoSala)
   //            {
   //               for(int dia = 0 ; dia < 7; dia++)
   //               {
   //                  v.reset();
   //                  v.setType(Variable::V_OFERECIMENTO);
   //                  v.setTurma(turma);
   //                  v.setDisciplina(*itDisc);
   //                  v.setUnidade(*itUnidade);
   //                  v.setSubCjtSala(*itCjtSala);
   //                  v.setDia(dia);

   //                  it_v = vHash.find(v);
   //                  if( it_v != vHash.end() )
   //                  { row.insert(it_v->second, -itCjtSala->capTotalSalas()); }
   //               }
   //            }
   //         }

   //         if(row.getnnz() != 0)
   //         {
   //            cHash[ c ] = lp->getNumRows();

   //            lp->addRow(row);
   //            restricoes++;
   //         }

   //         //lp->addRow(row);
   //         //++restricoes;
   //      }
   //   }
   //}

   //ITERA_GGROUP(it_campus,problemData->campi,Campus) {
   //   ITERA_GGROUP(it_disc,problemData->disciplinas,Disciplina) {
   //      for(int i=0;i<it_disc->num_turmas;++i) {

   //         c.reset();
   //         c.setType(Constraint::C_CAP_SALA_COMPATIVEL_TURMA);
   //         c.setCampus(*it_campus);
   //         c.setDisciplina(*it_disc);
   //         c.setTurma(i);

   //         sprintf( name, "%s", c.toString().c_str() ); 

   //         if (cHash.find(c) != cHash.end()) continue;

   //         cHash[ c ] = lp->getNumRows();

   //         nnz = problemData->cursos.size() +
   //            it_campus->totalSalas * 7;

   //         OPT_ROW row( nnz , OPT_ROW::LESS , 0.0 , name );

   //         ITERA_GGROUP(it_curso,problemData->cursos,Curso) {
   //            v.reset();
   //            v.setType(Variable::V_ALUNOS);
   //            v.setTurma(i);
   //            v.setDisciplina(*it_disc);
   //            v.setCampus(*it_campus);
   //            v.setCurso(*it_curso);

   //            it_v = vHash.find(v);
   //            if( it_v != vHash.end() )
   //            {
   //               row.insert(it_v->second, 1.0);
   //            }
   //         }

   //         ITERA_GGROUP(it_u,it_campus->unidades,Unidade) {
   //            ITERA_GGROUP(it_sala,it_u->salas,Sala) {
   //               for(int t=0;t<7;t++) {
   //                  v.reset();
   //                  v.setType(Variable::V_OFERECIMENTO);
   //                  v.setTurma(i);
   //                  v.setDisciplina(*it_disc);
   //                  v.setUnidade(*it_u);
   //                  v.setSala(*it_sala);
   //                  v.setDia(t);

   //                  it_v = vHash.find(v);
   //                  if( it_v != vHash.end() )
   //                  {
   //                     row.insert(it_v->second, -it_sala->capacidade);
   //                  }
   //               }
   //            }
   //         }
   //         lp->addRow(row);
   //         ++restricoes;
   //      }
   //   }
   //}

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Capacidade total de um conjunto de salas de uma unidade
%Desc

%MatExp

\begin{eqnarray}
\sum\limits_{c \in C} \sum\limits_{oft \in O_{d}} a_{i,d,oft} \leq A_{u,tps} + M \cdot (1-o_{i,d,u,tps,t}) \nonumber \qquad
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall u \in U \quad
\forall tps \in SCAP_{u} \quad
\forall cp \in CP \quad
\forall t \in T
\end{eqnarray}

%Data A_{u,s}
%Desc
capacidade da sala $s$ da unidade $u$.

%Data M
%Desc
big $M$.

%DocEnd
/====================================================================*/

// TRIEDA-391 - Capacidade da sala na unidade
int SolverMIP::cria_restricao_cap_sala_unidade( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade)
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	
				
               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  GGroup< int /*Dias*/ > disc_sala_dias =                     
                     problemData->disc_Conjutno_Salas__Dias[ std::make_pair< int, int >
                     ( disciplina->getId(), itCjtSala->getId() ) ];

                  ITERA_GGROUP_N_PT( itDiscSala_Dias, disc_sala_dias, int )
                  {
                     c.reset();
                     c.setType( Constraint::C_CAP_SALA_UNIDADE );

                     c.setUnidade( *itUnidade );
                     c.setSubCjtSala( *itCjtSala );
                     c.setDisciplina( disciplina );
                     c.setTurma( turma );
                     c.setCampus( *itCampus );
                     c.setDia( *itDiscSala_Dias );

                     sprintf( name, "%s", c.toString().c_str() ); 
                     if ( cHash.find( c ) != cHash.end() )
                     {
                        continue;
                     }

                     nnz = 200;

                     int tmp = ( itCjtSala->getCapacidadeRepr() > 0 ?
                        itCjtSala->getCapacidadeRepr() : ( -itCjtSala->getCapacidadeRepr() ) );

                     // itUnidade->maiorSala;
                     int rhs = tmp + 1000; 
                     OPT_ROW row( nnz, OPT_ROW::LESS , rhs , name );

                     // ---

                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );
                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );

                     it_v = vHash.find( v );
                     if( it_v != vHash.end() )
                     { 
                        row.insert( it_v->second, 1000 );
                     }
					 else
					 {
						continue;
					 }

                     // ---

                     GGroup< Oferta *, LessPtr< Oferta > > group_ofertas
                        = problemData->ofertasDisc[ disciplina->getId() ];
                     ITERA_GGROUP_LESSPTR( itOferta, group_ofertas, Oferta )
                     {
						 if ( itOferta->getCampusId() != campusId )
						 {
							 continue;
						 }

                        v.reset();
                        v.setType( Variable::V_ALUNOS );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setOferta( *itOferta );

                        it_v = vHash.find( v );
                        if( it_v != vHash.end() )
                        { 
                           row.insert( it_v->second, 1.0 );
                        }
                     }

                     // ---

                     if ( row.getnnz() != 0 )
                     {
                        cHash[ c ] = lp->getNumRows();

                        lp->addRow( row );
                        restricoes++;
                     }
                  }
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Contabiliza se há turmas da mesma disciplina em dias consecutivos (*)
%Desc 

%MatExp

\begin{eqnarray}
c_{i,d,t}  \geq \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}}(o_{i,d,u,tps,t} - o_{i,d,u,tps,t-1}) - 1  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall (t \geq 2) \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-392
int SolverMIP::cria_restricao_turma_disc_dias_consec( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina,
      problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
		   problemData->cp_discs[campusId].end() )
	  {
		  continue;
	  }

      for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
      {
         GGroup< int >::iterator itDiasLetDisc =
            disciplina->diasLetivos.begin();

         for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
         {
            c.reset();
            c.setType( Constraint::C_TURMA_DISC_DIAS_CONSEC );

            c.setDisciplina( disciplina );
            c.setTurma( turma );
            c.setDia( *itDiasLetDisc );

            sprintf( name, "%s", c.toString().c_str() ); 

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = ( problemData->totalSalas * 2 + 1 );
            OPT_ROW row( nnz, OPT_ROW::GREATER , -1 , name );

            v.reset();
            v.setType( Variable::V_DIAS_CONSECUTIVOS );
            v.setTurma( turma );
            v.setDisciplina( disciplina );
            v.setDia( *itDiasLetDisc );
			v.setCampus( problemData->refCampus[campusId] );		 // cp

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
            {
			   if ( itCampus->getId() != campusId )
			   {
				   continue;
			   }

               ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiasLetDisc );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, -1.0 );
                     }

                     v.setDia( ( *itDiasLetDisc ) - 1 );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }
                  }
               }
            }

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Mínimo de créditos alocados para turmas de um bloco (*)
%Desc 

%MatExp

\begin{eqnarray}
\underline{h}_{bc,i} \leq \sum\limits_{d \in D_{bc}} \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} tempo_{d} \cdot q_{i,d,oft,u,tps,t} \nonumber \qquad 
\forall bc \in B \quad
\forall i \in I_{oft} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-393
int SolverMIP::cria_restricao_min_creds_turm_bloco( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
   {
	  Oferta *oft = itBloco->oferta;

	  if ( itBloco->campus->getId() != campusId )
	  {
		  continue;
	  }

      for ( int turma = 0; turma < itBloco->getTotalTurmas(); turma++ )
      {
         GGroup< int >::iterator itDiasLetivosBlocoCurric = 
            itBloco->diasLetivos.begin();

         for (; itDiasLetivosBlocoCurric != itBloco->diasLetivos.end();
            itDiasLetivosBlocoCurric++ )
         {
            c.reset();
            c.setType( Constraint::C_MIN_CREDS_TURM_BLOCO );

            c.setBloco( *itBloco );
            c.setTurma( turma );
            c.setDia( *itDiasLetivosBlocoCurric );

            sprintf( name, "%s", c.toString().c_str() ); 

            if (cHash.find(c) != cHash.end())
            {
               continue;
            }

            nnz = ( ( itBloco->disciplinas.size() * problemData->totalConjuntosSalas ) + 1 );

            OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0 , name );

            ITERA_GGROUP_LESSPTR( it_disciplina, itBloco->disciplinas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

               ITERA_GGROUP_LESSPTR( itUnidade, itBloco->campus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     v.reset();
                     v.setType( Variable::V_CREDITOS_OFT );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
					 v.setOferta( oft );
                     v.setDia( *itDiasLetivosBlocoCurric );

                     it_v = vHash.find( v );
                     if( it_v != vHash.end() )
                     {
						 row.insert( it_v->second, disciplina->getTempoCredSemanaLetiva() );
                     }
                  }
               }
            }

            v.reset();
            v.setType( Variable::V_MIN_CRED_SEMANA );

            v.setTurma( turma );
            v.setBloco( *itBloco );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, -1.0 );
            }

            // Para evitar a criação da restrição no caso em que só a variável h seja encontrada. Isso é só uma
            // garantia. Como os dias letivos estão sendo respeitados, não devemos notar erros.
            if ( row.getnnz() > 1 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Máximo de créditos alocados para turmas de um bloco (*)
%Desc 

%MatExp

\begin{eqnarray}
\overline{h}_{bc,i} \geq \sum\limits_{d \in D_{bc}} \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} tempo_{d} \cdot q_{i,d,oft,u,tps,t} \nonumber \qquad 
\forall bc \in B \quad
\forall i \in I_{oft} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-394
int SolverMIP::cria_restricao_max_creds_turm_bloco( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
   {
	  Oferta *oft = itBloco->oferta;
			   
	  if ( itBloco->campus->getId() != campusId )
	  {
		  continue;
	  }

      for ( int turma = 0; turma < itBloco->getTotalTurmas(); turma++ )
      {
         GGroup< int >::iterator itDiasLetivosBlocoCurric = 
            itBloco->diasLetivos.begin();

         for(; itDiasLetivosBlocoCurric != itBloco->diasLetivos.end();
            itDiasLetivosBlocoCurric++ )
         {
            c.reset();
            c.setType( Constraint::C_MAX_CREDS_TURM_BLOCO );

            c.setBloco( *itBloco );
            c.setTurma( turma );
            c.setDia( *itDiasLetivosBlocoCurric );

            sprintf( name, "%s", c.toString().c_str() ); 

            if (cHash.find(c) != cHash.end()) continue;

            nnz = ( ( itBloco->disciplinas.size() * problemData->totalConjuntosSalas ) + 1 );

            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

            ITERA_GGROUP_LESSPTR( it_disciplina, itBloco->disciplinas, Disciplina )
            {
               disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

               ITERA_GGROUP_LESSPTR( itUnidade, itBloco->campus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     v.reset();
                     v.setType( Variable::V_CREDITOS_OFT );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
					 v.setOferta( oft );
                     v.setDia( *itDiasLetivosBlocoCurric );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, disciplina->getTempoCredSemanaLetiva() );
                     }
                  }
               }
            }

            v.reset();
            v.setType( Variable::V_MAX_CRED_SEMANA );

            v.setTurma( turma );
            v.setBloco( *itBloco );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, -1.0 );
            }

            // Para evitar a criação da restrição no caso em que só a
            // variável h seja encontrada. Isso é só uma garantia.
            // Como os dias letivos estão sendo respeitados, não devemos notar erros.
            if ( row.getnnz() > 1 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Contabiliza se houve aluno de determinado curso alocado em uma turma (*)
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{o \in O_{d}} a_{i,d,oft} \leq M \cdot b_{i,d,c,cp} \nonumber \qquad 
\forall cp \in CP
\forall c \in C \quad
\forall d \in D \quad
\forall i \in I_{d} \quad
\end{eqnarray}

%Data M
%Desc
big $M$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_aluno_curso_disc( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
      {
         ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
         {
            disciplina = ( *it_disciplina );

			// A disciplina deve ser ofertada no campus especificado
			if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
				 problemData->cp_discs[campusId].end() )
			{
				continue;
			}

			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
			{
				continue;
			}
			#pragma endregion	

            for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
            {
               c.reset();
               c.setType( Constraint::C_ALUNO_CURSO_DISC );

               c.setCampus( *itCampus );
               c.setCurso( *itCurso );
               c.setDisciplina( disciplina );
               c.setTurma( turma );

               sprintf( name, "%s", c.toString().c_str() );
               if ( cHash.find( c ) != cHash.end() )
               {
                  continue;
               }

               nnz = ( problemData->ofertasDisc[ disciplina->getId() ].size() + 1 );
               OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

               GGroup< Oferta *, LessPtr< Oferta > > ofertas
                  = problemData->ofertasDisc[ disciplina->getId() ];
               ITERA_GGROUP_LESSPTR( itOfertasDisc, ofertas, Oferta )
               {
                  if ( itOfertasDisc->campus == ( *itCampus ) )
                  {
                     if ( itOfertasDisc->curso == ( *itCurso ) )
                     {
                        v.reset();
                        v.setType( Variable::V_ALUNOS );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setOferta( *itOfertasDisc );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }
                     }
                  }
               }

               v.reset();
               v.setType( Variable::V_ALOC_ALUNO );

               v.setTurma( turma );
               v.setDisciplina( disciplina );
               v.setCurso( *itCurso );
               v.setCampus( *itCampus );

               it_v = vHash.find(v);
               if( it_v != vHash.end() )
               {
                  row.insert( it_v->second, -itCampus->getMaiorSala() * 100 );
               }

               if ( row.getnnz() != 0 )
               {
                  cHash[ c ] = lp->getNumRows();

                  lp->addRow( row );
                  restricoes++;
               }
            }
         }
      }
   }

   return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
TODO: conferir o funcionamento dessa restricao
Não permitir que alunos de cursos diferentes incompatíveis compartilhem turmas (*)
%Desc 

%MatExp

\begin{eqnarray} 
b_{i,d,c,cp} + b_{i,d,c',cp} - bs_{i,d,c,c',cp} \leq 1 \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall c,c' \notin CC \quad
\forall cp \in CP
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_alunos_cursos_incompat( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		if ( itCampus->getId() != campusId )
		{
			continue;
		}

		ITERA_GGROUP_LESSPTR( it1Cursos, problemData->cursos, Curso )
		{
			Curso* c1 = *it1Cursos;
			
			if ( itCampus->cursos.find( c1 ) == itCampus->cursos.end() )
			{
				continue;
			}

			ITERA_GGROUP_INIC_LESSPTR( it2Cursos, it1Cursos, problemData->cursos, Curso )
			{
				Curso* c2 = *it2Cursos;
			    
				if ( itCampus->cursos.find( c2 ) == itCampus->cursos.end() )
				{
					continue;
				}
				if ( problemData->cursosCompativeis(c1, c2) )
				{
					continue;
				}

				ITERA_GGROUP_LESSPTR( itDisc, problemData->disciplinas, Disciplina )
				{
					Disciplina *disciplina = *itDisc;

					// A disciplina deve ser ofertada no campus especificado
					if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
						 problemData->cp_discs[campusId].end() )
					{
						continue;
					}

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						 !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion	
										
					if ( !c1->possuiDisciplina(disciplina) || !c2->possuiDisciplina(disciplina) )
						continue;
					

					for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
					{
						c.reset();
						c.setType( Constraint::C_ALUNOS_CURSOS_INCOMP );
						c.setCampus( *itCampus );
						c.setParCursos( std::make_pair( c1, c2 ) );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHash.find( c ) != cHash.end() )
						{
							continue;
						}

						nnz = 3;

						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

						v.reset();
						v.setType( Variable::V_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c1 );
						v.setCampus( *itCampus );

						it_v = vHash.find( v );
						if( it_v != vHash.end() )
						{
							row.insert( it_v->second, 1 );
						}

						v.reset();
						v.setType( Variable::V_ALOC_ALUNO );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setCurso( c2 );
						v.setCampus( *itCampus );

						it_v = vHash.find( v );
						if( it_v != vHash.end() )
						{
							row.insert(it_v->second, 1);
						}

						v.reset();
						v.setType( Variable::V_SLACK_ALOC_ALUNOS_CURSO_INCOMPAT );
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setParCursos( std::make_pair( c1, c2 ) );
						v.setCampus( *itCampus );

						it_v = vHash.find( v );
						if ( it_v != vHash.end() )
						{
							row.insert( it_v->second, -1 );
						}

						if ( row.getnnz() != 0 )
						{
							cHash[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}
   }

   return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Fixação da distribuição de créditos por dia (*)
%Desc 

%MatExp

\begin{eqnarray}
x_{i,d,u,s,t} + fcp_{i,d,s,t} - fcm_{i,d,s,t} = FC_{d,s,t} \cdot z_{i,d,cp}  \nonumber \qquad 
\forall cp \in CP
\forall s \in S_{u} \quad
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-395
int SolverMIP::cria_restricao_de_folga_dist_cred_dia( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		    continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			 ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
                disciplina = ( *it_disciplina );

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  GGroup< int >::iterator itDiasLetDisc = disciplina->diasLetivos.begin();

                  for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
                  {
                     ITERA_GGROUP_LESSPTR( it_fix, problemData->fixacoes, Fixacao )
                     {
                        if ( it_fix->getDisciplinaId() == disciplina->getId() &&
                             it_fix->getDiaSemana() == ( *itDiasLetDisc ) &&
						     it_fix->sala != NULL )
                        {
						   Sala *s = (*itCjtSala)->salas.begin()->second;
						   if ( s->getId() != it_fix->sala->getId() )
						   {
							   continue;
						   }

                           c.reset();
                           c.setType( Constraint::C_SLACK_DIST_CRED_DIA );

                           c.setTurma( turma );
                           c.setDisciplina( disciplina );
                           c.setDia( *itDiasLetDisc );
                           c.setSubCjtSala( *itCjtSala );

                           sprintf( name, "%s", c.toString().c_str() );
                           if ( cHash.find( c ) != cHash.end() )
                           {
                              continue;
                           }

                           if ( disciplina->getNumTurmas() < 0 )
                           {
                              continue;
                           }

                           nnz = 4;

                           OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

							v.reset();
							v.setType( Variable::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetDisc );

							it_v = vHash.find(v);
							if( it_v != vHash.end() )
							{
								row.insert( it_v->second, 1.0 );
							}

							v.reset();
							v.setType( Variable::V_SLACK_DIST_CRED_DIA_SUPERIOR );
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setDia( *itDiasLetDisc );
							v.setSubCjtSala( *itCjtSala );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, 1.0 );
							}

							v.reset();
							v.setType( Variable::V_SLACK_DIST_CRED_DIA_INFERIOR );
							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setDia( *itDiasLetDisc );
							v.setSubCjtSala( *itCjtSala );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, -1.0 );
							}

							v.reset();
							v.setType( Variable::V_ABERTURA );

							v.setCampus( *itCampus );
							v.setDisciplina( disciplina );
							v.setTurma( turma );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second,
									-( it_fix->disciplina->getMaxCreds() ) ); // TODO!!!! coeficiente..
							}

							if ( row.getnnz() != 0 )
							{
								cHash[ c ] = lp->getNumRows();

								lp->addRow( row );
								restricoes++;
							}						  
                        }
                     }
                  }
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável r
%Desc 

%MatExp

\begin{eqnarray}
w_{bc,t,cp} \leq M \cdot r_{bc,t,cp} \nonumber \qquad 
\forall bc \in B \quad
\forall cp \in CP \quad
\forall t \in T
\end{eqnarray}

%Data M
%Desc
big $M$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_ativacao_var_r( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	   if ( it_bloco->campus->getId() != campusId )
	   {
		   continue;
	   }
		  
      GGroup< int >::iterator itDiasLetBloco = it_bloco->diasLetivos.begin();

      for (; itDiasLetBloco != it_bloco->diasLetivos.end(); itDiasLetBloco++ )
      {
         c.reset();
         c.setType( Constraint::C_VAR_R );

         c.setBloco( *it_bloco );
         c.setCampus( it_bloco->campus );
         c.setDia( *itDiasLetBloco );

         sprintf( name, "%s", c.toString().c_str() ); 

         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

         nnz = 2;

         OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

         v.reset();
         v.setType( Variable::V_N_SUBBLOCOS );

         v.setBloco( *it_bloco );
         v.setDia( *itDiasLetBloco );
         v.setCampus( it_bloco->campus );

         it_v = vHash.find( v );
         if ( it_v != vHash.end() )
         {
            row.insert( it_v->second, 1.0 );
         }

         v.reset();
         v.setType( Variable::V_ABERTURA_SUBBLOCO_DE_BLC_DIA_CAMPUS );

         v.setBloco( *it_bloco );
         v.setDia( *itDiasLetBloco );
         v.setCampus( it_bloco->campus );

         it_v = vHash.find( v );
         if ( it_v != vHash.end() )
         {
            row.insert( it_v->second, -9999.0 );
         }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Limita a abertura de turmas
%Desc 

%MatExp

\begin{eqnarray}
z_{i,d,cp} \leq \sum\limits_{oft \in O_{cp}} a_{i,d,oft}  \nonumber \qquad 
\forall cp \in CP \quad
\forall d \in D \quad
\forall i \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_limita_abertura_turmas( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   int min;
   if ( problemData->parametros->min_alunos_abertura_turmas )
   {
		min = problemData->parametros->min_alunos_abertura_turmas_value;
		if ( min <= 0 ) min = 1;
   }
   else
   {
	   min = 1;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			continue;
		 }

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion	

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( Constraint::C_LIMITA_ABERTURA_TURMAS );

            c.setCampus( *itCampus );
            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = 2;
            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

            v.reset();
            v.setType( Variable::V_ABERTURA );

            v.setTurma( turma );
            v.setDisciplina( disciplina );
            v.setCampus( *itCampus );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, min );
            }

            // ---

            GGroup< Oferta *, LessPtr< Oferta > > ofertas =
               problemData->ofertasDisc[ disciplina->getId() ];

            ITERA_GGROUP_LESSPTR( itOft, ofertas, Oferta )
            {
               if ( itOft->campus->getId() == itCampus->getId() )
               {            
                  v.reset();
                  v.setType( Variable::V_ALUNOS );

                  v.setTurma( turma );
                  v.setDisciplina( disciplina );
                  v.setOferta( *itOft );

                  it_v = vHash.find( v );
                  if ( it_v != vHash.end() )
                  {
                     row.insert( it_v->second, -1.0 );
                  }
               }
            }

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();
               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Abertura sequencial de turmas
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} \sum\limits_{t \in T} o_{i,d,u,tps,t} \geq \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} \sum\limits_{t \in T} o_{i',d,u,tps,t} \nonumber \qquad 
\forall d \in D \quad
\forall i,i' \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_abre_turmas_em_sequencia( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

      if ( disciplina->getNumTurmas() > 1 )
      {
         for ( int turma = 0; turma < ( disciplina->getNumTurmas() - 1 ); turma++ )
         {
            c.reset();
            c.setType( Constraint::C_ABRE_TURMAS_EM_SEQUENCIA );

            c.setDisciplina( disciplina );
            c.setTurma( turma );

            sprintf( name, "%s", c.toString().c_str() ); 
            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = 9999;
            OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0, name );

            ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
            {
				if ( itCampus->getId() != campusId )
				{
					continue;
				}

               ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
               {
                  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                  {
                     GGroup< int /*Dias*/ > disc_sala_dias =
                        problemData->disc_Conjutno_Salas__Dias[ std::make_pair< int, int >
                        ( disciplina->getId(), itCjtSala->getId() ) ];

                     ITERA_GGROUP_N_PT( itDiscSala_Dias, disc_sala_dias, int )
                     {
                        v.reset();
                        v.setType( Variable::V_OFERECIMENTO );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiscSala_Dias );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        v.reset();
                        v.setType( Variable::V_OFERECIMENTO );

                        int turmaSuc = turma + 1;
                        v.setTurma(turmaSuc);

                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiscSala_Dias );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, -1.0 );
                        }
                     }
                  }
               }
            }

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Regra de divisão de créditos
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} x_{i,d,u,tps,t} = \sum\limits_{k \in K_{d}}N_{d,k,t} \cdot m_{d,i,k} + fkp_{d,i,t} - fkm_{d,i,t} \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall t \in T
\end{eqnarray}

%Data N_{d,k,t}
%Desc
número de créditos determinados para a disciplina $d$ no dia $t$ na combinação de divisão de crédito $k$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_divisao_credito( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );
	  
	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

      if ( disciplina->divisao_creditos.size() != 0 )
      {
         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            ITERA_GGROUP_N_PT( itDiasLetDisc, disciplina->diasLetivos, int )
            {
               c.reset();
               c.setType( Constraint::C_DIVISAO_CREDITO );

               c.setDisciplina( disciplina );
               c.setTurma( turma );
               c.setDia( *itDiasLetDisc );

               sprintf( name, "%s", c.toString().c_str() ); 

               if ( cHash.find( c ) != cHash.end() )
               {
                  continue;
               }

               nnz = ( problemData->totalSalas + ( (int)( disciplina->combinacao_divisao_creditos.size() ) * 2 ) );
               OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

               ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
               {
				   if ( itCampus->getId() != campusId )
				   {
					    continue;
				   }

                  ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
                  {
                     ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
                     {
                        v.reset();
                        v.setType( Variable::V_CREDITOS );

                        v.setTurma( turma );
                        v.setDisciplina( disciplina );
                        v.setUnidade( *itUnidade );
                        v.setSubCjtSala( *itCjtSala );
                        v.setDia( *itDiasLetDisc );

                        it_v = vHash.find( v );
                        if ( it_v != vHash.end() )
                        {
                           row.insert( it_v->second, 1.0 );
                        }

                        for ( int k = 0; k < (int)disciplina->combinacao_divisao_creditos.size(); k++ )
                        {	
                           v.reset();
                           v.setType( Variable::V_COMBINACAO_DIVISAO_CREDITO );

                           v.setDisciplina( disciplina );
                           v.setTurma( turma );
                           v.setK( k );

                           int d = *itDiasLetDisc;

                           // N{d,k,t}
                           int numCreditos = ( disciplina->combinacao_divisao_creditos[ k ] )[ ( *itDiasLetDisc ) - 2 ].second;

                           it_v = vHash.find( v );
                           if ( it_v != vHash.end() )
                           {
                              row.insert( it_v->second, -numCreditos );
                           }

                           v.reset();
                           v.setType( Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_M );

                           v.setDisciplina( disciplina );
                           v.setTurma( turma );
                           v.setDia( *itDiasLetDisc );

                           it_v = vHash.find( v );
                           if( it_v != vHash.end() )
                           {
                              row.insert( it_v->second, -1.0 );
                           }

                           v.reset();
                           v.setType( Variable::V_SLACK_COMBINACAO_DIVISAO_CREDITO_P );

                           v.setDisciplina( disciplina );
                           v.setTurma( turma );
                           v.setDia( *itDiasLetDisc );

                           it_v = vHash.find( v );
                           if( it_v != vHash.end() )
                           {
                              row.insert( it_v->second, 1.0 );
                           }
                        }
                     }
                  }
               }

               if ( row.getnnz() != 0 )
               {
                  cHash[ c ] = lp->getNumRows();

                  lp->addRow( row );
                  restricoes++;
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Somente uma combinação de regra de divisão de créditos pode ser escolhida
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{k \in K_{d}} m_{d,i,k} \leq 1 \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d}
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_combinacao_divisao_credito( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );

	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		  continue;
	  }
	  #pragma endregion	

      for ( int i = 0; i < disciplina->getNumTurmas(); i++ )
      {
         c.reset();
         c.setType( Constraint::C_COMBINACAO_DIVISAO_CREDITO );

         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString().c_str() ); 

         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

         nnz = (int)( disciplina->combinacao_divisao_creditos.size() );
         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

         for ( int k = 0; k < (int)disciplina->combinacao_divisao_creditos.size(); k++ )
         {
            v.reset();
            v.setType( Variable::V_COMBINACAO_DIVISAO_CREDITO );

            v.setTurma( i );
            v.setDisciplina( disciplina );
            v.setK( k );

            it_v = vHash.find( v );

            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável y
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{t \in T} o_{i,d,u,tps,t}  \geq  y_{i,d,tps,u}  \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall u \in U \quad
\forall s \in S_{u}
\forall tps \in SCAP_{u}
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_ativacao_var_y( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			 ITERA_GGROUP_LESSPTR( it_disciplina, itCjtSala->disciplinas_associadas, Disciplina )
            {
               disciplina = ( *it_disciplina );

			   #pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
			   {
				   continue;
			   }
			   #pragma endregion

               for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
               {
                  c.reset();
                  c.setType( Constraint::C_VAR_Y );

                  c.setUnidade( *itUnidade );
                  c.setSubCjtSala( *itCjtSala );
                  c.setDisciplina( disciplina );
                  c.setTurma( turma );

                  sprintf( name, "%s", c.toString().c_str() ); 
                  if ( cHash.find( c ) != cHash.end() )
                  {
                     continue;
                  }

                  nnz = 8;
                  OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0, name );

                  GGroup< int /*Dias*/ >::iterator itDiscSala_Dias =
                     problemData->disc_Conjutno_Salas__Dias
                     [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].begin();

                  for (; itDiscSala_Dias != problemData->disc_Conjutno_Salas__Dias
                     [ std::make_pair< int, int > ( disciplina->getId(), itCjtSala->getId() ) ].end();
                     itDiscSala_Dias++ )
                  {
                     v.reset();
                     v.setType( Variable::V_OFERECIMENTO );

                     v.setTurma( turma );
                     v.setDisciplina( disciplina );
                     v.setUnidade( *itUnidade );
                     v.setSubCjtSala( *itCjtSala );
                     v.setDia( *itDiscSala_Dias );

                     it_v = vHash.find( v );
                     if ( it_v != vHash.end() )
                     {
                        row.insert( it_v->second, 1.0 );
                     }
                  }

                  v.reset();
                  v.setType( Variable::V_ALOC_DISCIPLINA );

                  v.setTurma( turma );
                  v.setDisciplina( disciplina );
                  v.setUnidade( *itUnidade );
                  v.setSubCjtSala( *itCjtSala );

                  it_v = vHash.find( v );
                  if ( it_v != vHash.end() )
                  {
                     row.insert( it_v->second, -1.0 );
                  }

                  if ( row.getnnz() != 0 )
                  {
                     cHash[ c ] = lp->getNumRows();

                     lp->addRow( row );
                     restricoes++;
                  }
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint
Máximo de créditos diários da disciplina
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} x_{i,d,u,tps,t} - xm_{bc, d, t} \leq 0 \nonumber \qquad 
\forall bc \in BC \quad
\forall d \in D_{bc} \quad
\forall i \in I_{d} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_creds_disc_dia( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	   if ( it_bloco->campus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR(it_disciplina,it_bloco->disciplinas,Disciplina)
      {
         disciplina = ( *it_disciplina );

		 #pragma region Equivalencias
		 if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
	 		continue;
		 }
		 #pragma endregion

         GGroup< int >::iterator itDiasLetBloco = it_bloco->diasLetivos.begin();
         for (; itDiasLetBloco != it_bloco->diasLetivos.end(); itDiasLetBloco++ )
         {
            for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
            {
               c.reset();
               c.setType( Constraint::C_MAX_CREDS_DISC_DIA );

               c.setDisciplina( disciplina );
               c.setTurma( turma );
               c.setDia( *itDiasLetBloco );
               c.setBloco(*it_bloco);

               sprintf( name, "%s", c.toString().c_str() ); 
               if (cHash.find(c) != cHash.end())
               {
                  continue;
               }

               nnz = 100;

               OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );

               ITERA_GGROUP_LESSPTR( it_Campus, problemData->campi, Campus )
               {
				   if ( it_Campus->getId() != campusId )
				   {
					   continue;
				   }

                  ITERA_GGROUP_LESSPTR( it_Unidade, it_Campus->unidades, Unidade )
                  {
                     ITERA_GGROUP_LESSPTR( it_Cjt_Sala, it_Unidade->conjutoSalas, ConjuntoSala )
                     {
                        std::map< std::pair< int, int>, GGroup< int > >::iterator

                           it_Disc_Cjt_Salas__Dias = problemData->disc_Conjutno_Salas__Dias.find(
                           std::make_pair( disciplina->getId(), it_Cjt_Sala->getId() ) );

                        // Testando se a disciplina em questao esta associada ao cjt de salas em questao
                        if ( it_Disc_Cjt_Salas__Dias != problemData->disc_Conjutno_Salas__Dias.end() )
                        {
                           // Testando se a dia (referenciado por <*it_Dias_Letivos>) é um dia 
                           // letivo comum à disciplina e o conjunto de salas em questão.
                           if ( it_Disc_Cjt_Salas__Dias->second.find( *itDiasLetBloco ) != 
                              it_Disc_Cjt_Salas__Dias->second.end() )
                           {
                              v.reset();
                              v.setType( Variable::V_CREDITOS );

                              v.setTurma( turma );
                              v.setDisciplina( disciplina );
                              v.setUnidade( *it_Unidade );
                              v.setSubCjtSala( *it_Cjt_Sala );
                              v.setDia( *itDiasLetBloco );

                              it_v = vHash.find( v );
                              if ( it_v != vHash.end() )
                              {
                                 row.insert( it_v->second, 1.0 );
                              }
                           }
                        }
                     }
                  }
               }

               if ( row.getnnz() <= 0 )
               {
                  continue;
               }

               v.reset();
               v.setType( Variable::V_CREDITOS_MODF );

               v.setDisciplina( disciplina );
               v.setDia( *itDiasLetBloco );
               v.setBloco(*it_bloco);

               it_v = vHash.find( v );
               if ( it_v != vHash.end() )
               {
                  row.insert( it_v->second, -1.0 );
               }

               if ( row.getnnz() != 0 )
               {
                  cHash[ c ] = lp->getNumRows();

                  lp->addRow( row );
                  restricoes++;
               }
            }
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Máximo de créditos diários do bloco
%Desc

%MatExp
\begin{eqnarray}
\sum\limits_{d \in D_{bc}} xm_{bc,d, t} \leq MAX_CRED \nonumber \qquad 
\forall bc \in B \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_creds_bloco_dia( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   ITERA_GGROUP_LESSPTR( it_bloco, problemData->blocos, BlocoCurricular )
   {
	   if ( it_bloco->getId() != campusId )
	   {
		   continue;
	   }

      GGroup< int >::iterator itDiasLetBloco = it_bloco->diasLetivos.begin();
      for (; itDiasLetBloco != it_bloco->diasLetivos.end(); itDiasLetBloco++ )
      {
         c.reset();
         c.setType( Constraint::C_MAX_CREDS_BLOCO_DIA );
         c.setBloco( *it_bloco );
         c.setDia( *itDiasLetBloco );

         sprintf( name, "%s", c.toString().c_str() ); 

         if ( cHash.find(c) != cHash.end() )
         {
            continue;
         }

         nnz = 100;
         double rhs = it_bloco->getMaxCredsNoDia(*itDiasLetBloco);

         OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

         ITERA_GGROUP_LESSPTR(it_disciplina,it_bloco->disciplinas,Disciplina)
         {
            disciplina = ( *it_disciplina );
			
			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( disciplina ) )
			{
				continue;
			}
			#pragma endregion

            v.reset();
            v.setType( Variable::V_CREDITOS_MODF );

            v.setBloco(*it_bloco);
            v.setDisciplina( disciplina );
            v.setDia( *itDiasLetBloco );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }
         }
         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável zc
%Desc

%MatExp
\begin{eqnarray}
\sum\limits_{i \in I} \sum\limits_{u \in U} \sum\limits_{tps \in SCAP_{u}} o_{i,d,u,tps,t} \leq zc_{d,t} \cdot N \nonumber \qquad 
\forall d \in D \quad
\forall t \in T
\end{eqnarray}


%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_ativacao_var_zc( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus *campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );
	  
	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		   continue;
	  }
	  #pragma endregion

      GGroup< int >::iterator itDiasLetDisc = disciplina->diasLetivos.begin();

      for (; itDiasLetDisc != disciplina->diasLetivos.end(); itDiasLetDisc++ )
      {
         c.reset();
         c.setType( Constraint::C_VAR_ZC );

         c.setDisciplina( disciplina );
         c.setDia( *itDiasLetDisc );
		 c.setCampus( campus );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

         nnz = 100;

         OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );
		 
		 ITERA_GGROUP_LESSPTR( itUnidade, campus->unidades, Unidade )
		 {
			ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
			{
				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
					v.reset();
					v.setType( Variable::V_OFERECIMENTO );

					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setUnidade( *itUnidade );
					v.setSubCjtSala( *itCjtSala );
					v.setDia( *itDiasLetDisc );

					it_v = vHash.find( v );
					if ( it_v != vHash.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
				}
			}
		 }

         v.reset();
         v.setType( Variable::V_ABERTURA_COMPATIVEL );

         v.setDisciplina( disciplina );
         v.setDia( *itDiasLetDisc );
		 v.setCampus( campus );

         it_v = vHash.find( v );
         if ( it_v != vHash.end() )
         {
            row.insert( it_v->second, -100.0 );
         }

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Disciplinas incompatíveis
%Desc

%MatExp
\begin{eqnarray}
zc_{d_1,t} + zc_{d_2,t} \leq 1 \nonumber \qquad 
(d_1, d_2),
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_disciplinas_incompativeis( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   Campus *campus = problemData->refCampus[ campusId ];

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
      disciplina = ( *it_disciplina );
	  
	  // A disciplina deve ser ofertada no campus especificado
	  if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			problemData->cp_discs[campusId].end() )
 	  {
		  continue;
	  }

	  #pragma region Equivalencias
	  if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
			 problemData->mapDiscSubstituidaPor.end() ) &&
			!problemData->ehSubstituta( disciplina ) )
	  {
		   continue;
	  }
	  #pragma endregion

      ITERA_GGROUP_N_PT( itDiasLetDisc, disciplina->diasLetivos, int )
      {
         ITERA_GGROUP_N_PT( it_inc, disciplina->ids_disciplinas_incompativeis, int )
         {
            //Disciplina * nova_disc = new Disciplina();
			std::map< int, Disciplina* >::iterator it_Ref_Disc = problemData->refDisciplinas.find( *it_inc );
			if ( it_Ref_Disc == problemData->refDisciplinas.end() )
			{ 
				continue;
			}
			
			Disciplina * nova_disc = it_Ref_Disc->second;

			// A disciplina deve ser ofertada no campus especificado
			if ( problemData->cp_discs[campusId].find( nova_disc->getId() ) ==
				problemData->cp_discs[campusId].end() )
 			{
				continue;
			}

			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( nova_disc ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( nova_disc ) )
			{
				continue;
			}
			#pragma endregion

            c.reset();
            c.setType( Constraint::C_DISC_INCOMPATIVEIS );

            c.setDisciplina( nova_disc );
            c.setDia( *itDiasLetDisc );
			c.setCampus( campus );

            sprintf( name, "%s", c.toString().c_str() ); 

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = 2;
            OPT_ROW row( nnz, OPT_ROW::LESS, 1.0, name );

            v.reset();
            v.setType( Variable::V_ABERTURA_COMPATIVEL );

            v.setDisciplina( disciplina );
            v.setDia( *itDiasLetDisc );
			v.setCampus( campus );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            v.setDisciplina( nova_disc );

            it_v = vHash.find( v );
			if ( it_v != vHash.end() )
            {
               row.insert(it_v->second, 1.0);
            }

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }

         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável n
%Desc

%MatExp
\begin{eqnarray}
\sum\limits_{u \in U} \sum\limits_{i \in I} \sum\limits_{d \in D_{bc}} 
o_{i,d,u,tps,t} \leq M \cdot n_{bc,tps} \nonumber \qquad 
\forall tps \in SCAP_{u}
\forall bc \in B
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/
int SolverMIP::cria_restricao_abertura_bloco_mesmoTPS( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;

   ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
   {
	     Campus *cp = itBloco->campus;

         ITERA_GGROUP_LESSPTR( itUnidade, cp->unidades, Unidade )
         {
            ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
            {
               std::map< Disciplina *, GGroup< int > >::iterator
                  it_disc_dias = itCjtSala->dias_letivos_disciplinas.begin();

               for (; it_disc_dias != itCjtSala->dias_letivos_disciplinas.end();
                  it_disc_dias++ )
               {
                  GGroup< int >::iterator itDiasLetCjtSala =
                     it_disc_dias->second.begin();

                  for (; itDiasLetCjtSala != it_disc_dias->second.end();
                     itDiasLetCjtSala++ )
                  {
                     c.reset();
                     c.setType( Constraint::C_EVITA_BLOCO_TPS_D );

                     c.setSubCjtSala( *itCjtSala );
                     c.setBloco( *itBloco );
                     c.setDia( *itDiasLetCjtSala );

                     sprintf( name, "%s", c.toString().c_str() ); 
                     if ( cHash.find(c) != cHash.end() )
                     {
                        continue;
                     }

                     nnz = 100;
                     OPT_ROW row( nnz, OPT_ROW::LESS, 0.0, name );

                     ITERA_GGROUP_LESSPTR( it_disciplina, itBloco->disciplinas, Disciplina )
                     {
                        disciplina = ( *it_disciplina );

						#pragma region Equivalencias
						if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
								problemData->mapDiscSubstituidaPor.end() ) &&
							!problemData->ehSubstituta( disciplina ) )
						{
							continue;
						}
						#pragma endregion
							  
                        for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
                        {
                            v.reset();
                            v.setType( Variable::V_OFERECIMENTO );

                            v.setTurma( turma );
                            v.setDisciplina( disciplina );
                            v.setUnidade( *itUnidade );
                            v.setSubCjtSala( *itCjtSala );
                            v.setDia( *itDiasLetCjtSala );

                            it_v = vHash.find( v );
                            if ( it_v != vHash.end() )
                            {
								row.insert( it_v->second, 1.0 );
                            }

                            v.reset();
                            v.setType( Variable::V_ABERTURA_BLOCO_MESMO_TPS );

                            v.setBloco( *itBloco );
                            v.setSubCjtSala( *itCjtSala );

                            it_v = vHash.find( v );
                            if ( it_v != vHash.end() )
                            {
								int bigM = 100;
								row.insert( it_v->second, -bigM );
                            }
                        }
                     }
                      
                     if ( row.getnnz() != 0 )
                     {
                        cHash[ c ] = lp->getNumRows();

                        lp->addRow( row );
                        restricoes++;
                     }
                  }
               }
            }
         }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Evitar alocação do mesmo bloco curricular em tipos de salas diferentes
%Desc

%MatExp
\begin{eqnarray}
\sum\limits_{tps \in SCAP_{u}} n_{bc,tps} + fn_{bc,tps} 
\leq 1 \nonumber \qquad 
\forall bc \in B
\end{eqnarray}

%DocEnd
/====================================================================*/
int SolverMIP::cria_restricao_folga_abertura_bloco_mesmoTPS( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
   {
	   if ( itBloco->campus->getId() != campusId )
	   {
		   continue;
	   }

      c.reset();
      c.setType( Constraint::C_SLACK_EVITA_BLOCO_TPS_D );
      c.setBloco( *itBloco );

      sprintf( name, "%s", c.toString().c_str() ); 

      if ( cHash.find( c ) != cHash.end() )
      {
         continue;
      }

      nnz = 100;

      OPT_ROW row( nnz, OPT_ROW::LESS, 1.0, name );

      ITERA_GGROUP_LESSPTR( itUnidade, itBloco->campus->unidades, Unidade )
      {
            ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
            {		
               v.reset();
               v.setType( Variable::V_ABERTURA_BLOCO_MESMO_TPS );

               v.setBloco( *itBloco );
               v.setSubCjtSala( *itCjtSala );

               it_v = vHash.find( v );
               if( it_v != vHash.end() )
               {
                  row.insert( it_v->second, 1.0 );
               }

               v.reset();
               v.setType( Variable::V_SLACK_ABERTURA_BLOCO_MESMO_TPS );

               v.setBloco( *itBloco );
               v.setSubCjtSala( *itCjtSala );

               it_v = vHash.find( v );
               if ( it_v != vHash.end() )
               {
                  row.insert( it_v->second, 1.0 );
               }
            }
      }

      if ( row.getnnz() != 0 )
      {
          cHash[ c ] = lp->getNumRows();

          lp->addRow( row );
          restricoes++;
      }
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Não permitir que alunos de cursos diferentes (mesmo que compativeis) compartilhem turmas.
%Desc 

%MatExp

\begin{eqnarray} 
b_{i,d,c,cp} + b_{i,d,c',cp} - fc_{i,d,c,c',cp} \leq 1 \nonumber \qquad 
\forall d \in D \quad
\forall i \in I_{d} \quad
\forall c,c' C \quad
\forall cp \in CP
\end{eqnarray}

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_proibe_compartilhamento( int campusId )
{
   int restricoes = 0;

   if ( problemData->parametros->permite_compartilhamento_turma_sel )
   {
	   return restricoes;
   }

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

	   std::map< std::pair< Curso *, Curso * >, std::vector< int > >::iterator
               it_cursoComp_disc = problemData->cursosComp_disc.begin();

        for (; it_cursoComp_disc != problemData->cursosComp_disc.end(); it_cursoComp_disc++ )
        {
			Curso *c1 = it_cursoComp_disc->first.first;
			Curso *c2 = it_cursoComp_disc->first.second;

			if ( itCampus->cursos.find( c1 ) == itCampus->cursos.end() ||
				 itCampus->cursos.find( c2 ) == itCampus->cursos.end() )
			{
				continue;
			}

            std::vector< int >::iterator it_disc = it_cursoComp_disc->second.begin();

            for (; it_disc != it_cursoComp_disc->second.end(); ++it_disc )
            {
				int discId = *it_disc;
				Disciplina * disciplina = problemData->retornaDisciplina(discId);
				  
				if (disciplina == NULL) continue;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion

				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
					c.reset();
					c.setType( Constraint::C_PROIBE_COMPARTILHAMENTO );
					c.setCampus( *itCampus );
					c.setParCursos( std::make_pair( c1, c2 ) );
					c.setDisciplina( disciplina );
					c.setTurma( turma );

					sprintf( name, "%s", c.toString().c_str() ); 

					if ( cHash.find( c ) != cHash.end() )
					{
						continue;
					}

					nnz = 3;

					OPT_ROW row( nnz, OPT_ROW::LESS , 1.0 , name );

					v.reset();
					v.setType( Variable::V_ALOC_ALUNO );
					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setCurso( c1 );
					v.setCampus( *itCampus );

					it_v = vHash.find( v );
					if( it_v != vHash.end() )
					{
						row.insert( it_v->second, 1 );
					}

					v.reset();
					v.setType( Variable::V_ALOC_ALUNO );
					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setCurso( c2 );
					v.setCampus( *itCampus );

					it_v = vHash.find( v );
					if( it_v != vHash.end() )
					{
						row.insert(it_v->second, 1);
					}

					v.reset();
					v.setType( Variable::V_SLACK_COMPARTILHAMENTO );
					v.setTurma( turma );
					v.setDisciplina( disciplina );
					v.setParCursos( std::make_pair( c1, c2 ) );
					v.setCampus( *itCampus );

					it_v = vHash.find( v );
					if ( it_v != vHash.end() )
					{
						row.insert( it_v->second, -1 );
					}

					if ( row.getnnz() != 0 )
					{
						cHash[ c ] = lp->getNumRows();
						lp->addRow( row );
						restricoes++;
					}
				}
			}
		}
   }

   return restricoes;
}


int SolverMIP::cria_restricao_ativacao_var_cs( int campusId )
{
   int restricoes = 0;

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() != 2 )
   {
	   return restricoes;
   }

   char name[ 100 ];   
   VariableHash::iterator it_v;
   Variable v;
   Constraint c;

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
      {
         ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
         {
			std::map< int, Sala * >::iterator itSala = itCjtSala->salas.begin();
			for( ; itSala != itCjtSala->salas.end(); itSala++ )
			{
				Sala *s = itSala->second;

				ITERA_GGROUP_N_PT( itDia, s->diasLetivos, int )
				{
					int dia = *itDia;

					c.reset();
					c.setType( Constraint::C_VAR_CS );
					c.setUnidade( *itUnidade );
					c.setSubCjtSala( *itCjtSala );
					c.setDia( dia );

					sprintf( name, "%s", c.toString().c_str() );
					if ( cHash.find( c ) != cHash.end() )
					{
						continue;
					}

					int nnz = s->getCombinaCredSLSize()[dia];
					
					OPT_ROW row( nnz, OPT_ROW::LESS , 1, name );

					std::map< Trio<int, int, Calendario*>, int >::iterator it_map = s->combinaCredSL.begin();
					for ( ; it_map != s->combinaCredSL.end(); it_map++ )
					{
						if ( it_map->first.first == dia )
						{
							v.reset();
							v.setType( Variable::V_COMBINA_SL_SALA );
							v.setSala( s );
							v.setDia( dia );
							v.setCombinaSL( it_map->first.second );

							it_v = vHash.find( v );
							if( it_v != vHash.end() )
							{
								row.insert( it_v->second, 1 );
							}
						}
					}
					
					if ( row.getnnz() != 0 )
					{
						cHash[ c ] = lp->getNumRows();
						lp->addRow( row );
						restricoes++;
					}
				}
			}
		 }
	  }
   }
   return restricoes;
}






/*
	RESTRICOES SOMENTE PARA O MODELO TATICO - BLOCO - SEM HORARIOS
*/


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Evita que, devido a compartilhamento de disciplinas entre duas ofertas,
uma sala tenha horario sobreposto.
%Desc

%MatExp
\begin{eqnarray}
 x_{i,d,u,s,t} + \sum\limits_{u' \in U} \sum\limits_{d' \in (D_{oft1} U D{oft2})} \sum\limits_{i' \in I_{d'}}( q_{i',d',oft,s',t} - p_{i',d',oft1,oft2,s',t})
\leq Q_{bc,t} + M ( 1 - of_{i,d,oft1,oft2} ) \qquad 

\forall d \in (D_{oft1} \cap D_{oft2})
\forall i \in I_{d}
\forall oft \in {oft1, oft2}
\forall u \in U
\forall s \in S_{u}
\forall s' \in S_{u'} \quad s' \ne s
\forall t \in T

\end{eqnarray}

%DocEnd
/====================================================================*/
int SolverMIP::cria_restricao_evita_sobrepos_sala_por_compartilhamento( int campusId )
{

	ofstream outTestFile;
	char outputTestFilename[] = "outTestRestricao_evita_sobrepos_sala_por_compartilhamento.txt";
	outTestFile.open(outputTestFilename, ios::out);
	if (!outTestFile) {
		cerr << "Can't open output file " << outputTestFilename << endl;
		exit(1);
	}

	int restricoes = 0;

	int nnz;
	double M = 9999.0;

	Constraint c;
	Variable v;
	VariableHash::iterator it_v;
	Disciplina * disciplina_equivalente = NULL;
	Curso * curso = NULL;
	Curriculo * curriculo = NULL;

	//map< int, map< pair< Oferta*, Oferta* >, vector<int> > > vars;

	// para cada campus
	ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
	{
		Campus *cp = *itCampus;

		if ( cp->getId() != campusId )
		{
			continue;
		}

		// para cada par de ofertas compativeis
		std::map< std::pair< Oferta *, Oferta * >, std::vector< int > >::iterator
			it_oftsComp_disc = problemData->oftsComp_disc.begin();

		for (; it_oftsComp_disc != problemData->oftsComp_disc.end(); it_oftsComp_disc++ )
		{
			Oferta *oft1 = it_oftsComp_disc->first.first;
			Oferta *oft2 = it_oftsComp_disc->first.second;

			if ( oft1->campus != cp || oft1->campus != cp )
				continue;

			Curso *c1 = oft1->curso;
			Curso *c2 = oft2->curso;

			if ( c1->getId() != c2->getId() &&
				!problemData->parametros->permite_compartilhamento_turma_sel )
			{
				continue;
			}

			// para cada disciplina em comum (possivel de ser compartilhada) ao par de ofertas
			std::vector< int >::iterator it_discComum = it_oftsComp_disc->second.begin();
			for (; it_discComum != it_oftsComp_disc->second.end(); ++it_discComum )
			{
				Disciplina * discComum = problemData->retornaDisciplina( *it_discComum );

				if (discComum == NULL)
					continue;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( discComum ) !=
					   problemData->mapDiscSubstituidaPor.end() ) &&
					 !problemData->ehSubstituta( discComum ) )
				{
					continue;
				}
				#pragma endregion

				int periodo1 = oft1->periodoDisciplina( discComum );
				int periodo2 = oft2->periodoDisciplina( discComum );

				// Cria a restrição somente para períodos que possuem uma mesma semana letiva
				GGroup< Calendario*, LessPtr<Calendario> > sls1 = oft1->curriculo->retornaSemanasLetivasNoPeriodo( periodo1 );
				GGroup< Calendario*, LessPtr<Calendario> > sls2 = oft2->curriculo->retornaSemanasLetivasNoPeriodo( periodo2 );
				if ( sls1.size() != 1 ||
					sls2.size() != 1 ||
					sls1.begin()->getId() != sls2.begin()->getId() )
				{
					continue;
				}

				// para cada turma da disciplina em comum
				for ( int turma = 0; turma < discComum->getNumTurmas(); turma++ )
				{
					vector< pair< int, double > > cols;

#pragma region Variavel of_{i,d,oft1,oft2}
					v.reset();
					v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT ); // of_{i,d,oft1,oft2}
					v.setTurma( turma );
					v.setDisciplina( discComum );
					v.setParOfertas( oft1, oft2 );

					it_v = vHash.find( v );
					if( it_v != vHash.end() )
					{
						//row.insert(it_v->second, M);
						cols.push_back(make_pair(it_v->second, M));
					}
					else
					{
						continue; // Não cria a restrição se não existe a variável of_{i,d,oft1,oft2}
					}
#pragma endregion

					// para cada unidade do campus da disc compartilhada
					ITERA_GGROUP_LESSPTR( itUnid, cp->unidades, Unidade )
					{
						// para cada sala aonde poderá ser ministrada a disc compartilhada
						ITERA_GGROUP_LESSPTR( itCjtSalaCompart, itUnid->conjutoSalas, ConjuntoSala )
						{   
							// cada conjunto de salas só pode ter 1 sala!
							if ( itCjtSalaCompart->salas.size() != 1 )
								continue;
							if ( itCjtSalaCompart->disciplinas_associadas.find( discComum ) ==
								itCjtSalaCompart->disciplinas_associadas.end() )
								continue;

							Sala* salaCompart = itCjtSalaCompart->salas.begin()->second;

							// Para cada dia em que discComum pode ser ministrada na salaCompart
							GGroup< int > diasLetivos = itCjtSalaCompart->dias_letivos_disciplinas[ discComum ];
							GGroup< int >::iterator itDia = diasLetivos.begin();
							for (; itDia != diasLetivos.end(); itDia++ )
							{
								//// para cada unidade
								//ITERA_GGROUP_LESSPTR( itUnid2, cp->unidades, Unidade )
								//{
								//	// para cada sala
								//	ITERA_GGROUP_LESSPTR( itCjtSala, itUnid2->conjutoSalas, ConjuntoSala )
								//	{  
								//		// cada conjunto de salas só pode ter 1 sala!
								//		if ( itCjtSala->salas.size() != 1 )
								//			continue;
								//		// sala diferente da sala da discComum
								//		if ( itCjtSala->salas.begin()->first == salaCompart->getId() )
								//			continue;

								

#pragma region Variavel x_{i,d,u,s,t}
								v.reset();
								v.setType( Variable::V_CREDITOS ); // x_{i,d,u,s,t}
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setUnidade( *itUnid );
								v.setSubCjtSala( *itCjtSalaCompart );
								v.setDia(*itDia);											

								it_v = vHash.find( v );
								if( it_v != vHash.end() )
								{
									//row.insert(it_v->second, 1);
									cols.push_back(make_pair(it_v->second, 1));
								}
								else
								{
									continue; // Não cria a restrição se não existe a variável x_{i,d,u,s,t}
								}
#pragma endregion

								/*outTestFile << "R" << restricoes
								<< "  i=" << c.getTurma()
								<< " d=" << c.getDisciplina()->getId()
								<< " ofts=" << c.getParOfertas().first->getId() << " " << c.getParOfertas().second->getId()
								<< " u=" << c.getUnidade()
								<< " sC" << c.getSubCjtSalaCompart()												
								<< " s" << c.getSubCjtSala()
								<< " t=" << c.getDia() << endl;*/

								/*if(!verificou)
								{
								verificou = true;
								bool inseriu = false;*/

								// para cada unidade
								ITERA_GGROUP_LESSPTR( itUnid2, cp->unidades, Unidade )
								{
									// para cada sala
									ITERA_GGROUP_LESSPTR( itCjtSala, itUnid2->conjutoSalas, ConjuntoSala )
									{  
										// cada conjunto de salas só pode ter 1 sala!
										if ( itCjtSala->salas.size() != 1 )
											continue;
										// sala diferente da sala da discComum
										if ( itCjtSala->salas.begin()->first == salaCompart->getId() )
											continue;

										bool inseriu = false;

										// para cada disciplina (diferente de discComum) pertencente à uniao dos
										// blocos curric que contêm discComum das duas ofertas, que
										// pode ser dada na sala itCjtSala
										ITERA_GGROUP_LESSPTR( it_uniao_disc, problemData->disciplinas, Disciplina )
										{													
											Disciplina *disc = ( *it_uniao_disc );

											// A disciplina deve ser ofertada no campus especificado
											if ( problemData->cp_discs[campusId].find( disc->getId() ) ==
												problemData->cp_discs[campusId].end() )
 											{
												continue;
											}

											#pragma region Equivalencias
											if ( ( problemData->mapDiscSubstituidaPor.find( disc ) !=
													problemData->mapDiscSubstituidaPor.end() ) &&
													!problemData->ehSubstituta( disc ) )
											{
												continue;
											}
											#pragma endregion

											if ( disc->getId() == discComum->getId() )
												continue;

											// confere se a sala é apta a receber a disciplina
											if ( itCjtSala->disciplinas_associadas.find( disc ) ==
												 itCjtSala->disciplinas_associadas.end() )
												continue;

											int p1 = oft1->periodoDisciplina( disc );
											int p2 = oft2->periodoDisciplina( disc );

											if ( p1 != periodo1 && p2 != periodo2 )
												continue;	

											Oferta *oft;
											bool ambos = false;

											if ( p1 == periodo1 && p2 == periodo2 )	ambos = true;
											else if ( p1 == periodo1 ) oft = oft1;
											else if ( p2 == periodo2 ) oft = oft2;
											
											if ( ambos )
											{														
												// para cada turma da disciplina em comum
												for ( int j = 0; j < disc->getNumTurmas(); j++ )
												{
#pragma region Primeira Variavel q_{j,d,oft1,u,s,t}
													// Primeira oferta: q_{j,d,oft1,u,s,t}
													v.reset();
													v.setType( Variable::V_CREDITOS_OFT );
													v.setTurma( j );
													v.setDisciplina( disc );
													v.setUnidade( *itUnid2 );
													v.setSubCjtSala( *itCjtSala );
													v.setDia( *itDia );
													v.setOferta( oft1 );

													it_v = vHash.find( v );
													if( it_v != vHash.end() )
													{
														//row.insert( it_v->second, 1 );
														cols.push_back(make_pair(it_v->second, 1));
														//vars.push_back(make_pair(it_v->second, 1));
														inseriu = true;
													}
#pragma endregion

#pragma region Segunda Variavel q_{j,d,oft2,u,s,t}
													// Segunda oferta: q_{j,d,oft2,u,s,t}
													v.reset();
													v.setType( Variable::V_CREDITOS_OFT );
													v.setTurma( j );
													v.setDisciplina( disc );
													v.setUnidade( *itUnid2 );
													v.setSubCjtSala( *itCjtSala );
													v.setDia( *itDia );
													v.setOferta( oft2 );

													it_v = vHash.find( v );
													if( it_v != vHash.end() )
													{
														//row.insert( it_v->second, 1 );
														cols.push_back(make_pair(it_v->second, 1));
														//vars.push_back(make_pair(it_v->second, 1));
														inseriu = true;
													}
#pragma endregion

#pragma region Variavel p_{i,d,oft1,oft2,u,tps,t}
													// Variavel p: desconto do possivel excesso
													// que foi acrescentado acima, caso a disciplina
													// disc tenha sido compartilhada entre as ofertas
													v.reset();
													v.setType( Variable::V_CREDITOS_PAR_OFT );
													v.setTurma( j );
													v.setDisciplina( disc );
													v.setUnidade( *itUnid2 );
													v.setSubCjtSala( *itCjtSala );
													v.setDia( *itDia );
													v.setParOfertas( oft1, oft2 );

													it_v = vHash.find( v );
													if( it_v != vHash.end() )
													{
														//row.insert( it_v->second, -1 );
														cols.push_back(make_pair(it_v->second, -1));
														//vars.push_back(make_pair(it_v->second, -1));
														inseriu = true;
													}									
#pragma endregion
												}
											}
											else
											{
												// para cada turma da disciplina em comum
												for ( int j = 0; j < disc->getNumTurmas(); j++ )
												{
#pragma region Variavel q_{j,d,oft,u,s,t}
													v.reset();
													v.setType( Variable::V_CREDITOS_OFT ); // q_{j,d,oft,u,s,t}
													v.setTurma( j );
													v.setDisciplina( disc );
													v.setUnidade( *itUnid2 );
													v.setSubCjtSala( *itCjtSala );
													v.setDia( *itDia );
													v.setOferta( oft );

													it_v = vHash.find( v );
													if( it_v != vHash.end() )
													{
														//row.insert( it_v->second, 1 );
														cols.push_back(make_pair(it_v->second, 1));
														//vars.push_back(make_pair(it_v->second, 1));
														inseriu = true;
													}
#pragma endregion
												}
											}
										}

										if ( !inseriu )
										{
											continue; // Se não tiver inserido nenhum q ou p, não cria a restrição.
											//break;
										}
										/*}
										else
										{
										for(vector< pair <int,int > >::iterator itC = vars.begin();
										itC != vars.end();
										itC++)
										cols.push_back(*itC);
										}*/
										// FIM DA RESTRICAO
										//-------------------------------------------------------------------------

										if ( /*row.getnnz() != 0*/ cols.size() > 0 )
										{
											//-------------------------------------------------------------------------
											// NOVA RESTRICAO

											c.reset();
											c.setType( Constraint::C_EVITA_SOBREPOS_SALA_POR_COMPART );
											c.setParOfertas( std::make_pair( oft1, oft2 ) );
											c.setDisciplina( discComum );
											c.setTurma( turma );
											c.setSubCjtSalaCompart(*itCjtSalaCompart);
											c.setDia(*itDia);
											c.setSubCjtSala(*itCjtSala);

											if ( cHash.find( c ) != cHash.end() )
											{
												continue;
											}

											//sprintf( name, "%s", c.toString().c_str() ); 
											nnz = 30;

											// Maximo de creditos no dia para os curriculos aonde estão
											// a disciplina compartilhada. Tanto faz pegar de Oft1 ou Oft2,
											// o valor tem que ser igual para as duas, já que se podem compartilhar
											// é porque têm mesma semana letiva.
											int maxCredDia = oft1->curriculo->getMaxCreds(*itDia);
											if ( oft2->curriculo->getMaxCreds(*itDia) != maxCredDia )
											{
												cerr << endl << "Erro em SolverMIP::cria_restricao_evita_sobrepos_sala_por_compartilhamento():";
												cerr << endl << "Semanas letivas devem ser iguais!" << endl;
												cerr << "curr1: " << oft1->curriculo->getId();
												cerr << "curr2: " << oft2->curriculo->getId() << endl;

												cerr << "sl1: " << oft1->curriculo->calendario->getId();
												cerr << "sl2: " << oft2->curriculo->calendario->getId() << endl;

												cerr << "oft1: " << oft1->getId();
												cerr << "oft2: " << oft2->getId() << endl;

												cerr << "max1: " << maxCredDia;
												cerr << "max2: " << oft2->curriculo->getMaxCreds(*itDia) << endl << endl;


												if (oft2->curriculo->getMaxCreds(*itDia) < maxCredDia)
													maxCredDia = oft2->curriculo->getMaxCreds(*itDia);
											}

											double rhs = M + maxCredDia;
											OPT_ROW row( nnz, OPT_ROW::LESS , rhs , (char*)c.toString().c_str());

											for(vector< pair< int, double > >::iterator itC = cols.begin();
												itC != cols.end();
												itC++)
												row.insert(itC->first, itC->second);

											pair< int, double > p1 = cols[0];
											pair< int, double > p2 = cols[1];

											cols.clear();
											cols.push_back(p1);
											cols.push_back(p2);

											cHash[ c ] = lp->getNumRows();
											lp->addRow( row );
											restricoes++;
										}													
									}
								}

								cols.pop_back();
							}
						}
					}
				}
			}
		}
	}

	outTestFile.close();

	return restricoes;

}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável e
%Desc 

%MatExp

\begin{eqnarray}
a_{i,d,oft} \le M \cdot e_{i,d,oft} \nonumber \qquad 
\forall i \in I_{d} \quad
\forall d \in D_{oft} \quad
\forall oft \in O
\end{eqnarray}

%Data M
%Desc
big $M$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_ativacao_var_e( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;
   double M = 9999.0;

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
   {
	    Oferta *oft = *itOft;

		if ( oft->getCampusId() != campusId )
		{
			continue;
		}

	    map < Disciplina*, int, LessPtr< Disciplina > >::iterator it_disc = oft->curriculo->disciplinas_periodo.begin();
	    for (; it_disc != oft->curriculo->disciplinas_periodo.end(); it_disc++ )
	    {
			Disciplina * d = it_disc->first;
			
			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( d ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( d ) )
			{
				continue;
			}
			#pragma endregion
			 
		    for ( int turma = 0; turma < d->getNumTurmas(); turma++ )
		    {
				c.reset();
				c.setType( Constraint::C_VAR_E );
				c.setTurma( turma );
				c.setDisciplina( d );
				c.setOferta( oft );

				sprintf( name, "%s", c.toString().c_str() ); 

				if ( cHash.find( c ) != cHash.end() )
				{
					continue;
				}

				nnz = 2;

				OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

				v.reset();
				v.setType( Variable::V_ALUNOS );
				v.setTurma( turma );
				v.setDisciplina( d );
				v.setOferta( oft );

				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row.insert( it_v->second, 1.0 );
				}

				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_OFT );
				v.setTurma( turma );
				v.setDisciplina( d );
				v.setOferta( oft );

				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row.insert( it_v->second, -M );
				}

				if ( row.getnnz() != 0 )
				{
					cHash[ c ] = lp->getNumRows();
					lp->addRow( row );
					restricoes++;
				}
			}
		}
   }

   return restricoes;
}



/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável of
%Desc 

%MatExp

\begin{eqnarray}
	e_{i,d,oft1} \cdot e_{i,d,oft2} \eq of_{i,d,oft1,oft2} \qquad
		 
		 =  \qquad

	e_{i,d,oft1} + e_{i,d,oft2} - 1 \le of_{i,d,oft1,oft2} \qquad
	of_{i,d,oft1,oft2} \le e_{i,d,oft2}  \qquad
	of_{i,d,oft1,oft2} \le e_{i,d,oft1}   \qquad

\forall i \in I_{d} \quad
\forall d \in D_{oft} \quad
\forall oft1 \in O_{d} \quad
\forall oft2 \in O_{d}
\end{eqnarray}

%Data M
%Desc
big $M$.

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_ativacao_var_of( int campusId )
{
    int restricoes = 0;
    char name[ 100 ];
    int nnz;
    double M = 9999.0;

    Variable v;
    Constraint c;
    VariableHash::iterator it_v;

	// para cada par de ofertas compativeis
	std::map< std::pair< Oferta *, Oferta * >, std::vector< int > >::iterator
            it_oftsComp_disc = problemData->oftsComp_disc.begin();

    for (; it_oftsComp_disc != problemData->oftsComp_disc.end(); it_oftsComp_disc++ )
    {
		Oferta *oft1 = it_oftsComp_disc->first.first;
		Oferta *oft2 = it_oftsComp_disc->first.second;

		Curso *c1 = oft1->curso;
		Curso *c2 = oft2->curso;

		if ( c1->getId() != c2->getId() &&
			 !problemData->parametros->permite_compartilhamento_turma_sel )
		{
			continue;
		}

		if ( oft1->getCampusId() != campusId ||
			 oft2->getCampusId() != campusId )
		{
			continue;
		}

		// para cada disciplina em comum (possivel de ser compartilhada) ao par de ofertas
        std::vector< int >::iterator it_discComum = it_oftsComp_disc->second.begin();
        for (; it_discComum != it_oftsComp_disc->second.end(); ++it_discComum )
        {
			Disciplina * discComum = problemData->retornaDisciplina( *it_discComum );
				  
			if (discComum == NULL) continue;
				
			for ( int turma = 0; turma < discComum->getNumTurmas(); turma++ )
			{
				bool vNotfound = false;
				// Se pelo menos 1 das variaveis não existir,
				// não tem sentido o trio de restrições, logo nenhuma será criada.

				// ----------------------------------------------------------
				// 1
				#pragma region Restricao tipo 1
				c.reset();
				c.setType( Constraint::C_VAR_OF_1 );
				c.setTurma( turma );
				c.setDisciplina( discComum);
				c.setParOfertas( std::make_pair(oft1, oft2) );

				sprintf( name, "%s", c.toString().c_str() ); 

				if ( cHash.find( c ) != cHash.end() )
				{
					continue;
				}

				nnz = 3;

				OPT_ROW row1( nnz, OPT_ROW::LESS , 1.0, name );
							
				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT );
				v.setTurma( turma );
				v.setDisciplina( discComum );
				v.setParOfertas( oft1, oft2 );

				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row1.insert( it_v->second, -1.0 );
				}
				else
				{
					vNotfound = true;
					continue;
				}

				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_OFT );
				v.setTurma( turma );
				v.setDisciplina( discComum );
				v.setOferta( oft1 );
							
				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row1.insert( it_v->second, 1.0 );
				}				
				else
				{
					vNotfound = true;
					continue;
				}

				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_OFT );
				v.setTurma( turma );
				v.setDisciplina( discComum );
				v.setOferta( oft2 );
							
				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row1.insert( it_v->second, 1.0 );
				}
				else
				{
					vNotfound = true;
					continue;
				}

				#pragma endregion

				// ----------------------------------------------------------
				// 2
				#pragma region Restricao tipo 2
				c.reset();
				c.setType( Constraint::C_VAR_OF_2 );
				c.setTurma( turma );
				c.setDisciplina( discComum);
				c.setParOfertas( std::make_pair(oft1, oft2) );

				sprintf( name, "%s", c.toString().c_str() ); 

				if ( cHash.find( c ) != cHash.end() )
				{
					continue;
				}

				nnz = 2;

				OPT_ROW row2( nnz, OPT_ROW::LESS , 0.0, name );
							
				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT );
				v.setTurma( turma );
				v.setDisciplina( discComum );
				v.setParOfertas( oft1, oft2 );

				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row2.insert( it_v->second, 1.0 );
				}
				else
				{
					vNotfound = true;
					continue;
				}

				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_OFT );
				v.setTurma( turma );
				v.setDisciplina( discComum );
				v.setOferta( oft1 );
							
				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row2.insert( it_v->second, -1.0 );
				}
				else
				{
					vNotfound = true;
					continue;
				}
				#pragma endregion

				// ----------------------------------------------------------
				// 3
				#pragma region Restricao tipo 3
				c.reset();
				c.setType( Constraint::C_VAR_OF_3 );
				c.setTurma( turma );
				c.setDisciplina( discComum);
				c.setParOfertas( std::make_pair(oft1, oft2) );

				sprintf( name, "%s", c.toString().c_str() ); 

				if ( cHash.find( c ) != cHash.end() )
				{
					continue;
				}

				nnz = 2;

				OPT_ROW row3( nnz, OPT_ROW::LESS , 0.0, name );
							
				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT );
				v.setTurma( turma );
				v.setDisciplina( discComum );
				v.setParOfertas( oft1, oft2 );

				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row3.insert( it_v->second, 1.0 );
				}
				else
				{
					vNotfound = true;
					continue;
				}

				v.reset();
				v.setType( Variable::V_ALOC_ALUNOS_OFT );
				v.setTurma( turma );
				v.setDisciplina( discComum );
				v.setOferta( oft2 );
							
				it_v = vHash.find( v );
				if ( it_v != vHash.end() )
				{
					row3.insert( it_v->second, -1.0 );
				}
				else
				{
					vNotfound = true;
					continue;
				}

				#pragma endregion

				// Cria a restrição tipo 1
				if ( row1.getnnz() != 0 )
				{
					cHash[ c ] = lp->getNumRows();
					lp->addRow( row1 );
					restricoes++;
				}
				// Cria a restrição tipo 2																
				if ( row2.getnnz() != 0 )
				{
					cHash[ c ] = lp->getNumRows();
					lp->addRow( row2 );
					restricoes++;
				}
				// Cria a restrição tipo 3
				if ( row3.getnnz() != 0 )
				{
					cHash[ c ] = lp->getNumRows();
					lp->addRow( row3 );
					restricoes++;
				}
			}
		}
	}

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável p
%Desc 

%MatExp

\begin{eqnarray}
	
	 p_{i,d,oft1,oft2,u,s,t} \eq x_{i,d,u,s,t} \cdot of_{i,d,oft1,oft2} \nonumber \qquad
	  
	  \eq  \qquad

	 p_{i,d,oft1,oft2,u,s,t} \le M \cdot of_{i,d,oft1,oft2} \nonumber \qquad
	 p_{i,d,oft1,oft2,u,s,t} \ge x_{i,d,u,s,t} - M \cdot ( 1 - of_{i,d,oft1,oft2} ) \nonumber \qquad
	 x_{i,d,u,s,t} \ge p_{i,d,oft1,oft2,u,s,t} - M \cdot ( 1 - of_{i,d,oft1,oft2} ) \nonumber \qquad

\forall i \in I_{d} \quad
\forall d \in D_{oft} \quad
\forall oft1 \in O_{d} \quad
\forall oft2 \in O_{d}
\forall u \in U \quad
\forall s \in S_{u} \quad
\forall t \in T \quad
\end{eqnarray}

%Data M
%Desc
big $M$.

%DocEnd
/====================================================================*/
int SolverMIP::cria_restricao_ativacao_var_p( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;
   double M = 9999.0;
   
   VariableHash::iterator it_v;
   Variable v;
   
   // para cada campus
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus *cp = *itCampus;
	   
	   if ( cp->getId() != campusId )
	   {
		   continue;
	   }

	   // para cada par de ofertas compativeis
	   std::map< std::pair< Oferta *, Oferta * >, std::vector< int > >::iterator
               it_oftsComp_disc = problemData->oftsComp_disc.begin();

        for (; it_oftsComp_disc != problemData->oftsComp_disc.end(); it_oftsComp_disc++ )
        {
			Oferta *oft1 = it_oftsComp_disc->first.first;
			Oferta *oft2 = it_oftsComp_disc->first.second;

			if ( oft1->campus != cp || oft1->campus != cp )
				continue;

			Curso *c1 = oft1->curso;
			Curso *c2 = oft2->curso;

			if ( c1->getId() != c2->getId() && !problemData->parametros->permite_compartilhamento_turma_sel )
				continue;

			// para cada disciplina em comum (possivel de ser compartilhada) ao par de ofertas
            std::vector< int >::iterator it_discComum = it_oftsComp_disc->second.begin();
            for (; it_discComum != it_oftsComp_disc->second.end(); ++it_discComum )
            {
				Disciplina * discComum = problemData->retornaDisciplina( *it_discComum );
													
				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( discComum ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( discComum ) )
				{
					continue;
				}
				#pragma endregion

				if (discComum == NULL) continue;
						
				// para cada unidade do campus de discComum
				ITERA_GGROUP_LESSPTR( itUnid, cp->unidades, Unidade )
				{
					// para cada sala aonde poderá ser ministrada a disc compartilhada
					ITERA_GGROUP_LESSPTR( itCjtSalaCompart, itUnid->conjutoSalas, ConjuntoSala )
					{   
						if ( itCjtSalaCompart->disciplinas_associadas.find( discComum ) ==
								itCjtSalaCompart->disciplinas_associadas.end() )
							continue;

						Sala* salaCompart = itCjtSalaCompart->salas.begin()->second;
										
						GGroup< int > diasLetivos = itCjtSalaCompart->dias_letivos_disciplinas[ discComum ];
									
						// Para cada dia em que discComum pode ser ministrada na salaCompart
						GGroup< int >::iterator itDia = diasLetivos.begin();
						for (; itDia != diasLetivos.end(); itDia++ )
						{
							for ( int turma = 0; turma < discComum->getNumTurmas(); turma++ )
							{
								bool vNotfound = false;
								// Se pelo menos 1 das variaveis não existir,
								// não tem sentido o trio de restrições, logo nenhuma será criada.


								// ----------------------------------------------------------
								// 1
								#pragma region Restricao tipo 1
										
								Constraint c;

								c.reset();
								c.setType( Constraint::C_VAR_P_1 );
								c.setTurma( turma );
								c.setDisciplina( discComum);
								c.setParOfertas( std::make_pair(oft1, oft2) );
								c.setDia( *itDia );
								c.setUnidade( *itUnid );
								c.setSubCjtSala( *itCjtSalaCompart );

								sprintf( name, "%s", c.toString().c_str() ); 

								if ( cHash.find( c ) != cHash.end() )
								{
									continue;
								}

								nnz = 2;
								OPT_ROW row1( nnz, OPT_ROW::LESS , 0.0, name );

								v.reset();
								v.setType( Variable::V_CREDITOS_PAR_OFT );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setParOfertas( oft1, oft2 );
								v.setUnidade( *itUnid );
								v.setSubCjtSala( *itCjtSalaCompart );
								v.setDia( *itDia );

								it_v = vHash.find( v );
								if ( it_v != vHash.end() )
								{
									row1.insert( it_v->second, 1 );
								}
								else
								{
									vNotfound = true;
									continue;
								}

								v.reset();
								v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setParOfertas( oft1, oft2 );

								it_v = vHash.find( v );
								if ( it_v != vHash.end() )
								{
									row1.insert( it_v->second, -M );
								}
								else
								{
									vNotfound = true;
									continue;
								}

								#pragma endregion
										
								// ----------------------------------------------------------
								// 2
								#pragma region Restricao tipo 2
										
								c.reset();
								c.setType( Constraint::C_VAR_P_2 );
								c.setTurma( turma );
								c.setDisciplina( discComum);
								c.setParOfertas( std::make_pair(oft1, oft2) );
								c.setDia( *itDia );
								c.setUnidade( *itUnid );
								c.setSubCjtSala( *itCjtSalaCompart );

								sprintf( name, "%s", c.toString().c_str() ); 

								if ( cHash.find( c ) != cHash.end() )
								{
									continue;
								}

								nnz = 3;
								OPT_ROW row2( nnz, OPT_ROW::LESS , M, name );

								v.reset();
								v.setType( Variable::V_CREDITOS_PAR_OFT );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setParOfertas( oft1, oft2 );
								v.setUnidade( *itUnid );
								v.setSubCjtSala( *itCjtSalaCompart );
								v.setDia( *itDia );

								it_v = vHash.find( v );
								if ( it_v != vHash.end() )
								{
									row2.insert( it_v->second, -1 );
								}
								else
								{
									vNotfound = true;
									continue;
								}

								v.reset();
								v.setType( Variable::V_CREDITOS );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setUnidade( *itUnid );
								v.setSubCjtSala( *itCjtSalaCompart );
								v.setDia( *itDia );

								it_v = vHash.find( v );
								if ( it_v != vHash.end() )
								{
									row2.insert( it_v->second, 1 );
								}
								else
								{
									vNotfound = true;
									continue;
								}

								v.reset();
								v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setParOfertas( oft1, oft2 );

								it_v = vHash.find( v );
								if ( it_v != vHash.end() )
								{
									row2.insert( it_v->second, M );
								}
								else
								{
									vNotfound = true;
									continue;
								}

								#pragma endregion

								// ----------------------------------------------------------
								// 3
								#pragma region Restricao tipo 3

								c.reset();
								c.setType( Constraint::C_VAR_P_3 );
								c.setTurma( turma );
								c.setDisciplina( discComum);
								c.setParOfertas( std::make_pair(oft1, oft2) );
								c.setDia( *itDia );
								c.setUnidade( *itUnid );
								c.setSubCjtSala( *itCjtSalaCompart );

								sprintf( name, "%s", c.toString().c_str() ); 

								if ( cHash.find( c ) != cHash.end() )
								{
									continue;
								}

								nnz = 3;
								OPT_ROW row3( nnz, OPT_ROW::LESS , M, name );

								v.reset();
								v.setType( Variable::V_CREDITOS_PAR_OFT );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setParOfertas( oft1, oft2 );
								v.setUnidade( *itUnid );
								v.setSubCjtSala( *itCjtSalaCompart );
								v.setDia( *itDia );

								it_v = vHash.find( v );
								if ( it_v != vHash.end() )
								{
									row3.insert( it_v->second, 1 );
								}
								else
								{
									vNotfound = true;
									continue;
								}

								v.reset();
								v.setType( Variable::V_CREDITOS );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setUnidade( *itUnid );
								v.setSubCjtSala( *itCjtSalaCompart );
								v.setDia( *itDia );

								it_v = vHash.find( v );
								if ( it_v != vHash.end() )
								{
									row3.insert( it_v->second, -1 );
								}
								else
								{
									vNotfound = true;
									continue;
								}

								v.reset();
								v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT );
								v.setTurma( turma );
								v.setDisciplina( discComum );
								v.setParOfertas( oft1, oft2 );

								it_v = vHash.find( v );
								if ( it_v != vHash.end() )
								{
									row3.insert( it_v->second, M );
								}
								else
								{
									vNotfound = true;
									continue;
								}

								#pragma endregion
								
								// Cria a restrição tipo 1
								if ( row1.getnnz() != 0 )
								{
									cHash[ c ] = lp->getNumRows();
									lp->addRow( row1 );
									restricoes++;
								}
								// Cria a restrição tipo 2																
								if ( row2.getnnz() != 0 )
								{
									cHash[ c ] = lp->getNumRows();
									lp->addRow( row2 );
									restricoes++;
								}
								// Cria a restrição tipo 3
								if ( row3.getnnz() != 0 )
								{
									cHash[ c ] = lp->getNumRows();
									lp->addRow( row3 );
									restricoes++;
								}

							}
						}
					}
				}
			}
		}
   }

   return restricoes;
}


/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável g
%Desc 

%MatExp

\begin{eqnarray}
	
	 g_{d,oft,t} \ge \sum\limits_{i \in I_{d}} ( q_{i,d,u,s,t,oft} ) \nonumber \qquad

\forall d \in D_{oft} \quad
\forall oft \in O_{d}
\forall u \in U \quad
\forall s \in S_{u} \quad
\forall t \in T \quad
\end{eqnarray}

%DocEnd
/====================================================================*/
int SolverMIP::cria_restricao_ativacao_var_g( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;
   
   VariableHash::iterator it_v;   

   ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
   {
	    Oferta *oft = *itOft;
		Campus *cp = oft->campus;

		if ( cp->getId() != campusId )
		{
			continue;
		}

	    map < Disciplina*, int, LessPtr< Disciplina > >::iterator it_disc = oft->curriculo->disciplinas_periodo.begin();
	    for (; it_disc != oft->curriculo->disciplinas_periodo.end(); it_disc++ )
	    {
			Disciplina * d = it_disc->first;

			#pragma region Equivalencias
			if ( ( problemData->mapDiscSubstituidaPor.find( d ) !=
					problemData->mapDiscSubstituidaPor.end() ) &&
					!problemData->ehSubstituta( d ) )
			{
				continue;
			}
			#pragma endregion

			// para cada unidade do campus de oft
			ITERA_GGROUP_LESSPTR( itUnid, cp->unidades, Unidade )
			{
				// para cada sala aonde poderá ser ministrada a disciplina
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
				{   
					if ( itCjtSala->disciplinas_associadas.find( d ) ==
						 itCjtSala->disciplinas_associadas.end() )
						continue;

					GGroup< int > diasLetivos = itCjtSala->dias_letivos_disciplinas[ d ];
									
					// Para cada dia em que d pode ser ministrada em itCjtSala
					GGroup< int >::iterator itDia = diasLetivos.begin();
					for (; itDia != diasLetivos.end(); itDia++ )
					{
						Constraint c;
						c.reset();
						c.setType( Constraint::C_VAR_G );
						c.setDisciplina( d );
						c.setOferta( oft );
						c.setDia( *itDia );
						c.setSubCjtSala( *itCjtSala );

						sprintf( name, "%s", c.toString().c_str() ); 

						if ( cHash.find( c ) != cHash.end() )
						{
							continue;
						}

						nnz = 5;
						OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );
				
						Variable v;
						v.reset();
						v.setType( Variable::V_MIN_HOR_DISC_OFT_DIA ); // g_{d,oft,t}
						v.setDisciplina(d);
						v.setOferta(oft);
						v.setDia(*itDia);

						it_v = vHash.find( v );
						if ( it_v != vHash.end() )
						{
							row.insert( it_v->second, -1 );
						}
						else
						{
							continue;
						}
						
						bool found = false;

						#pragma region Numero de creditos da disciplina d alocados para oft, no dia t, para a sala s
						for ( int turma = 0; turma < d->getNumTurmas(); turma++ )
						{
							Variable v;
							v.reset();
							v.setType( Variable::V_CREDITOS_OFT ); // q_{i,d,oft,u,s,t}
							v.setTurma(turma);
							v.setDisciplina(d);
							v.setOferta(oft);
							v.setUnidade(*itUnid);
							v.setSubCjtSala(*itCjtSala);
							v.setDia(*itDia);

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, 1 );
								found = true;
							}
						}
						#pragma endregion 

						if ( !found )
						{
							continue; // Só cria a restrição se existir pelo menos 1 variavel q
						}

						if ( row.getnnz() != 0 )
						{
							cHash[ c ] = lp->getNumRows();
							lp->addRow( row );
							restricoes++;
						}
					}
				}
			}
		}
   }
   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Evita sobreposição de sala por turmas de uma mesma disciplina e mesmo bloco
curricular
%Desc 

%MatExp

\begin{eqnarray}
	
	 \sum\limits_{d \in D_{bc}} ( g_{d,oft,t} ) \le MaxCred_{oft,t} \qquad

\forall bc \in oft
\forall oft \in O
\forall u \in U \quad
\forall s \in S_{u} \quad
\forall t \in T \quad
\end{eqnarray}

%DocEnd
/====================================================================*/
int SolverMIP::cria_restricao_evita_sobrepos_sala_por_div_turmas( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;
   
   VariableHash::iterator it_v; 

   // Para cada oferta
   ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
   {
	    Oferta *oft = *itOft;

		if ( oft->getCampusId() != campusId )
		{
			continue;
		}

		// Para cada dia
		GGroup< int >::iterator itDia = oft->campus->diasLetivos.begin();
		for (; itDia != oft->campus->diasLetivos.end(); itDia++ )
		{
			int dia = *itDia;

			// Para cada bloco curricular da oferta
			ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
			{	
				if ( itBloco->curriculo->getId() != oft->getCurriculoId() )
				{
					continue;
				}

				BlocoCurricular *bc = *itBloco;
				int periodo = bc->getPeriodo();
			
				GGroup< Calendario*, LessPtr<Calendario> > calendarios = itBloco->curriculo->retornaSemanasLetivasNoPeriodo( periodo );

				ITERA_GGROUP_LESSPTR( itSL, calendarios, Calendario )
				{
					Calendario *sl = *itSL;
				
					Constraint c;
					c.reset();
					c.setType( Constraint::C_EVITA_SOBREPOS_SALA_POR_TURMA );
					c.setOferta( oft );
					c.setBloco( bc );
					c.setDia( dia );
					c.setSemanaLetiva( sl );

					sprintf( name, "%s", c.toString().c_str() ); 

					if ( cHash.find( c ) != cHash.end() )
					{
						continue;
					}

					nnz = 10;

					OPT_ROW row( nnz, OPT_ROW::LESS , 0, name );

					// Para cada disciplina de bc
					map < Disciplina*, int, LessPtr< Disciplina > >::iterator it_disc = oft->curriculo->disciplinas_periodo.begin();
					for (; it_disc != oft->curriculo->disciplinas_periodo.end(); it_disc++ )
					{
						Disciplina * d = it_disc->first;

						// Disciplina deve pertencer à mesma semana letiva corrente
						if ( d->getCalendario() != sl )
						{
							continue;
						}
						
						// Disciplinas devem pertencer ao período do bloco curricular bc
						if ( it_disc->second != bc->getPeriodo() )
						{
							continue;
						}

						Variable v;
						v.reset();
						v.setType( Variable::V_MIN_HOR_DISC_OFT_DIA );
						v.setDisciplina(d);
						v.setOferta(oft);
						v.setDia(dia);

						it_v = vHash.find( v );
						if ( it_v != vHash.end() )
						{
							row.insert( it_v->second, 1 );
						}
					}

					std::map< Trio<int, int, Calendario*>, int >::iterator it_map = bc->combinaCredSL.begin();
					for ( ; it_map != bc->combinaCredSL.end(); it_map++  )
					{
						if ( it_map->first.first == dia && it_map->first.third == sl )
						{
							int k = it_map->first.second;
							
							Variable v;
							v.reset();
							v.setType( Variable::V_COMBINA_SL_BLOCO );
							v.setBloco( bc );
							v.setDia( dia );
							v.setCombinaSLBloco( k );

							it_v = vHash.find( v );
							if( it_v != vHash.end() )
							{
								int coef = bc->getNroMaxCredCombinaSL( k, sl, dia );

								row.insert( it_v->second, -coef );
							}
						}
					}

					if ( row.getnnz() != 0 )
					{
						cHash[ c ] = lp->getNumRows();
						lp->addRow( row );
						restricoes++;
					}
				}
			}
		}
   }

   return restricoes;
}

// Restricoes 1.2.44, 1.2.45, 1.2.46
/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Ativação da variável q
%Desc 

%MatExp

\begin{eqnarray}
	
	 q_{i,d,oft,u,s,t} \eq x_{i,d,u,s,t} \cdot e_{i,d,oft} \nonumber \qquad
	  
	  =  \qquad

	 q_{i,d,oft,u,s,t} \le M \cdot e_{i,d,oft} \nonumber \qquad
	 q_{i,d,oft,u,s,t} \ge x_{i,d,u,s,t} - M \cdot ( 1 - e_{i,d,oft} ) \nonumber \qquad
	 x_{i,d,u,s,t} \ge q_{i,d,oft,u,s,t} - M \cdot ( 1 - e_{i,d,oft} ) \nonumber \qquad

\forall i \in I_{d} \quad
\forall d \in D_{oft} \quad
\forall oft \in O \quad
\forall u \in U \quad
\forall s \in S_{u} \quad
\forall t \in T \quad
\end{eqnarray}

%Data M
%Desc
big $M$.

%DocEnd
/====================================================================*/
int SolverMIP::cria_restricao_ativacao_var_q( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;
   double M = 9999.0;
   
   VariableHash::iterator it_v;
   Variable v;
   Constraint c;
   
   ITERA_GGROUP_LESSPTR( itOft, problemData->ofertas, Oferta )
   {
	    Oferta *oft = *itOft;
		Campus *cp = oft->campus;

		if ( cp->getId() != campusId )
		{
			continue;
		}

	    map < Disciplina*, int, LessPtr< Disciplina > >::iterator it_disc = oft->curriculo->disciplinas_periodo.begin();
	    for (; it_disc != oft->curriculo->disciplinas_periodo.end(); it_disc++ )
	    {
			Disciplina * d = it_disc->first;

			// para cada unidade do campus de oft
			ITERA_GGROUP_LESSPTR( itUnid, cp->unidades, Unidade )
			{
				// para cada sala aonde poderá ser ministrada a disciplina
				ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
				{   
					if ( itCjtSala->disciplinas_associadas.find( d ) ==
						 itCjtSala->disciplinas_associadas.end() )
						continue;

					GGroup< int > diasLetivos = itCjtSala->dias_letivos_disciplinas[ d ];
									
					// Para cada dia em que d pode ser ministrada em itCjtSala
					GGroup< int >::iterator itDia = diasLetivos.begin();
					for (; itDia != diasLetivos.end(); itDia++ )
					{
						for ( int turma = 0; turma < d->getNumTurmas(); turma++ )
						{
							bool vNotfound = false;
							// Se pelo menos 1 das variaveis não existir,
							// não tem sentido o trio de restrições, logo nenhuma será criada.

							// ----------------------------------------------------------
							// 1
							#pragma region Restricao tipo 1

							c.reset();
							c.setType( Constraint::C_VAR_Q_1 );
							c.setTurma( turma );
							c.setDisciplina( d );
							c.setOferta( oft );
							c.setDia( *itDia );
							c.setUnidade( *itUnid );
							c.setSubCjtSala( *itCjtSala );

							sprintf( name, "%s", c.toString().c_str() ); 

							if ( cHash.find( c ) != cHash.end() )
							{
								continue;
							}

							nnz = 2;
							OPT_ROW row1( nnz, OPT_ROW::LESS , 0.0, name );

							v.reset();
							v.setType( Variable::V_CREDITOS_OFT );
							v.setTurma( turma );
							v.setDisciplina( d );
							v.setOferta( oft );
							v.setUnidade( *itUnid );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDia );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row1.insert( it_v->second, 1 );
							}
							else
							{
								vNotfound = true;
								continue;
							}

							v.reset();
							v.setType( Variable::V_ALOC_ALUNOS_OFT );
							v.setTurma( turma );
							v.setDisciplina( d );
							v.setOferta( oft );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row1.insert( it_v->second, -M );
							}
							else
							{
								vNotfound = true;
								continue;
							}

							#pragma endregion
										
							// ----------------------------------------------------------
							// 2
							#pragma region Restricao tipo 2
										
							c.reset();
							c.setType( Constraint::C_VAR_Q_2 );
							c.setTurma( turma );
							c.setDisciplina( d );
							c.setOferta( oft );
							c.setDia( *itDia );
							c.setUnidade( *itUnid );
							c.setSubCjtSala( *itCjtSala );

							sprintf( name, "%s", c.toString().c_str() ); 

							if ( cHash.find( c ) != cHash.end() )
							{
								continue;
							}

							nnz = 3;
							OPT_ROW row2( nnz, OPT_ROW::LESS , M, name );

							v.reset();
							v.setType( Variable::V_CREDITOS_OFT );
							v.setTurma( turma );
							v.setDisciplina( d );
							v.setOferta( oft );
							v.setUnidade( *itUnid );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDia );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row2.insert( it_v->second, -1 );
							}
							else
							{
								vNotfound = true;
								continue;
							}

							v.reset();
							v.setType( Variable::V_CREDITOS );
							v.setTurma( turma );
							v.setDisciplina( d );
							v.setUnidade( *itUnid );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDia );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row2.insert( it_v->second, 1 );
							}
							else
							{
								vNotfound = true;
								continue;
							}

							v.reset();
							v.setType( Variable::V_ALOC_ALUNOS_OFT );
							v.setTurma( turma );
							v.setDisciplina( d );
							v.setOferta( oft );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row2.insert( it_v->second, M );
							}
							else
							{
								vNotfound = true;
								continue;
							}

							#pragma endregion

							// ----------------------------------------------------------
							// 3
							#pragma region Restricao tipo 3

							c.reset();
							c.setType( Constraint::C_VAR_Q_3 );
							c.setTurma( turma );
							c.setDisciplina( d );
							c.setOferta( oft );
							c.setDia( *itDia );
							c.setUnidade( *itUnid );
							c.setSubCjtSala( *itCjtSala );

							sprintf( name, "%s", c.toString().c_str() ); 

							if ( cHash.find( c ) != cHash.end() )
							{
								continue;
							}

							nnz = 3;
							OPT_ROW row3( nnz, OPT_ROW::LESS , M, name );

							v.reset();
							v.setType( Variable::V_CREDITOS_OFT );
							v.setTurma( turma );
							v.setDisciplina( d );
							v.setOferta( oft );
							v.setUnidade( *itUnid );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDia );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row3.insert( it_v->second, 1 );
							}
							else
							{
								vNotfound = true;
								continue;
							}

							v.reset();
							v.setType( Variable::V_CREDITOS );
							v.setTurma( turma );
							v.setDisciplina( d );
							v.setUnidade( *itUnid );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDia );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row3.insert( it_v->second, -1 );
							}
							else
							{
								vNotfound = true;
								continue;
							}

							v.reset();
							v.setType( Variable::V_ALOC_ALUNOS_OFT );
							v.setTurma( turma );
							v.setDisciplina( d );
							v.setOferta( oft );

							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row3.insert( it_v->second, M );
							}
							else
							{
								vNotfound = true;
								continue;
							}

							#pragma endregion

							// Cria a restrição tipo 1
							if ( row1.getnnz() != 0 )
							{
								cHash[ c ] = lp->getNumRows();
								lp->addRow( row1 );
								restricoes++;
							}
							// Cria a restrição tipo 2																
							if ( row2.getnnz() != 0 )
							{
								cHash[ c ] = lp->getNumRows();
								lp->addRow( row2 );
								restricoes++;
							}
							// Cria a restrição tipo 3
							if ( row3.getnnz() != 0 )
							{
								cHash[ c ] = lp->getNumRows();
								lp->addRow( row3 );
								restricoes++;
							}
						}
					}
				}
			}
		}
   }

   return restricoes;

}

/*
	Impede que ofertas que possuem disciplinas de diferentes semanas letivas
	tenham turmas compartilhadas.
	Essa restrição só é necessária para que a restrição que evita sobreposição
	de sala por compartilhamento de turma
	(int cria_restricao_evita_sobrepos_sala_por_div_turmas(void)) não falhe.
*/
int SolverMIP::cria_restricao_fixa_nao_compartilhamento( int campusId )
{
   int restricoes = 0;
   
   #pragma region Condições para criar as restrições
   
   // Se o compartilhamento não é permitido, nenhuma restrição é criada.
   if ( !problemData->parametros->permite_compartilhamento_turma_sel )
   {
	   return restricoes;
   }   

   // Metodo somente utilizado quando há 2 semanas letivas
   if ( problemData->calendarios.size() != 2 )
   {
	   return restricoes;
   }
   
   #pragma endregion
   
   char name[ 200 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;
   
   // para cada campus
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   Campus *cp = *itCampus;

	   if ( cp->getId() != campusId )
	   {
		   continue;
	   }

	   // para cada par de cursos compativeis
	   std::map< std::pair< Curso *, Curso * >, std::vector< int > >::iterator
               it_cursoComp_disc = problemData->cursosComp_disc.begin();
        for (; it_cursoComp_disc != problemData->cursosComp_disc.end(); it_cursoComp_disc++ )
        {
			Curso* c1 = it_cursoComp_disc->first.first;
			Curso* c2 = it_cursoComp_disc->first.second;
			
			if ( cp->cursos.find( c1 ) == cp->cursos.end() ||
				 cp->cursos.find( c2 ) == cp->cursos.end() )
			{
				continue;
			}
			
			// para cada disciplina em comum (possivel de ser compartilhada) ao par de cursos
            std::vector< int >::iterator it_discComum = it_cursoComp_disc->second.begin();
            for (; it_discComum != it_cursoComp_disc->second.end(); ++it_discComum )
            {
				Disciplina * discComum = problemData->retornaDisciplina( *it_discComum );
				  
				if (discComum == NULL) continue;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( discComum ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( discComum ) )
				{
					continue;
				}
				#pragma endregion
				
				GGroup<Oferta*, LessPtr<Oferta>> ofts1 = cp->retornaOfertasComCursoDisc( c1->getId(), discComum );
				GGroup<Oferta*, LessPtr<Oferta>> ofts2 = cp->retornaOfertasComCursoDisc( c2->getId(), discComum );

				// para cada oferta contendo discComum do curso c1
				ITERA_GGROUP_LESSPTR( itOft1, ofts1, Oferta )
				{
					Oferta *oft1 = *itOft1;
					int periodo1 = oft1->periodoDisciplina( discComum );
					
					if ( oft1->getCampusId() != campusId )
					{
						continue;
					}
					
					GGroup< Calendario*, LessPtr<Calendario> > semanasLetivas1 = oft1->curriculo->retornaSemanasLetivasNoPeriodo( periodo1 );
					
					// para cada oferta contendo discComum do curso c2
					ITERA_GGROUP_LESSPTR( itOft2, ofts2, Oferta )
					{		
						Oferta *oft2 = *itOft2;
						int periodo2 = oft2->periodoDisciplina( discComum );
					
						if ( oft2->getCampusId() != campusId )
						{
							continue;
						}						

						GGroup< Calendario*, LessPtr<Calendario> > semanasLetivas2 =  oft2->curriculo->retornaSemanasLetivasNoPeriodo( periodo2 );

						// Cria a restrição somente para períodos que possuem mais de uma semana letiva, ou sl's diferentes
						if ( semanasLetivas1.size() == 1 &&
							 semanasLetivas2.size() == 1 &&
							 semanasLetivas1.begin()->getId() == semanasLetivas2.begin()->getId() )
						{
							continue;
						}

						// para cada turma da disciplina em comum
						for ( int turma = 0; turma < discComum->getNumTurmas(); turma++ )
						{
							c.reset();
							c.setType( Constraint::C_FIXA_NAO_COMPARTILHAMENTO );
							c.setParOfertas( std::make_pair(oft1, oft2) );
							c.setDisciplina( discComum );
							c.setTurma( turma );

							sprintf( name, "%s", c.toString().c_str() ); 

							if ( cHash.find( c ) != cHash.end() )
							{
								continue;
							}

							nnz = 1;

							OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0 , name );

							v.reset();
							v.setType( Variable::V_ALOC_ALUNOS_PAR_OFT );
							v.setTurma( turma );
							v.setDisciplina( discComum );
							v.setParOfertas( oft1, oft2 );

							it_v = vHash.find( v );
							if( it_v != vHash.end() )
							{
								row.insert( it_v->second, 1 );
							}
							
							if ( row.getnnz() != 0 )
							{
								cHash[ c ] = lp->getNumRows();
								lp->addRow( row );
								restricoes++;
							}
						}
					}
				}
			}
		}
   }
   return restricoes;
}


int SolverMIP::cria_restricao_ativacao_var_cbc( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];   
   VariableHash::iterator it_v;
   Variable v;
   Constraint c;

   ITERA_GGROUP_LESSPTR( itBloco, problemData->blocos, BlocoCurricular )
   {
	   BlocoCurricular *bc = *itBloco;
		
	   if ( bc->campus->getId() != campusId )
	   {
		   continue;
	   }

	   ITERA_GGROUP_N_PT( itDia, bc->diasLetivos, int )
	   {
		   int dia = *itDia;

			c.reset();
			c.setType( Constraint::C_VAR_CBC );
			c.setBloco( *itBloco );
			c.setDia( dia );

			sprintf( name, "%s", c.toString().c_str() );
			if ( cHash.find( c ) != cHash.end() )
			{
				continue;
			}

			int nnz = bc->getCombinaCredSLSize()[dia];
					
			OPT_ROW row( nnz, OPT_ROW::LESS , 1, name );

			std::map< Trio< int/*dia*/, int /*k_id*/, Calendario* /*sl*/ >,
					  int/*nroCreds*/ >::iterator it_map = bc->combinaCredSL.begin();

			for ( ; it_map != bc->combinaCredSL.end(); it_map++ )
			{
				if ( it_map->first.first == dia )
				{
					Variable v;
					v.reset();
					v.setType( Variable::V_COMBINA_SL_BLOCO );

					v.setBloco( bc );
					v.setDia( dia );
					v.setCombinaSLBloco( it_map->first.second );
					
					it_v = vHash.find( v );
					if( it_v != vHash.end() )
					{
						row.insert( it_v->second, 1 );
					}
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHash[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
   }

   return restricoes;
}





/*
	RESTRICOES SOMENTE PARA O MODELO TATICO - ALUNO - SEM HORARIOS
*/

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Turmas de disciplinas de mesmo aluno não devem exceder máximo de créditos por dia
%Desc 

%MatExp

\begin{eqnarray}
\sum\limits_{d \in D_{a}} \sum\limits_{u \in U} \sum\limits_{s \in S_{u}} \sum\limits_{i \in I_{a,d}} x_{i,d,u,s,t} 
			\leq \sum\limits_{k} ( Nh_{a,t,sl,k} \cdot ca_{a,t,k} )  \nonumber \qquad 
\forall a \in A \quad
\forall cp \in CP
\forall t \in T \quad
\end{eqnarray}

%Data Nh_{a,t,sl,k}
%Desc
máximo de créditos permitidos por dia $t$ para a combinacao de horarios .

%DocEnd
/====================================================================*/

int SolverMIP::cria_restricao_max_cred_disc_aluno( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   Disciplina * disciplina_equivalente = NULL;

   Curso * curso = NULL;
   Curriculo * curriculo = NULL;
   
   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
		   continue;
	   }

      GGroup< int >::iterator itDiasLetCampus = itCampus->diasLetivos.begin();

      ITERA_GGROUP_N_PT( itDiasLetCampus, itCampus->diasLetivos, int )
      {
		 int dia = *itDiasLetCampus;

         ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
         {
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->campus->getId() != campusId )
			{
				continue;
			}

			GGroup< Calendario*, LessPtr<Calendario> > calendarios = itAluno->retornaSemanasLetivas();

			ITERA_GGROUP_LESSPTR( itSL, calendarios, Calendario )
			{
				Calendario *sl = *itSL;

				c.reset();
				c.setType( Constraint::C_MAX_CRED_DISC_ALUNO );

				c.setAluno( aluno );
				c.setDia( dia );
				c.setCampus( *itCampus );
				c.setSemanaLetiva( sl );

				sprintf( name, "%s", c.toString().c_str() ); 
				if ( cHash.find( c ) != cHash.end() )
				{
				   continue;
				}

				nnz =  50; /*FIX-ME*/

				OPT_ROW row( nnz + 1, OPT_ROW::LESS , 0.0, name );

				bool inseriuX = false;
				bool inseriuCa = false;

				ITERA_GGROUP_LESSPTR( it_al_dem, aluno->demandas, AlunoDemanda )
				{
					disciplina = ( *it_al_dem )->demanda->disciplina;

					#pragma region Equivalencias
					if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
							problemData->mapDiscSubstituidaPor.end() ) &&
						  !problemData->ehSubstituta( disciplina ) )
					{
						continue;
					}
					#pragma endregion	

				   // Só considera disciplinas da semana letiva corrente
				   if ( disciplina->getCalendario() != *itSL )
				   {
					   continue;
				   }

				   ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
				   {
					  ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					  {
						 if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
							  itCjtSala->disciplinas_associadas.end() )
							continue;

						 int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );

						 if ( turma != -1 )
						 {
							v.reset();
							v.setType( Variable::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetCampus );
							
							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
							   row.insert( it_v->second, 1.0 );

							   inseriuX = true;
							}
						 }
					  }
				   }
				}

				std::map< Trio<int, int, Calendario*>, int >::iterator it_map = aluno->combinaCredSL.begin();
				for ( ; it_map != aluno->combinaCredSL.end(); it_map++  )
				{
					if ( it_map->first.first == dia && it_map->first.third == sl )
					{
						int k = it_map->first.second;
						
						v.reset();
						v.setType( Variable::V_COMBINA_SL_ALUNO );
						v.setAluno( aluno );
						v.setDia( dia );
						v.setCombinaSLAluno( k );

						it_v = vHash.find( v );
						if( it_v != vHash.end() )
						{
							int coef = aluno->getNroMaxCredCombinaSL( k, sl, dia );

							row.insert( it_v->second, -coef );

							inseriuCa = true;
						}
					}
				}

				if ( inseriuX && inseriuCa )
				{
				   cHash[ c ] = lp->getNumRows();

				   lp->addRow( row );
				   restricoes++;
				}
			}
         }
      }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Mínimo de créditos alocados para turmas de um aluno (*)
%Desc 

%MatExp

\begin{eqnarray}
\underline{h}_{a} \leq \sum\limits_{d \in D_{a}} \sum\limits_{u \in U} \sum\limits_{s \in S_{u}} tempo_{d} \cdot a_{i,d,u,s,t} \nonumber \qquad 
\forall a \in A \quad
\forall i \in I_{a,d} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-393
int SolverMIP::cria_restricao_min_creds_semana_aluno( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus* campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	    Aluno *aluno = *itAluno;

	    if ( aluno->getOferta()->getCampusId() != campusId )
	    {
		    continue;
	    }

         GGroup< int >::iterator itDiasLetivos = 
            campus->diasLetivos.begin();

         for (; itDiasLetivos != campus->diasLetivos.end();
            itDiasLetivos++ )
         {
            c.reset();
            c.setType( Constraint::C_MIN_CREDS_SEMANA_ALUNO );

            c.setAluno( aluno );
            c.setDia( *itDiasLetivos );

            sprintf( name, "%s", c.toString().c_str() ); 

            if (cHash.find(c) != cHash.end())
            {
               continue;
            }

			nnz = ( ( aluno->demandas.size() * campus->diasLetivos.size() ) + 1 );

            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

			ITERA_GGROUP_LESSPTR( it_al_dem, aluno->demandas, AlunoDemanda )
			{
				disciplina = ( *it_al_dem )->demanda->disciplina;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

				ITERA_GGROUP_LESSPTR( itUnidade, campus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{
						if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
							 itCjtSala->disciplinas_associadas.end() )
							continue;

						int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );

						if ( turma != -1 )
						{
							v.reset();
							v.setType( Variable::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetivos );
							
							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, -disciplina->getTempoCredSemanaLetiva() );
							}
						}
					}
				}
			}
			
            v.reset();
            v.setType( Variable::V_MIN_CRED_SEMANA_ALUNO );

            v.setAluno( aluno );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            // Para evitar a criação da restrição no caso em que só a variável h seja encontrada. Isso é só uma
            // garantia. Como os dias letivos estão sendo respeitados, não devemos notar erros.
            if ( row.getnnz() > 1 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
        }
   }

   return restricoes;
}

/*====================================================================/
%DocBegin TRIEDA_LOAD_MODEL

%Constraint 
Máximo de créditos alocados para turmas de um aluno (*)
%Desc 

%MatExp

\begin{eqnarray}
\overline{h}_{a} \geq \sum\limits_{d \in D_{a}} \sum\limits_{u \in U} \sum\limits_{s \in S_{u}} tempo_{d} \cdot x_{i,d,u,s,t} \nonumber \qquad 
\forall a \in A \quad
\forall i \in I_{a,d} \quad
\forall t \in T
\end{eqnarray}

%DocEnd
/====================================================================*/

// TRIEDA-394
int SolverMIP::cria_restricao_max_creds_semana_aluno( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   Campus* campus = problemData->refCampus[campusId];

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	    Aluno *aluno = *itAluno;

	    if ( aluno->getOferta()->getCampusId() != campusId )
	    {
		    continue;
	    }

         GGroup< int >::iterator itDiasLetivos = 
            campus->diasLetivos.begin();

         for (; itDiasLetivos != campus->diasLetivos.end();
            itDiasLetivos++ )
         {
            c.reset();
            c.setType( Constraint::C_MAX_CREDS_SEMANA_ALUNO );

            c.setAluno( aluno );
            c.setDia( *itDiasLetivos );

            sprintf( name, "%s", c.toString().c_str() ); 

            if (cHash.find(c) != cHash.end())
            {
               continue;
            }

			nnz = ( ( aluno->demandas.size() * campus->diasLetivos.size() ) + 1 );

            OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0 , name );

			ITERA_GGROUP_LESSPTR( it_al_dem, aluno->demandas, AlunoDemanda )
			{
				disciplina = ( *it_al_dem )->demanda->disciplina;

				#pragma region Equivalencias
				if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
						problemData->mapDiscSubstituidaPor.end() ) &&
						!problemData->ehSubstituta( disciplina ) )
				{
					continue;
				}
				#pragma endregion	

				ITERA_GGROUP_LESSPTR( itUnidade, campus->unidades, Unidade )
				{
					ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
					{
						if ( itCjtSala->disciplinas_associadas.find( disciplina ) ==
							 itCjtSala->disciplinas_associadas.end() )
							continue;

						int turma = problemData->retornaTurmaDiscAluno( aluno, disciplina );

						if ( turma != -1 )
						{
							v.reset();
							v.setType( Variable::V_CREDITOS );

							v.setTurma( turma );
							v.setDisciplina( disciplina );
							v.setUnidade( *itUnidade );
							v.setSubCjtSala( *itCjtSala );
							v.setDia( *itDiasLetivos );
							
							it_v = vHash.find( v );
							if ( it_v != vHash.end() )
							{
								row.insert( it_v->second, -disciplina->getTempoCredSemanaLetiva() );
							}
						}
					}
				}
			}
			
            v.reset();
            v.setType( Variable::V_MAX_CRED_SEMANA_ALUNO );

            v.setAluno( aluno );

            it_v = vHash.find( v );
            if ( it_v != vHash.end() )
            {
               row.insert( it_v->second, 1.0 );
            }

            // Para evitar a criação da restrição no caso em que só a variável h seja encontrada. Isso é só uma
            // garantia. Como os dias letivos estão sendo respeitados, não devemos notar erros.
            if ( row.getnnz() > 1 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
        }
   }

   return restricoes;
}



int SolverMIP::cria_restricao_evita_sobrepos_turmas_mesmos_alunos( int campusId )
{
   int restricoes = 0;
   char name[ 200 ];						   
   int nnz = 50;

   GGroup< Sala *, LessPtr< Sala > > salas = this->problemData->getSalas();

   Constraint c;
   VariableHash::iterator vit;
   ConstraintHash::iterator cit;

   Campus * campus = problemData->refCampus[campusId];
   	
   GGroup< int > disciplinas = problemData->cp_discs[campusId];

   ITERA_GGROUP_N_PT( itDisc, disciplinas, int )
   {
	   Disciplina * disciplina = problemData->refDisciplinas[*itDisc];

	   if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
	   {
		   continue;
	   }

	   for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
	   {
		   if ( ! problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId ) )
				continue;

		   Unidade* u = retornaUnidadeDeAtendimento( turma, disciplina, campus );
		   ConjuntoSala* s = retornaSalaDeAtendimento( turma, disciplina, campus );

		   // Para cada dia
		   ITERA_GGROUP_N_PT( itDia, disciplina->diasLetivos, int )
		   {
			   int dia = *itDia;
			   
			   // Lado direito caso so haja 1 semana letiva na restrição
			   double rhs = disciplina->getCalendario()->getTempoTotal( dia );

			   // Calcula o lado direito geral das restrições
			   double rhs_geral = 99999999;	   
			   GGroup<Calendario*> calendarios = campus->getCalendarios();
			   ITERA_GGROUP( itSl, calendarios, Calendario )
			   {
					double tempo = itSl->getTempoTotal( dia );
					if ( tempo < rhs_geral )
						rhs_geral = tempo;
			   }

			   ITERA_GGROUP_LESSPTR( itUnid, campus->unidades, Unidade )
			   {
				   // Para cada sala diferente da sala s
				   ITERA_GGROUP_LESSPTR( itCjtSala, itUnid->conjutoSalas, ConjuntoSala )
					{
						ConjuntoSala *cjtSala = *itCjtSala;
		   
						if ( cjtSala == s )
						{
							continue;
						}

						c.reset();
						c.setType( Constraint::C_EVITA_SOBREPOS_TURMAS_ALUNOS );
						c.setSubCjtSala( cjtSala );
						c.setDia( dia );
						c.setDisciplina( disciplina );
						c.setTurma( turma );

						cit = cHash.find(c);
						if ( cit != cHash.end() )
						{
							continue;
						}

						cHash[ c ] = lp->getNumRows();
				   
						sprintf( name, "%s", c.toString().c_str() );
						OPT_ROW row( nnz, OPT_ROW::LESS , rhs, name );
											    
						Variable v;
						v.reset();
						v.setType( Variable::V_CREDITOS );
						v.setTurma( turma );            // i
						v.setDisciplina( disciplina );  // d
						v.setUnidade( u );				// u
						v.setSubCjtSala( s );			// tps  
						v.setDia( dia );				// t

						int tempoDiscV = disciplina->getTempoCredSemanaLetiva();

						vit = vHash.find( v );
					    if ( vit != vHash.end())
					    {
							row.insert( vit->second, tempoDiscV );
					    }
						
						// Procura os atendimentos feitos na sala cjtSala que têm aluno em comum com i/d

						GGroup< std::pair< int,Disciplina* > > atends = retornaAtendEmCjtSala( cjtSala );

						GGroup< std::pair< int,Disciplina* > >::iterator itAtends = atends.begin();
						for ( ; itAtends != atends.end(); itAtends++ )
						{
							int turmaSum = (*itAtends).first;
							Disciplina *discSum = (*itAtends).second;

							// Só se tiver aluno em comum
							if ( problemData->alunosEmComum( turma, disciplina, turmaSum, discSum, campus ).size() == 0 )
							{
								continue;
							}

							int tempoDiscV = discSum->getTempoCredSemanaLetiva();

							v.reset();
							v.setType( Variable::V_CREDITOS );
							v.setTurma( turmaSum );         // i
							v.setDisciplina( discSum );     // d
							v.setUnidade( *itUnid );		// u
							v.setSubCjtSala( cjtSala );		// tps  
							v.setDia( dia );				// t

							vit = vHash.find( v );
							if ( vit != vHash.end() )
							{
								row.insert( vit->second, tempoDiscV );

								if ( discSum->getCalendario()->getTempoTotal( dia ) != rhs )
								{
									row.setRhs( rhs_geral );
									rhs = rhs_geral;
								}
							}

						}

						if ( row.getnnz() > 1 )
						{
							lp->addRow( row );
							restricoes++;
						}
					}
			   }
		   }
	   }   
   }

   return restricoes;

}

/*
	Para cada i, d, cp:

	z_{i,d,cp} + fd_{i,d,cp} = 1

	min nAlunos_{i,d,cp} * fd_{i,d,cp}
*/
int SolverMIP::cria_restricao_aloc_dem_disc( int campusId )
{
   int restricoes = 0;
   char name[ 100 ];
   int nnz;

   Constraint c;
   Variable v;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;
   
   Campus* cp = problemData->refCampus[ campusId ];

   ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
   {
       disciplina = ( *it_disciplina );

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		{
			continue;
		}
		#pragma endregion	

		if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			 continue;

      for ( int i = 0; i < disciplina->getNumTurmas(); ++i )
      {	  
         c.reset();
         c.setType( Constraint::C_ALOC_DEM );
		 c.setCampus( cp );
         c.setDisciplina( disciplina );
         c.setTurma( i );

         sprintf( name, "%s", c.toString().c_str() ); 
         if ( cHash.find( c ) != cHash.end() )
         {
            continue;
         }

		 nnz = 2;
         OPT_ROW row( nnz, OPT_ROW::EQUAL, 1.0, name );

		 v.reset();
		 v.setType( Variable::V_ABERTURA );
		 v.setTurma( i );
		 v.setDisciplina( disciplina );
		 v.setCampus( cp );

		 it_v = vHash.find( v );
		 if( it_v != vHash.end() )
		 {
			row.insert( it_v->second, 1.0 );
		 }

		 v.reset();
		 v.setType( Variable::V_SLACK_DEMANDA_ALUNO );
		 v.setTurma( i );
		 v.setDisciplina( disciplina );
		 v.setCampus( cp );

		 it_v = vHash.find( v );
		 if( it_v != vHash.end() )
		 {
			row.insert( it_v->second, 1.0 );
		 }         

         if ( row.getnnz() != 0 )
         {
            cHash[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }
      }
   }

   return restricoes;
}

/*
	Para cada i, d, cp:

	minAlunos * z_{i,d,cp} <= sum[u]sum[s]sum[t] o_{i,d,u,s,t}
*/
int SolverMIP::cria_restricao_limita_abertura_turmas_aluno( int campusId )
{
  int restricoes = 0;
	
   int nnz;
   char name[ 100 ];

   Variable v;
   Constraint c;
   VariableHash::iterator it_v;

   Disciplina * disciplina = NULL;

   int minAlunos;
   if ( problemData->parametros->min_alunos_abertura_turmas )
   {
		minAlunos = problemData->parametros->min_alunos_abertura_turmas_value;
		if ( minAlunos <= 0 ) minAlunos = 1;
   }
   else
   {
	   minAlunos = 1;
   }

   ITERA_GGROUP_LESSPTR( itCampus, problemData->campi, Campus )
   {
	   if ( itCampus->getId() != campusId )
	   {
			continue;
	   }

      ITERA_GGROUP_LESSPTR( it_disciplina, problemData->disciplinas, Disciplina )
      {
         disciplina = ( *it_disciplina );

		 // A disciplina deve ser ofertada no campus especificado
		 if ( problemData->cp_discs[campusId].find( disciplina->getId() ) ==
			  problemData->cp_discs[campusId].end() )
		 {
			 continue;
		 }
		
		 if ( ! problemData->haDemandaDiscNoCampus( disciplina->getId(), campusId ) )
			 continue;
		 
		 #pragma region Equivalencias
	     if ( ( problemData->mapDiscSubstituidaPor.find( disciplina ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( disciplina ) )
		 {
			continue;
		 }
		 #pragma endregion

         for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
         {
            c.reset();
            c.setType( Constraint::C_LIMITA_ABERTURA_TURMAS );

            c.setCampus( *itCampus );
            c.setTurma( turma );
            c.setDisciplina( disciplina );

            sprintf( name, "%s", c.toString().c_str() );

            if ( cHash.find( c ) != cHash.end() )
            {
               continue;
            }

            nnz = ( itCampus->getTotalSalas() * 7 );

            OPT_ROW row( nnz + 1, OPT_ROW::LESS , 0 , name );

            v.reset();
            v.setType( Variable::V_OFERECIMENTO );

            // Insere variaveis Oferecimento (o) ---

            ITERA_GGROUP_LESSPTR( itUnidade, itCampus->unidades, Unidade )
            {
               ITERA_GGROUP_LESSPTR( itCjtSala, itUnidade->conjutoSalas, ConjuntoSala )
               {
				   if ( itCjtSala->disciplinas_associadas.find( disciplina) ==
					    itCjtSala->disciplinas_associadas.end() )
				   {
					   continue;
				   }
				   					
				   ITERA_GGROUP_N_PT ( it_Dia, itCjtSala->dias_letivos_disciplinas[disciplina], int )
				   {
						int dia = *it_Dia;
																								
						v.setTurma( turma );
						v.setDisciplina( disciplina );
						v.setUnidade( *itUnidade );
						v.setSubCjtSala( *itCjtSala );
						v.setDia( dia );                   

						it_v = vHash.find( v );
						if( it_v != vHash.end() )
						{
							Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
							trio.set(campusId, turma, disciplina);
							int nAlunos = problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size();

							row.insert( it_v->second, -nAlunos );
						}
				   }
                }
            }

            // Insere variaveis Abertura (z) ---

            v.reset();
            v.setType( Variable::V_ABERTURA );
            v.setCampus( *itCampus );
            v.setDisciplina( disciplina );
            v.setTurma( turma );

            it_v = vHash.find( v );
            if( it_v != vHash.end() )
            {
               row.insert( it_v->second, minAlunos );
            }

            // Insere restrição no Hash ---

            if ( row.getnnz() != 0 )
            {
               cHash[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

	return restricoes;
}


/*
	Para cada (i1, d, cp) e (i2, -d, cp) com alunos em comum:

	fd{i1,d,cp} + fd_{i2,-d,cp} - 2*ffd_{i1,d,i2,-d,cp} <= 0
*/
int SolverMIP::cria_restricao_disc_pratica_teorica( int campusId )
{
    int restricoes = 0;
    int nnz;
    char name[ 100 ];

    Variable v;
    Constraint c;
    VariableHash::iterator it_v;
   
    Campus* campus = problemData->refCampus[ campusId ];
	     
	GGroup< int > disciplinas = problemData->cp_discs[ campusId ];

	ITERA_GGROUP_N_PT( it_disciplina, disciplinas, int )
	{
		Disciplina * discPratica = problemData->refDisciplinas[ *it_disciplina ];

		#pragma region Equivalencias
		if ( ( problemData->mapDiscSubstituidaPor.find( discPratica ) !=
				problemData->mapDiscSubstituidaPor.end() ) &&
				!problemData->ehSubstituta( discPratica ) )
		{
			continue;
		}
		#pragma endregion

		if ( discPratica->getId() > 0 )
		{
			continue;
		}
		
		std::map< int, Disciplina * >::iterator itMapDisc =
			problemData->refDisciplinas.find( - discPratica->getId() );
				
		if ( itMapDisc == problemData->refDisciplinas.end() )
		{
			continue;
		}
		
		Disciplina *discTeorica = itMapDisc->second;

		if ( ! problemData->haDemandaDiscNoCampus( discPratica->getId(), campusId ) )
		{
			continue;
		}

		for ( int turma1 = 0; turma1 < discPratica->getNumTurmas(); turma1++ )
		{
			for ( int turma2 = 0; turma2 < discTeorica->getNumTurmas(); turma2++ )
			{		
				GGroup<Aluno*> alunos = problemData->alunosEmComum( turma1, discPratica, turma2, discTeorica, campus );
				
				if ( alunos.size() == 0 )
				{
					continue;
				}

				c.reset();
				c.setType( Constraint::C_DISC_PRATICA_TEORICA );
				c.setCampus( campus );
				c.setDisciplina1( discPratica );
				c.setTurma1( turma1 );
				c.setDisciplina2( discTeorica );
				c.setTurma2( turma2 );

				sprintf( name, "%s", c.toString().c_str() );

				if ( cHash.find( c ) != cHash.end() )
				{
					continue;
				}
			
				nnz = 3;
				OPT_ROW row( nnz, OPT_ROW::LESS , 0.0 , name );

				// Variavel de folga fd_{dp,i1,cp}
				v.reset();
				v.setType( Variable::V_SLACK_DEMANDA_ALUNO );
				v.setDisciplina( discPratica );  // dp
				v.setTurma( turma1 );			 // i1
				v.setCampus( campus );			 // cp

				it_v = vHash.find( v );
				if( it_v != vHash.end() )
				{
					row.insert( it_v->second, 1.0 );
				}
			
				// Variavel de folga fd_{dt,i2,cp}
				v.reset();
				v.setType( Variable::V_SLACK_DEMANDA_ALUNO );
				v.setDisciplina( discTeorica );  // dt
				v.setTurma( turma2 );			 // i2
				v.setCampus( campus );			 // cp

				it_v = vHash.find( v );
				if( it_v != vHash.end() )
				{
					row.insert( it_v->second, 1.0 );
				}

				// Variavel de folga ffd_{i1,dp,i2,dt,cp}
				v.reset();
				v.setType( Variable::V_SLACK_SLACKDEMANDA_PT );
				v.setTurma1( turma1 );			 // i1
				v.setDisciplina1( discPratica );  // dp
				v.setTurma2( turma2 );			 // i2
				v.setDisciplina2( discTeorica );  // dt				
				v.setCampus( campus );			 // cp

				it_v = vHash.find( v );
				if( it_v != vHash.end() )
				{
					row.insert( it_v->second, -2.0 );
				}

				// Insere restrição no Hash ---
				if ( row.getnnz() != 0 )
				{
					cHash[ c ] = lp->getNumRows();

					lp->addRow( row );
					restricoes++;
				}
			}
        }
   }

	return restricoes;
}

int SolverMIP::cria_restricao_ativacao_var_ca( int campusId )
{
   int restricoes = 0;

   char name[ 100 ];   
   VariableHash::iterator it_v;
   Variable v;
   Constraint c;

   ITERA_GGROUP_LESSPTR( itAluno, problemData->alunos, Aluno )
   {
	   Aluno *aluno = *itAluno;

	   if ( aluno->getOferta()->getCampusId() != campusId )
	   {
			continue;
	   }

	   ITERA_GGROUP_N_PT( itDia, aluno->getOferta()->campus->diasLetivos, int )
	   {
		   int dia = *itDia;

			c.reset();
			c.setType( Constraint::C_ATIVA_CA );
			c.setAluno( aluno );
			c.setDia( dia );

			sprintf( name, "%s", c.toString().c_str() );
			if ( cHash.find( c ) != cHash.end() )
			{
				continue;
			}

			int nnz = aluno->getCombinaCredSLSize()[dia];
					
			OPT_ROW row( nnz, OPT_ROW::LESS , 1, name );

		    std::map< Trio< int/*dia*/, int /*k_id*/, Calendario* /*sl*/ >,
					  int/*nroCreds*/ >::iterator it_map = aluno->combinaCredSL.begin();

			for ( ; it_map != aluno->combinaCredSL.end(); it_map++ )
			{
				if ( it_map->first.first == dia )
				{
					Variable v;
					v.reset();
					v.setType( Variable::V_COMBINA_SL_ALUNO );
					v.setAluno( aluno );
					v.setDia( dia );
					v.setCombinaSLAluno( it_map->first.second );
					
					it_v = vHash.find( v );
					if( it_v != vHash.end() )
					{
						row.insert( it_v->second, 1.0 );
					}
				}
			}

			if ( row.getnnz() != 0 )
			{
				cHash[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
	    }
   }   

   return restricoes;
}


#pragma endregion TATICO POR BLOCO OU POR ALUNO SEM HORARIOS

#endif

/*
	-------------------------------------------------------------------------------
*/

void SolverMIP::cria_solucao_inicial( int cnt, int * indices, double * valores )
{
   VariableHash::iterator itVHash = vHash.begin();

   for (; itVHash != vHash.end(); itVHash++ )
   {
      if ( itVHash->first.getType() != Variable::V_SLACK_DEMANDA )
      {
         indices[ cnt ] = itVHash->second;
         valores[ cnt ] = 0;
         cnt++;
      }
      else
      {
         indices[ cnt ] = itVHash->second;
         valores[ cnt ] = -1;
         cnt++;
      }
   }
}

int SolverMIP::criaVariaveisOperacional()
{
   int numVars = 0;

#ifdef PRINT_cria_variaveis
   int numVarsAnterior = 0;
#endif

   numVars += criaVariavelProfessorAulaHorario(); 

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_X_PROF_AULA_HOR: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelProfessorDisciplina(); 

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_Y_PROF_DISCIPLINA: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelDisciplinaHorario(); 

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_Z_DISCIPLINA_HOR: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaFixProfDiscSalaDiaHor(); 

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_FIX_PROF_DISC_SALA_DIA_HOR: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaFixProfDiscDiaHor(); 

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_FIX_PROF_DISC_DIA_HOR: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaFixProfDisc(); 

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_FIX_PROF_DISC: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaFixProfDiscSala(); 

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_FIX_PROF_DISC_SALA: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaFixProfSala();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_FIX_PROF_SALA: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelProfessorCurso();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_PROF_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   /*
   lp->updateLP();
   numVars += criaVariavelAvaliacaoCorpoDocente();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_AVALIACAO_CORPO_DOCENTE: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif*/

   /*lp->updateLP();
   numVars += criaVariavelCustoCorpoDocente();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_CUSTO_CORPO_DOCENTE: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif*/

   lp->updateLP();
   numVars += criaVariavelDiasProfessoresMinistramAulas();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_DIAS_PROF_MINISTRA_AULAS: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   /* // deletar
   lp->updateLP();
//   numVars += criaVariavelFolgaMinimoMestresCurso(); // deletar

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_MIN_MEST_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
//  numVars += criaVariavelFolgaMinimoDoutoresCurso(); // deletar

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_MIN_DOUT_CURSO: "  
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif*/

   lp->updateLP();
   numVars += criaVariavelMaxDiscProfCurso();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_DISC_PROF_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaMaxDiscProfCurso();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_MAX_DISC_PROF_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaCargaHorariaMinimaProfessor();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_CARGA_HOR_MIN_PROF: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaCargaHorariaMinimaProfessorSemana();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_CARGA_HOR_MIN_PROF_SEMANA: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaCargaHorariaMaximaProfessorSemana();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_CARGA_HOR_MAX_PROF_SEMANA: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelProfessorDiaHorarioIF();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_HI_PROFESSORES e V_HF_PROFESSORES: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaUltimaPrimeiraAulas();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_F_ULTIMA_PRIMEIRA_AULA_PROF: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif

   lp->updateLP();
   numVars += criaVariavelFolgaDemanda();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_FOLGA_DEMANDA: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif   

   lp->updateLP();
   numVars += criaVariavelFolgaDisciplinaTurmaHorario();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_FOLGA_DISC_TURMA_HOR: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif
   
   lp->updateLP();
   numVars += criaVariavelNroProfsReaisAlocadosCurso();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_NRO_PROFS_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif   

   lp->updateLP();
   numVars += criaVariavelNroProfsVirtuaisAlocadosCurso();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_NRO_PROFS_VIRTUAIS_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif   

   lp->updateLP();
   numVars += criaVariavelNroProfsVirtuaisMestresAlocadosCurso();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_NRO_PROFS_VIRTUAIS_MEST_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif   


   lp->updateLP();
   numVars += criaVariavelNroProfsVirtuaisDoutoresAlocadosCurso();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_NRO_PROFS_VIRTUAIS_DOUT_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif   
   

   lp->updateLP();
   numVars += criaVariavelNroProfsVirtuaisGeraisAlocadosCurso();

#ifdef PRINT_cria_variaveis
   std::cout << "numVars V_NRO_PROFS_VIRTUAIS_GERAIS_CURSO: "
             << ( numVars - numVarsAnterior ) << std::endl;
   numVarsAnterior = numVars;
#endif   
   

   lp->updateLP(); 

   return numVars;
}

int SolverMIP::criaVariavelProfessorAulaHorario( void )
{
   int num_vars = 0;
   double coeff = 0.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( itProfessor, professores, Professor )
   {
      ITERA_GGROUP_LESSPTR( itMagisterio, itProfessor->magisterio, Magisterio )
      {
         Disciplina * discMinistradaProf = itMagisterio->disciplina;

         ITERA_GGROUP_LESSPTR( itAula, problemData->aulas, Aula )
         {
            Disciplina * discAula = itAula->getDisciplina();
			
            if ( discMinistradaProf != discAula )
            {
               continue;
            } 

            std::pair< int, int > prof_disc( itProfessor->getId(), discMinistradaProf->getId() );
						
            // Se o professor e a disciplina da aula em questão se relacionarem:
            if ( problemData->prof_Disc_Dias.find( prof_disc )
                  == problemData->prof_Disc_Dias.end() )
            {
               continue;
            }

            // Retorna lista de horarios possiveis para o professor, aula e sala
            std::list< HorarioDia * > listaHorarios;
			
            retornaHorariosPossiveis( *itProfessor, *itAula, listaHorarios );

            for ( std::list< HorarioDia * >::iterator itHor = listaHorarios.begin();
                  itHor != listaHorarios.end(); itHor++ )
            {
               HorarioDia * horarioDia = ( *itHor );

			   VariableOp v;
               v.reset();
               v.setType( VariableOp::V_X_PROF_AULA_HOR );

               Aula * aula = ( *itAula );

			   HorarioAula *hf = horarioDia->getHorarioAula();
			   for ( int i = 1; i < aula->getTotalCreditos(); i++ )
			   {
					hf = aula->getDisciplina()->getCalendario()->getProximoHorario( hf );				
			   }

               v.setAula( aula ); 
               v.setProfessor( *itProfessor );
               v.setHorario( horarioDia );
               v.setHorarioAula( horarioDia->getHorarioAula() );
               v.setDia( horarioDia->getDia() );
               v.setDisciplina( aula->getDisciplina() );
               v.setTurma( aula->getTurma() );
               v.setSala( aula->getSala() );
			   v.setUnidade( problemData->refUnidade[ aula->getSala()->getIdUnidade() ] );

               if ( vHashOp.find( v ) == vHashOp.end() )
               {
                    vHashOp[ v ] = lp->getNumCols();

					double lb = 0.0;

					OPT_COL col( OPT_COL::VAR_BINARY, coeff, lb, 1.0,
						( char * )v.toString().c_str() );

					lp->newCol( col );
					num_vars++;				  
               }
            }
         }
	  }
   }
   
   // Professores virtuais para as aulas
   ITERA_GGROUP_LESSPTR( itPV, problemData->profsVirtuais, Professor )
   {
	   Professor *pv = *itPV;   
	   
	   ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
	   {
		  Aula * aula = ( *it_aula );
		  Disciplina * discAula = aula->getDisciplina();

		  // Retorna lista de horarios possiveis para o professor, aula e sala
		  std::list< HorarioDia * > listaHorarios;

		  retornaHorariosPossiveis( NULL, aula, listaHorarios );

		  for ( std::list< HorarioDia * >::iterator itHor = listaHorarios.begin();
				itHor != listaHorarios.end(); itHor++ )
		  {
			 HorarioDia * horarioDia = ( *itHor );

			 VariableOp v;
			 v.reset();
			 v.setType( VariableOp::V_X_PROF_AULA_HOR );
			 v.setAula( aula ); 
			 v.setProfessor( pv );
			 v.setHorario( horarioDia );
			 v.setHorarioAula( horarioDia->getHorarioAula() );
			 v.setDia( horarioDia->getDia() );
			 v.setDisciplina( aula->getDisciplina() );
			 v.setTurma( aula->getTurma() );
			 v.setSala( aula->getSala() );
			 v.setUnidade( problemData->refUnidade[ aula->getSala()->getIdUnidade() ] );

			 double coeff = 750.0 * aula->getTotalCreditos();

			 if ( vHashOp.find( v ) == vHashOp.end() )
			 {
				vHashOp[ v ] = lp->getNumCols();

				OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
				   ( char * ) v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			 }
		  }
	   }
   }

   return num_vars;
}

int SolverMIP::criaVariavelProfessorDisciplina()
{
   int num_vars = 0;

   double coeff = 0.0;
   double pesoNota = 10;//100;
   double pesoPreferencia = 10;//100;

   if ( !problemData->parametros->considerar_preferencia_prof )
   {
		pesoPreferencia = 0;
   }
   if ( !problemData->parametros->considerar_desempenho_prof )
   {
		pesoNota = 0;
   }

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( itProfessor, professores, Professor )
   {
	  double custoCredito = (*itProfessor)->getValorCredito();

      ITERA_GGROUP_LESSPTR( itMagisterio, itProfessor->magisterio, Magisterio )
      {
         Disciplina * discMinistradaProf = itMagisterio->disciplina;

         int nota = itMagisterio->getNota();
         int preferencia = itMagisterio->getPreferencia();
		 
         ITERA_GGROUP_LESSPTR( itAula, problemData->aulas, Aula )
         {
			Aula *aula = *itAula;
            Disciplina * discAula = aula->getDisciplina();

            if ( discMinistradaProf != discAula )
            {
               continue;
            }

            std::pair< int, int > prof_disc ( itProfessor->getId(),
               discMinistradaProf->getId() );

            // Se o professor e a disciplina da aula em questão se relacionarem:
            if ( problemData->prof_Disc_Dias.find( prof_disc )
                  == problemData->prof_Disc_Dias.end() )
            {
               continue;
            }

            VariableOp v;
            v.reset();
            v.setType( VariableOp::V_Y_PROF_DISCIPLINA );

            v.setDisciplina( discAula ); 
            v.setProfessor( ( *itProfessor ) );
            v.setTurma( itAula->getTurma() );

            //------------------------------------------------------
            // Preferência:
            // 10  --> Maior preferência
            // 1 --> Menor preferência
            //------------------------------------------------------
            // Nota de desempenho:
            // 1  --> Menor desempenho
            // 10 --> Maior desempenho
            //------------------------------------------------------
            // Assim, o 'peso' da preferência e da nota
            // de desempenho na função objetivo variam
            // entre 0 e 9, sendo 0 o MELHOR CASO e 9 o PIOR CASO
            //------------------------------------------------------
            coeff = ( ( 10 - nota ) * ( pesoNota )
               + ( 10 - preferencia ) * ( pesoPreferencia )
			   + custoCredito * aula->getDisciplina()->getTotalCreditos() );

            if ( vHashOp.find( v ) == vHashOp.end() )
            {
               vHashOp[ v ] = lp->getNumCols();

               OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
                  ( char * ) v.toString().c_str() );

               lp->newCol( col );
               num_vars++;
            }
         }
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelDisciplinaHorario()
{
   int num_vars = 0;
   double coeff = 0.0;

   ITERA_GGROUP_LESSPTR( itAula, problemData->aulas, Aula )
   {
      Disciplina * discAula = itAula->getDisciplina();

      // Retorna lista de horarios possiveis para a aula e a sala
      std::list< HorarioDia * > listaHorarios;

      retornaHorariosPossiveis( NULL, *itAula, listaHorarios );

      std::list< HorarioDia * >::iterator
         itHor = listaHorarios.begin();

      for (; itHor != listaHorarios.end(); itHor++ )
      {
         HorarioDia * horarioDia = ( *itHor );

         VariableOp v;
         v.reset();
         v.setType( VariableOp::V_Z_DISCIPLINA_HOR );

         Aula * aula = ( *itAula );

		 Campus *campus = problemData->retornaCampus( aula->getSala()->getIdUnidade() );

         v.setHorarioAula( horarioDia->getHorarioAula() );
         v.setDisciplina( aula->getDisciplina() );
         v.setTurma( aula->getTurma() );
		 v.setCampus( campus );

         if ( vHashOp.find( v ) == vHashOp.end() )
         {
            vHashOp[ v ] = lp->getNumCols();

            OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
               ( char * ) v.toString().c_str() );

            lp->newCol( col );
            num_vars++;
         }
      }
   }

   return num_vars;
}

void SolverMIP::retornaHorariosPossiveis( Professor * prof,
   Aula * aula, std::list< HorarioDia * > & listaHor )
{  
	listaHor.clear();

    // Verifica-se a disponibilidade do
    // professor, da disciplina e da sala
    Disciplina * disc = aula->getDisciplina();
    Sala * sala = aula->getSala();

    int nCred = this->problemData->totalHorariosTurnoAula( aula );
    int diaS = aula->getDiaSemana();
    int nCredAula = aula->getTotalCreditos();

	Calendario *calendario = disc->getCalendario();	

	GGroup<HorarioAula*, LessPtr<HorarioAula>> horarios = calendario->retornaHorariosDisponiveisNoDia( diaS );	
	ITERA_GGROUP_LESSPTR( itHor, horarios, HorarioAula )
	{
        HorarioAula * horarioAula = *itHor;	 
		bool disponivel = problemData->verificaDisponibilidadeHorario( horarioAula, diaS, sala, prof, disc );

		if ( !disponivel )
		{
			continue;
		}
		bool available = true;

		HorarioAula *hf = horarioAula;
		int i = 1;
		for ( ; i < nCredAula; i++ )
		{
		 	hf = calendario->getProximoHorario( hf );
			disponivel = problemData->verificaDisponibilidadeHorario( hf, diaS, sala, prof, disc );	

			if ( !disponivel )
			{
				break;
				available = false;
			}
		}	 

        if ( i == nCredAula && available )
        {
			HorarioDia *horarioDia = problemData->getHorarioDiaCorrespondente( horarioAula, diaS );		
			listaHor.push_back( horarioDia );
        }
	}

}

int SolverMIP::criaVariavelFolgaFixProfDiscSalaDiaHor()
{
   int num_vars = 0;
   double coeff = 1000.0;

   ITERA_GGROUP_LESSPTR( itFix,
      problemData->fixacoes_Prof_Disc_Sala_Dia_Horario, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      VariableOp v;
      v.reset();
      v.setType( VariableOp::V_F_FIX_PROF_DISC_SALA_DIA_HOR );
      v.setDisciplina( fixacao->disciplina );
      v.setProfessor( fixacao->professor );
      v.setSala( fixacao->sala );

      HorarioDia * auxHD = new HorarioDia();
      auxHD->setDia( fixacao->getDiaSemana() );
      auxHD->setHorarioAula( fixacao->horario_aula );
      auxHD->setHorarioAulaId( fixacao->getHorarioAulaId() );

      GGroup< HorarioDia *, LessPtr< HorarioDia > >::iterator
         itH = problemData->horariosDia.find( auxHD );
      delete auxHD;

      if ( itH == problemData->horariosDia.end() )
      {
         printf( "ERRO: HORARIO NAO ENCONTRADO NA FIXACAO\n" );
         continue;
      }

      v.setHorario( *itH );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         vHashOp[v] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelFolgaFixProfDiscDiaHor()
{
   int num_vars = 0;
   double coeff = 1000.0;

   ITERA_GGROUP_LESSPTR( itFix,
      problemData->fixacoes_Prof_Disc_Dia_Horario, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      VariableOp v;
      v.reset();
      v.setType( VariableOp::V_F_FIX_PROF_DISC_DIA_HOR );
      v.setDisciplina( fixacao->disciplina );
      v.setProfessor( fixacao->professor );

      HorarioDia * auxHD = new HorarioDia();
      auxHD->setDia( fixacao->getDiaSemana() );
      auxHD->setHorarioAula( fixacao->horario_aula );
      auxHD->setHorarioAulaId( fixacao->getHorarioAulaId() );

      GGroup< HorarioDia *, LessPtr< HorarioDia > >::iterator
         itH = problemData->horariosDia.find( auxHD );
      delete auxHD;

      if ( itH == problemData->horariosDia.end() )
      {
         printf( "ERRO em SolverMIP::criaVariavelFolgaFixProfDiscDiaHor(): HORARIO NAO ENCONTRADO NA FIXACAO\n" );
         continue;
      }

      v.setHorario( *itH );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         vHashOp[ v ] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}
   
int SolverMIP::criaVariavelFolgaFixProfDisc()
{
   int num_vars = 0;
   double coeff = 1000.0;

   ITERA_GGROUP_LESSPTR( itFix,
      problemData->fixacoes_Prof_Disc, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      VariableOp v;
      v.reset();
      v.setType( VariableOp::V_F_FIX_PROF_DISC );
      v.setDisciplina( fixacao->disciplina );
      v.setProfessor( fixacao->professor );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         vHashOp[v] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelFolgaFixProfDiscSala()
{
   int num_vars = 0;
   double coeff = 1000.0;

   ITERA_GGROUP_LESSPTR( itFix,
      problemData->fixacoes_Prof_Disc_Sala, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      VariableOp v;
      v.reset();
      v.setType( VariableOp::V_F_FIX_PROF_DISC_SALA );
      v.setDisciplina( fixacao->disciplina );
      v.setProfessor( fixacao->professor );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         vHashOp[v] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
            ( char * ) v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}
   
int SolverMIP::criaVariavelFolgaFixProfSala()
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( itFix,
      problemData->fixacoes_Prof_Sala, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      VariableOp v;
      v.reset();
      v.setType( VariableOp::V_F_FIX_PROF_SALA );
      v.setSala(fixacao->sala);
      v.setProfessor(fixacao->professor);

      double coeff = 100000.0;

      if ( vHashOp.find(v) == vHashOp.end() )
      {
         vHashOp[v] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_INTEGRAL, coeff, 0.0, OPT_INF,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelProfessorCurso()
{
   int num_vars = 0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( itProfessor, professores, Professor )
   {
      ITERA_GGROUP_LESSPTR( itMagisterio, itProfessor->magisterio, Magisterio )
      {
         Disciplina * discMinistradaProf = itMagisterio->disciplina;

         ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
         {
            Aula * aula = ( *it_aula );

            Disciplina * discAula = aula->getDisciplina();

            if ( discMinistradaProf != discAula )
            {
               continue;
            }

            std::pair< int, int > professor_disciplina (
               itProfessor->getId(), discMinistradaProf->getId() );

            // Se o professor e a disciplina da aula em questão se relacionarem:
            if ( problemData->prof_Disc_Dias.find( professor_disciplina )
                  == problemData->prof_Disc_Dias.end() )
            {
               continue;
            }

            // Como o professor em questão está alocado nessa aula, então dizemos que
            // ele leciona disciplinas de cada curso que essa aula está relacionada.
            // Para encontrar os cursos que a aula atende, basta verificar suas ofertas
            ITERA_GGROUP_LESSPTR( itOferta, aula->ofertas, Oferta )
            {
               Oferta * oferta = ( *itOferta );
               Curso * curso = oferta->curso;

               // Cria a variavel 'professor/curso' w_{p,c}
               VariableOp v;
               v.reset();
               v.setType( VariableOp::V_PROF_CURSO );

               v.setProfessor( *itProfessor ); 
               v.setCurso( curso );

               double coeff = 0.0;

               if ( vHashOp.find( v ) == vHashOp.end() )
               {
                  v.setValue( 1.0 );

                  vHashOp[ v ] = lp->getNumCols();

                  OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
                     ( char * )v.toString().c_str() );

                  lp->newCol( col );
                  num_vars++;
               }
            }
         }
      }
   }

   // Pode deletar esse trecho se w realmente não for mais util para profs virtuais 
   /*
   ITERA_GGROUP_LESSPTR( itPV, problemData->profsVirtuais, Professor )
   {
	   ITERA_GGROUP_LESSPTR( itCursos, problemData->cursos, Curso )
       {
            // Cria a variavel 'professor/curso' w_{p,c}
            VariableOp v;
            v.reset();
            v.setType( VariableOp::V_PROF_CURSO );

            v.setProfessor( *itPV ); 
            v.setCurso( *itCursos );

            double coeff = 0.0;

            if ( vHashOp.find( v ) == vHashOp.end() )
            {
                v.setValue( 1.0 );

                vHashOp[ v ] = lp->getNumCols();

                OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
                    ( char * )v.toString().c_str() );

                lp->newCol( col );
                num_vars++;
            }
       }
   }
   */
   return num_vars;
}

int SolverMIP::criaVariavelCustoCorpoDocente()
{
   int num_vars = 0;
   double coeff = 0.0;
   double alfa = 250.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      VariableOp v;
      v.reset();
      v.setType( VariableOp::V_CUSTO_CORPO_DOCENTE );
      v.setProfessor( professor );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         v.setValue( 1.0 );
         coeff = ( professor->getValorCredito() * alfa );

         vHashOp[ v ] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelDiasProfessoresMinistramAulas()
{
   int num_vars = 0;

   if ( problemData->parametros->carga_horaria_semanal_prof == ParametrosPlanejamento::CHS::INDIFERENTE )
   {
	   return num_vars;
   }
   
   double coeff = 0.0;
   if ( problemData->parametros->carga_horaria_semanal_prof == ParametrosPlanejamento::CHS::EQUILIBRAR )
   {
	   coeff = -10.0;
   }
   else if ( problemData->parametros->carga_horaria_semanal_prof == ParametrosPlanejamento::CHS::MINIMIZAR_DIAS )
   {
	   coeff = 10.0;
   }

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   // Dias em que cada professor pode dar aula
   std::map< Professor *, GGroup< int > > mapProfessorDias;

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_LESSPTR( it_horario_dia, professor->horariosDia, HorarioDia )
      {
         mapProfessorDias[ professor ].add( it_horario_dia->getDia() );
      }
   }

   // Criando as variáveis apenas para os dias possíveis de cada professor
   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );
      GGroup< int > dias_professor = mapProfessorDias[ professor ];

      ITERA_GGROUP_N_PT( it_dia, dias_professor, int )
      {
         VariableOp v;
         v.reset();

         v.setType( VariableOp::V_DIAS_PROF_MINISTRA_AULAS );
         v.setProfessor( *it_prof );
         v.setDia( *it_dia );

         if ( vHashOp.find( v ) == vHashOp.end() )
         {
            vHashOp[ v ] = lp->getNumCols();

            OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
               ( char * )v.toString().c_str() );

            lp->newCol( col );
            num_vars++;
         }
      }
   }

   return num_vars;
}

// NÃO ESTÁ SENDO MAIS USADA, A DELETAR
int SolverMIP::criaVariavelFolgaMinimoMestresCurso()
{
   int num_vars = 0;

   if ( !problemData->parametros->min_mestres )
   {
		return num_vars;
   }

   double coeff = 20000.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   int ub = professores.size();

   ITERA_GGROUP_LESSPTR( it_curso, problemData->cursos, Curso )
   {
      VariableOp v;
      v.reset();

      v.setType( VariableOp::V_F_MIN_MEST_CURSO );
      v.setCurso( *it_curso );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         v.setValue( 1.0 );

         vHashOp[ v ] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_INTEGRAL, coeff, 0.0, ub,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

// NÃO ESTÁ SENDO MAIS USADA, A DELETAR
int SolverMIP::criaVariavelFolgaMinimoDoutoresCurso()
{
   int num_vars = 0;

   if ( !problemData->parametros->min_doutores )
   {
		return num_vars;
   }

   double coeff = 20000.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   int ub = professores.size();

   ITERA_GGROUP_LESSPTR( it_curso, problemData->cursos, Curso )
   {
      VariableOp v;
      v.reset();

      v.setType( VariableOp::V_F_MIN_DOUT_CURSO );
      v.setCurso( *it_curso );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         v.setValue( 1.0 );

         vHashOp[ v ] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_INTEGRAL, coeff, 0.0, ub,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelMaxDiscProfCurso()
{
   int num_vars = 0;
   double coeff = 0.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      GGroup< Disciplina *, LessPtr< Disciplina > > disciplinasProf
         = problemData->mapProfessorDisciplinasAssociadas[ professor ];

      ITERA_GGROUP_LESSPTR( it_disc, disciplinasProf, Disciplina )
      {
         Disciplina * disciplina = ( *it_disc );

         ITERA_GGROUP_LESSPTR( it_curso, problemData->cursos, Curso )
         {
            Curso * curso = ( *it_curso );

			if ( !curso->possuiDisciplina( disciplina ) )
				continue;

            VariableOp v;
            v.reset();
            v.setType( VariableOp::V_DISC_PROF_CURSO );

            v.setProfessor( professor );
            v.setDisciplina( disciplina );
            v.setCurso( curso );

            if ( vHashOp.find( v ) == vHashOp.end() )
            {
               v.setValue( coeff );

               vHashOp[ v ] = lp->getNumCols();

               OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
                  ( char * )v.toString().c_str() );

               lp->newCol( col );
               num_vars++;
            }
         }
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelFolgaMaxDiscProfCurso()
{
   int num_vars = 0;
   double coeff = 10.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      GGroup< Disciplina *, LessPtr< Disciplina > > disciplinasProf
         = problemData->mapProfessorDisciplinasAssociadas[ professor ];

      ITERA_GGROUP_LESSPTR( it_disc, disciplinasProf, Disciplina )
      {
         Disciplina * disciplina = ( *it_disc );

         ITERA_GGROUP_LESSPTR( it_curso, problemData->cursos, Curso )
         {
            Curso * curso = ( *it_curso );

			if ( !curso->possuiDisciplina( disciplina ) )
				continue;

            VariableOp v;
            v.reset();
            v.setType( VariableOp::V_F_MAX_DISC_PROF_CURSO );
            v.setProfessor( professor );
            v.setCurso( curso );

            if ( vHashOp.find( v ) == vHashOp.end() )
            {
               v.setValue( coeff );

               vHashOp[ v ] = lp->getNumCols();

			   OPT_COL col( OPT_COL::VAR_INTEGRAL, coeff, 0.0, OPT_INF,
                  ( char * )v.toString().c_str() );

               lp->newCol( col );
               num_vars++;
			   break;
            }
         }
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelFolgaCargaHorariaMinimaProfessor()
{
   int num_vars = 0;
   double coeff = 10.0;
   int ub = 168; // Total de horas da semana

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      VariableOp v;
      v.reset();

      v.setType( VariableOp::V_F_CARGA_HOR_MIN_PROF );
      v.setProfessor( *it_prof );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         v.setValue( 1.0 );
         vHashOp[ v ] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_INTEGRAL, coeff, 0.0, ub,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelFolgaCargaHorariaMinimaProfessorSemana()
{
   int num_vars = 0;
   double coeff = 10.0;
   int ub = 168; // Total de horas da semana

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      VariableOp v;
      v.reset();

      v.setType( VariableOp::V_F_CARGA_HOR_MIN_PROF_SEMANA );
      v.setProfessor( *it_prof );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         v.setValue( 1.0 );
         vHashOp[ v ] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_INTEGRAL, coeff, 0.0, ub,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelFolgaCargaHorariaMaximaProfessorSemana()
{
   int num_vars = 0;
   double coeff = 1000.0;
   int ub = 168; // Total de horas da semana

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      VariableOp v;
      v.reset();

      v.setType( VariableOp::V_F_CARGA_HOR_MAX_PROF_SEMANA );
      v.setProfessor( *it_prof );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         v.setValue( 1.0 );
         vHashOp[ v ] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_INTEGRAL, coeff, 0.0, ub,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelAvaliacaoCorpoDocente()
{
   int num_vars = 0;
   double coeff = 0.0;
   double alfa = 1.0;//500.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      VariableOp v;
      v.reset();
      v.setType( VariableOp::V_AVALIACAO_CORPO_DOCENTE );
      v.setProfessor( professor );

      if ( vHashOp.find( v ) == vHashOp.end() )
      {
         v.setValue( 1.0 );

         double avaliacao = 0.0;
         double total_notas = 0.0;

         ITERA_GGROUP_LESSPTR( it_mag, professor->magisterio, Magisterio )
         {
            avaliacao += it_mag->getNota();
            total_notas += 10.0;
         }

         coeff = ( ( total_notas - avaliacao ) * alfa );

         vHashOp[ v ] = lp->getNumCols();

         OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
            ( char * )v.toString().c_str() );

         lp->newCol( col );
         num_vars++;
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelGapsProfessores()
{
   int num_vars = 0;
   double coeff = 0.0;
   
   if ( !problemData->parametros->minimizar_horarios_vazios_professor )
   {
		return num_vars;
   }

   // Custo da variável do gap, que deve 
   // multiplicado pelo número de horários
   // de aula o gap de horários
   double alfa = 10.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   GGroup< int > dias_letivos;
   for ( int i = 2; i <= 7; i++ )
   {
      dias_letivos.add( i );
   }

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_N_PT( it_dia, dias_letivos, int )
      {
         int dia = ( *it_dia );

         for ( int ini = 0; ini < (int)problemData->horarios_aula_ordenados.size(); ini++ )
         {
            for ( int fim = ini + 1; fim < (int)problemData->horarios_aula_ordenados.size(); fim++ )
            {
               HorarioAula * h1 = problemData->horarios_aula_ordenados[ ini ];
               HorarioAula * h2 = problemData->horarios_aula_ordenados[ fim ];

               if ( abs( fim - ini ) <= 1 )
               {
                  continue;
               }

               if ( h1->getCalendario() != h2->getCalendario() )
               {
                  continue;
               }

               VariableOp v;
               v.reset();
               v.setType( VariableOp::V_GAPS_PROFESSORES );

               v.setProfessor( professor );
               v.setDia( dia );
               v.setH1( h1 );
               v.setH2( h2 );

               if ( vHashOp.find( v ) == vHashOp.end() )
               {
                  // Leva em consideração o número de horários no gap
                  coeff = ( fim - ini ) * alfa;

                  vHashOp[ v ] = lp->getNumCols();

                  OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
                     ( char * )v.toString().c_str() );

                  lp->newCol( col );
                  num_vars++;
               }
            }
         }
      }
   }

   return num_vars;
}

int SolverMIP::criaVariavelFolgaUltimaPrimeiraAulas()
{
   int num_vars = 0;

   if ( ! problemData->parametros->evitar_prof_ultimo_primeiro_hr )
   {
		return num_vars;
   }

   double coeff = 100.0;
   double alfa = 100.0;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_LESSPTR( it_h1,
         professor->horariosDia, HorarioDia )
      {
            HorarioDia * h1 = ( *it_h1 );
         
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_F_ULTIMA_PRIMEIRA_AULA_PROF );

			v.setProfessor( professor );
			v.setDia( h1->getDia() );

			if ( vHashOp.find( v ) == vHashOp.end() )
			{
				vHashOp[ v ] = lp->getNumCols();

				OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
					( char * ) v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			}         
       }
   }

   return num_vars;
}


int SolverMIP::criaVariavelFolgaDemanda( void )
{
   int num_vars = 0;

   ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
   {
		Aula * aula = ( *it_aula );

		VariableOp v;
		v.reset();
		v.setType( VariableOp::V_FOLGA_DEMANDA );
		v.setAula( aula );
		
		if ( vHashOp.find( v ) == vHashOp.end() )
		{
			double coeff = 0.0;

			int campusId = problemData->retornaCampus( v.getAula()->getSala()->getIdUnidade() )->getId();
			int turma = v.getAula()->getTurma();
			Disciplina* disc = v.getAula()->getDisciplina();

			std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator itMapAtend;

			Trio< int, int, Disciplina* > trio;
			trio.set( campusId, turma, disc );

			itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
			if ( itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
			{
				GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = (*itMapAtend).second;
				coeff = alunosDemanda.size()*100000.0;
			}

			vHashOp[ v ] = lp->getNumCols();

			OPT_COL col( OPT_COL::VAR_BINARY, coeff, 0.0, 1.0,
				( char * ) v.toString().c_str() );

			lp->newCol( col );
			num_vars++;
		}
   }

   return num_vars;

}

int SolverMIP::criaVariavelFolgaDisciplinaTurmaHorario( void )
{
	int num_vars = 0;
	
   ITERA_GGROUP_LESSPTR( itAula, problemData->aulas, Aula )
   {      
	    Disciplina * disciplina = (*itAula)->getDisciplina();
		int turma = (*itAula)->getTurma();
		Campus* campus = problemData->retornaCampus( (*itAula)->getSala()->getIdUnidade() );

		VariableOp v;
		v.reset();
		v.setType( VariableOp::V_FOLGA_DISCIPLINA_HOR );
		v.setDisciplina( disciplina );
		v.setTurma( turma );
		v.setCampus( campus );

		if ( vHashOp.find( v ) == vHashOp.end() )
		{
			double coeff = 1000.0;

			vHashOp[ v ] = lp->getNumCols();

			int nHor = disciplina->horarios.size();

			if ( nHor <= 0 )
			{
				std::cout << "\nAtencao na funcao SolverMIP::criaVariavelFolgaDisciplinaTurmaHorario:"
				<< " nao ha horarios disponiveis para a disciplina "<<disciplina->getId();
			}

			OPT_COL col( OPT_COL::VAR_INTEGRAL, coeff, 0.0, nHor,
						( char* ) v.toString().c_str() );

			lp->newCol( col );
			num_vars++;
		}			
	}

	return num_vars;
}


int SolverMIP::criaVariavelProfessorDiaHorarioIF()
{
   int num_vars = 0;

   if ( !problemData->parametros->minimizar_horarios_vazios_professor )
   {
	   return num_vars;
   }

   double coeff = 0.0;
   double peso = 10;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( itProfessor, professores, Professor )
   {
	   GGroup<int> dias;
	   ITERA_GGROUP_LESSPTR( itHor, itProfessor->horariosDia, HorarioDia )
	   {
		    dias.add( itHor->getDia() );
	   }

	   ITERA_GGROUP_N_PT( itDia, dias, int )
	   {
		    int dia = *itDia;

			HorarioAula *h = itProfessor->getPrimeiroHorarioDisponivelDia( dia );
			double lb = h->getInicio().getDateMinutes();
			h = itProfessor->getUltimoHorarioDisponivelDia( dia );						
			double ub = h->getInicio().getDateMinutes();
			
            VariableOp v;
            v.reset();
            v.setProfessor( *itProfessor );
            v.setDia( dia );
			
			v.setType( VariableOp::V_HI_PROFESSORES );			
						
			if ( problemData->parametros->funcao_objetivo == 0 ) // max
			{
				coeff = 1.0;
			}
			else if ( problemData->parametros->funcao_objetivo == 1 ) // min
			{
				coeff = -1.0;
			}              

            if ( vHashOp.find( v ) == vHashOp.end() )
            {
               vHashOp[ v ] = lp->getNumCols();
			   
               OPT_COL col( OPT_COL::VAR_INTEGRAL, peso*coeff, lb, ub,
                  ( char * ) v.toString().c_str() );

               lp->newCol( col );
               num_vars++;
            }

            v.setType( VariableOp::V_HF_PROFESSORES );
			
			if ( problemData->parametros->funcao_objetivo == 0 ) // max
			{
				coeff = -1.0;
			}
			else if ( problemData->parametros->funcao_objetivo == 1 ) // min
			{
				coeff = 1.0;
			}     

            if ( vHashOp.find( v ) == vHashOp.end() )
            {
               vHashOp[ v ] = lp->getNumCols();

               OPT_COL col( OPT_COL::VAR_INTEGRAL, peso*coeff, lb, ub,
                  ( char * ) v.toString().c_str() );

               lp->newCol( col );
               num_vars++;
            }
	   }
   }

   return num_vars;
}


int SolverMIP::criaVariavelNroProfsReaisAlocadosCurso()
{
   int num_vars = 0;
      
   if ( ! problemData->parametros->min_mestres &&
	    ! problemData->parametros->min_doutores )
   {
		return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
   {
        Curso *curso = ( *itCurso );
		
		// Se o curso tem aula associada
		bool DEMANDA = false;
		ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
		{
			Aula * aula = ( *it_aula );			
			ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
			{
				if ( it_oferta->getCursoId() == curso->getId() )
				{
					DEMANDA = true;
					break;
				}
			}
		}
		if ( DEMANDA )
		{
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_CURSO );		
			v.setCurso( curso );

			if ( vHashOp.find( v ) == vHashOp.end() )
			{
				vHashOp[ v ] = lp->getNumCols();
			   
				int ub = 100;

				OPT_COL col( OPT_COL::VAR_INTEGRAL, 0.0, 0.0, ub,
					( char * ) v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			}
		} 
   }
   return num_vars;
}

int SolverMIP::criaVariavelNroProfsVirtuaisAlocadosCurso()
{
   int num_vars = 0;
      
   if ( ! problemData->parametros->min_mestres &&
	    ! problemData->parametros->min_doutores )
   {
		return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
   {
        Curso *curso = ( *itCurso );
		
		// Se o curso tem aula associada
		bool DEMANDA = false;
		ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
		{
			Aula * aula = ( *it_aula );			
			ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
			{
				if ( it_oferta->getCursoId() == curso->getId() )
				{
					DEMANDA = true;
					break;
				}
			}
		}
		if ( DEMANDA )
		{
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_CURSO );		
			v.setCurso( curso );

			if ( vHashOp.find( v ) == vHashOp.end() )
			{
				vHashOp[ v ] = lp->getNumCols();
			   
				int ub = 100;

				OPT_COL col( OPT_COL::VAR_INTEGRAL, 1.0, 0.0, ub,
					( char * ) v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			}
		} 
   }
   return num_vars;
}

int SolverMIP::criaVariavelNroProfsVirtuaisMestresAlocadosCurso()
{
   int num_vars = 0;
      
   if ( ! problemData->parametros->min_mestres )
   {
		return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
   {
        Curso *curso = ( *itCurso );
		
		// Se o curso tem aula associada
		bool DEMANDA = false;
		ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
		{
			Aula * aula = ( *it_aula );			
			ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
			{
				if ( it_oferta->getCursoId() == curso->getId() )
				{
					DEMANDA = true;
					break;
				}
			}
		}
		if ( DEMANDA )
		{
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_MEST_CURSO );		
			v.setCurso( curso );

			if ( vHashOp.find( v ) == vHashOp.end() )
			{
				vHashOp[ v ] = lp->getNumCols();
			   
				int ub = 100;
				double coef = 5000;

				OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, ub,
					( char * ) v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			}
		} 
   }
   return num_vars;
}

int SolverMIP::criaVariavelNroProfsVirtuaisDoutoresAlocadosCurso()
{
   int num_vars = 0;
      
   if ( ! problemData->parametros->min_doutores )
   {
		return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
   {
        Curso *curso = ( *itCurso );
		
		// Se o curso tem aula associada
		bool DEMANDA = false;
		ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
		{
			Aula * aula = ( *it_aula );			
			ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
			{
				if ( it_oferta->getCursoId() == curso->getId() )
				{
					DEMANDA = true;
					break;
				}
			}
		}
		if ( DEMANDA )
		{
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_DOUT_CURSO );		
			v.setCurso( curso );

			if ( vHashOp.find( v ) == vHashOp.end() )
			{
				vHashOp[ v ] = lp->getNumCols();
			   
				int ub = 100;
				double coef = 5000;

				OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, ub,
					( char * ) v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			}
		} 
   }
   return num_vars;
}

int SolverMIP::criaVariavelNroProfsVirtuaisGeraisAlocadosCurso()
{
   int num_vars = 0;
      
   if ( ! problemData->parametros->min_doutores &&
	    ! problemData->parametros->min_mestres )
   {
		return num_vars;
   }

   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
   {
        Curso *curso = ( *itCurso );
		
		// Se o curso tem aula associada
		bool DEMANDA = false;
		ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
		{
			Aula * aula = ( *it_aula );			
			ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
			{
				if ( it_oferta->getCursoId() == curso->getId() )
				{
					DEMANDA = true;
					break;
				}
			}
		}
		if ( DEMANDA )
		{
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_GERAIS_CURSO );		
			v.setCurso( curso );

			if ( vHashOp.find( v ) == vHashOp.end() )
			{
				vHashOp[ v ] = lp->getNumCols();
			   
				int ub = 100;
				double coef = 5000;

				OPT_COL col( OPT_COL::VAR_INTEGRAL, coef, 0.0, ub,
					( char * ) v.toString().c_str() );

				lp->newCol( col );
				num_vars++;
			}
		} 
   }
   return num_vars;
}

int SolverMIP::criaRestricoesOperacional()
{

	CPUTimer timer;
	double dif = 0.0;

	int restricoes = 0;

#ifdef PRINT_cria_restricoes
	int numRestAnterior = 0;
#endif

	if ( problemData->parametros->otimizarPor == "ALUNO" )
	{
		lp->updateLP();
		timer.start();
		restricoes += criaRestricaoAlunoHorario();
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest C_ALUNO_HORARIO: "
			<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
		numRestAnterior = restricoes;
		#endif	
	}
	else if ( problemData->parametros->otimizarPor == "BLOCOCURRICULAR" )
	{
		lp->updateLP();
		timer.start();
		restricoes += criaRestricaoBlocoHorario();
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest C_BLOCO_HORARIO: "
			<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
		numRestAnterior = restricoes;
		#endif

		lp->updateLP();
		timer.start();
		restricoes += criaRestricaoBlocoHorarioDisc();
		timer.stop();
		dif = timer.getCronoCurrSecs();

		#ifdef PRINT_cria_restricoes
		std::cout << "numRest C_BLOCO_HORARIO_DISC: "
			<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
		numRestAnterior = restricoes;
		#endif

	}

	timer.start();
	restricoes += criaRestricaoSalaHorario();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_SALA_HORARIO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoProfessorHorario();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_PROFESSOR_HORARIO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoAlocAula();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_ALOC_AULA: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoProfessorDisciplina();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_PROF_DISC: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoProfessorDisciplinaUnico();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_PROF_DISC_UNI: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoDisciplinaMesmoHorario();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_DISC_HORARIO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoDisciplinaHorarioUnico();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_DISC_HORARIO_UNICO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoFixProfDiscSalaDiaHor();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_FIX_PROF_DISC_SALA_DIA_HOR: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoFixProfDiscDiaHor();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_FIX_PROF_DISC_DIA_HOR: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoFixProfDisc();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_FIX_PROF_DISC: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoFixProfDiscSala();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_FIX_PROF_DISC_SALA: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoFixProfSala();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_FIX_PROF_SALA: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoDeslocamentoViavel();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_DESLOC_VIAVEL: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoDeslocamentoProfessor();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_DESLOC_PROF: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif
	
	/*
	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoAvaliacaoCorpoDocente();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_AVALIACAO_CORPO_DOCENTE: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif*/

	/*lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCustoCorpoDocente();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CUSTO_CORPO_DOCENTE: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif*/

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCalculaDiasProfMinistra_Min();
	restricoes += criaRestricaoCalculaDiasProfMinistra_Max();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_DIAS_PROF_MINISTRA_AULA: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoMinimoMestresCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_MIN_MEST_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoMinimoDoutoresCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_MIN_DOUT_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoUltimaPrimeiraAulas();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_ULTIMA_PRIMEIRA_AULA_PROF: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoAlocacaoProfessorCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_ALOC_PROF_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCargaHorariaMinimaProfessor();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CARGA_HOR_MIN_PROF: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoMaxDiscProfCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_MAX_DISC_PROF_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCargaHorariaMinimaProfessorSemana();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CARGA_HOR_MIN_PROF_SEMANA: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCargaHorariaMaximaProfessorSemana();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CARGA_HOR_MAX_PROF_SEMANA: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoGapsHorariosProfessores();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_GAPS_PROFESSORES_I, C_GAPS_PROFESSORES_F, C_GAPS_PROFESSORES_I_F: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif
	
	lp->updateLP();
	timer.start();
//	restricoes += criaRestricaoProfHorarioMultiUnid();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_PROF_HORARIO_MULTIUNID: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif

		
	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCalculaNroProfsAlocadosCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CALCULA_NRO_PROFS_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif
	

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCalculaNroProfsVirtuaisAlocadosCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CALCULA_NRO_PROFS_VIRTUAIS_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif


	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoMaximoNaoMestresCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_MAX_NAO_MEST_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif


	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoMaximoNaoDoutoresCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_MAX_NAO_DOUT_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif
	

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCalculaNroProfsVirtuaisMestresAlocadosCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CALCULA_NRO_PROFS_VIRTUAIS_MEST_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif


	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCalculaNroProfsVirtuaisDoutoresAlocadosCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CALCULA_NRO_PROFS_VIRTUAIS_DOUT_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif
	

	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoCalculaNroProfsVirtuaisGeraisAlocadosCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_CALCULA_NRO_PROFS_VIRTUAIS_GERAIS_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif


	lp->updateLP();
	timer.start();
	restricoes += criaRestricaoSomaNroProfsVirtuaisAlocadosCurso();
	timer.stop();
	dif = timer.getCronoCurrSecs();

#ifdef PRINT_cria_restricoes
	std::cout << "numRest C_SOMA_NRO_PROFS_VIRTUAIS_CURSO: "
		<< ( restricoes - numRestAnterior ) <<" " <<dif <<"seg" <<std::endl;
	numRestAnterior = restricoes;
#endif
			
	lp->updateLP();	

	return restricoes;
}

void SolverMIP::chgCoeffList(
   std::vector< std::pair< int, int > > cL,
   std::vector< double > cLV )
{
   lp->updateLP();

   int * rList = new int[ cL.size() ];
   int * cList = new int[ cL.size() ];
   double * vList = new double[ cLV.size() ];

   for ( int i = 0; i < (int) cL.size(); i++ )
   {
      rList[ i ] = cL[ i ].first;
      cList[ i ] = cL[ i ].second;
      vList[ i ] = cLV[ i ];
   }

   lp->chgCoefList( (int) cL.size(), rList, cList, vList );
   lp->updateLP();

   delete [] rList;
   delete [] cList;
   delete [] vList;
}

int SolverMIP::criaRestricaoSalaHorario()
{
   int restricoes = 0;
   char name[ 200 ];
   int nnz = ( this->problemData->aulas.size() * this->problemData->horarios_aula_ordenados.size() );

   GGroup< Sala *, LessPtr< Sala > > salas = this->problemData->getSalas();

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   vit = vHashOp.begin();

   while(vit != vHashOp.end())
   {
	   VariableOp vOp = ( vit->first );

	   if (vOp.getType() != VariableOp::V_X_PROF_AULA_HOR)
	   {
		   vit++;
		   continue;
	   }

	   Sala *sala = vOp.getSala();
	   ITERA_GGROUP_LESSPTRPTR( it_horario_dia,
		   sala->horariosDia, HorarioDia )
	   {
		   HorarioDia * horario_dia = ( *it_horario_dia );

		   int dia_semana = horario_dia->getDia();

		   if(vOp.getDia() != dia_semana)
			   continue;

		   HorarioAula * horario_aula = horario_dia->getHorarioAula();

		   DateTime inicio = horario_aula->getInicio();
		   DateTime fim = horario_aula->getFinal();

		   int nCred2 = vOp.getAula()->getTotalCreditos();
		   int duracao = vOp.getDisciplina()->getTempoCredSemanaLetiva();			
		   DateTime dt2Inicio = vOp.getHorarioAula()->getInicio();
		   HorarioAula *horarioAulaFim = vOp.getHorarioAula();
		   for (int k = 1; k < nCred2; k++)
           {
			   horarioAulaFim = horarioAulaFim->getCalendario()->getProximoHorario(horarioAulaFim);
		   }
		   DateTime dt2Fim = horarioAulaFim->getFinal();

		   if (  ( vOp.getHorarioAula() != horario_aula ) &&				    
			   !( ( dt2Inicio <= inicio ) && ( dt2Fim > inicio ) ) )
		   {
			   continue;
		   }

		   c.reset();
		   c.setType( ConstraintOp::C_SALA_HORARIO );
		   c.setSala( sala );
		   c.setHorario( horario_dia );
		   c.setHorarioAula( horario_aula );
		   c.setDia( dia_semana );

		   cit = cHashOp.find(c);
		   if ( cit == cHashOp.end() )
		   {
			   cHashOp[ c ] = lp->getNumRows();

			   sprintf( name, "%s", c.toString().c_str() );
			   OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
			   row.insert( vit->second, 1.0 );
			   lp->addRow( row );
			   restricoes++;
		   }
		   else
		   {
			   lp->chgCoef(cit->second, vit->second, 1.0);
		   }
	   }
	   vit++;
   }

   return restricoes;
}

//int SolverMIP::criaRestricaoSalaHorario()
//{
//   int restricoes = 0;
//   char name[ 200 ];
//   int nnz = ( this->problemData->aulas.size() * this->problemData->horarios_aula_ordenados.size() );
//
//   GGroup< Sala *, LessPtr< Sala > > salas = this->problemData->getSalas();
//
//   ConstraintOp c;
//   VariableOpHash::iterator vit;
//   ConstraintOpHash::iterator cit;
//
//   ITERA_GGROUP_LESSPTR( it_sala, salas, Sala )
//   {
//      Sala * sala = ( *it_sala );
//
//      ITERA_GGROUP_LESSPTRPTR( it_horario_dia,
//         sala->horariosDia, HorarioDia )
//      {
//         HorarioDia * horario_dia = ( *it_horario_dia );
//
//         int dia_semana = horario_dia->getDia();
//         HorarioAula * horario_aula = horario_dia->getHorarioAula();
//	     int idxHor1 = problemData->getHorarioDiaIdx( horario_dia );
//
//         c.reset();
//         c.setType( ConstraintOp::C_SALA_HORARIO );
//         c.setSala( sala );
//         c.setHorario( horario_dia );
//         c.setHorarioAula( horario_aula );
//         c.setDia( dia_semana );
//
//         cit = cHashOp.find( c );
//
//         if ( cit == cHashOp.end() )
//         {
//            cHashOp[ c ] = lp->getNumRows();
//
//            sprintf( name, "%s", c.toString().c_str() );
//            OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
//
//            bool adicionouVariavel = false;
//            vit = vHashOp.begin();
//
//            for (; vit != vHashOp.end(); vit++ )
//            {
//               VariableOp vOp = ( vit->first );
//
//               if (  vOp.getType() != VariableOp::V_X_PROF_AULA_HOR
//                  || vOp.getSala() != sala 
//                  || vOp.getDia() != dia_semana
//				  || sala->disciplinasAssociadas.find( vOp.getDisciplina() ) ==  sala->disciplinasAssociadas.end() )
//               {
//                  continue;
//               }
//
//			   int nCred2 = vOp.getAula()->getTotalCreditos();
//			   int duracao = vOp.getDisciplina()->getTempoCredSemanaLetiva();
//
//			   DateTime inicio = horario_aula->getInicio();
//			   DateTime dt2Inicio = vOp.getHorarioAula()->getInicio();
//			   DateTime fim = horario_aula->getFinal();
//			   DateTime dt2Fim = vOp.getHorarioAula()->getInicio();
//			   dt2Fim.addMinutes( duracao*nCred2 );
//
//			   if (  ( vOp.getHorarioAula() != horario_aula ) &&				    
//				    !( ( dt2Inicio <= inicio ) && ( dt2Fim > inicio ) ) &&
//					!( ( dt2Inicio >= inicio ) && ( dt2Inicio < fim ) ) )
//			   {
//				   continue;
//			   }
//
//               row.insert( vit->second, 1.0 );
//               adicionouVariavel = true;
//            }
//
//            if ( adicionouVariavel )
//            {
//               lp->addRow( row );
//               restricoes++;
//            }
//         }
//      }
//   }
//
//   return restricoes;
//}


int SolverMIP::criaRestricaoProfessorHorario()
{
   int restricoes = 0;
   char name[ 200 ];
   int nnz = ( this->problemData->aulas.size() * this->problemData->horarios_aula_ordenados.size() );
   
   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   vit = vHashOp.begin();

   while(vit != vHashOp.end())
   {
	   VariableOp vOp = ( vit->first );

	   if (vOp.getType() != VariableOp::V_X_PROF_AULA_HOR || vOp.getProfessor()->eVirtual() )
	   {
		   vit++;
		   continue;
	   }

	   Professor *prof = vOp.getProfessor();
	   ITERA_GGROUP_LESSPTR( it_horario_dia, prof->horariosDia, HorarioDia )
      {
		   HorarioDia * horario_dia = ( *it_horario_dia );

		   int dia = horario_dia->getDia();

		   if(vOp.getDia() != dia)
			   continue;

		   HorarioAula * horario_aula = horario_dia->getHorarioAula();

		   int nCred2 = vOp.getAula()->getTotalCreditos();
		   int duracao = vOp.getDisciplina()->getTempoCredSemanaLetiva();

		   DateTime inicio = horario_aula->getInicio();
		   DateTime dt2Inicio = vOp.getHorarioAula()->getInicio();
		   DateTime fim = horario_aula->getFinal();
		   DateTime dt2Fim = vOp.getHorarioAula()->getInicio();
		   dt2Fim.addMinutes( duracao*nCred2 );

		   if (  ( vOp.getHorarioAula() != horario_aula ) &&				    
			   !( ( dt2Inicio <= inicio ) && ( dt2Fim > inicio ) ) &&
			   !( ( dt2Inicio >= inicio ) && ( dt2Inicio < fim ) ) )
		   {
			   continue;
		   }

		   c.reset();
		   c.setType( ConstraintOp::C_PROFESSOR_HORARIO );
		   c.setHorarioAula( horario_aula );
		   c.setDia( dia );
		   c.setProfessor( prof );

		   cit = cHashOp.find(c);
		   if ( cit == cHashOp.end() )
		   {
			   cHashOp[ c ] = lp->getNumRows();

			   sprintf( name, "%s", c.toString().c_str() );
			   OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
			   row.insert( vit->second, 1.0 );
			   lp->addRow( row );
			   restricoes++;
		   }
		   else
		   {
			   lp->chgCoef(cit->second, vit->second, 1.0);
		   }
	   }
	   vit++;
   }

   return restricoes;
}


//int SolverMIP::criaRestricaoProfessorHorario()
//{
//   int restricoes = 0;
//   char name[ 200 ];
//   int nnz = ( this->problemData->aulas.size() * this->problemData->horarios_aula_ordenados.size() );
//   
//   ConstraintOp c;
//   VariableOpHash::iterator vit;
//   ConstraintOpHash::iterator cit;
//
//   GGroup< Professor *, LessPtr< Professor > > professores
//      = problemData->getProfessores();
//
//   ITERA_GGROUP_LESSPTR( itProfessor, professores, Professor )
//   {
//	   Professor *prof = *itProfessor;
//
//      ITERA_GGROUP_LESSPTR( it_horario_dia, itProfessor->horariosDia, HorarioDia )
//      {
//		  HorarioDia * horario_dia = ( *it_horario_dia );
//		  int dia = horario_dia->getDia();
//
//		  HorarioAula * horario_aula = horario_dia->getHorarioAula();
//
//		  c.reset();
//		  c.setType( ConstraintOp::C_PROFESSOR_HORARIO );
//		  c.setHorarioAula( horario_aula );
//		  c.setDia( dia );
//		  c.setProfessor( prof );
//
//          cit = cHashOp.find( c );
//
//          if ( cit == cHashOp.end() )
//          {
//            cHashOp[ c ] = lp->getNumRows();
//
//            sprintf( name, "%s", c.toString().c_str() );
//            OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
//
//            bool adicionouVariavel = false;
//            vit = vHashOp.begin();
//
//            for (; vit != vHashOp.end(); vit++ )
//            {
//               VariableOp vOp = ( vit->first );
//
//               if ( vOp.getType() != VariableOp::V_X_PROF_AULA_HOR
//                  || vOp.getDia() != dia
//				  || vOp.getProfessor() != prof )
//               {
//                  continue;
//               }
//
//			   int nCred2 = vOp.getAula()->getTotalCreditos();
//			   int duracao = vOp.getDisciplina()->getTempoCredSemanaLetiva();
//
//			   DateTime inicio = horario_aula->getInicio();
//			   DateTime dt2Inicio = vOp.getHorarioAula()->getInicio();
//			   DateTime fim = horario_aula->getFinal();
//			   DateTime dt2Fim = vOp.getHorarioAula()->getInicio();
//			   dt2Fim.addMinutes( duracao*nCred2 );
//
//			   if (  ( vOp.getHorarioAula() != horario_aula ) &&				    
//				    !( ( dt2Inicio <= inicio ) && ( dt2Fim > inicio ) ) &&
//					!( ( dt2Inicio >= inicio ) && ( dt2Inicio < fim ) ) )
//			   {
//				   continue;
//			   }
//
//               row.insert( vit->second, 1.0 );
//               adicionouVariavel = true;
//            }
//
//            if ( adicionouVariavel )
//            {
//               lp->addRow( row );
//               restricoes++;
//            }
//         }
//      }
//   }
//
//   return restricoes;
//}


/*
int SolverMIP::criaRestricaoProfessorHorario()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int , int > auxCoef;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR
         || v.getProfessor()->eVirtual() )
      {
         continue;
      }

      int nCred = v.getAula()->getTotalCreditos();
      int idxHor = problemData->getHorarioDiaIdx( v.getHorario() );

      for ( int h = idxHor; h < idxHor+nCred; h++ )
      {
         c.reset();
         c.setType( ConstraintOp::C_PROFESSOR_HORARIO );
         c.setProfessor( v.getProfessor() );
         c.setHorario( problemData->horariosDiaIdx[ h ] );
         c.setDia( problemData->horariosDiaIdx[ h ]->getDia() );
         c.setHorarioAula( problemData->horariosDiaIdx[ h ]->getHorarioAula() );

         cit = cHashOp.find( c );

         if ( cit != cHashOp.end() )
         {
            auxCoef.first = cit->second;
            auxCoef.second = vit->second;

            coeffList.push_back( auxCoef );
            coeffListVal.push_back( 1.0 );
         }
         else
         {
            sprintf( name, "%s", c.toString().c_str() );
            nnz = 100;

            OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

            row.insert( vit->second, 1.0 );
            cHashOp[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }   
      }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}
*/


int SolverMIP::criaRestricaoAlunoHorario( void )
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR )
      {
         continue;
      }

	  int campusId = problemData->retornaCampus( v.getAula()->getSala()->getIdUnidade() )->getId();
	  int turma = v.getAula()->getTurma();
	  Disciplina* disc = v.getAula()->getDisciplina();
      
	  std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator itMapAtend;

	  Trio< int, int, Disciplina* > trio;
	  trio.set( campusId, turma, disc );

	  itMapAtend = problemData->mapCampusTurmaDisc_AlunosDemanda.find( trio );
	  if ( itMapAtend != problemData->mapCampusTurmaDisc_AlunosDemanda.end() )
	  {
		  GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunosDemanda = (*itMapAtend).second;

		  // Para cada aluno alocado na aula
		  ITERA_GGROUP_LESSPTR( itAlunoDem, alunosDemanda, AlunoDemanda )
		  {
			    int alunoId = ( *itAlunoDem )->getAlunoId();
			    Aluno *aluno = problemData->retornaAluno( alunoId );

				Sala *sala = v.getSala();
				ITERA_GGROUP_LESSPTRPTR( it_horario_dia, sala->horariosDia, HorarioDia )
				{
					HorarioDia * horario_dia = ( *it_horario_dia );

					int dia = horario_dia->getDia();

					if ( v.getDia() != dia )
						continue;

					HorarioAula * horario_aula = horario_dia->getHorarioAula();

					DateTime inicio = horario_aula->getInicio();

					int nCred = v.getAula()->getTotalCreditos();
					int duracao = v.getDisciplina()->getTempoCredSemanaLetiva();			
					DateTime vInicio = v.getHorarioAula()->getInicio();
					HorarioAula *horarioAulaFim = v.getHorarioAula();
					for (int k = 1; k < nCred; k++)
           			{
						horarioAulaFim = horarioAulaFim->getCalendario()->getProximoHorario(horarioAulaFim);
					}
					DateTime vFim = horarioAulaFim->getFinal();

					if ( !( ( vInicio <= inicio ) && ( vFim > inicio ) ) )
					{
						continue;
					}         

					c.reset();
					c.setType( ConstraintOp::C_ALUNO_HORARIO );
					c.setAluno( aluno );
					c.setHorario( horario_dia );
					c.setDia( dia );
					c.setHorarioAula( horario_aula );

					cit = cHashOp.find( c );

					if ( cit != cHashOp.end() )
					{
						auxCoef.first = cit->second;
						auxCoef.second = vit->second;

						coeffList.push_back( auxCoef );
						coeffListVal.push_back( 1.0 );
					}
					else
					{
						sprintf( name, "%s", c.toString().c_str() );
						nnz = 100;

						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

						row.insert( vit->second, 1.0 );
						cHashOp[ c ] = lp->getNumRows();

						lp->addRow( row );
						restricoes++;
					}   
				} 
		  }
       }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

int SolverMIP::criaRestricaoBlocoHorario()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR )
      {
         continue;
      }

      std::map< Aula *, GGroup< BlocoCurricular *,
         LessPtr< BlocoCurricular > >, LessPtr< Aula > >::iterator
         itAulaBlocosCurriculares = problemData->aulaBlocosCurriculares.find( v.getAula() );

      // Para cada Bloco Curricular ao qual a aula pertence
      ITERA_GGROUP_LESSPTR( itBlocoCurric, itAulaBlocosCurriculares->second, BlocoCurricular )
      {
			BlocoCurricular * bloco = ( *itBlocoCurric );

			Sala *sala = v.getSala();
			ITERA_GGROUP_LESSPTRPTR( it_horario_dia, sala->horariosDia, HorarioDia )
			{
				HorarioDia * horario_dia = ( *it_horario_dia );

				int dia = horario_dia->getDia();

				if ( v.getDia() != dia )
					continue;

				HorarioAula * horario_aula = horario_dia->getHorarioAula();

				DateTime inicio = horario_aula->getInicio();
				DateTime fim = horario_aula->getFinal();

				int nCred = v.getAula()->getTotalCreditos();
				int duracao = v.getDisciplina()->getTempoCredSemanaLetiva();			
				DateTime vInicio = v.getHorarioAula()->getInicio();
				HorarioAula *horarioAulaFim = v.getHorarioAula();
				for (int k = 1; k < nCred; k++)
           		{
					horarioAulaFim = horarioAulaFim->getCalendario()->getProximoHorario(horarioAulaFim);
				}
				DateTime vFim = horarioAulaFim->getFinal();

				if ( !( ( vInicio <= inicio ) && ( vFim > inicio ) ) )
				{
					continue;
				}         

				c.reset();
				c.setType( ConstraintOp::C_BLOCO_HORARIO );
				c.setBloco( bloco );
				c.setHorario( horario_dia );
				c.setDia( dia );
				c.setHorarioAula( horario_aula );
				c.setTurma( v.getTurma() );

				cit = cHashOp.find( c );

				if ( cit != cHashOp.end() )
				{
				   auxCoef.first = cit->second;
				   auxCoef.second = vit->second;

				   coeffList.push_back( auxCoef );
				   coeffListVal.push_back( 1.0 );
				}
				else
				{
				   sprintf( name, "%s", c.toString().c_str() );
				   nnz = 100;

				   OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

				   row.insert( vit->second, 1.0 );
				   cHashOp[ c ] = lp->getNumRows();

				   lp->addRow( row );
				   restricoes++;
				}   
			}
       }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

/*
	Impede que duas disciplinas distintas de um mesmo bloco curricular sejam alocadas
	no mesmo horario do mesmo dia. 
*/

int SolverMIP::criaRestricaoBlocoHorarioDisc()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit1;
   VariableOpHash::iterator vit2;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   map<Disciplina*, map<int, vector<VariableOpHash::iterator>>, LessPtr<Disciplina>> varsDisciplina;

   for (vit1 = vHashOp.begin(); vit1 != vHashOp.end(); vit1++ )
   {
	   VariableOp v1 = vit1->first;
	   if ( v1.getType() != VariableOp::V_X_PROF_AULA_HOR )
	   {
		   continue;
	   }

	   Disciplina *d1 = v1.getDisciplina();
	   int dia1 = v1.getDia();
	   varsDisciplina[d1][dia1].push_back(vit1);
   }

   map<Disciplina*, map<int, vector<VariableOpHash::iterator>>, LessPtr<Disciplina>>::iterator vitD1;
   map<Disciplina*, map<int, vector<VariableOpHash::iterator>>, LessPtr<Disciplina>>::iterator vitD2;

   for(vitD1 = varsDisciplina.begin(); vitD1 != varsDisciplina.end(); vitD1++)
   {
	   Disciplina *d1 = vitD1->first;
	   for(map<int, vector<VariableOpHash::iterator>>::iterator it1 = vitD1->second.begin();
		   it1 != vitD1->second.end();
		   it1++)
	   {
		   int dia1 = it1->first;
		   for(vector<VariableOpHash::iterator>::iterator it2 = it1->second.begin();
			   it2 != it1->second.end();
			   it2++)
		   {
			   vit1 = *it2;
			   VariableOp v1 = vit1->first;

			   std::map< Aula *, GGroup< BlocoCurricular *, LessPtr< BlocoCurricular > >, LessPtr< Aula > >::iterator
				   itAulaBlocosCurriculares = problemData->aulaBlocosCurriculares.find( v1.getAula() );

			   // Para cada Bloco Curricular ao qual a aula pertence
			   ITERA_GGROUP_LESSPTR( itBlocoCurric,	itAulaBlocosCurriculares->second, BlocoCurricular )
			   {
				   BlocoCurricular * bloco = *itBlocoCurric;

               for (GGroup<Aula*,LessPtr<Aula> >::iterator itAB = problemData->blocoCurricularDiaAulas[bloco][v1.getDia()].begin();
               itAB != problemData->blocoCurricularDiaAulas[bloco][dia1].end(); itAB++)
               {
                  Aula *aula2 = *itAB;

                  Disciplina *d2 = aula2->getDisciplina();

                  vector<VariableOpHash::iterator> vars2 = varsDisciplina[d2][dia1];
					   for(vector<VariableOpHash::iterator>::iterator it3 = vars2.begin();
						   it3 != vars2.end();
						   it3++)
					   {
						   vit2 = *it3;
						   VariableOp v2 = vit2->first;

                     if ( v2.getAula() != aula2 )
                        continue;

						   int nCred1 = v1.getAula()->getTotalCreditos();
						   HorarioAula* h1 = v1.getHorario()->getHorarioAula();
						   //int idxHor1 = problemData->getHorarioDiaIdx( v1.getHorario() );

						   int nCred2 = v2.getAula()->getTotalCreditos();
						   HorarioAula* h2 = v2.getHorario()->getHorarioAula();
						   //int idxHor2 = problemData->getHorarioDiaIdx( v2.getHorario() );

						   //GGroup< HorarioAula* > horarios;

						   DateTime fim1 = h1->getInicio();
						   fim1.addMinutes( h1->getTempoAula() * nCred1 );

						   DateTime fim2 = h2->getInicio();
						   fim2.addMinutes( h2->getTempoAula() * nCred2 );

						   // ---------------------------------------------------

						   if ( ( ( h1->getInicio() <= h2->getInicio() ) && ( fim1 >  h2->getInicio() ) ) ||
							   ( ( h2->getInicio() <=  h1->getInicio() ) && ( fim2 >  h1->getInicio() ) ) )
						   {	// intersecao de horarios, com d1 comecando antes de (ou junto com) d2
							   // intersecao de horarios, com d2 comecando antes de (ou junto com) d1

							   c.reset();
							   c.setType( ConstraintOp::C_BLOCO_HORARIO_DISC );
							   c.setBloco( bloco );
							   c.setDia( dia1 );
							   c.setH1( h1 );
							   c.setH2( h2 );
							   c.setParDiscTurma( d1, v1.getTurma(), d2, v2.getTurma() );

							   cit = cHashOp.find( c );

							   if ( cit != cHashOp.end() )
							   {
								   lp->chgCoef(cit->second, vit1->second, 1.0);
								   lp->chgCoef(cit->second, vit2->second, 1.0);
							   }
							   else
							   {
								   sprintf( name, "%s", c.toString().c_str() );
								   nnz = 100;

								   OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

								   row.insert( vit1->second, 1.0 );
								   row.insert( vit2->second, 1.0 );
								   cHashOp[ c ] = lp->getNumRows();

								   lp->addRow( row );
								   restricoes++;
							   }
						   }
					   }
				   }
			   }
		   }
	   }
   }

   return restricoes;
}

//int SolverMIP::criaRestricaoBlocoHorarioDisc()
//{
//   int restricoes = 0;
//   int nnz;
//   char name[ 200 ];
//
//   ConstraintOp c;
//   VariableOpHash::iterator vit1;
//   VariableOpHash::iterator vit2;
//   ConstraintOpHash::iterator cit;
//
//   std::vector< std::pair< int, int > > coeffList;
//   std::vector< double > coeffListVal;
//   std::pair< int, int > auxCoef;
//   
//   for (vit1 = vHashOp.begin(); vit1 != vHashOp.end(); vit1++ )
//   {
//	   VariableOp v1 = vit1->first;
//	   if ( v1.getType() != VariableOp::V_X_PROF_AULA_HOR )
//	   {
//		   continue;
//	   }
//	   Disciplina *d1 = v1.getDisciplina();
//	   int dia1 = v1.getDia();
//	   
//	   std::map< Aula *, GGroup< BlocoCurricular *, LessPtr< BlocoCurricular > >, LessPtr< Aula > >::iterator
//			itAulaBlocosCurriculares = problemData->aulaBlocosCurriculares.find( v1.getAula() );
//
//	   // Para cada Bloco Curricular ao qual a aula pertence
//	   ITERA_GGROUP_LESSPTR( itBlocoCurric,	itAulaBlocosCurriculares->second, BlocoCurricular )
//	   {
//		   vit2 = vit1;
//		   vit2++;
//		   for (; vit2 != vHashOp.end(); vit2++ )
//		   {
//			   VariableOp v2 = vit2->first;
//			   if ( v2.getType() != VariableOp::V_X_PROF_AULA_HOR )
//			   {
//				   continue;
//			   }
//
//			   Disciplina *d2 = v2.getAula()->getDisciplina();
//			   if( ( itBlocoCurric->disciplinas.find( d2 ) == itBlocoCurric->disciplinas.end() ) ||
//				   ( *d1 == *d2 ) ||
//				   ( dia1 != v2.getDia() ) )
//			   {	// Se a disciplina d2 nao estiver no mesmo bloco curricular que d1 OU
//				    // se as disciplinas d1 e d2 forem a mesma OU
//				    // se os dias das aulas de vit1 e vit2 foram diferentes
//				    // passa para a proxima variavel (itera vit2)
//					continue;
//			   }
//
//			   BlocoCurricular * bloco = ( *itBlocoCurric );
//
//			   int nCred1 = v1.getAula()->getTotalCreditos();
//			   HorarioAula* h1 = v1.getHorario()->getHorarioAula();
//			   //int idxHor1 = problemData->getHorarioDiaIdx( v1.getHorario() );
//
//			   int nCred2 = v2.getAula()->getTotalCreditos();
//			   HorarioAula* h2 = v2.getHorario()->getHorarioAula();
//			   //int idxHor2 = problemData->getHorarioDiaIdx( v2.getHorario() );
//			   			   
//			   GGroup< HorarioAula* > horarios;
//			   
//			   DateTime fim1 = h1->getInicio();
//			   fim1.addMinutes( h1->getTempoAula() * nCred1 );
//			   
//			   DateTime fim2 = h2->getInicio();
//			   fim2.addMinutes( h2->getTempoAula() * nCred2 );
//
//			   // ---------------------------------------------------
//
//			   if ( ( ( h1->getInicio() <= h2->getInicio() ) && ( fim1 >  h2->getInicio() ) ) ||
//					( ( h2->getInicio() <=  h1->getInicio() ) && ( fim2 >  h1->getInicio() ) ) )
//			   {	// intersecao de horarios, com d1 comecando antes de (ou junto com) d2
//				    // intersecao de horarios, com d2 comecando antes de (ou junto com) d1
//
//					c.reset();
//					c.setType( ConstraintOp::C_BLOCO_HORARIO_DISC );
//					c.setBloco( bloco );
//					c.setDia( dia1 );
//					c.setH1( h1 );
//					c.setH2( h2 );
//					c.setParDiscTurma( d1, v1.getTurma(), d2, v2.getTurma() );
//
//					cit = cHashOp.find( c );
//
//					if ( cit != cHashOp.end() )
//					{
//						auxCoef.first = cit->second; // restricao C_BLOCO_HORARIO_DISC
//						auxCoef.second = vit1->second; // variavel V_X_PROF_AULA_HOR
//						coeffList.push_back( auxCoef );
//						coeffListVal.push_back( 1.0 );
//
//						auxCoef.first = cit->second; // restricao C_BLOCO_HORARIO_DISC
//						auxCoef.second = vit2->second; // variavel V_X_PROF_AULA_HOR
//						coeffList.push_back( auxCoef );
//						coeffListVal.push_back( 1.0 );
//					}
//					else
//					{
//						sprintf( name, "%s", c.toString().c_str() );
//						nnz = 100;
//
//						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
//
//						row.insert( vit1->second, 1.0 );
//						row.insert( vit2->second, 1.0 );
//						cHashOp[ c ] = lp->getNumRows();
//
//						lp->addRow( row );
//						restricoes++;
//					}
//			   }
//
//			   // ----------------------------------------------------
//
//			   /*
//
//			   if ( ( h1->getInicio() < h2->getInicio() ) &&
//				    ( fim1 >  h2->getInicio() ) )
//			   {	// intersecao de horarios, com d1 comecando antes de d2
//				    
//				    HorarioAula *hInicio = h2;
//
//					DateTime fim;
//					if ( fim1 < fim2 )
//						fim = fim1;
//					else
//						fim = fim2;
//
//					HorarioAula *h = hInicio;
//					for ( int creds = 1; creds <= nCred2; creds++ ) // adiciona horariosAula do calendario de d2
//					{
//						if ( h == NULL )
//							continue;
//						if ( h->getInicio() >= fim )
//							continue;
//						horarios.add( h );
//						h = d2->getCalendario()->getProximoHorario( h );			
//					}
//
//					h = d1->getCalendario()->getProximoHorario( h1 );
//					for ( int creds = 2; creds <= nCred1; creds++ ) // adiciona horariosAula do calendario de d1
//					{
//						if ( h == NULL )
//							continue;
//						if ( h->getInicio() >= fim )
//							continue;
//						horarios.add( h );
//						h = d1->getCalendario()->getProximoHorario( h );					
//					}
//					
//			   }
//			   else if ( ( h2->getInicio() <  h1->getInicio() ) &&
//					     ( fim2 >  h1->getInicio() ) )
//			   {	// intersecao de horarios, com d2 comecando antes de d1
//				    HorarioAula *hInicio = h1;
//
//					DateTime fim;
//					if ( fim1 < fim2 )
//						fim = fim1;
//					else
//						fim = fim2;
//
//					HorarioAula *h = hInicio;
//					for ( int creds = 1; creds <= nCred1; creds++ ) // adiciona horariosAula do calendario de d1
//					{
//						if ( h == NULL )
//							continue;
//						if ( h->getInicio() >= fim )
//							continue;
//						horarios.add( h );
//						h = d1->getCalendario()->getProximoHorario( h );		
//					}
//
//					h = d2->getCalendario()->getProximoHorario( h2 );
//					for ( int creds = 2; creds <= nCred2; creds++ ) // adiciona horariosAula do calendario de d2
//					{
//						if ( h == NULL )
//							continue;
//						if ( h->getInicio() >= fim )
//							continue;
//						horarios.add( h );
//						h = d2->getCalendario()->getProximoHorario( h );
//					}
//
//			   }
//			   else
//			   {   // sem intersecao de horarios	
//				   continue;
//			   }
//
//			   ITERA_GGROUP( itHor, horarios, HorarioAula )
//			   {
//					c.reset();
//					c.setType( ConstraintOp::C_BLOCO_HORARIO_DISC );
//					c.setBloco( bloco );
//					c.setDia( dia1 );
//					c.setHorarioAula( *itHor );
//					c.setParDiscTurma( d1, v1.getTurma(), d2, v2.getTurma() );
//
//					cit = cHashOp.find( c );
//
//					if ( cit != cHashOp.end() )
//					{
//						auxCoef.first = cit->second; // restricao C_BLOCO_HORARIO_DISC
//						auxCoef.second = vit1->second; // variavel V_X_PROF_AULA_HOR
//						coeffList.push_back( auxCoef );
//						coeffListVal.push_back( 1.0 );
//
//						auxCoef.first = cit->second; // restricao C_BLOCO_HORARIO_DISC
//						auxCoef.second = vit2->second; // variavel V_X_PROF_AULA_HOR
//						coeffList.push_back( auxCoef );
//						coeffListVal.push_back( 1.0 );
//					}
//					else
//					{
//						sprintf( name, "%s", c.toString().c_str() );
//						nnz = 100;
//
//						OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );
//
//						row.insert( vit1->second, 1.0 );
//						row.insert( vit2->second, 1.0 );
//						cHashOp[ c ] = lp->getNumRows();
//
//						lp->addRow( row );
//						restricoes++;
//					}   
//				}
//			
//			   */
//			}
//		}
//   }
//   chgCoeffList( coeffList, coeffListVal );
//
//   return restricoes;
//}



int SolverMIP::criaRestricaoAlocAula()
{
   int restricoes = 0;

   int totalHorariosAula = ( (int)( this->problemData->horarios_aula_ordenados.size() ) );
   int totalProfessores = ( this->problemData->getProfessores().size() + 1 );
   int nnz = ( totalProfessores * totalHorariosAula );
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR &&
		   v.getType() != VariableOp::V_FOLGA_DEMANDA )
      {
         continue;
      }

      c.reset();
      c.setType( ConstraintOp::C_ALOC_AULA );
      c.setAula( v.getAula() );

      cit = cHashOp.find( c );

      if ( cit != cHashOp.end() )
      {
         auxCoef.first = cit->second;
         auxCoef.second = vit->second;

         coeffList.push_back( auxCoef );
         coeffListVal.push_back( 1.0 );
      }
      else
      {
         sprintf( name, "%s", c.toString().c_str() );

         OPT_ROW row( nnz, OPT_ROW::EQUAL , 1.0, name );

         row.insert( vit->second, 1.0 );
         cHashOp[ c ] = lp->getNumRows();

         lp->addRow( row );
         restricoes++;
      }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

int SolverMIP::criaRestricaoProfessorDisciplinaUnico()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() != VariableOp::V_Y_PROF_DISCIPLINA )
      {
         continue;
      }

      c.reset();
      c.setType( ConstraintOp::C_PROF_DISC_UNI );
      c.setDisciplina( v.getDisciplina() );
      c.setTurma( v.getTurma() );

      cit = cHashOp.find( c );

      if ( cit != cHashOp.end() )
      {
         auxCoef.first = cit->second;
         auxCoef.second = vit->second;

         coeffList.push_back( auxCoef );
         coeffListVal.push_back( 1.0 );
      }
      else
      {
         sprintf( name, "%s", c.toString().c_str() );
         nnz = 100;

         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

         row.insert( vit->second, 1.0 );
         cHashOp[ c ] = lp->getNumRows();

         lp->addRow( row );
         restricoes++;
      }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

int SolverMIP::criaRestricaoProfessorDisciplina()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() != VariableOp::V_Y_PROF_DISCIPLINA
            && v.getType() != VariableOp::V_X_PROF_AULA_HOR )
      {
         continue;
      }

      if ( v.getProfessor()->eVirtual() )
      {
         continue;
      }

      if ( v.getType() == VariableOp::V_Y_PROF_DISCIPLINA )
      {
         c.reset();
         c.setType( ConstraintOp::C_PROF_DISC );
         c.setProfessor( v.getProfessor() );
         c.setDisciplina( v.getDisciplina() );
         c.setTurma( v.getTurma() );

         cit = cHashOp.find( c );

         if ( cit != cHashOp.end() )
         {
            auxCoef.first = cit->second;
            auxCoef.second = vit->second;

            coeffList.push_back( auxCoef );
            coeffListVal.push_back( -10.0 );
         }
         else
         {
            sprintf( name, "%s", c.toString().c_str() );
            nnz = 100;

            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

            row.insert( vit->second, -10.0 );
            cHashOp[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }   
      }
      else
      {
         c.reset();
         c.setType( ConstraintOp::C_PROF_DISC );
         c.setProfessor( v.getProfessor() );
         c.setDisciplina( v.getAula()->getDisciplina() );
         c.setTurma( v.getAula()->getTurma() );

         cit = cHashOp.find( c );

         if ( cit != cHashOp.end() )
         {
            auxCoef.first = cit->second;
            auxCoef.second = vit->second;

            coeffList.push_back( auxCoef );
            coeffListVal.push_back( 1.0 );
         }
         else
         {
            sprintf( name, "%s", c.toString().c_str() );
            nnz = 100;

            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

            row.insert( vit->second, 1.0 );
            cHashOp[ c ] = lp->getNumRows();

            lp->addRow( row );
            restricoes++;
         }   
      }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

int SolverMIP::criaRestricaoFixProfDiscSalaDiaHor()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   ITERA_GGROUP_LESSPTR( itFix,
     problemData->fixacoes_Prof_Disc_Sala_Dia_Horario, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      c.reset();
      c.setType( ConstraintOp::C_FIX_PROF_DISC_SALA_DIA_HOR );

      vit = vHashOp.begin();

      for (; vit != vHashOp.end(); vit++ )
      {
         VariableOp v = vit->first;

         if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR
            && v.getType() != VariableOp::V_F_FIX_PROF_DISC_SALA_DIA_HOR )
         {
            continue;
         }

		 if ( v.getProfessor()->eVirtual() )
			 continue;

         // Compara para verificar se a variavel vai ser fixada
         if ( v.getProfessor()->getId() == fixacao->getProfessorId()
            && v.getDisciplina()->getId() == fixacao->getDisciplinaId()
            && v.getSala()->getId() == fixacao->getSalaId()
            && v.getHorario()->getDia() == fixacao->getDiaSemana()
            && v.getHorario()->getHorarioAulaId()  == fixacao->getHorarioAulaId() )
         {
            c.setProfessor( v.getProfessor() );
            c.setDisciplina( v.getDisciplina() );
            c.setSala( v.getSala() );
            c.setHorario( v.getHorario() );
			c.setDia( v.getHorario()->getDia() );

            cit = cHashOp.find( c );

            if ( cit != cHashOp.end() )
            {
               auxCoef.first = cit->second;
               auxCoef.second = vit->second;

               coeffList.push_back( auxCoef );
               coeffListVal.push_back( 1.0 );
            }
            else
            {
               sprintf( name, "%s", c.toString().c_str() );

			   nnz = v.getDisciplina()->getNumTurmas() + 1;

               OPT_ROW row( nnz, OPT_ROW::EQUAL , 1.0, name );

               row.insert( vit->second, 1.0 );
               cHashOp[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoFixProfDiscDiaHor()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   ITERA_GGROUP_LESSPTR( itFix,
      problemData->fixacoes_Prof_Disc_Dia_Horario, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      c.reset();
      c.setType( ConstraintOp::C_FIX_PROF_DISC_DIA_HOR );

      vit = vHashOp.begin();

      for (; vit != vHashOp.end(); vit++ )
      {
         VariableOp v = vit->first;

         if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR
            && v.getType() != VariableOp::V_F_FIX_PROF_DISC_DIA_HOR )
         {
            continue;
         }

		 if ( v.getProfessor()->eVirtual() )
			 continue;

         // Compara para verificar se a variavel vai ser fixada
         if ( v.getProfessor()->getId() == fixacao->getProfessorId()
            && v.getDisciplina()->getId() == fixacao->getDisciplinaId()
            && v.getHorario()->getDia() == fixacao->getDiaSemana()
            && v.getHorario()->getHorarioAulaId()  == fixacao->getHorarioAulaId() )
         {
            c.setProfessor( v.getProfessor() );
            c.setDisciplina( v.getDisciplina() );
            c.setHorario( v.getHorario() );
			c.setDia( v.getHorario()->getDia() );

            cit = cHashOp.find( c );

            if ( cit != cHashOp.end() )
            {
               auxCoef.first = cit->second;
               auxCoef.second = vit->second;

               coeffList.push_back( auxCoef );
               coeffListVal.push_back( 1.0 );
            }
            else
            {
               sprintf( name, "%s", c.toString().c_str() );
               nnz = 100;

               OPT_ROW row( nnz, OPT_ROW::EQUAL , 1.0, name );

               row.insert( vit->second, 1.0 );
               cHashOp[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoFixProfDisc()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   ITERA_GGROUP_LESSPTR( itFix, 
      problemData->fixacoes_Prof_Disc_Dia_Horario, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      c.reset();
      c.setType( ConstraintOp::C_FIX_PROF_DISC );
      
      vit = vHashOp.begin();

      for (; vit != vHashOp.end(); vit++ )
      {
         VariableOp v = vit->first;

         if ( v.getType() != VariableOp::V_Y_PROF_DISCIPLINA
            && v.getType() != VariableOp::V_F_FIX_PROF_DISC )
         {
            continue;
         }

		 if ( v.getProfessor()->eVirtual() )
			 continue;

         // Compara para verificar se a variavel vai ser fixada
         if ( v.getProfessor()->getId() == fixacao->getProfessorId()
            && v.getDisciplina()->getId() == fixacao->getDisciplinaId() )
         {
            c.setProfessor( v.getProfessor() );
            c.setDisciplina( v.getDisciplina() );

            cit = cHashOp.find( c );

            if ( cit != cHashOp.end() )
            {
               auxCoef.first = cit->second;
               auxCoef.second = vit->second;

               coeffList.push_back( auxCoef );
               coeffListVal.push_back( 1.0 );
            }
            else
            {
               sprintf( name, "%s", c.toString().c_str() );
               
			   nnz = v.getDisciplina()->getNumTurmas() + 1;

               OPT_ROW row( nnz, OPT_ROW::EQUAL , 1.0, name );

               row.insert( vit->second, 1.0 );
               cHashOp[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoFixProfDiscSala()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   ITERA_GGROUP_LESSPTR( itFix,
      problemData->fixacoes_Prof_Disc_Dia_Horario, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      c.reset();
      c.setType( ConstraintOp::C_FIX_PROF_DISC_SALA );
      
      vit = vHashOp.begin();

      for (; vit != vHashOp.end(); vit++ )
      {
         VariableOp v = vit->first;

         if ( v.getType() != VariableOp::V_Y_PROF_DISCIPLINA
            && v.getType() != VariableOp::V_F_FIX_PROF_DISC_SALA )
         {
            continue;
         }

         // Compara para verificar se a variavel vai ser fixada
         if ( v.getProfessor()->getId() == fixacao->getProfessorId()
            && v.getDisciplina()->getId() == fixacao->getDisciplinaId() )
         {
            c.setProfessor( v.getProfessor() );
            c.setDisciplina( v.getDisciplina() );

            cit = cHashOp.find( c );

            if ( cit != cHashOp.end() )
            {
               auxCoef.first = cit->second;
               auxCoef.second = vit->second;

               coeffList.push_back( auxCoef );
               coeffListVal.push_back( 1.0 );
            }
            else
            {
               sprintf( name, "%s", c.toString().c_str() );
               nnz = 100;

               OPT_ROW row( nnz, OPT_ROW::EQUAL , 1.0, name );

               row.insert( vit->second, 1.0 );
               cHashOp[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoFixProfSala()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;
 
   ITERA_GGROUP_LESSPTR( itFix,
      problemData->fixacoes_Prof_Disc_Dia_Horario, Fixacao )
   {
      Fixacao * fixacao = ( *itFix );

      c.reset();
      c.setType( ConstraintOp::C_FIX_PROF_SALA );
      
      vit = vHashOp.begin();

      for (; vit != vHashOp.end(); vit++ )
      {
         VariableOp v = vit->first;

         if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR
            && v.getType() != VariableOp::V_F_FIX_PROF_SALA )
         {
            continue;
         }
		 		 
		 if ( v.getProfessor()->eVirtual() )
			 continue;

         // Compara para verificar se a variavel vai ser fixada
         if ( v.getProfessor()->getId() == fixacao->getProfessorId()
            && v.getSala()->getId() != fixacao->getSalaId() )
         {
            c.setProfessor( v.getProfessor() );
            c.setSala( fixacao->sala );

            cit = cHashOp.find( c );

            if ( cit != cHashOp.end() )
            {
               auxCoef.first = cit->second;
               auxCoef.second = vit->second;

               coeffList.push_back( auxCoef );

               if ( v.getType() == VariableOp::V_F_FIX_PROF_SALA )
               {
                  coeffListVal.push_back( -1.0 );
               }
               else
               {
                  coeffListVal.push_back( 1.0 );
               }
            }
            else
            {
               sprintf( name, "%s", c.toString().c_str() );
               nnz = 100;

               OPT_ROW row( nnz, OPT_ROW::EQUAL , 0.0, name );

               if ( v.getType() == VariableOp::V_F_FIX_PROF_SALA )
               {
                  row.insert( vit->second, -1.0 );
               }
               else
               {
                  row.insert( vit->second, 1.0 );
               }

               cHashOp[ c ] = lp->getNumRows();

               lp->addRow( row );
               restricoes++;
            }
         }
      }
   }

   return restricoes;
}

/*
	sum[p] sum[pv] sum[u] sum[s] x_{p,i,d,u,s,t,h} + x_{pv,i,d,u,s,t,h} <= z_{i,d,h}

	forall d \in D
	forall i \in I_{d}
	forall t \in T
	forall h \in H
*/
int SolverMIP::criaRestricaoDisciplinaMesmoHorario()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR )
      {
         continue;
      }

      c.reset();
      c.setType( ConstraintOp::C_DISC_HORARIO );
      c.setDisciplina( v.getDisciplina() );
      c.setTurma( v.getTurma() );
      c.setHorarioAula( v.getHorario()->getHorarioAula() );
      c.setDia( v.getHorario()->getDia() );

      cit = cHashOp.find( c );

      if ( cit != cHashOp.end() )
      {
         auxCoef.first = cit->second;
         auxCoef.second = vit->second;
         coeffList.push_back( auxCoef );
         coeffListVal.push_back( 1.0 );
      }
      else
      {
         sprintf( name, "%s", c.toString().c_str() );
         nnz = 100;

         OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );

         row.insert( vit->second, 1.0 );
         cHashOp[ c ] = lp->getNumRows();

         lp->addRow( row );
         restricoes++;
      }   
   }

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() == VariableOp::V_Z_DISCIPLINA_HOR )
      {
         c.reset();
         c.setType( ConstraintOp::C_DISC_HORARIO );
         c.setDisciplina( v.getDisciplina() );
         c.setTurma( v.getTurma() );
         c.setHorarioAula( v.getHorarioAula() );

         for ( int dia = 0; dia <= 7; dia++ )
         {
            c.setDia( dia );

            cit = cHashOp.find( c );

            if ( cit != cHashOp.end() )
            {
               auxCoef.first = cit->second;
               auxCoef.second = vit->second;

               coeffList.push_back( auxCoef );
               coeffListVal.push_back( -1.0 );
            }
         }
      }
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

int SolverMIP::criaRestricaoCustoCorpoDocente()
{
   int restricoes = 0;
   int nnz = 0;
   double rhs = 0.0;
   char name[ 200 ];
   double M = 1000000;

   ConstraintOp c;
   VariableOp v_find;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   // Informa quantas variáveis 'y' foram criadas para cada professor.
   // Esse valor será o 'nnz' das restrições desse professor
   std::map< Professor *, int > mapProfessorVariaveis;

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );
      mapProfessorVariaveis[ professor ] += 1;

      vit = vHashOp.begin();
      for (; vit != vHashOp.end(); vit++ )
      {
         if ( vit->first.getType() == VariableOp::V_Y_PROF_DISCIPLINA
            && vit->first.getProfessor() == professor )
         {
            mapProfessorVariaveis[ professor ]++;
         }
      }
   }

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      c.reset();
      c.setType( ConstraintOp::C_CUSTO_CORPO_DOCENTE );
      c.setProfessor( professor );

      if ( cHashOp.find( c ) == cHashOp.end() )
      {
         // Cria duas novas linhas no modelo
         sprintf( name, "%s", c.toString().c_str() );

         // Total de variáveis 'y' do professor mais um ( que
         // corresponde ao lado direito da desigualdade no modelo )
         nnz = mapProfessorVariaveis[ professor ];

         OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

         // Procura pela variável 'cd' do professor
         v_find.reset();
         v_find.setType( VariableOp::V_CUSTO_CORPO_DOCENTE );
         v_find.setProfessor( professor );

         vit = vHashOp.find( v_find );

         if ( vit == vHashOp.end() )
         {
            continue;
         }
      
         VariableOp v = vit->first;

         // Insere a variável 'cd' nas restrições
         row.insert( vit->second, -1000.0 );

         // Cada varíável 'y' do professor
         // insere um índice nas restrições
         vit = vHashOp.begin();
         for (; vit != vHashOp.end(); vit++ )
         {
            if ( vit->first.getType() == VariableOp::V_Y_PROF_DISCIPLINA
               && vit->first.getProfessor() == professor )
            {
               row.insert( vit->second, 1.0 );
            }
         }

         cHashOp[ c ] = lp->getNumRows();
         lp->addRow( row );
         restricoes++;
      }
   }

   return restricoes;
}

/*
	Usada quando o parametro carga_horaria_semanal_prof é CONCENTRAR a carga horária durante semana,
	ou seja, MINIMIZAR o número de dias de aulas do professor.
*/
int SolverMIP::criaRestricaoCalculaDiasProfMinistra_Min()
{
	int restricoes = 0;
   
	if ( problemData->parametros->carga_horaria_semanal_prof != ParametrosPlanejamento::CHS::MINIMIZAR_DIAS )
    {
	    return restricoes;
    }
   
	int nnz = 100;
	char name[ 200 ];

	ConstraintOp c;
	VariableOpHash::iterator vit;
	ConstraintOpHash::iterator cit;

	map< ConstraintOp, int > numVars;

	vit = vHashOp.begin();

	while(vit != vHashOp.end())
	{
		VariableOp vOp = ( vit->first );

		if (vOp.getType() != VariableOp::V_X_PROF_AULA_HOR)
		{
			vit++;
			continue;
		}

		if ( vOp.getProfessor()->eVirtual() )
        {
           vit++;
           continue;
        }

		Professor *professor = vOp.getProfessor();
		int dia = vOp.getHorario()->getDia();

		c.reset();
		c.setType( ConstraintOp::C_DIAS_PROF_MINISTRA_AULA );
		c.setProfessor( professor );
		c.setDia( dia );

		cit = cHashOp.find(c);
		if ( cit == cHashOp.end() )
		{
			cHashOp[ c ] = lp->getNumRows();

			sprintf( name, "%s", c.toString().c_str() );
			OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );
			row.insert( vit->second, 1.0 );
			lp->addRow( row );
			restricoes++;
			numVars[ c ] = 1;
		}
		else
		{
			lp->chgCoef(cit->second, vit->second, 1.0);
			numVars[c]++;
		}

		vit++;
	}

	vit = vHashOp.begin();

	while(vit != vHashOp.end())
	{
		VariableOp vOp = ( vit->first );

		if (vOp.getType() != VariableOp::V_DIAS_PROF_MINISTRA_AULAS)
		{
			vit++;
			continue;
		}

		Professor *professor = vOp.getProfessor();
		int dia = vOp.getDia();

		c.reset();
		c.setType( ConstraintOp::C_DIAS_PROF_MINISTRA_AULA );
		c.setProfessor( professor );
		c.setDia( dia );

		cit = cHashOp.find(c);
		if ( cit != cHashOp.end() )
		{
			lp->chgCoef(cit->second, vit->second, -1*numVars[ c ]);
		}

		vit++;
	}

   return restricoes;
}

/*
	Usada quando o parametro carga_horaria_semanal_prof é DISTRIBUIR as aulas durante a semana,
	ou seja, maximizar o número de dias de aulas do professor.
*/
int SolverMIP::criaRestricaoCalculaDiasProfMinistra_Max()
{
	int restricoes = 0;
   
	if ( problemData->parametros->carga_horaria_semanal_prof != ParametrosPlanejamento::CHS::EQUILIBRAR )
    {
	    return restricoes;
    }
   
	int nnz = 100;
	char name[ 200 ];

	ConstraintOp c;
	VariableOpHash::iterator vit;
	ConstraintOpHash::iterator cit;

	map< ConstraintOp, int > numVars;

	vit = vHashOp.begin();

	while(vit != vHashOp.end())
	{
		VariableOp vOp = ( vit->first );

		if (vOp.getType() != VariableOp::V_X_PROF_AULA_HOR)
		{
			vit++;
			continue;
		}

		if ( vOp.getProfessor()->eVirtual() )
        {
           vit++;
           continue;
        }

		Professor *professor = vOp.getProfessor();
		int dia = vOp.getHorario()->getDia();

		c.reset();
		c.setType( ConstraintOp::C_DIAS_PROF_MINISTRA_AULA );
		c.setProfessor( professor );
		c.setDia( dia );

		cit = cHashOp.find(c);
		if ( cit == cHashOp.end() )
		{
			cHashOp[ c ] = lp->getNumRows();

			sprintf( name, "%s", c.toString().c_str() );
			OPT_ROW row( nnz, OPT_ROW::GREATER , 0.0, name );
			row.insert( vit->second, 1.0 );
			lp->addRow( row );
			restricoes++;
			numVars[ c ] = 1;
		}
		else
		{
			lp->chgCoef(cit->second, vit->second, 1.0);
			numVars[c]++;
		}

		vit++;
	}

	vit = vHashOp.begin();

	while(vit != vHashOp.end())
	{
		VariableOp vOp = ( vit->first );

		if (vOp.getType() != VariableOp::V_DIAS_PROF_MINISTRA_AULAS)
		{
			vit++;
			continue;
		}

		Professor *professor = vOp.getProfessor();
		int dia = vOp.getDia();

		c.reset();
		c.setType( ConstraintOp::C_DIAS_PROF_MINISTRA_AULA );
		c.setProfessor( professor );
		c.setDia( dia );

		cit = cHashOp.find(c);
		if ( cit != cHashOp.end() )
		{
			lp->chgCoef(cit->second, vit->second, -1*numVars[ c ]);
		}

		vit++;
	}

   return restricoes;
}

//int SolverMIP::criaRestricaoCalculaDiasProfMinistra()
//{
//   int restricoes = 0;
//   int nnz = 100;
//   char name[ 200 ];
//
//   ConstraintOp c;
//   VariableOpHash::iterator vit;
//   ConstraintOpHash::iterator cit;
//
//   GGroup< Professor *, LessPtr< Professor > > professores
//      = problemData->getProfessores();
//
//   // Dias em que cada professor pode dar aula
//   std::map< Professor *, GGroup< int > > mapProfessorDias;
//
//   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
//   {
//      Professor * professor = ( *it_prof );
//
//      ITERA_GGROUP_LESSPTR( it_horario_dia, professor->horariosDia, HorarioDia )
//      {
//         mapProfessorDias[ professor ].add( it_horario_dia->getDia() );
//      }
//   }
//
//   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
//   {
//      Professor * professor = ( *it_prof );
//      GGroup< int > dias_professor = mapProfessorDias[ professor ];
//
//      ITERA_GGROUP_N_PT( it_dia, dias_professor, int )
//      {
//         int dia = ( *it_dia );
//         GGroup< HorarioDia *, LessPtr< HorarioDia > > horarios_dia_considerados;
//         horarios_dia_considerados.clear();
//
//         c.reset();
//         c.setType( ConstraintOp::C_DIAS_PROF_MINISTRA_AULA );
//         c.setProfessor( professor );
//         c.setDia( dia );
//
//         if ( cHashOp.find( c ) == cHashOp.end() )
//         {
//            sprintf( name, "%s", c.toString().c_str() );
//
//            OPT_ROW row( nnz, OPT_ROW::LESS , 0.0, name );
//
//            // Procura as variáveis X_p_a_h relacionadas a esse professor e dia
//            vit = vHashOp.begin();
//
//            for (; vit != vHashOp.end(); vit++ )
//            {
//               VariableOp v = vit->first;
//
//               if ( v.getType() != VariableOp::V_X_PROF_AULA_HOR )
//               {
//                  continue;
//               }
//
//               GGroup< HorarioDia *, LessPtr< HorarioDia > >::iterator
//                  it_find = horarios_dia_considerados.find( v.getHorario() );
//
//               if ( v.getHorario()->getDia() == dia
//                  && v.getProfessor() == professor
//                  && it_find == horarios_dia_considerados.end() )
//               {
//                  horarios_dia_considerados.add( v.getHorario() );
//
//                  row.insert( vit->second, 1.0 );
//               }
//            }
//
//            // Inserindo o limite de horários que podem ser considerados
//            VariableOp v;
//            v.reset();
//            v.setType( VariableOp::V_DIAS_PROF_MINISTRA_AULAS );
//            v.setProfessor( professor );
//            v.setDia( dia );
//
//            vit = vHashOp.find( v );
//
//            if ( vit != vHashOp.end() )
//            {
//               // NUM_HORARIOS_DIA * T_p_t
//               double val = (-1.0) * ( horarios_dia_considerados.size() );
//
//               row.insert( vit->second, val );
//            }
//
//            cHashOp[ c ] = lp->getNumRows();
//
//            lp->addRow( row );
//            restricoes++;
//         }
//      }
//   }
//
//   return restricoes;
//}

int SolverMIP::criaRestricaoDisciplinaHorarioUnico()
{
   int restricoes = 0;
   int nnz;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   std::vector< std::pair< int, int > > coeffList;
   std::vector< double > coeffListVal;
   std::pair< int, int > auxCoef;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = vit->first;

      if ( v.getType() != VariableOp::V_Z_DISCIPLINA_HOR &&
		   v.getType() != VariableOp::V_FOLGA_DISCIPLINA_HOR )
      {
         continue;
      }

      c.reset();
      c.setType( ConstraintOp::C_DISC_HORARIO_UNICO );
      c.setDisciplina( v.getDisciplina() );
      c.setTurma( v.getTurma() );
	  c.setCampus( v.getCampus() );

      cit = cHashOp.find( c );

      if ( cit != cHashOp.end() )
      {
         auxCoef.first = cit->second; //constraint
         auxCoef.second = vit->second; //variable

         coeffList.push_back( auxCoef );

		 if (  v.getType() == VariableOp::V_Z_DISCIPLINA_HOR )
		 {
			coeffListVal.push_back( 1.0 );
		 }

		 else if (v.getType() == VariableOp::V_FOLGA_DISCIPLINA_HOR)
		 {
			coeffListVal.push_back( -1.0 );
		 }
      }
      else
      {
         sprintf( name, "%s", c.toString().c_str() );
         nnz = 100;

         OPT_ROW row( nnz, OPT_ROW::LESS , 1.0, name );

		 if (  v.getType() == VariableOp::V_Z_DISCIPLINA_HOR )
		 {
			row.insert( vit->second, 1.0 );		 
		 }

		 else if (v.getType() == VariableOp::V_FOLGA_DISCIPLINA_HOR)
		 {
			row.insert( vit->second, -1.0 );
		 }
		 
         cHashOp[ c ] = lp->getNumRows();

         lp->addRow( row );
         restricoes++;
      }   
   }

   chgCoeffList( coeffList, coeffListVal );

   return restricoes;
}

int SolverMIP::criaRestricaoMinimoMestresCurso()
{
   int restricoes = 0;
      
   if ( ! problemData->parametros->min_mestres )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   // Agrupando os professores que ministram disciplinas de cada curso
   std::map< Curso *, GGroup< Professor *,
      LessPtr< Professor > > > mapCursoProfessores;

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
      {
         Aula * aula = ( *it_aula );
         Disciplina * disciplina = aula->getDisciplina();

         std::pair< int, int > professor_disciplina (
            professor->getId(), disciplina->getId() );

         // Se o professor e a disciplina da aula em questão se relacionarem
         if ( problemData->prof_Disc_Dias.find( professor_disciplina )
            == problemData->prof_Disc_Dias.end() )
         {
            continue;
         }

         ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
         {
            Oferta * oferta = ( *it_oferta );

            mapCursoProfessores[ oferta->curso ].add( professor );
         }
      }
   }

   std::map< Curso *, GGroup< Professor *, LessPtr< Professor > > >::iterator
      it_map = mapCursoProfessores.begin();

   for (; it_map != mapCursoProfessores.end();
          it_map++ )
   {
        Curso * curso = it_map->first;

		c.reset();
		c.setType( ConstraintOp::C_MIN_MEST_CURSO );
		c.setCurso( curso );

		cit = cHashOp.find( c );

		if ( cit == cHashOp.end() )
		{
			GGroup< Professor *, LessPtr< Professor > > professores_curso
				= it_map->second;

			sprintf( name, "%s", c.toString().c_str() );
			nnz = professores_curso.size();
			rhs = 0.0;

			OPT_ROW row( nnz, OPT_ROW::GREATER, rhs, name );
				  
			// professores reais
			ITERA_GGROUP_LESSPTR( it_prof, professores_curso, Professor )
			{
				Professor * professor = ( *it_prof );
				
				// Recupera os professores que estão associados ao curso, e que são no minimo mestres
				VariableOpHash::iterator vit_find = vHashOp.begin();

				for (; vit_find != vHashOp.end(); vit_find++ )
				{
				   VariableOp v_find = vit_find->first;

				   if ( v_find.getType() == VariableOp::V_PROF_CURSO
					  && v_find.getCurso() == curso
					  && v_find.getProfessor() == professor
					  && ( professor->getTitulacaoId() == 4 || professor->getTitulacaoId() == 5 ) )
				   {
					  row.insert( vit_find->second, 1.0 );
				   }
				}
			}

			// Variavel npvm_{c}
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_MEST_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, 1.0 );
			}

			// Variavel npvd_{c}			
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_DOUT_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, 1.0 );
			}

			double minPercMestre = ( curso->regra_min_mestres.second / 100.0 );

			// Variavel np_{c}			
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -minPercMestre );
			}

			// Variavel npv_{c}
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -minPercMestre );
			}
			
			if ( row.getnnz() != 0 )
			{
				cHashOp[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
        }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoMinimoDoutoresCurso()
{
   int restricoes = 0;
      
   if ( ! problemData->parametros->min_doutores )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   // Agrupando os professores que ministram disciplinas de cada curso
   std::map< Curso *, GGroup< Professor *,
      LessPtr< Professor > > > mapCursoProfessores;

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
      {
         Aula * aula = ( *it_aula );
         Disciplina * disciplina = aula->getDisciplina();

         std::pair< int, int > professor_disciplina (
            professor->getId(), disciplina->getId() );

         // Se o professor e a disciplina da aula em questão se relacionarem
         if ( problemData->prof_Disc_Dias.find( professor_disciplina )
            == problemData->prof_Disc_Dias.end() )
         {
            continue;
         }

         ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
         {
            Oferta * oferta = ( *it_oferta );

            mapCursoProfessores[ oferta->curso ].add( professor );
         }
      }
   }

   std::map< Curso *, GGroup< Professor *, LessPtr< Professor > > >::iterator
      it_map = mapCursoProfessores.begin();

   for (; it_map != mapCursoProfessores.end();
          it_map++ )
   {
        Curso * curso = it_map->first;

		c.reset();
		c.setType( ConstraintOp::C_MIN_DOUT_CURSO );
		c.setCurso( curso );

		cit = cHashOp.find( c );

		if ( cit == cHashOp.end() )
		{			
			GGroup< Professor *, LessPtr< Professor > > professores_curso
				= it_map->second;

			sprintf( name, "%s", c.toString().c_str() );
			nnz = professores_curso.size();
			rhs = 0;

			OPT_ROW row( nnz, OPT_ROW::GREATER, rhs, name );

			// professores reais
			ITERA_GGROUP_LESSPTR( it_prof, professores_curso, Professor )
			{
				Professor * professor = ( *it_prof );

				// Recupera os professores que estão associados ao curso, e que são doutores
				VariableOpHash::iterator vit_find = vHashOp.begin();

				for (; vit_find != vHashOp.end(); vit_find++ )
				{
				   VariableOp v_find = vit_find->first;

				   if ( v_find.getType() == VariableOp::V_PROF_CURSO
					  && v_find.getCurso() == curso
					  && v_find.getProfessor() == professor
					  && professor->getTitulacaoId() >= 5 )
				   {
					  row.insert( vit_find->second, 1.0 );
				   }
				}
			}

			// Variavel npvd_{c}
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_DOUT_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, 1.0 );
			}

			double minPercDoutor = ( curso->regra_min_doutores.second / 100.0 );
        
			// Variavel np_{c}
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -minPercDoutor );
			}	
			
			// Variavel npv_{c}
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -minPercDoutor );
			}
			
			if ( row.getnnz() != 0 )
			{
				cHashOp[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
   }

   return restricoes;
}

int SolverMIP::criaRestricaoMaximoNaoMestresCurso()
{
   int restricoes = 0;
      
   if ( ! problemData->parametros->min_mestres )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   // Agrupando os professores que ministram disciplinas de cada curso
   std::map< Curso *, GGroup< Professor *,
      LessPtr< Professor > > > mapCursoProfessores;

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
      {
         Aula * aula = ( *it_aula );
         Disciplina * disciplina = aula->getDisciplina();

         std::pair< int, int > professor_disciplina (
            professor->getId(), disciplina->getId() );

         // Se o professor e a disciplina da aula em questão se relacionarem
         if ( problemData->prof_Disc_Dias.find( professor_disciplina )
            == problemData->prof_Disc_Dias.end() )
         {
            continue;
         }

         ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
         {
            Oferta * oferta = ( *it_oferta );

            mapCursoProfessores[ oferta->curso ].add( professor );
         }
      }
   }

   std::map< Curso *, GGroup< Professor *, LessPtr< Professor > > >::iterator
      it_map = mapCursoProfessores.begin();

   for (; it_map != mapCursoProfessores.end();
          it_map++ )
   {
        Curso * curso = it_map->first;

		c.reset();
		c.setType( ConstraintOp::C_MAX_NAO_MEST_CURSO );
		c.setCurso( curso );

		cit = cHashOp.find( c );

		if ( cit == cHashOp.end() )
		{
			GGroup< Professor *, LessPtr< Professor > > professores_curso
				= it_map->second;

			sprintf( name, "%s", c.toString().c_str() );
			nnz = professores_curso.size();
			rhs = 0.0;

			OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );
				  
			ITERA_GGROUP_LESSPTR( it_prof, professores_curso, Professor )
			{
				Professor * professor = ( *it_prof );
				
				// Recupera os professores que estão associados ao curso, e que são menos que mestres
				VariableOpHash::iterator vit_find = vHashOp.begin();

				for (; vit_find != vHashOp.end(); vit_find++ )
				{
				   VariableOp v_find = vit_find->first;

				   if ( v_find.getType() == VariableOp::V_PROF_CURSO
					  && v_find.getCurso() == curso
					  && v_find.getProfessor() == professor
					  && ( professor->getTitulacaoId() < 4 ) )
				   {
					  row.insert( vit_find->second, 1.0 );
				   }
				}
			}

			double minPercMestre = ( curso->regra_min_mestres.second / 100.0 );
        
			// Variavel np_{c}
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -(1-minPercMestre) );
			}

			// Variavel npv_{c}			
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -(1-minPercMestre) );
			}
			
			if ( row.getnnz() > 2 )
			{
				cHashOp[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
        }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoMaximoNaoDoutoresCurso()
{
   int restricoes = 0;
      
   if ( ! problemData->parametros->min_doutores )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   // Agrupando os professores que ministram disciplinas de cada curso
   std::map< Curso *, GGroup< Professor *,
      LessPtr< Professor > > > mapCursoProfessores;

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
      {
         Aula * aula = ( *it_aula );
         Disciplina * disciplina = aula->getDisciplina();

         std::pair< int, int > professor_disciplina (
            professor->getId(), disciplina->getId() );

         // Se o professor e a disciplina da aula em questão se relacionarem
         if ( problemData->prof_Disc_Dias.find( professor_disciplina )
            == problemData->prof_Disc_Dias.end() )
         {
            continue;
         }

         ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
         {
            Oferta * oferta = ( *it_oferta );

            mapCursoProfessores[ oferta->curso ].add( professor );
         }
      }
   }

   std::map< Curso *, GGroup< Professor *, LessPtr< Professor > > >::iterator
      it_map = mapCursoProfessores.begin();

   for (; it_map != mapCursoProfessores.end();
          it_map++ )
   {
        Curso * curso = it_map->first;

		c.reset();
		c.setType( ConstraintOp::C_MAX_NAO_DOUT_CURSO );
		c.setCurso( curso );

		cit = cHashOp.find( c );

		if ( cit == cHashOp.end() )
		{
			GGroup< Professor *, LessPtr< Professor > > professores_curso
				= it_map->second;

			sprintf( name, "%s", c.toString().c_str() );
			nnz = professores_curso.size();
			rhs = 0.0;

			OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );
				  
			ITERA_GGROUP_LESSPTR( it_prof, professores_curso, Professor )
			{
				Professor * professor = ( *it_prof );
				
				// Recupera os professores que estão associados ao curso, e que são menos que doutores
				VariableOpHash::iterator vit_find = vHashOp.begin();
				for (; vit_find != vHashOp.end(); vit_find++ )
				{
				   VariableOp v_find = vit_find->first;

				   if ( v_find.getType() == VariableOp::V_PROF_CURSO
					  && v_find.getCurso() == curso
					  && v_find.getProfessor() == professor
					  && professor->getTitulacaoId() < 5 )
				   {
					  row.insert( vit_find->second, 1.0 );
				   }
				}
			}

			double minPercDout = ( curso->regra_min_doutores.second / 100.0 );
        
			// Variavel np_{c}
			VariableOp v;
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -(1-minPercDout) );
			}

			// Variavel npv_{c}			
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -(1-minPercDout) );
			}
						
			if ( row.getnnz() > 2 )
			{
				cHashOp[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
        }
   }

   return restricoes;
}


int SolverMIP::criaRestricaoAlocacaoProfessorCurso()
{
	int restricoes = 0;
	int nnz = 0;
	double rhs = 0.0;
	char name[ 200 ];
	int bigM = 1000;

	ConstraintOp c;
	VariableOpHash::iterator vit;
	VariableOpHash::iterator vit_f;
	ConstraintOpHash::iterator cit;

	// Informando quais cursos estão associadas a cada aula
	std::map< std::pair<int, Disciplina*>, GGroup< Curso *,
			LessPtr< Curso > > > mapAulaCurso;

	ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
	{
		Aula * aula = ( *it_aula );
		std::pair<int, Disciplina*> par( aula->getTurma(), aula->getDisciplina() );

		ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
		{
			Oferta * oferta = ( *it_oferta );

			mapAulaCurso[ par ].add( oferta->curso );
		}
	}

	vit = vHashOp.begin();

	while(vit != vHashOp.end())
	{
		VariableOp v = ( vit->first );

		if (v.getType() != VariableOp::V_PROF_CURSO)
		{
			vit++;
			continue;
		}

		c.reset();
		c.setType( ConstraintOp::C_ALOC_PROF_CURSO );
		c.setProfessor( v.getProfessor() );
		c.setCurso( v.getCurso() );

		cit = cHashOp.find(c);
		if ( cit == cHashOp.end() )
		{
			cHashOp[ c ] = lp->getNumRows();

			sprintf( name, "%s", c.toString().c_str() );
			OPT_ROW row( 100, OPT_ROW::GREATER, rhs, name );

			row.insert( vit->second, bigM );

			lp->addRow( row );
			restricoes++;
		}
		else
		{
			lp->chgCoef(cit->second, vit->second, 1.0);
		}

		vit++;
	}

	vit = vHashOp.begin();

	while(vit != vHashOp.end())
	{
		VariableOp v = ( vit->first );

		if (v.getType() != VariableOp::V_Y_PROF_DISCIPLINA)
		{
			vit++;
			continue;
		}

		std::pair<int, Disciplina*> par( v.getTurma(), v.getDisciplina() );

		GGroup< Curso *, LessPtr< Curso > > cursos = mapAulaCurso[ par ];
		for(GGroup< Curso *, LessPtr< Curso > >::iterator itC = cursos.begin();
			itC != cursos.end();
			itC++)
		{
			c.reset();
			c.setType( ConstraintOp::C_ALOC_PROF_CURSO );
			c.setProfessor( v.getProfessor() );
			c.setCurso( *itC );

			cit = cHashOp.find(c);
			if ( cit != cHashOp.end() )
			{
				lp->chgCoef(cit->second, vit->second, -1.0);
			}
		}

		vit++;
	}

	return restricoes;
}

//int SolverMIP::criaRestricaoAlocacaoProfessorCurso()
//{
//   int restricoes = 0;
//   int nnz = 0;
//   double rhs = 0.0;
//   char name[ 200 ];
//   int bigM = 1000;
//
//   ConstraintOp c;
//   VariableOpHash::iterator vit;
//   VariableOpHash::iterator vit_f;
//   ConstraintOpHash::iterator cit;
//
//   // Informando quais disciplinas estão associadas a cada curso
//   std::map< Curso *, GGroup< Disciplina *,
//      LessPtr< Disciplina > > > mapCursoDisciplinas;
//
//   ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
//   {
//      Aula * aula = ( *it_aula );
//
//      ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
//      {
//         Oferta * oferta = ( *it_oferta );
//
//         mapCursoDisciplinas[ oferta->curso ].add( aula->getDisciplina() );
//      }
//   }
//
//   GGroup< Professor *, LessPtr< Professor > > professores
//      = problemData->getProfessores();
//
//   int totalCursos = problemData->cursos.size();
//   int totalProfessores = professores.size();
//
//   ITERA_GGROUP_LESSPTR( itProf, professores, Professor )
//   {
//      Professor * professor = ( *itProf );
//
//      ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
//      {
//         Curso * curso = ( *itCurso );
//
//         VariableOp v;
//         v.reset();
//
//         v.setType( VariableOp::V_PROF_CURSO );
//         v.setProfessor( professor );
//         v.setCurso( curso );
//         vit = vHashOp.find( v );
//
//         if ( vit != vHashOp.end() )
//         {
//            // Cria a restriçao de m ( p, c ) * M >= E ( E ( y( p, d, i ) ) )
//            c.reset();
//            c.setType( ConstraintOp::C_ALOC_PROF_CURSO );
//
//            c.setProfessor( v.getProfessor() );
//            c.setCurso( v.getCurso() );
//
//            cit = cHashOp.find( c );
//
//            if ( cit == cHashOp.end() )
//            {
//               sprintf( name, "%s", c.toString().c_str() );
//               nnz = ( totalProfessores + totalCursos );
//
//               OPT_ROW row( nnz, OPT_ROW::GREATER, rhs, name );
//               row.insert( vit->second, bigM );
//
//               VariableOpHash::iterator vit_find = vHashOp.begin();
//
//               for (; vit_find != vHashOp.end(); vit_find++ )
//               {
//                  VariableOp v_find = vit_find->first;
//
//                  if ( v_find.getType() == VariableOp::V_Y_PROF_DISCIPLINA 
//                        && v_find.getProfessor() == professor )
//                  {
//                     // Verifica se a disciplina da variável está associada ao curso
//                     GGroup< Disciplina *, LessPtr< Disciplina > >::iterator
//                        it_find = mapCursoDisciplinas[ curso ].find( v_find.getDisciplina() );
//
//                     if ( it_find != mapCursoDisciplinas[ curso ].end() )
//                     {
//                        row.insert( vit_find->second, -1.0 );
//                     }
//                  }
//               }
//
//               cHashOp[ c ] = lp->getNumRows();
//               lp->addRow( row );
//
//               restricoes++;
//            }
//         }
//      }
//   }
//
//   return restricoes;
//}


int SolverMIP::criaRestricaoCargaHorariaMinimaProfessor()
{
   int restricoes = 0;
   int nnz = problemData->aulas.size();
   double rhs;
   char name[ 200 ];

   if ( nnz == 0 || !problemData->parametros->evitar_reducao_carga_horaria_prof )
   {
      return restricoes;
   }

   double percMaxReducaoCHP = problemData->parametros->perc_max_reducao_CHP;

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );
	        
      c.reset();
      c.setType( ConstraintOp::C_CARGA_HOR_MIN_PROF );
      c.setProfessor( professor );

      cit = cHashOp.find( c );

      if ( cit == cHashOp.end() )
      {
         sprintf( name, "%s", c.toString().c_str() );
         rhs = professor->getChAnterior() * ( 1 - percMaxReducaoCHP/100 );

         OPT_ROW row( nnz, OPT_ROW::GREATER, rhs, name );
         
         vit = vHashOp.begin();

         for (; vit != vHashOp.end(); vit++ )
         {
            VariableOp v = vit->first;

            if ( v.getType() == VariableOp::V_Y_PROF_DISCIPLINA
               && v.getProfessor() == professor )
            {
				double val = v.getDisciplina()->getTotalCreditos();
                row.insert( vit->second, val );
            }
			else if ( v.getType() == VariableOp::V_F_CARGA_HOR_MIN_PROF
					&& v.getProfessor() == professor )
			{   
				row.insert( vit->second, 1.0 ); // Insere a variável de folga na restrição
			}
         }
         
		 if ( row.getnnz() != 0 )
		 {
			cHashOp[ c ] = lp->getNumRows();
			lp->addRow( row );
		    restricoes++;
		 }
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoCargaHorariaMinimaProfessorSemana()
{
   int restricoes = 0;
   int nnz = problemData->aulas.size();
   double rhs;
   char name[ 200 ];

   if ( nnz == 0 )
   {
      return restricoes;
   }

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      c.reset();
      c.setType( ConstraintOp::C_CARGA_HOR_MIN_PROF_SEMANA );
      c.setProfessor( professor );

      cit = cHashOp.find( c );

      if ( cit == cHashOp.end() )
      {
         sprintf( name, "%s", c.toString().c_str() );
         rhs = ( professor->getChMin() > 0 ? professor->getChMin() : 1 );

         OPT_ROW row( nnz, OPT_ROW::GREATER, rhs, name );

         vit = vHashOp.begin();

         for (; vit != vHashOp.end(); vit++ )
         {
            VariableOp v = vit->first;

            if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR
                  && v.getProfessor() == professor )
            {
               // Verifica se o professor está alocado a essa disciplina
               bool encontrou = false;

               GGroup< std::pair< Aula *, Disciplina * > >::iterator
                  it_disciplinas = problemData->mapProfessorDisciplinas[ professor ].begin();

               for (; it_disciplinas != problemData->mapProfessorDisciplinas[ professor ].end();
                      it_disciplinas++ )
               {
                  if ( ( *it_disciplinas ).second == v.getDisciplina() )
                  {
                     encontrou = true;
                     break;
                  }
               }

               if ( encontrou )
               {
                  double totalCreditos = ( v.getAula()->getTotalCreditos() );

                  row.insert( vit->second, totalCreditos );
               }
               ///////
            }
         }

         // Insere a variável de folga na restrição
         VariableOp v;
         v.reset();
         v.setType( VariableOp::V_F_CARGA_HOR_MIN_PROF_SEMANA );
         v.setProfessor( professor );

         vit = vHashOp.find( v );

         if ( vit != vHashOp.end() )
         {
            row.insert( vit->second, 1.0 );
         }
         ///////

         cHashOp[ c ] = lp->getNumRows();
         lp->addRow( row );

         restricoes++;
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoCargaHorariaMaximaProfessorSemana()
{
   int restricoes = 0;
   int nnz = problemData->aulas.size();
   double rhs;
   char name[ 200 ];

   if ( nnz == 0 )
   {
      return restricoes;
   }

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      c.reset();
      c.setType( ConstraintOp::C_CARGA_HOR_MAX_PROF_SEMANA );
      c.setProfessor( professor );

      cit = cHashOp.find( c );

      if ( cit == cHashOp.end() )
      {
         sprintf( name, "%s", c.toString().c_str() );
         rhs = ( professor->getChMax() > 0 ? professor->getChMax() : 1 );

         OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

         vit = vHashOp.begin();

         for (; vit != vHashOp.end(); vit++ )
         {
            VariableOp v = vit->first;

            if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR
               && v.getProfessor() == professor )
            {
               // Verifica se o professor está alocado a essa disciplina
               bool encontrou = false;

               GGroup< std::pair< Aula *, Disciplina * > >::iterator
                  it_disciplinas = problemData->mapProfessorDisciplinas[ professor ].begin();

               for (; it_disciplinas != problemData->mapProfessorDisciplinas[ professor ].end();
                      it_disciplinas++ )
               {
                  if ( ( *it_disciplinas ).second == v.getDisciplina() )
                  {
                     encontrou = true;
                     break;
                  }
               }

               if ( encontrou )
               {
                  double totalCreditos = ( v.getAula()->getTotalCreditos() );

                  row.insert( vit->second, totalCreditos );
               }
            }
         }

         // Insere a variável de folga na restrição
         VariableOp v;
         v.reset();
         v.setType( VariableOp::V_F_CARGA_HOR_MAX_PROF_SEMANA );
         v.setProfessor( professor );

         vit = vHashOp.find( v );

         if ( vit != vHashOp.end() )
         {
            row.insert( vit->second, -1.0 );
         }

         cHashOp[ c ] = lp->getNumRows();
         lp->addRow( row );

         restricoes++;
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoAvaliacaoCorpoDocente()
{
   int restricoes = 0;
   int nnz = 0;
   double rhs = 0.0;
   char name[ 200 ];
   double M = 1000000;

   ConstraintOp c;
   VariableOp v_find;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   // Informa quantas variáveis 'y' foram criadas para cada professor.
   // Esse valor será o 'nnz' das restrições desse professor
   std::map< Professor *, int > mapProfessorVariaveis;

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );
      mapProfessorVariaveis[ professor ] = 1;

      vit = vHashOp.begin();
      for (; vit != vHashOp.end(); vit++ )
      {
         if ( vit->first.getType() == VariableOp::V_Y_PROF_DISCIPLINA
            && vit->first.getProfessor() == professor )
         {
            mapProfessorVariaveis[ professor ]++;
         }
      }
   }

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      c.reset();
      c.setType( ConstraintOp::C_AVALIACAO_CORPO_DOCENTE );
      c.setProfessor( professor );

      if ( cHashOp.find( c ) == cHashOp.end() )
      {
         // Cria duas novas linhas no modelo
         sprintf( name, "%s", c.toString().c_str() );

         // Total de variáveis 'y' do professor mais um ( que
         // corresponde ao lado direito da desigualdade no modelo )
         nnz = mapProfessorVariaveis[ professor ];

         if ( nnz == 0 )
         {
            continue;
         }

         OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

         // Procura pela variável 'l' do professor
         v_find.reset();
         v_find.setType( VariableOp::V_AVALIACAO_CORPO_DOCENTE );
         v_find.setProfessor( professor );

         vit = vHashOp.find( v_find );

         if ( vit == vHashOp.end() )
         {
            continue;
         }
      
         VariableOp v = vit->first;

         // Insere a variável 'l' nas restrições
         row.insert( vit->second, -1000.0 );
         ///////

         // Cada varíável 'y' do professor
         // insere um índice nas restrições
         vit = vHashOp.begin();
         for (; vit != vHashOp.end(); vit++ )
         {
            if ( vit->first.getType() == VariableOp::V_Y_PROF_DISCIPLINA
               && vit->first.getProfessor() == professor )
            {
               row.insert( vit->second, 1.0 );
            }
         }
         ///////

         cHashOp[ c ] = lp->getNumRows();
         lp->addRow( row );

         restricoes++;
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoMaxDiscProfCurso()
{
   int restricoes = 0;
   int nnz = 0;
   double rhs = 0.0;
   char name[ 200 ];
   double M = 1000000.0;

   ConstraintOp c;
   VariableOp v_find;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;

	vit = vHashOp.begin();

	while(vit != vHashOp.end())
	{
		VariableOp v = ( vit->first );

		if (v.getType() != VariableOp::V_DISC_PROF_CURSO && v.getType() != VariableOp::V_Y_PROF_DISCIPLINA
			&& v.getType() != VariableOp::V_F_MAX_DISC_PROF_CURSO)
		{
			vit++;
			continue;
		}

		if(v.getType() == VariableOp::V_DISC_PROF_CURSO)
		{
			c.reset();
			c.setType( ConstraintOp::C_MAX_DISC_PROF_CURSO );
			c.setProfessor( v.getProfessor() );
			c.setCurso( v.getCurso() );
			c.setDisciplina( v.getDisciplina() );

			cit = cHashOp.find(c);
			if ( cit == cHashOp.end() )
			{
				cHashOp[ c ] = lp->getNumRows();

				sprintf( name, "%s", c.toString().c_str() );
				OPT_ROW row( 100, OPT_ROW::LESS, 0.0, name );

				double M = ( v.getDisciplina()->getCredTeoricos() + v.getDisciplina()->getCredPraticos() );
				row.insert( vit->second, -M );

				lp->addRow( row );
				restricoes++;
			}
			else
			{
				double M = ( v.getDisciplina()->getCredTeoricos() + v.getDisciplina()->getCredPraticos() );
				lp->chgCoef(cit->second, vit->second, -M);
			}

			c.reset();
			c.setType( ConstraintOp::C_MAX_DISC_PROF_CURSO2 );
			c.setProfessor( v.getProfessor() );
			c.setCurso( v.getCurso() );

			cit = cHashOp.find(c);
			if ( cit == cHashOp.end() )
			{
				cHashOp[ c ] = lp->getNumRows();

				sprintf( name, "%s", c.toString().c_str() );
				rhs = v.getCurso()->getQtdMaxProfDisc();
				OPT_ROW row( 100, OPT_ROW::LESS, rhs, name );

				double M = ( v.getDisciplina()->getCredTeoricos() + v.getDisciplina()->getCredPraticos() );
				row.insert( vit->second, 1.0 );

				lp->addRow( row );
				restricoes++;
			}
			else
			{
				lp->chgCoef(cit->second, vit->second, 1.0);
			}
		}
		else if(v.getType() == VariableOp::V_Y_PROF_DISCIPLINA)
		{
			ITERA_GGROUP_LESSPTR( it_curso, problemData->cursos, Curso )
			{
				Curso * curso = *it_curso;

				if(!problemData->aulaAtendeCurso( v.getAula(), curso))
					continue;

				if ( !curso->possuiDisciplina( v.getDisciplina() ) )
					continue;

				c.reset();
				c.setType( ConstraintOp::C_MAX_DISC_PROF_CURSO );
				c.setProfessor( v.getProfessor() );
				c.setCurso( curso );
				c.setDisciplina( v.getDisciplina() );

				cit = cHashOp.find(c);
				if ( cit == cHashOp.end() )
				{
					cHashOp[ c ] = lp->getNumRows();

					sprintf( name, "%s", c.toString().c_str() );
					OPT_ROW row( 100, OPT_ROW::LESS, 0.0, name );

					row.insert( vit->second, 1.0 );

					lp->addRow( row );
					restricoes++;
				}
				else
				{
					lp->chgCoef(cit->second, vit->second, 1.0);
				}
			}
		}
		else if(v.getType() == VariableOp::V_F_MAX_DISC_PROF_CURSO)
		{
			c.reset();
			c.setType( ConstraintOp::C_MAX_DISC_PROF_CURSO2 );
			c.setProfessor( v.getProfessor() );
			c.setCurso( v.getCurso() );

			cit = cHashOp.find(c);
			if ( cit == cHashOp.end() )
			{
				cHashOp[ c ] = lp->getNumRows();

				sprintf( name, "%s", c.toString().c_str() );
				rhs = v.getCurso()->getQtdMaxProfDisc();
				OPT_ROW row( 100, OPT_ROW::LESS, rhs, name );

				double M = ( v.getDisciplina()->getCredTeoricos() + v.getDisciplina()->getCredPraticos() );
				row.insert( vit->second, -1.0 );

				lp->addRow( row );
				restricoes++;
			}
			else
			{
				lp->chgCoef(cit->second, vit->second, -1.0);
			}
		}

		vit++;
	}


	return restricoes;
}

//int SolverMIP::criaRestricaoMaxDiscProfCurso()
//{
//   int restricoes = 0;
//   int nnz = 0;
//   double rhs = 0.0;
//   char name[ 200 ];
//   double M = 1000000.0;
//
//   ConstraintOp c;
//   VariableOp v_find;
//   VariableOpHash::iterator vit;
//   ConstraintOpHash::iterator cit;
//
//   GGroup< Professor *, LessPtr< Professor > > professores
//      = problemData->getProfessores();
//
//   GGroup< Disciplina *, LessPtr< Disciplina > > disciplinas
//      = problemData->disciplinas;
//
//   GGroup< Curso *, LessPtr< Curso > > cursos
//      = problemData->cursos;
//
//   GGroup< Aula *, LessPtr< Aula > > aulas
//      = problemData->aulas;
//
//   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
//   {
//      Professor * professor = ( *it_prof );
//      
//      ITERA_GGROUP_LESSPTR( it_curso, cursos, Curso )
//      {
//         Curso * curso = ( *it_curso );
//
//         c.reset();
//         c.setType( ConstraintOp::C_MAX_DISC_PROF_CURSO );
//
//         c.setProfessor( professor );
//         c.setCurso( curso );
//
//         if ( cHashOp.find( c ) == cHashOp.end() )
//         {
//            sprintf( name, "%s", c.toString().c_str() );
//
//            ITERA_GGROUP_LESSPTR( it_disc, disciplinas, Disciplina )
//            {
//               Disciplina * disciplina = ( *it_disc );
//
//			   if ( !curso->possuiDisciplina( disciplina ) )
//					continue;
//
//               // Procura pela variável 'Lpcd'
//               v_find.reset();
//               v_find.setType( VariableOp::V_DISC_PROF_CURSO );
//
//               v_find.setProfessor( professor );
//               v_find.setCurso( curso );
//               v_find.setDisciplina( disciplina );
//
//               vit = vHashOp.find( v_find );
//
//               if ( vit == vHashOp.end() )
//               {
//                  continue;
//               }
//
//               // Hash da variável 'Lpcd'
//               int idHashVLpcd = vit->second;
//               ///////
//
//               // Sum[ Xpah ] - ( M * Lpcd ) <= 0
//               rhs = 0.0;
//               nnz = ( disciplina->getCredTeoricos() + disciplina->getCredPraticos() + 1 );
//
//               OPT_ROW row1( nnz, OPT_ROW::LESS, rhs, name );
//
//               // Máximo de horários que a disciplina pode ocupar
//               M = ( disciplina->getCredTeoricos() + disciplina->getCredPraticos() );
//
//               // ( - M * Lpcd )
//               row1.insert( idHashVLpcd, -M );
//
//               vit = vHashOp.begin();
//               for (; vit != vHashOp.end(); vit++ )
//               {
//                  if ( vit->first.getType() == VariableOp::V_Y_PROF_DISCIPLINA
//                     && vit->first.getProfessor() == professor
//                     && vit->first.getDisciplina() == disciplina )
//                  {
//                     if ( problemData->aulaAtendeCurso( vit->first.getAula(), curso ) )
//                     {
//                        // Sum[ Xpah ]
//                        row1.insert( vit->second, 1.0 );
//                     }
//                  }
//               }
//
//               lp->addRow( row1 );
//               ///////
//            }
//
//            // SUM[ Lpcd ] - SUM[ LpcdSlack ] <= MaxDiscCurso
//            rhs = curso->getQtdMaxProfDisc();
//            nnz = ( 2 * disciplinas.size() );
//
//            OPT_ROW row2( nnz, OPT_ROW::LESS, rhs, name );
//
//            vit = vHashOp.begin();
//            for (; vit != vHashOp.end(); vit++ )
//            {
//               if ( vit->first.getType() == VariableOp::V_DISC_PROF_CURSO
//                  && vit->first.getProfessor() == professor
//                  && vit->first.getCurso() == curso )
//               {
//                  // Sum[ Lpcd ]
//                  row2.insert( vit->second, 1.0 );
//               }
//
//               if ( vit->first.getType() == VariableOp::V_F_MAX_DISC_PROF_CURSO
//                  && vit->first.getProfessor() == professor
//                  && vit->first.getCurso() == curso )
//               {
//                  // - SUM[ LpcdSlack ]
//                  row2.insert( vit->second, -1.0 );
//               }
//            }
//
//            lp->addRow( row2 );
//            ///////
//
//            cHashOp[ c ] = lp->getNumRows();
//            restricoes++;
//         }
//      }
//   }
//
//   return restricoes;
//}

int SolverMIP::criaRestricaoDeslocamentoProfessor()
{
   int restricoes = 0;
   int nnz = 2;
   double rhs = 1.0;
   char name[ 200 ];

   if ( problemData->tempo_campi.size() == 0
      || problemData->tempo_unidades.size() == 0 )
   {
      return restricoes;
   }

   ConstraintOp c;
   VariableOpHash::iterator vit1;
   VariableOpHash::iterator vit2;

   // Hash que armazena apenas as variáveis 'Xpah'
   VariableOpHash hashX;
   vit1 = vHashOp.begin();

   for (; vit1 != vHashOp.end(); vit1++ )
   {
      if ( vit1->first.getType() == VariableOp::V_X_PROF_AULA_HOR )
      {
		  if ( ! vit1->first.getProfessor()->eVirtual() )
			 hashX[ vit1->first ] = vit1->second;
      }
   }

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      c.reset();
      c.setType( ConstraintOp::C_DESLOC_PROF );
      c.setProfessor( professor );

      if ( cHashOp.find( c ) == cHashOp.end() )
      {
         sprintf( name, "%s", c.toString().c_str() );

         vit1 = hashX.begin();
         for (; vit1 != hashX.end(); vit1++ )
         {
            VariableOp v1 = vit1->first;
            int idUnidade1 = v1.getSala()->getIdUnidade();

            vit2 = hashX.begin();
            for (; vit2 != hashX.end(); vit2++ )
            {
               VariableOp v2 = vit2->first;
               int idUnidade2 = v2.getSala()->getIdUnidade();

               if ( v1 == v2 || idUnidade1 == idUnidade2
                  || v1.getHorario()->getDia() != v2.getHorario()->getDia()
                  || v1.getProfessor() != professor
                  || v2.getProfessor() != professor )
               {
                  continue;
               }

               Unidade * unidade1 = problemData->refUnidade[ idUnidade1 ];
               Campus * campus1 = problemData->refCampus[ unidade1->getIdCampus() ];

               Unidade * unidade2 = problemData->refUnidade[ idUnidade2 ];
               Campus * campus2 = problemData->refCampus[ unidade2->getIdCampus() ];

               int tempo_minimo = problemData->calculaTempoEntreCampusUnidades(
                  campus1, campus2, unidade1, unidade2 );

               int tempo_disponivel = problemData->minutosIntervalo(
                  v1.getHorario()->getHorarioAula()->getInicio(),
                  v2.getHorario()->getHorarioAula()->getInicio() );

               if ( tempo_minimo > tempo_disponivel )
               {
                  // Cria a restrição 'Xpah1 + Xpah2 <= 1'
                  // --> Aloca no máximo uma das aulas ao professor
                  OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

                  row.insert( vit1->second, 1.0 );
                  row.insert( vit2->second, 1.0 );

                  lp->addRow( row );
               }
            }
         }

         cHashOp[ c ] = lp->getNumRows();
         restricoes++;
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoDeslocamentoViavel()
{
   int restricoes = 0;
   int nnz = 2;
   double rhs = 1.0;
   char name[ 200 ];

   if ( problemData->tempo_campi.size() == 0
      || problemData->tempo_unidades.size() == 0 )
   {
      return restricoes;
   }

   ConstraintOp c;
   VariableOpHash::iterator vit1;
   VariableOpHash::iterator vit2;

   // Hash que armazena apenas as variáveis 'Xpah'
   VariableOpHash hashX;
   vit1 = vHashOp.begin();

   for (; vit1 != vHashOp.end(); vit1++ )
   {
      if ( vit1->first.getType() == VariableOp::V_X_PROF_AULA_HOR )
      {
		  if ( ! vit1->first.getProfessor()->eVirtual() )
			 hashX[ vit1->first ] = vit1->second;
      }
   }

    GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   vit1 = hashX.begin();

   for (; vit1 != hashX.end(); vit1++ )
   {
      VariableOp v1 = vit1->first;
      int idUnidade1 = v1.getSala()->getIdUnidade();
      Aula * aula1 = v1.getAula();

      c.reset();
      c.setType( ConstraintOp::C_DESLOC_VIAVEL );
      c.setAula( aula1 );

      if ( cHashOp.find( c ) == cHashOp.end() )
      {
         sprintf( name, "%s", c.toString().c_str() );

         vit2 = hashX.begin();
         for (; vit2 != hashX.end(); vit2++ )
         {
            VariableOp v2 = vit2->first;
            int idUnidade2 = v2.getSala()->getIdUnidade();
            Aula * aula2 = v2.getAula();

            if ( v1 == v2 || idUnidade1 == idUnidade2
               || v1.getHorario()->getDia() != v2.getHorario()->getDia() )
            {
               continue;
            }

            ITERA_GGROUP_LESSPTR( it_oferta1, aula1->ofertas, Oferta )
            {
               Oferta * oferta1 = ( *it_oferta1 );
               Curriculo * curriculo1 = oferta1->curriculo;
            
               ITERA_GGROUP_LESSPTR( it_oferta2, aula2->ofertas, Oferta )
               {
                  Oferta * oferta2 = ( *it_oferta2 );
                  Curriculo * curriculo2 = oferta2->curriculo;

                  if ( curriculo1 == curriculo2 )
                  {
                     continue;
                  }

                  Unidade * unidade1 = problemData->refUnidade[ idUnidade1 ];
                  Campus * campus1 = problemData->refCampus[ unidade1->getIdCampus() ];

                  Unidade * unidade2 = problemData->refUnidade[ idUnidade2 ];
                  Campus * campus2 = problemData->refCampus[ unidade2->getIdCampus() ];

                  int tempo_minimo = problemData->calculaTempoEntreCampusUnidades(
                     campus1, campus2, unidade1, unidade2 );

                  int tempo_disponivel = problemData->minutosIntervalo(
                     v1.getHorario()->getHorarioAula()->getInicio(),
                     v2.getHorario()->getHorarioAula()->getInicio() );

                  if ( tempo_minimo > tempo_disponivel )
                  {
                     // Cria a restrição 'Xpah1 + Xpah2 <= 1'
                     // --> Aloca no máximo uma das aulas ao professor
                     OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

                     row.insert( vit1->second, 1.0 );
                     row.insert( vit2->second, 1.0 );

                     lp->addRow( row );
                  }
               }
            }
         }

         cHashOp[ c ] = lp->getNumRows();
         restricoes++;
      }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoUltimaPrimeiraAulas()
{
   int restricoes = 0;

   if ( ! problemData->parametros->evitar_prof_ultimo_primeiro_hr )
   {
		return restricoes;
   }

   int nnz = 100;
   double rhs = 1.0;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit1;
   VariableOpHash::iterator vit2;
   VariableOpHash::iterator vitSlack;

   map< Professor*, map< HorarioDia*, vector< VariableOpHash::iterator > , LessPtr < HorarioDia > >, LessPtr< Professor > > mapPrimeirasAulas;
   map< Professor*, map< HorarioDia*, vector< VariableOpHash::iterator > , LessPtr < HorarioDia > >, LessPtr< Professor > > mapUltimassAulas;
   
   vit1 = vHashOp.begin();

   for (; vit1 != vHashOp.end(); vit1++ )
   {
	   if ( vit1->first.getType() == VariableOp::V_X_PROF_AULA_HOR && !vit1->first.getProfessor()->eVirtual() )
      {
		  VariableOp v = vit1->first;

		  if( problemData->verificaPrimeiraAulas(v.getHorario()) )
			  mapPrimeirasAulas[v.getProfessor()][v.getHorario()].push_back(vit1);
		  else
		  {
			  int nCreds = v.getAula()->getTotalCreditos();
			  HorarioAula *hai = v.getHorarioAula();
			  HorarioAula *haf = hai->getCalendario()->addNCredsHorario( hai, nCreds-1 );
			  HorarioDia *ha = problemData->getHorarioDiaCorrespondente( haf, v.getDia() );
			  if( problemData->verificaUltimaAulas( ha ) )
				mapUltimassAulas[v.getProfessor()][v.getHorario()].push_back(vit1);
		  }
      }
   }

   map< Professor*, map< HorarioDia*, vector< VariableOpHash::iterator > , LessPtr < HorarioDia > >, LessPtr< Professor > >::iterator itP1 = mapPrimeirasAulas.begin();
   for(; itP1 != mapPrimeirasAulas.end(); itP1++)
   {
	   Professor *professor = itP1->first;

	   map< HorarioDia*, vector< VariableOpHash::iterator > , LessPtr < HorarioDia > >::iterator itP2 = itP1->second.begin();
	   for(; itP2 != itP1->second.end(); itP2++)
	   {
		   HorarioDia *horario1 = itP2->first; // primeiro horario do segundo dia

		   map< HorarioDia*, vector< VariableOpHash::iterator > , LessPtr < HorarioDia > > mapTemp = mapUltimassAulas[professor];
		   map< HorarioDia*, vector< VariableOpHash::iterator > , LessPtr < HorarioDia > >::iterator itU1 = mapTemp.begin();
		   for(; itU1 != mapTemp.end(); itU1++)
		   {
			   HorarioDia *horario2 = itU1->first; // ultimo horario do primeiro dia

			   if ( horario1->getDia() - horario2->getDia() != 1 )
				   continue;

			   c.reset();
			   c.setType( ConstraintOp::C_ULTIMA_PRIMEIRA_AULA_PROF );
			   c.setProfessor( professor );
			   c.setHorarioDiaD( horario1 );
			   c.setHorarioDiaD1( horario2 );

			   if ( cHashOp.find( c ) != cHashOp.end() )
				   continue;

			   sprintf( name, "%s", c.toString().c_str() );

			   cHashOp[ c ] = lp->getNumRows();
			   restricoes++;

			   OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

			   vector< VariableOpHash::iterator > vars = itP2->second;

			   for(vector< VariableOpHash::iterator >::iterator itV = vars.begin();
				   itV != vars.end();
				   itV++)
			   {
				   VariableOpHash::iterator vit = *itV;
				   row.insert(vit->second, 1.0);
			   }

			   vars = itU1->second;

			   for(vector< VariableOpHash::iterator >::iterator itV = vars.begin();
				   itV != vars.end();
				   itV++)
			   {
				   VariableOpHash::iterator vit = *itV;
				   row.insert(vit->second, 1.0);
			   }


			   // Adiciona a variável de folga
			   VariableOp vSlack;
			   vSlack.reset();
			   vSlack.setType( VariableOp::V_F_ULTIMA_PRIMEIRA_AULA_PROF );

			   vSlack.setProfessor( professor );
			   vSlack.setDia( horario2->getDia() ); // primeiro dia

			   vitSlack = vHashOp.find( vSlack );

			   if ( vitSlack != vHashOp.end() )
			   {
				   row.insert( vitSlack->second, -1.0 );
			   }

			   lp->addRow( row );
		   }

	   }
   }

   return restricoes;
}

//int SolverMIP::criaRestricaoUltimaPrimeiraAulas()
//{
//   int restricoes = 0;
//   int nnz = 3;
//   double rhs = 1.0;
//   char name[ 200 ];
//
//   ConstraintOp c;
//   VariableOpHash::iterator vit1;
//   VariableOpHash::iterator vit2;
//   VariableOpHash::iterator vitSlack;
//
//   // Hash que armazena apenas as variáveis 'Xpah'
//   VariableOpHash hashX;
//   vit1 = vHashOp.begin();
//
//   for (; vit1 != vHashOp.end(); vit1++ )
//   {
//      if ( vit1->first.getType() == VariableOp::V_X_PROF_AULA_HOR )
//      {
//         hashX[ vit1->first ] = vit1->second;
//      }
//   }
//   
//   vit1 = hashX.begin();
//
//   for (; vit1 != hashX.end(); vit1++ )
//   {
//      VariableOp v1 = vit1->first;
//
//      vit2 = vit1;
//      vit2++;
//
//      for (; vit2 != hashX.end(); vit2++ )
//      {
//         VariableOp v2 = vit2->first;
//
//         if ( v1.getProfessor() != v2.getProfessor() )
//         {
//            continue;
//         }
//
//         Professor * professor = ( v1.getProfessor() );
//
//         // Verifica se essas aulas ocorrem no último
//         // horário do dia D e no primeiro horário do dia ( D + 1 )
//         bool verificaAulas = problemData->verificaUltimaPrimeiraAulas(
//            v1.getHorario(), v2.getHorario() );
//
//         if ( !verificaAulas )
//         {
//            continue;
//         }
//
//         // Insere a nova restrição professor + dias + horários
//         c.reset();
//         c.setType( ConstraintOp::C_ULTIMA_PRIMEIRA_AULA_PROF );
//         c.setProfessor( professor );
//         c.setHorarioDiaD( v1.getHorario() );
//         c.setHorarioDiaD1( v2.getHorario() );
//
//         if ( cHashOp.find( c ) != cHashOp.end() )
//         {
//            continue;
//         }
//
//         sprintf( name, "%s", c.toString().c_str() );
//
//         cHashOp[ c ] = lp->getNumRows();
//         restricoes++;
//
//         // Cria a restrição 'Xpah1 + Xpah2 <= 1'
//         // --> Aloca no máximo uma das aulas ao professor
//         OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );
//
//         row.insert( vit1->second, 1.0 );
//         row.insert( vit2->second, 1.0 );
//
//         // Adiciona a variável de folga
//         VariableOp vSlack;
//         vSlack.reset();
//         vSlack.setType( VariableOp::V_F_ULTIMA_PRIMEIRA_AULA_PROF );
//
//         vSlack.setProfessor( professor );
//         vSlack.setHorarioDiaD( v1.getHorario() );
//         vSlack.setHorarioDiaD1( v2.getHorario() );
//
//         vitSlack = vHashOp.find( vSlack );
//
//         if ( vitSlack != vHashOp.end() )
//         {
//            row.insert( vitSlack->second, 1.0 );
//         }
//
//         // Apenar adicionamos a restrição no modelo se existir
//         // a variável de folga, para que não aconteça inviabilidades
//         lp->addRow( row );
//      }
//   }
//
//   return restricoes;
//}


int SolverMIP::criaRestricaoGapsProfessores()
{
   int restricoes = 0;

   if ( !problemData->parametros->minimizar_horarios_vazios_professor )
   {
	   return restricoes;
   }

   ConstraintOp c;
   VariableOpHash::iterator vit1;
   VariableOpHash::iterator vit2;

   const int totalHorariosAula = (int)( problemData->horarios_aula_ordenados .size() );

   // Horários * Aulas * Dias Letivos
   int nnz = ( totalHorariosAula * (int)( problemData->aulas.size() ) * 5 );
   double rhs = 1.0;
   char name[ 200 ];

   if ( nnz == 0 )
   {
      return 0;
   }

   map< Professor*, map< int, vector< VariableOpHash::iterator > >, LessPtr< Professor > > variaveisHashGapsProfessores;
   map< Professor*, map< int, vector< VariableOpHash::iterator > >, LessPtr< Professor > > variaveisHashX;

   vit1 = vHashOp.begin();

   for (; vit1 != vHashOp.end(); vit1++ )
   {
      VariableOp v = ( vit1->first );

	  if ( v.getType() == VariableOp::V_GAPS_PROFESSORES && !v.getProfessor()->eVirtual() )
      {
		  variaveisHashGapsProfessores[v.getProfessor()][v.getDia()].push_back(vit1);
      }
	  else if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR && !v.getProfessor()->eVirtual() )
      {
         variaveisHashX[v.getProfessor()][v.getDia()].push_back(vit1);
      }
   }

   map< Professor*, map< int, vector< VariableOpHash::iterator > >, LessPtr< Professor > >::iterator it1 = variaveisHashGapsProfessores.begin();
   for(; it1 != variaveisHashGapsProfessores.end(); it1++)
   {
	   Professor *professor = it1->first;

	   map< int, vector< VariableOpHash::iterator > >::iterator it2 = it1->second.begin();
	   for(; it2 != it1->second.end(); it2++)
	   {
		   int dia = it2->first;

		   vector< VariableOpHash::iterator >::iterator it3 = it2->second.begin();
		   for(; it3 != it2->second.end(); it3++)
		   {
			   vit1 = *it3;
			   VariableOp v_temp = vit1->first;

			   // Horários nos extremos do intervalo de horários
			   HorarioAula * h1 = v_temp.getH1();
			   HorarioAula * h2 = v_temp.getH2();

			   c.reset();
			   c.setType( ConstraintOp::C_GAPS_PROFESSORES );
			   c.setProfessor( professor );
			   c.setDia( dia );
			   c.setH1( h1 );
			   c.setH2( h2 );

			   if ( cHashOp.find( c ) == cHashOp.end() )
			   {
				   sprintf( name, "%s", c.toString().c_str() );

				   OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

				   // Variável do gap
				   row.insert( vit1->second, -1.0 );

				   bool inseriuVariavel = false;

				   vector< VariableOpHash::iterator > vars = variaveisHashX[professor][dia];
				   vector< VariableOpHash::iterator >::iterator it4 = vars.begin();

				   for(; it4 != vars.end(); it4++)
				   {
					   vit2 = *it4;
					   VariableOp v_x = vit2->first;

					   if ( v_x.getHorario()->getHorarioAula()->getInicio() >= h1->getInicio()
						   && v_x.getHorario()->getHorarioAula()->getInicio() <= h2->getInicio() )
					   {
						   inseriuVariavel = true;

						   // Variáveis dos horários nos extremos do intervalo
						   if ( v_x.getHorario()->getHorarioAula()->getInicio() == h1->getInicio()
							   || v_x.getHorario()->getHorarioAula()->getInicio() == h2->getInicio() )
						   {
							   row.insert( vit2->second, 1.0 );
						   }
						   // Variáveis dos horários no meio do intervalo
						   else
						   {
							   row.insert( vit2->second, -1.0 );
						   }
					   }
				   }

				   if ( inseriuVariavel )
				   {
					   cHashOp[ c ] = lp->getNumRows();
					   lp->addRow( row );
					   restricoes++;
				   }
			   }
		   }
	   }
   }

   return restricoes;
}

//int SolverMIP::criaRestricaoGapsProfessores()
//{
//   int restricoes = 0;
//
//   ConstraintOp c;
//   VariableOpHash::iterator vit1;
//   VariableOpHash::iterator vit2;
//
//   const int totalHorariosAula = (int)(
//     problemData->horarios_aula_ordenados .size() );
//
//   // Horários * Aulas * Dias Letivos
//   int nnz = ( totalHorariosAula * (int)( problemData->aulas.size() ) * 5 );
//   double rhs = 1.0;
//   char name[ 200 ];
//
//   if ( nnz == 0 )
//   {
//      return 0;
//   }
//
//   VariableOpHash variaveisHashGapsProfessores;
//   VariableOpHash variaveisHashX;
//
//   vit1 = vHashOp.begin();
//
//   for (; vit1 != vHashOp.end(); vit1++ )
//   {
//      VariableOp v = ( vit1->first );
//
//      if ( v.getType() == VariableOp::V_GAPS_PROFESSORES )
//      {
//         variaveisHashGapsProfessores[ v ] = ( vit1->second );
//      }
//      else if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR )
//      {
//         variaveisHashX[ v ] = ( vit1->second );
//      }
//   }
//
//   GGroup< Professor *, LessPtr< Professor > > professores
//      = problemData->getProfessores();
//
//   GGroup< int > dias_letivos;
//
//   for ( int i = 1; i <= 7; i++ )
//   {
//      dias_letivos.add( i );
//   }
//
//   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
//   {
//      Professor * professor = ( *it_prof );
//
//      ITERA_GGROUP_N_PT( it_dia, dias_letivos, int )
//      {
//         int dia = ( *it_dia );
//
//         vit1 = variaveisHashGapsProfessores.begin();
//
//         for (; vit1 != variaveisHashGapsProfessores.end(); vit1++ )
//         {
//            VariableOp v_temp = vit1->first;
//
//            if ( v_temp.getProfessor() == professor
//               && v_temp.getDia() == dia )
//            {
//               // Horários nos extremos do intervalo de horários
//               HorarioAula * h1 = v_temp.getH1();
//               HorarioAula * h2 = v_temp.getH2();
//
//               c.reset();
//               c.setType( ConstraintOp::C_GAPS_PROFESSORES );
//
//               c.setProfessor( professor );
//               c.setDia( dia );
//               c.setH1( h1 );
//               c.setH2( h2 );
//
//               if ( cHashOp.find( c ) == cHashOp.end() )
//               {
//                  sprintf( name, "%s", c.toString().c_str() );
//
//                  OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );
//
//                  // Variável do gap
//                  row.insert( vit1->second, -1.0 );
//
//                  bool inseriuVariavel = false;
//                  vit2 = variaveisHashX.begin();
//
//                  for (; vit2 != variaveisHashX.end(); vit2++ )
//                  {
//                     VariableOp v_x = vit2->first;
//
//                     if ( v_x.getProfessor() == professor
//                        && v_x.getHorario()->getDia() == dia 
//                        && v_x.getHorario()->getHorarioAula()->getInicio() >= h1->getInicio()
//                        && v_x.getHorario()->getHorarioAula()->getInicio() <= h2->getInicio() )
//                     {
//                        inseriuVariavel = true;
//
//                        // Variáveis dos horários nos extremos do intervalo
//                        if ( v_x.getHorario()->getHorarioAula()->getInicio() == h1->getInicio()
//                           || v_x.getHorario()->getHorarioAula()->getInicio() == h2->getInicio() )
//                        {
//                           row.insert( vit2->second, 1.0 );
//                        }
//                        // Variáveis dos horários no meio do intervalo
//                        else
//                        {
//                           row.insert( vit2->second, -1.0 );
//                        }
//                     }
//                  }
//
//                  cHashOp[ c ] = lp->getNumRows();
//
//                  if ( inseriuVariavel )
//                  {
//                     lp->addRow( row );
//                     restricoes++;
//                  }
//               }
//            }
//         }
//      }
//   }
//
//   return restricoes;
//}


void SolverMIP::buscaLocalTempoDeslocamentoSolucao()
{
   if ( this->problemData->parametros->modo_otimizacao != "OPERACIONAL" )
   {
      return;
   }

   // Dado um turno e um dia da semana, temos
   // a lista de atendimentos de cada professor
   std::map< Professor *, std::map< int, GGroup< AtendimentoBase *,
      LessPtr< AtendimentoBase > > >, LessPtr< Professor > > mapProfessorDiaAtendimentos;

   ITERA_GGROUP( it_at_campi,
      ( *this->problemSolution->atendimento_campus ), AtendimentoCampus )
   {
      Campus * campus = this->problemData->refCampus[ it_at_campi->getId() ];

      ITERA_GGROUP( it_at_unidade,
         ( *it_at_campi->atendimentos_unidades ), AtendimentoUnidade )
      {
         Unidade * unidade = this->problemData->refUnidade[ it_at_unidade->getId() ];

         ITERA_GGROUP( it_at_sala,
            ( *it_at_unidade->atendimentos_salas ), AtendimentoSala )
         {
            Sala * sala = this->problemData->refSala[ it_at_sala->getId() ];

            ITERA_GGROUP( it_at_dia,
               ( *it_at_sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
            {
               int dia_semana = it_at_dia->getDiaSemana();

               ITERA_GGROUP( it_at_turno,
                  ( *it_at_dia->atendimentos_turno ), AtendimentoTurno )
               {
                  Turno * turno = this->problemData->findTurno( it_at_turno->getTurnoId() );

                  ITERA_GGROUP( it_at_horario,
                     ( *it_at_turno->atendimentos_horarios_aula ), AtendimentoHorarioAula )
                  {
                     HorarioAula * horario_aula = this->problemData->findHorarioAula(
                        it_at_horario->getHorarioAulaId() );

                     Professor * professor = this->problemData->findProfessor(
                        it_at_horario->getProfessorId() );

                     AtendimentoBase * atendimento = new AtendimentoBase();

                     atendimento->campus = campus;
                     atendimento->unidade = unidade;
                     atendimento->sala = sala;
                     atendimento->dia_semana = dia_semana;
                     atendimento->turno = turno;
                     atendimento->horario_aula = horario_aula;
                     atendimento->professor = professor;
                     atendimento->idAtHorario = it_at_horario->getId();

                     mapProfessorDiaAtendimentos[ professor ][ dia_semana ].add( atendimento );
                  } // Horário da Aula
               } // Turno
            } // Dia da semana
         } // Sala
      } // Unidade
   } // Campus

   std::map< Professor *, std::map< int, GGroup< AtendimentoBase *,
      LessPtr< AtendimentoBase > > >, LessPtr< Professor > >::iterator
      it_map = mapProfessorDiaAtendimentos.begin();

   for (; it_map != mapProfessorDiaAtendimentos.end();
          it_map++ )
   {
      Professor * professor = it_map->first;

      std::map< int, GGroup< AtendimentoBase *,
         LessPtr< AtendimentoBase > > > professorDia = it_map->second;

      std::map< int, GGroup< AtendimentoBase *,
         LessPtr< AtendimentoBase > > >::iterator
         it_prof_dia = professorDia.begin();

      for (; it_prof_dia != professorDia.end();
             it_prof_dia++ )
      {
         int dia_semana = it_prof_dia->first;

         // Para haver possibilidade de alterarmos o deslocamento
         // entre unidades, deve existir pelo menos três atendimentos
         // para o professor no mesmo dia, e em no mínimo duas unidades distintas

         // Verifica se há pelo menos 3 atendimentos
         GGroup< AtendimentoBase *,
            LessPtr< AtendimentoBase > > atendimentos = it_prof_dia->second;

         if ( atendimentos.size() <= 2 )
         {
            continue;
         }

         // Verifica se há pelo menos 2 unidades
         GGroup< Unidade *, LessPtr< Unidade > > unidadesDistintas;

         GGroup< AtendimentoBase *, LessPtr< AtendimentoBase > >::iterator
            it_at = atendimentos.begin();

         for (; it_at != atendimentos.end();
                it_at++ )
         {
            unidadesDistintas.add( it_at->unidade );
         }

         if ( unidadesDistintas.size() <= 1 )
         {
            continue;
         }

         std::vector< AtendimentoBase > vectorAtendimentos;
         ITERA_GGROUP_LESSPTR( it_at, atendimentos, AtendimentoBase )
         {
            vectorAtendimentos.push_back( **it_at );
         }

         // Armazena todas as combinações possíveis dos
         // atendimentos nos horários de aula do turno atual
         std::vector< std::vector< HorarioAula > > arranjosHorariosDia;

         std::vector< HorarioAula > horarios;
         for ( int i = 0; i < (int)problemData->horarios_aula_ordenados.size(); i++ )
         {
            horarios.push_back( ( *problemData->horarios_aula_ordenados.at( i ) ) );
         }

         Combinatoria< HorarioAula >::arranjos(
            horarios, (int)atendimentos.size(),  arranjosHorariosDia );

         std::vector< std::vector< HorarioAula > >::iterator
            it_arranjosHorariosDia = arranjosHorariosDia.begin();

         for (; it_arranjosHorariosDia != arranjosHorariosDia.end();
                it_arranjosHorariosDia++ )
         {
            std::vector< HorarioAula > horarios = ( *it_arranjosHorariosDia );
            std::list< int > ids_horarios_antigos;
            ids_horarios_antigos.clear();

            int deslocamentoAnterior = calculaDeslocamentoUnidades(
               professor->getId(), dia_semana );

            // Realiza a troca de horários
            for ( int i = 0; i < (int)horarios.size(); i++ )
            {
               AtendimentoBase atendimento_base = vectorAtendimentos.at( i );
               HorarioAula horario_aula = horarios.at( i );

               int horario_antigo = alteraHorarioAulaAtendimento(
                  horario_aula.getId(), atendimento_base.idAtHorario );

               ids_horarios_antigos.push_back( horario_antigo );
            }

            int deslocamentoPosterior = calculaDeslocamentoUnidades(
               professor->getId(), dia_semana );

            bool solucaoValida = validateSolution->checkSolution(
               this->problemData, this->problemSolution );

            bool melhorouSolucao = ( deslocamentoPosterior < deslocamentoAnterior );

            // Desfaz a troca, caso seja inviável ou
            // caso não tenha diminuido o deslocamento
            if ( !solucaoValida || !melhorouSolucao )
            {
               for ( int i = 0; i < (int)horarios.size(); i++ )
               {
                  AtendimentoBase atendimento_base = vectorAtendimentos.at( i );
                  int horario_antigo = ids_horarios_antigos.front();
                  ids_horarios_antigos.pop_front();

                  int horario_antigo_alterado = alteraHorarioAulaAtendimento(
                     horario_antigo, atendimento_base.idAtHorario );
               }
            }
         }
      }
   }
}

/*
	Garante um intervalo de tempo mínimo entre aulas de um mesmo professor
	em um mesmo dia e em unidades distintas.

*/
int SolverMIP::criaRestricaoProfHorarioMultiUnid( void )
{
	int restricoes = 0;
	int nnz;
	char name[ 200 ];

	ConstraintOp c;
	VariableOpHash::iterator vit;
	ConstraintOpHash::iterator cit;

	map< Professor*, map< int, map< HorarioDia*, map< Aula*, vector< VariableOpHash::iterator >, 
															 LessPtr< Aula > >,
							                     LessPtr< HorarioDia > > >,
					 LessPtr< Professor > > mapVariaveis;

	vit = vHashOp.begin();
	while( vit != vHashOp.end() )
	{
		if( vit->first.getType() == VariableOp::V_X_PROF_AULA_HOR && !vit->first.getProfessor()->eVirtual() )
		{
			VariableOp v = vit->first;
			mapVariaveis[v.getProfessor()][v.getDia()][v.getHorario()][v.getAula()].push_back(vit);
		}

		vit++;
	}

	map< Professor*, map< int, map< HorarioDia*, map< Aula*, vector< VariableOpHash::iterator >, 
		LessPtr< Aula > >, LessPtr< HorarioDia > > >, LessPtr< Professor > >::iterator it1 = mapVariaveis.begin();

	for(; it1 != mapVariaveis.end(); it1++)
	{
		Professor *professor = it1->first;

		map< int, map< HorarioDia*, map< Aula*, vector< VariableOpHash::iterator >, 
				LessPtr< Aula > >, LessPtr< HorarioDia > > >::iterator it2 = it1->second.begin();

		for(; it2 != it1->second.end(); it2++)
		{
			int dia = it2->first;

			map< HorarioDia*, map< Aula*, vector< VariableOpHash::iterator >, 
					LessPtr< Aula > >, LessPtr< HorarioDia > >::iterator it3 = it2->second.begin();

			for(; it3 != it2->second.end(); it3++)
			{
				HorarioDia *horControle = it3->first;
				DateTime inicioControle = horControle->getHorarioAula()->getInicio();

				map< HorarioDia*, map< Aula*, vector< VariableOpHash::iterator >, 
							LessPtr< Aula > >, LessPtr< HorarioDia > >::iterator it4 = it2->second.begin();

				for(; it4 != it2->second.end(); it4++)
				{
					HorarioDia *hor2 = it4->first;
					DateTime inicio2 = hor2->getHorarioAula()->getInicio();

					map< Aula*, vector< VariableOpHash::iterator >, 
								LessPtr< Aula > >::iterator it5 = it3->second.begin();

					for(; it5 != it3->second.end(); it5++)
					{
						Aula *aula = it5->first;

						Unidade *unid = problemData->refUnidade[ aula->getSala()->getIdUnidade() ];
						Campus *cp = problemData->retornaCampus( unid->getId() );

						int tempoCred = aula->getDisciplina()->getTempoCredSemanaLetiva();
						int nCred = aula->getTotalCreditos();
						int duracaoAulaControle = tempoCred * nCred;

						c.reset();
						c.setType( ConstraintOp::C_PROF_HORARIO_MULTIUNID );
						c.setCampus( cp );
						c.setUnidade( unid );
						c.setProfessor( professor );
						c.setDia( dia );
						c.setHorarioAula( horControle->getHorarioAula() ); // Controle
						c.setDuracaoAula( duracaoAulaControle ); // Controle
						c.setH2( hor2->getHorarioAula() );

						cit = cHashOp.find( c );

						if ( cHashOp.find( c ) == cHashOp.end() )
						{
							sprintf( name, "%s", c.toString().c_str() );
							nnz = 100;
							OPT_ROW row( nnz, OPT_ROW::LESS, 1.0, name );

							bool inseriuUnidControle = false;
							bool inseriuUnidDiferente = false;

							map< Aula*, vector< VariableOpHash::iterator >, 
										LessPtr< Aula > >::iterator it6 = it3->second.begin();

							for(; it6 != it3->second.end(); it6++)
							{
								Aula *aula = it6->first;

								Unidade *unidAula = problemData->refUnidade[ aula->getSala()->getIdUnidade() ];
								Campus *cpAula = problemData->retornaCampus( unidAula->getId() );

								if ( cpAula->getId() == cp->getId() &&
									unidAula->getId() == unid->getId() )
								{
									if ( aula->getDiaSemana() != dia ||
										aula->getDisciplina()->horariosDia.find( horControle ) ==
										aula->getDisciplina()->horariosDia.end() )
									{
										continue;
									}

									int nCred = aula->getTotalCreditos();
									int tempoCred = aula->getDisciplina()->getTempoCredSemanaLetiva();							
									int aulaDuracao = tempoCred * nCred;

									if ( aulaDuracao != duracaoAulaControle )
									{
										continue;
									}

									vector< VariableOpHash::iterator >::iterator it7 = it6->second.begin();
									for(; it7 != it6->second.end(); it7++)
									{
										VariableOpHash::iterator vit = *it7;
										row.insert(vit->second, 1.0);
										inseriuUnidControle = true;
									}
								}
							}

							it6 = it4->second.begin();

							for(; it6 != it4->second.end(); it6++)
							{
								Aula *aula = it6->first;

								Unidade *unidAula = problemData->refUnidade[ aula->getSala()->getIdUnidade() ];
								Campus *cpAula = problemData->retornaCampus( unidAula->getId() );

								if(! ( cpAula->getId() == cp->getId() &&
									unidAula->getId() == unid->getId() ))
								{
									if ( aula->getDisciplina()->horariosDia.find( hor2 ) ==
										aula->getDisciplina()->horariosDia.end() )
									{
										continue;
									}

									int tempoCred = aula->getDisciplina()->getTempoCredSemanaLetiva();
									int nCred = aula->getTotalCreditos();
									int duracaoAula = tempoCred * nCred;

									int tempoMinDesloc = problemData->calculaTempoEntreCampusUnidades( cp, cpAula, unid, unidAula );

									DateTime fimControle = inicioControle;
									fimControle.addMinutes( duracaoAulaControle + tempoMinDesloc );

									DateTime fim2 = inicio2;
									fim2.addMinutes( duracaoAula + tempoMinDesloc );

									if ( ( ( fim2 > inicioControle ) &&
										( inicio2 < fimControle ) )										
										||
										( ( fimControle > inicio2 ) &&
										( fimControle < fim2 ) ) )
									{
										vector< VariableOpHash::iterator >::iterator it7 = it6->second.begin();
										for(; it7 != it6->second.end(); it7++)
										{
											VariableOpHash::iterator vit = *it7;
											row.insert(vit->second, 1.0);
											inseriuUnidDiferente = true;
										}
									}			
								}
							}

							if ( inseriuUnidControle && inseriuUnidDiferente )
							{
								cHashOp[ c ] = lp->getNumRows();
								lp->addRow( row );
								restricoes++;
							}
						}
					}
				}
			}
		}
	}

	return restricoes;
}


int SolverMIP::criaRestricaoGapsHorariosProfessores()
{
   int restricoes = 0;

   if ( !problemData->parametros->minimizar_horarios_vazios_professor )
   {
	   return restricoes;
   }

   VariableOpHash::iterator vit;
   VariableOpHash::iterator vit_x;
   VariableOpHash::iterator vit_h;
   
   int nnz = 100; // TODO

   double rhs = 0.0;
   char name[ 200 ];

   if ( nnz == 0 )
   {
      return 0;
   }

   map< Professor*, map< int, vector< VariableOpHash::iterator > >, LessPtr< Professor > > variaveisHashHorariosIFProfessores;
   map< Professor*, map< int, vector< VariableOpHash::iterator > >, LessPtr< Professor > > variaveisHashX;

   vit = vHashOp.begin();

   for (; vit != vHashOp.end(); vit++ )
   {
      VariableOp v = ( vit->first );

	  if ( ( v.getType() == VariableOp::V_HI_PROFESSORES ) ||
		   ( v.getType() == VariableOp::V_HF_PROFESSORES ) )
      {
		  variaveisHashHorariosIFProfessores[v.getProfessor()][v.getDia()].push_back( vit );
      }
      else if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR &&
				!v.getProfessor()->eVirtual() )
      {
         variaveisHashX[v.getProfessor()][v.getDia()].push_back( vit );
      }
   }

   // Para cada professor
   map< Professor*, map< int, vector< VariableOpHash::iterator > >, LessPtr< Professor > >::iterator it1 = variaveisHashHorariosIFProfessores.begin();
   for(; it1 != variaveisHashHorariosIFProfessores.end(); it1++)
   {
	   Professor *professor = it1->first;
		
	   // Para cada dia
	   map< int, vector< VariableOpHash::iterator > >::iterator it2 = it1->second.begin();
	   for(; it2 != it1->second.end(); it2++)
	   {
		   int dia = it2->first;

		   // --------------- C_GAPS_PROFESSORES_I_F ---------------------------------------
		    
		   ConstraintOp c2;
		   c2.reset();
		   c2.setType( ConstraintOp::C_GAPS_PROFESSORES_I_F );
		   c2.setProfessor( professor );
		   c2.setDia( dia );
				
		   if ( cHashOp.find( c2 ) != cHashOp.end() )
		   {
			   continue;
		   }

		   sprintf( name, "%s", c2.toString().c_str() );

		   OPT_ROW row2( nnz, OPT_ROW::LESS, 0.0, name );

		   // Par cada variavel Hi_{p,t} ou Hf_{p,t}
		   vector< VariableOpHash::iterator >::iterator it3 = it2->second.begin();
		   for(; it3 != it2->second.end(); it3++)
		   {
			    vit_h = *it3;
			    VariableOp vh = vit_h->first;

				// --------------- insere variaveis em C_GAPS_PROFESSORES_I_F ----------------------
				
				// Insere Hi_{p,t}
				if ( vh.getType() == VariableOp::V_HI_PROFESSORES )
				{
					row2.insert( vit_h->second, 1.0 );		
				}
				// Insere Hf_{p,t}
				else
				{
					row2.insert( vit_h->second, -1.0 );
				}

				// ------------------------------------------------------------------------------

			   // Para cada horario no dia
			   ITERA_GGROUP_LESSPTR( itHor, professor->horariosDia, HorarioDia )
			   {
				   if ( itHor->getDia() != dia )
					   continue;

				   HorarioAula * h = itHor->getHorarioAula();
				
				   int horEmMinutos = h->getInicio().getDateMinutes();

				   // Variável Hi_{p,t}
				   if ( vh.getType() == VariableOp::V_HI_PROFESSORES )
				   {
					   // --------------- C_GAPS_PROFESSORES_I ---------------------------------------
					    ConstraintOp c;
						c.reset();
						c.setType( ConstraintOp::C_GAPS_PROFESSORES_I );
						c.setProfessor( professor );
						c.setDia( dia );
						c.setHorarioAula( h );

						double bigM = professor->getUltimoHorarioDisponivelDia( dia )->getInicio().getDateMinutes() + h->getTempoAula();						
						
						rhs = (double) horEmMinutos;
						rhs += bigM;

						if ( cHashOp.find( c ) == cHashOp.end() )
						{
							sprintf( name, "%s", c.toString().c_str() );

							OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );

							// Insere Hi_{p,t}
							row.insert( vit_h->second, 1.0 );					   	   

							bool inseriuVariavel = false;

							vector< VariableOpHash::iterator > vars = variaveisHashX[professor][dia];
							vector< VariableOpHash::iterator >::iterator it4 = vars.begin();

							for(; it4 != vars.end(); it4++)
							{
								vit_x = *it4;
								VariableOp v_x = vit_x->first;

								if ( v_x.getHorario()->getHorarioAula()->getId() == h->getId() )
								{
									row.insert( vit_x->second, bigM );			   
									inseriuVariavel = true;
								}
							}

							if ( inseriuVariavel )
							{
								cHashOp[ c ] = lp->getNumRows();
								lp->addRow( row );
								restricoes++;
							}
						}
						// --------------------------------------------------------------------
				   }

				   // Variável Hf_{p,t}
				   else if ( vh.getType() == VariableOp::V_HF_PROFESSORES )
				   {
					   // --------------- C_GAPS_PROFESSORES_F ---------------------------------------
						ConstraintOp c;
					    c.reset();
						c.setType( ConstraintOp::C_GAPS_PROFESSORES_F );
						c.setProfessor( professor );
						c.setDia( dia );
						c.setHorarioAula( h );

						rhs = 0.0;

						if ( cHashOp.find( c ) == cHashOp.end() )
						{
							sprintf( name, "%s", c.toString().c_str() );

							OPT_ROW row( nnz, OPT_ROW::GREATER, rhs, name );

							// Insere Hf_{p,t}
							row.insert( vit_h->second, 1.0 );

							bool inseriuVariavel = false;

							vector< VariableOpHash::iterator > vars = variaveisHashX[professor][dia];
							vector< VariableOpHash::iterator >::iterator it4 = vars.begin();

							for(; it4 != vars.end(); it4++)
							{
								vit_x = *it4;
								VariableOp v_x = vit_x->first;

								if ( v_x.getHorario()->getHorarioAula()->getId() == h->getId() )
								{
									row.insert( vit_x->second, -horEmMinutos );							   
									inseriuVariavel = true;
								}
							}

							if ( inseriuVariavel )
							{
								cHashOp[ c ] = lp->getNumRows();
								lp->addRow( row );
								restricoes++;
							}
						}
					   // ------------------------------------------------------------------
				   }			  
			   }
		   }

		   if ( row2.getnnz() > 0 )
		   {
				cHashOp[ c2 ] = lp->getNumRows();
				lp->addRow( row2 );
				restricoes++;
		   }
		    // --------------------------------------------------------------------------------
	   }
   }

   return restricoes;
}

int SolverMIP::criaRestricaoCalculaNroProfsAlocadosCurso()
{
   int restricoes = 0;  
      
   if ( ! problemData->parametros->min_mestres &&
	    ! problemData->parametros->min_doutores )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;
   VariableOp v;

   GGroup< Professor *, LessPtr< Professor > > professores
      = problemData->getProfessores();

   // Agrupando os professores que ministram disciplinas de cada curso
   std::map< Curso *, GGroup< Professor *,
      LessPtr< Professor > > > mapCursoProfessores;

   ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
   {
      Professor * professor = ( *it_prof );

      ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
      {
         Aula * aula = ( *it_aula );
         Disciplina * disciplina = aula->getDisciplina();

         std::pair< int, int > professor_disciplina (
            professor->getId(), disciplina->getId() );

         // Se o professor e a disciplina da aula em questão se relacionarem
         if ( problemData->prof_Disc_Dias.find( professor_disciplina )
            == problemData->prof_Disc_Dias.end() )
         {
            continue;
         }

         ITERA_GGROUP_LESSPTR( it_oferta, aula->ofertas, Oferta )
         {
            Oferta * oferta = ( *it_oferta );

            mapCursoProfessores[ oferta->curso ].add( professor );
         }
      }
   }


   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
   {
	   Curso *curso = *itCurso;
	   	   
	   c.reset();
	   c.setType( ConstraintOp::C_CALCULA_NRO_PROFS_CURSO );
	   c.setCurso( curso );

	   cit = cHashOp.find( c );

		if ( cit == cHashOp.end() )
		{		
			GGroup< Professor *, LessPtr< Professor > > profs;

			std::map< Curso *, GGroup< Professor *, LessPtr< Professor > > >::iterator
				itCursoProfs = mapCursoProfessores.find(curso);		
			if ( itCursoProfs != mapCursoProfessores.end() )
			{
				profs = itCursoProfs->second;
			}

			sprintf( name, "%s", c.toString().c_str() );
			nnz = profs.size() + 1;
			rhs = 0;

			OPT_ROW row( nnz, OPT_ROW::EQUAL, rhs, name );

			// Itera todos os professores hábeis para o curso
			ITERA_GGROUP_LESSPTR( it_prof, profs, Professor )
			{
				Professor * professor = ( *it_prof );

				// Recupera os professores que estão associados ao curso
				v.reset();
				v.setType( VariableOp::V_PROF_CURSO );
				v.setProfessor( professor );
				v.setCurso( curso );
						
				vit = vHashOp.find( v );

				if ( vit != vHashOp.end() )
				{
					row.insert( vit->second, -1.0 );
				}
			}      
					
			// Variavel np_{c}
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, 1.0 );
			}

			// Insere restrição
			if ( row.getnnz() != 0 )
			{
				cHashOp[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
   }


   return restricoes;
}

int SolverMIP::criaRestricaoCalculaNroProfsVirtuaisAlocadosCurso()
{
   int restricoes = 0;  
      
   if ( ! problemData->parametros->min_mestres &&
	    ! problemData->parametros->min_doutores )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;
   VariableOp v;

   ITERA_GGROUP_LESSPTR( itHorDia, problemData->horariosDia, HorarioDia )
   {
	   int dia = (*itHorDia)->getDia();
	   HorarioAula *horarioAula = (*itHorDia)->getHorarioAula();

	   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
	   {
		   Curso *curso = *itCurso;
	   	   
		   c.reset();
		   c.setType( ConstraintOp::C_CALCULA_NRO_PROFS_VIRTUAIS_CURSO );
		   c.setCurso( curso );
		   c.setDia( dia );
		   c.setHorarioAula( horarioAula );

		   cit = cHashOp.find( c );

			if ( cit == cHashOp.end() )
			{
				sprintf( name, "%s", c.toString().c_str() );
				nnz = problemData->profsVirtuais.size() * problemData->horariosDia.size() + 1;
				rhs = 0;

				OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );
					   				  
				for ( vit = vHashOp.begin(); vit != vHashOp.end(); vit++ )
				{
					v.reset();
					v = ( vit->first );
					if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR &&
						 v.getProfessor()->eVirtual() &&
						 v.getDia() == dia &&
						 v.getAula()->atendeAoCurso( curso->getId() ) )
					{	
						HorarioAula *h = v.getHorarioAula();
						Calendario *sl = h->getCalendario();
						for ( int i=1; i<=v.getAula()->getTotalCreditos(); i++ )
						{
							if ( h->sobrepoe( *horarioAula ) )
							{
								row.insert( vit->second, 1.0 );
								break;
							}
							h = sl->getProximoHorario( h );
						}
					}					
				}      
					
				// Variavel npv_{c}
				v.reset();
				v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_CURSO );
				v.setCurso( curso );
				vit = vHashOp.find( v );

				if ( vit != vHashOp.end() )
				{
					row.insert( vit->second, -1.0 );
				}

				// Insere restrição
				if ( row.getnnz() > 1 )
				{
					cHashOp[ c ] = lp->getNumRows();
					lp->addRow( row );
					restricoes++;
				}
			}
	   }

   }

   return restricoes;
}

int SolverMIP::criaRestricaoCalculaNroProfsVirtuaisDoutoresAlocadosCurso()
{
   int restricoes = 0;  
      
   if ( ! problemData->parametros->min_doutores )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;
   VariableOp v;

   ITERA_GGROUP_LESSPTR( itHorDia, problemData->horariosDia, HorarioDia )
   {
	   int dia = (*itHorDia)->getDia();
	   HorarioAula *horarioAula = (*itHorDia)->getHorarioAula();

	   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
	   {
		   Curso *curso = *itCurso;
	   	   
		   c.reset();
		   c.setType( ConstraintOp::C_CALCULA_NRO_PROFS_VIRTUAIS_DOUT_CURSO );
		   c.setCurso( curso );
		   c.setDia( dia );
		   c.setHorarioAula( horarioAula );

		   cit = cHashOp.find( c );

			if ( cit == cHashOp.end() )
			{
				sprintf( name, "%s", c.toString().c_str() );
				nnz = problemData->profsVirtuais.size() * problemData->horariosDia.size() + 1;
				rhs = 0;

				OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );
					   				  
				for ( vit = vHashOp.begin(); vit != vHashOp.end(); vit++ )
				{
					v.reset();
					v = ( vit->first );
					if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR &&
						 v.getProfessor()->eVirtual() &&
						 v.getProfessor()->getTitulacaoId() == 5 &&
						 v.getDia() == dia &&
						 v.getAula()->atendeAoCurso( curso->getId() ) )
					{	
						HorarioAula *h = v.getHorarioAula();
						Calendario *sl = h->getCalendario();
						for ( int i=1; i<=v.getAula()->getTotalCreditos(); i++ )
						{
							if ( h->sobrepoe( *horarioAula ) )
							{
								row.insert( vit->second, 1.0 );
								break;
							}
							h = sl->getProximoHorario( h );
						}
					}					
				}      
					
				// Variavel npvd_{c}
				v.reset();
				v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_DOUT_CURSO );
				v.setCurso( curso );
				vit = vHashOp.find( v );

				if ( vit != vHashOp.end() )
				{
					row.insert( vit->second, -1.0 );
				}

				// Insere restrição
				if ( row.getnnz() > 1 )
				{
					cHashOp[ c ] = lp->getNumRows();
					lp->addRow( row );
					restricoes++;
				}
			}
	   }

   }

   return restricoes;
}
int SolverMIP::criaRestricaoCalculaNroProfsVirtuaisMestresAlocadosCurso()
{
   int restricoes = 0;  
      
   if ( ! problemData->parametros->min_mestres )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;
   VariableOp v;

   ITERA_GGROUP_LESSPTR( itHorDia, problemData->horariosDia, HorarioDia )
   {
	   int dia = (*itHorDia)->getDia();
	   HorarioAula *horarioAula = (*itHorDia)->getHorarioAula();

	   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
	   {
		   Curso *curso = *itCurso;
	   	   
		   c.reset();
		   c.setType( ConstraintOp::C_CALCULA_NRO_PROFS_VIRTUAIS_MEST_CURSO );
		   c.setCurso( curso );
		   c.setDia( dia );
		   c.setHorarioAula( horarioAula );

		   cit = cHashOp.find( c );

			if ( cit == cHashOp.end() )
			{
				sprintf( name, "%s", c.toString().c_str() );
				nnz = problemData->profsVirtuais.size() * problemData->horariosDia.size() + 1;
				rhs = 0;

				OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );
					   				  
				for ( vit = vHashOp.begin(); vit != vHashOp.end(); vit++ )
				{
					v.reset();
					v = ( vit->first );
					if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR &&
						 v.getProfessor()->eVirtual() &&
						 v.getProfessor()->getTitulacaoId() == 4 &&
						 v.getDia() == dia &&
						 v.getAula()->atendeAoCurso( curso->getId() ) )
					{	
						HorarioAula *h = v.getHorarioAula();
						Calendario *sl = h->getCalendario();
						for ( int i=1; i<=v.getAula()->getTotalCreditos(); i++ )
						{
							if ( h->sobrepoe( *horarioAula ) )
							{
								row.insert( vit->second, 1.0 );
								break;
							}
							h = sl->getProximoHorario( h );
						}
					}					
				}      
					
				// Variavel npvm_{c}
				v.reset();
				v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_MEST_CURSO );
				v.setCurso( curso );
				vit = vHashOp.find( v );

				if ( vit != vHashOp.end() )
				{
					row.insert( vit->second, -1.0 );
				}

				// Insere restrição
				if ( row.getnnz() > 1 )
				{
					cHashOp[ c ] = lp->getNumRows();
					lp->addRow( row );
					restricoes++;
				}
			}
	   }

   }

   return restricoes;
}
int SolverMIP::criaRestricaoCalculaNroProfsVirtuaisGeraisAlocadosCurso()
 {
    int restricoes = 0;  
      
   if ( ! problemData->parametros->min_mestres &&
	    ! problemData->parametros->min_doutores )
   {
		return restricoes;
   }

   int nnz;
   double rhs;
   char name[ 200 ];

   ConstraintOp c;
   VariableOpHash::iterator vit;
   ConstraintOpHash::iterator cit;
   VariableOp v;

   ITERA_GGROUP_LESSPTR( itHorDia, problemData->horariosDia, HorarioDia )
   {
	   int dia = (*itHorDia)->getDia();
	   HorarioAula *horarioAula = (*itHorDia)->getHorarioAula();

	   ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
	   {
		   Curso *curso = *itCurso;
	   	   
		   c.reset();
		   c.setType( ConstraintOp::C_CALCULA_NRO_PROFS_VIRTUAIS_GERAIS_CURSO );
		   c.setCurso( curso );
		   c.setDia( dia );
		   c.setHorarioAula( horarioAula );

		   cit = cHashOp.find( c );

			if ( cit == cHashOp.end() )
			{
				sprintf( name, "%s", c.toString().c_str() );
				nnz = problemData->profsVirtuais.size() * problemData->horariosDia.size() + 1;
				rhs = 0;

				OPT_ROW row( nnz, OPT_ROW::LESS, rhs, name );
					   				  
				for ( vit = vHashOp.begin(); vit != vHashOp.end(); vit++ )
				{
					v.reset();
					v = ( vit->first );
					if ( v.getType() == VariableOp::V_X_PROF_AULA_HOR &&
						 v.getProfessor()->eVirtual() &&
						 v.getProfessor()->getTitulacaoId() < 4 &&
						 v.getDia() == dia &&
						 v.getAula()->atendeAoCurso( curso->getId() ) )
					{	
						HorarioAula *h = v.getHorarioAula();
						Calendario *sl = h->getCalendario();
						for ( int i=1; i<=v.getAula()->getTotalCreditos(); i++ )
						{
							if ( h->sobrepoe( *horarioAula ) )
							{
								row.insert( vit->second, 1.0 );
								break;
							}
							h = sl->getProximoHorario( h );
						}
					}					
				}      
					
				// Variavel npvg_{c}
				v.reset();
				v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_GERAIS_CURSO );
				v.setCurso( curso );
				vit = vHashOp.find( v );

				if ( vit != vHashOp.end() )
				{
					row.insert( vit->second, -1.0 );
				}

				// Insere restrição
				if ( row.getnnz() > 1 )
				{
					cHashOp[ c ] = lp->getNumRows();
					lp->addRow( row );
					restricoes++;
				}
			}
	   }

   }

   return restricoes;
 }
int SolverMIP::criaRestricaoSomaNroProfsVirtuaisAlocadosCurso()
 {
    int restricoes = 0;  
      
	if ( ! problemData->parametros->min_mestres &&
		 ! problemData->parametros->min_doutores )
	{
		return restricoes;
	}

	int nnz;
	double rhs;
	char name[ 200 ];

	ConstraintOp c;
	VariableOpHash::iterator vit;
	ConstraintOpHash::iterator cit;
	VariableOp v;

	ITERA_GGROUP_LESSPTR( itCurso, problemData->cursos, Curso )
	{
		Curso *curso = *itCurso;
	   	   
		c.reset();
		c.setType( ConstraintOp::C_SOMA_NRO_PROFS_VIRTUAIS_CURSO );
		c.setCurso( curso );

		cit = cHashOp.find( c );

		if ( cit == cHashOp.end() )
		{
			sprintf( name, "%s", c.toString().c_str() );
			nnz = problemData->profsVirtuais.size() * problemData->horariosDia.size() + 1;
			rhs = 0;

			OPT_ROW row( nnz, OPT_ROW::EQUAL, rhs, name );				   				  

			// Variavel npvg_{c}
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_GERAIS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, 1.0 );
			}

			// Variavel npvm_{c}
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_MEST_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, 1.0 );
			}

			// Variavel npvd_{c}
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_DOUT_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, 1.0 );
			}

			// Variavel npv_{c}
			v.reset();
			v.setType( VariableOp::V_NRO_PROFS_VIRTUAIS_CURSO );
			v.setCurso( curso );
			vit = vHashOp.find( v );

			if ( vit != vHashOp.end() )
			{
				row.insert( vit->second, -1.0 );
			}

			// Insere restrição
			if ( row.getnnz() != 0 )
			{
				cHashOp[ c ] = lp->getNumRows();
				lp->addRow( row );
				restricoes++;
			}
		}
	}
	   
   return restricoes;
 }


//int SolverMIP::criaRestricaoProfHorarioMultiUnid( void )
//{
//   int restricoes = 0;
//   int nnz;
//   char name[ 200 ];
//
//   ConstraintOp c;
//   VariableOpHash::iterator vit;
//   ConstraintOpHash::iterator cit;
//
//   GGroup< int > duracoesTodasAulas;
//
//   ITERA_GGROUP_LESSPTR( it_aula, problemData->aulas, Aula )
//   {
//		int tempoCred = (*it_aula)->getDisciplina()->getTempoCredSemanaLetiva();
//		int nCred = (*it_aula)->getTotalCreditos();
//		int aulaDuracao = tempoCred * nCred;
//
//		duracoesTodasAulas.add( aulaDuracao );
//   }
//
//   GGroup< Professor *, LessPtr< Professor > > professores = problemData->getProfessores();
//
//   ITERA_GGROUP_LESSPTR( it_campus, problemData->campi, Campus )
//   {
//	    Campus *cp = *it_campus;
//		
//		ITERA_GGROUP_LESSPTR( it_unid, cp->unidades, Unidade )
//		{
//			Unidade *unid = *it_unid;
//
//			ITERA_GGROUP_LESSPTR( it_horControle, problemData->horariosDia, HorarioDia )
//			{
//				HorarioDia *horControle = ( *it_horControle );
//
//				DateTime inicioControle = horControle->getHorarioAula()->getInicio();
//				
//				int dia = horControle->getDia();
//
//				ITERA_GGROUP_LESSPTR( it_hor2, problemData->horariosDia, HorarioDia )
//				{
//					HorarioDia *hor2 = ( *it_hor2 );
//					
//					if ( hor2->getDia() != dia )
//						continue;
//
//					DateTime inicio2 = hor2->getHorarioAula()->getInicio();
//
//					ITERA_GGROUP_N_PT( it_duracao, duracoesTodasAulas, int )
//					{
//						int duracaoAulaControle = *it_duracao;
//				
//						ITERA_GGROUP_LESSPTR( it_prof, professores, Professor )
//						{
//							Professor * professor = ( *it_prof );
//
//							c.reset();
//							c.setType( ConstraintOp::C_PROF_HORARIO_MULTIUNID );
//							c.setCampus( cp );
//							c.setUnidade( unid );
//							c.setProfessor( professor );
//							c.setDia( dia );
//							c.setHorarioAula( horControle->getHorarioAula() ); // Controle
//							c.setDuracaoAula( duracaoAulaControle ); // Controle
//							c.setH2( hor2->getHorarioAula() );
//
//							cit = cHashOp.find( c );
//					
//							sprintf( name, "%s", c.toString().c_str() );
//							if ( cHashOp.find( c ) != cHashOp.end() )
//							{
//								continue;
//							}
//
//							nnz = 100;
//
//							OPT_ROW row( nnz, OPT_ROW::LESS, 1.0, name );
//
//							bool inseriuUnidControle = false;
//							bool inseriuUnidDiferente = false;
//
//							GGroup< std::pair< Aula *, Disciplina * > >::iterator
//								it_aula_disc = problemData->mapProfessorDisciplinas[ professor ].begin();
//
//							for ( ; it_aula_disc != problemData->mapProfessorDisciplinas[ professor ].end(); it_aula_disc++ )
//							{
//								Aula * aula = ( *it_aula_disc ).first;
//
//								Unidade *unidAula = problemData->refUnidade[ aula->getSala()->getIdUnidade() ];
//								Campus *cpAula = problemData->retornaCampus( unidAula->getId() );
//
//								#pragma region Aulas na mesma unidade da restrição (unidade controle)
//								if ( cpAula->getId() == cp->getId() &&
//									 unidAula->getId() == unid->getId() )
//								{
//									if ( aula->getDiaSemana() != dia ||
//										 aula->getDisciplina()->horariosDia.find( horControle ) ==
//										 aula->getDisciplina()->horariosDia.end() )
//									{
//										continue;
//									}
//
//									int nCred = aula->getTotalCreditos();
//									int tempoCred = aula->getDisciplina()->getTempoCredSemanaLetiva();							
//									int aulaDuracao = tempoCred * nCred;
//						
//									if ( aulaDuracao != duracaoAulaControle )
//									{
//										continue;
//									}
//								
//									VariableOp v;
//									v.reset();
//									v.setType( VariableOp::V_X_PROF_AULA_HOR );
//									v.setAula( aula ); 
//									v.setProfessor( professor );
//									v.setHorario( horControle );
//									v.setHorarioAula( horControle->getHorarioAula() );
//									v.setDia( dia );
//							 		v.setDisciplina( aula->getDisciplina() );
//									v.setTurma( aula->getTurma() );
//									v.setUnidade( unidAula );
//									v.setSala( aula->getSala() );				   
//							
//									vit = vHashOp.find( v );
//									if ( vit != vHashOp.end() )
//									{
//										row.insert( vit->second, 1.0 );
//										inseriuUnidControle = true;
//									}
//								}
//								#pragma endregion
//
//								#pragma region Aulas em unidades diferentes da unidade controle da restrição
//								else
//								{
//									if ( aula->getDisciplina()->horariosDia.find( hor2 ) ==
//										 aula->getDisciplina()->horariosDia.end() )
//									{
//										 continue;
//								    }
//
//									int tempoCred = aula->getDisciplina()->getTempoCredSemanaLetiva();
//									int nCred = aula->getTotalCreditos();
//									int duracaoAula = tempoCred * nCred;
//
//									int tempoMinDesloc = problemData->calculaTempoEntreCampusUnidades( cp, cpAula, unid, unidAula );
//
//									DateTime fimControle = inicioControle;
//									fimControle.addMinutes( duracaoAulaControle + tempoMinDesloc );
//									
//									DateTime fim2 = inicio2;
//									fim2.addMinutes( duracaoAula + tempoMinDesloc );
//									
//									if ( ( ( fim2 > inicioControle ) &&
//										   ( inicio2 < fimControle ) )										
//										||
//										 ( ( fimControle > inicio2 ) &&
//										   ( fimControle < fim2 ) ) )
//									{
//										VariableOp v;
//										v.reset();
//										v.setType( VariableOp::V_X_PROF_AULA_HOR );
//										v.setAula( aula ); 
//										v.setProfessor( professor );
//										v.setHorario( hor2 );
//										v.setHorarioAula( hor2->getHorarioAula() );
//										v.setDia( dia );
//							 			v.setDisciplina( aula->getDisciplina() );
//										v.setTurma( aula->getTurma() );
//										v.setUnidade( unidAula );
//										v.setSala( aula->getSala() );				   
//							
//										vit = vHashOp.find( v );
//										if ( vit != vHashOp.end() )
//										{
//											row.insert( vit->second, 1.0 );
//											inseriuUnidDiferente = true;
//										}
//									}			
//								}
//								#pragma endregion
//							}
//
//							if ( inseriuUnidControle && inseriuUnidDiferente )
//							{
//								if ( row.getnnz() != 0 )
//								{
//									cHashOp[ c ] = lp->getNumRows();
//									lp->addRow( row );
//									restricoes++;
//								}
//							}
//						}
//					}
//				}
//			}
//		}
//   }
//
//   return restricoes;
//
//}


int SolverMIP::alteraHorarioAulaAtendimento(
   const int id_novo_horario_aula, const int id_at_horario )
{
   return 1; // ?? TODO

   ITERA_GGROUP( it_at_campi,
      ( *this->problemSolution->atendimento_campus ), AtendimentoCampus )
   {
      Campus * campus = it_at_campi->campus;

      ITERA_GGROUP( it_at_unidade,
         ( *it_at_campi->atendimentos_unidades ), AtendimentoUnidade )
      {
         Unidade * unidade = it_at_unidade->unidade;

         ITERA_GGROUP( it_at_sala,
            ( *it_at_unidade->atendimentos_salas ), AtendimentoSala )
         {
            Sala * sala = it_at_sala->sala;

            ITERA_GGROUP( it_at_dia,
               ( *it_at_sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
            {
               int dia_semana = it_at_dia->getDiaSemana();

               ITERA_GGROUP( it_at_turno,
                  ( *it_at_dia->atendimentos_turno ), AtendimentoTurno )
               {
                  Turno * turno = it_at_turno->turno;

                  ITERA_GGROUP( it_at_horario,
                     ( *it_at_turno->atendimentos_horarios_aula ), AtendimentoHorarioAula )
                  {
                     AtendimentoHorarioAula * at_h = ( *it_at_horario );

                     if ( at_h->getId() == id_novo_horario_aula )
                     {
                        int id_horario_aula = at_h->getHorarioAulaId();

                        HorarioAula * novo_horario_aula
                           = problemData->refHorarioAula.find( id_novo_horario_aula )->second;

                        at_h->horario_aula = novo_horario_aula;
                        at_h->setHorarioAulaId( id_novo_horario_aula );

                        return id_horario_aula;
                     }
                  }
               }
            }
         }
      }
   }

   return -1;
}

bool ordenaAtendimentosBaseHorarioAula(
   AtendimentoBase at1 , AtendimentoBase at2 )
{
   if ( at1.horario_aula == NULL
      || at2.horario_aula == NULL )
   {
      return false;
   }

   if ( at1.horario_aula->getInicio() < at2.horario_aula->getInicio() ) return true;
   if ( at1.horario_aula->getInicio() > at2.horario_aula->getInicio() ) return false;

   return false;
}

int SolverMIP::calculaDeslocamentoUnidades(
   const int id_prof, const int dia )
{
   std::vector< AtendimentoBase > atendimentos;

   ITERA_GGROUP( it_at_campi,
      ( *this->problemSolution->atendimento_campus ), AtendimentoCampus )
   {
      Campus * campus = it_at_campi->campus;

      ITERA_GGROUP( it_at_unidade,
         ( *it_at_campi->atendimentos_unidades ), AtendimentoUnidade )
      {
         Unidade * unidade = it_at_unidade->unidade;

         ITERA_GGROUP( it_at_sala,
            ( *it_at_unidade->atendimentos_salas ), AtendimentoSala )
         {
            Sala * sala = it_at_sala->sala;

            ITERA_GGROUP( it_at_dia,
               ( *it_at_sala->atendimentos_dias_semana ), AtendimentoDiaSemana )
            {
               int dia_semana = it_at_dia->getDiaSemana();

               ITERA_GGROUP( it_at_turno,
                  ( *it_at_dia->atendimentos_turno ), AtendimentoTurno )
               {
                  Turno * turno = it_at_turno->turno;

                  ITERA_GGROUP( it_at_horario,
                     ( *it_at_turno->atendimentos_horarios_aula ), AtendimentoHorarioAula )
                  {
                     AtendimentoHorarioAula * at_h = ( *it_at_horario );

                     HorarioAula * horario_aula = it_at_horario->horario_aula;
                     Professor * professor = it_at_horario->professor;

                     if ( dia_semana == dia
                        && at_h->getProfessorId() == id_prof )
                     {
                        AtendimentoBase atendimento;

                        atendimento.unidade = unidade;
                        atendimento.horario_aula = horario_aula;
                        atendimento.horario_aula = horario_aula;

                        atendimentos.push_back( atendimento );
                     }
                  }
               }
            }
         }
      }
   }

   int contDeslocamentos = 0;

   std::sort( atendimentos.begin(), atendimentos.end(),
      ordenaAtendimentosBaseHorarioAula );

   for ( int i = 0; i < (int)atendimentos.size() - 1; i++ )
   {
      Unidade * unidade1 = atendimentos.at( i ).unidade;
      Unidade * unidade2 = atendimentos.at( i + 1 ).unidade;

      if ( unidade1->getId()  != unidade2->getId() )
      {
         contDeslocamentos++;
      }
   }

   return contDeslocamentos;
}



GGroup< int > SolverMIP::retornaCliques( int turma, Disciplina* disciplina, int campusId )
{
	GGroup< int > cliquesIds;

	Trio< int, int, Disciplina* > trio;
	trio.set( campusId, turma, disciplina );

	std::map< int, std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > >::iterator 
		itMapCliques = this->cliques.begin();

	for ( ; itMapCliques != this->cliques.end(); itMapCliques++ )
	{
		int id = itMapCliques->first;

		std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > ggroupDiscTurma = itMapCliques->second;
		
		if ( ggroupDiscTurma.find( trio ) != ggroupDiscTurma.end() )
		{
			cliquesIds.add( id );
		}
	}

	return cliquesIds;
}



struct CliqueComputation
{
    std::map< int, std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > > *cliqueList;
	
	std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup<int> > *cliquesListPorTrio;

    CliqueComputation()
    { cliqueList = NULL; }

    template <typename Clique, typename Graph>
    inline void
    clique(const Clique& c, Graph& g)
    {
		int n = cliqueList->size();
		++n;
	
		std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > auxList;
        typename Clique::const_iterator i, end = c.end();
        for(i = c.begin(); i != end; ++i) 
		{
			Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio = g[*i];

			auxList.insert(g[*i]);

			(*cliquesListPorTrio)[trio].add( n );
        }

		(*cliqueList)[n] = auxList;		
    }
};

void SolverMIP::atualizaGrafoInsercao( Aluno* aluno, Trio<int,int,Disciplina*> node )
{
	int campusId = node.first;
	int turma = node.second;
	Disciplina *disciplina = node.third;

	Campus* campus = problemData->refCampus[campusId];

   std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator
			 itMap1 = problemData->mapAluno_CampusTurmaDisc.find( aluno );

   if ( itMap1 != problemData->mapAluno_CampusTurmaDisc.end() )
   {
	   
	   GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >::iterator itTrio = itMap1->second.begin();
	   for ( ; itTrio != itMap1->second.end(); itTrio++ )
	   {
		    int campusId2 = (*itTrio).first;
			int turma2 = (*itTrio).second;
			Disciplina *disciplina2 = (*itTrio).third;			

			if ( turma == turma2 &&
				 disciplina == disciplina2 &&
				 campusId == campusId2 )
				 continue;

			if ( problemData->possuiAlunosEmComum( turma, disciplina, turma2, disciplina2, campus ) )
			{
				Trio< int /*campusId*/, int /*turma*/, Disciplina* > auxNode;
				
				auxNode.first = campusId2; 
				auxNode.second = turma2; 
				auxNode.third = disciplina2; 
				
				Vertex v = this->mapVertex[node];
				Vertex vaux = this->mapVertex[auxNode];

				graph.add_edge( v, vaux );
			}
	   }
   }
}

// Esta função deve ser usada ANTES de se remover o aluno do map mapAluno_CampusTurmaDisc.
// Caso contrário, a remoção não será efetivada.
void SolverMIP::atualizaGrafoRemocao( Aluno* aluno, Trio<int,int,Disciplina*> node )
{
	int campusId = node.first;
	int turma = node.second;
	Disciplina *disciplina = node.third;

	Campus* campus = problemData->refCampus[campusId];

   std::map< Aluno*, GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >, LessPtr< Aluno > >::iterator
			 itMap1 = problemData->mapAluno_CampusTurmaDisc.find( aluno );

   if ( itMap1 != problemData->mapAluno_CampusTurmaDisc.end() )
   {
	   
	   GGroup< Trio< int /*campusId*/, int /*turma*/, Disciplina* > >::iterator itTrio = itMap1->second.begin();
	   for ( ; itTrio != itMap1->second.end(); itTrio++ )
	   {
		    int campusId2 = (*itTrio).first;
			int turma2 = (*itTrio).second;
			Disciplina *disciplina2 = (*itTrio).third;			

			GGroup<Aluno*> alunosEmComum = problemData->alunosEmComum( turma, disciplina, turma2, disciplina2, campus );
			
			bool remover = false;
			if ( alunosEmComum.size() == 1 && (*alunosEmComum.begin()) == aluno )
				remover = true;

			if ( remover )
			{
				Trio< int /*campusId*/, int /*turma*/, Disciplina* > auxNode;
				
				auxNode.first = campusId2; 
				auxNode.second = turma2; 
				auxNode.third = disciplina2; 
				
				Vertex v = this->mapVertex[node];
				Vertex vaux = this->mapVertex[auxNode];

				graph.remove_edge( v, vaux );
			}
	   }
   }
}

// Usada somente para soluções intermediárias dos pre-modelos,
// em prioridade maior que 2
void SolverMIP::constroiGrafoAux( int campusAtualId )
{	
   // -------------------------------------------------
   // Constroi grafo
   	std::cout<<"\nConstroi grafo aux...";fflush(NULL);

   graph.clear();
   mapVertex.clear();

   std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, 
			 GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
	   itMap1 = this->auxMapCampusTurmaDisc_AlunosDemanda.begin();

   for ( ; itMap1 != this->auxMapCampusTurmaDisc_AlunosDemanda.end(); itMap1++ )
   {
	   Trio< int /*campusId*/, int /*turma*/, Disciplina* > auxNode;
	   auxNode.first = itMap1->first.first;  //campus
	   auxNode.second = itMap1->first.second;//turma
	   auxNode.third = itMap1->first.third;  //disciplina

	   if ( auxNode.first == campusAtualId )
	   {			
			Vertex v = graph.add_vertex(auxNode);
			mapVertex[auxNode] = v;
	   }
   }

   itMap1 = this->auxMapCampusTurmaDisc_AlunosDemanda.begin();
   for ( ; itMap1 != this->auxMapCampusTurmaDisc_AlunosDemanda.end(); itMap1++ )
   {
	    int campusId1 = itMap1->first.first;
	    
		if ( campusId1 != campusAtualId )
		{
			continue;
		}

	    int turma1 = itMap1->first.second;
	    Disciplina *disciplina1 = itMap1->first.third;
		
	    Trio< int /*campusId*/, int /*turma*/, Disciplina* > auxNode1;
	    auxNode1.first = campusId1;  //campus
	    auxNode1.second = turma1;  //turma
	    auxNode1.third = disciplina1; //disciplina
		
		std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, 
				  GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
		itMap2 = itMap1;
		itMap2++;
		for ( ; itMap2 != this->auxMapCampusTurmaDisc_AlunosDemanda.end(); itMap2++ )
		{
			int campusId2 = itMap2->first.first;
	    
			if ( campusId2 != campusAtualId )
			{
				continue;
			}

			int turma2 = itMap2->first.second;
			Disciplina *disciplina2 = itMap2->first.third;			

			if ( this->aux_possuiAlunosEmComum( turma1, disciplina1, campusId1, turma2, disciplina2, campusId2 ) )
			{
				Trio< int /*campusId*/, int /*turma*/, Disciplina* > auxNode2;
				
				auxNode2.first = campusId2;  //campus
				auxNode2.second = turma2;  //turma
				auxNode2.third = disciplina2; //disciplina
				
				graph.add_edge( mapVertex[auxNode1], mapVertex[auxNode2] );		
			}
		}
   }
   std::cout<<" construiu grafo";fflush(NULL);

}

// Usada somente para soluções finais dos pre-modelos
void SolverMIP::constroiGrafo( int campusAtualId )
{
   // -------------------------------------------------
   // Constroi grafo
   std::cout<<"\nConstroi grafo...";fflush(NULL);

	graph.clear();
	mapVertex.clear();   

	// INCLUSÃO DOS VÉRTICES

   std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, 
			 GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
	   itMap1 = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();

   for ( ; itMap1 != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMap1++ )
   {
	   Trio< int /*campusId*/, int /*turma*/, Disciplina* > auxNode;
	   auxNode.first = itMap1->first.first;  //campus
	   auxNode.second = itMap1->first.second;//turma
	   auxNode.third = itMap1->first.third;  //disciplina

	   if ( auxNode.first == campusAtualId )
	   {			
			Vertex v = graph.add_vertex(auxNode);
			mapVertex[auxNode] = v;
	   }
   }

	// INCLUSÃO DAS ARESTAS

   itMap1 = problemData->mapCampusTurmaDisc_AlunosDemanda.begin();
   for ( ; itMap1 != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMap1++ )
   {
	    int campusId1 = itMap1->first.first;
	    
		if ( campusId1 != campusAtualId )
		{
			continue;
		}

		Campus* campus1 = problemData->refCampus[campusId1];

	    int turma1 = itMap1->first.second;
	    Disciplina *disciplina1 = itMap1->first.third;
		
	    Trio< int /*campusId*/, int /*turma*/, Disciplina* > auxNode1;
	    auxNode1.first = campusId1;  //campus
	    auxNode1.second = turma1;  //turma
	    auxNode1.third = disciplina1; //disciplina
		
		ConjuntoSala* s1 = this->retornaSalaDeAtendimento( turma1, disciplina1, campus1 );

		std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, 
				  GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator
		itMap2 = itMap1;
		itMap2++;
		for ( ; itMap2 != problemData->mapCampusTurmaDisc_AlunosDemanda.end(); itMap2++ )
		{
			int campusId2 = itMap2->first.first;

			if ( campusId2 != campusAtualId )
			{
				continue;
			}

			int turma2 = itMap2->first.second;
			Disciplina *disciplina2 = itMap2->first.third;	
			Campus* campus2 = problemData->refCampus[campusId2];

			ConjuntoSala* s2 = this->retornaSalaDeAtendimento( turma2, disciplina2, campus2 );		

			if ( problemData->possuiAlunosEmComum( turma1, disciplina1, turma2, disciplina2, campus1 ) ||
				 s1 == s2 )
			{
				Trio< int /*campusId*/, int /*turma*/, Disciplina* > auxNode2;
				
				auxNode2.first = campusId2;  //campus
				auxNode2.second = turma2;  //turma
				auxNode2.third = disciplina2; //disciplina
				
				graph.add_edge( mapVertex[auxNode1], mapVertex[auxNode2] );		
			}
		}
   }
   std::cout<<" construiu";fflush(NULL);
}

void SolverMIP::encontraCliques( bool zerarGrafo )
{
	cliques.clear();
	cliquesPorTrio.clear();

	if (zerarGrafo)
		constroiGrafo( campusAtualId );
   
    CliqueComputation cliquesComput;

    cliquesComput.cliqueList = & cliques;
	cliquesComput.cliquesListPorTrio = & cliquesPorTrio;

    std::cout<<"\nCalculando cliques...";fflush(NULL);
    
	bron_kerbosch_all_cliques( graph,cliquesComput );
	
	std::cout<<" calculou cliques";fflush(NULL);
}

// pode deletar se não for usar mais a função de callback
void SolverMIP::encontraCliquesAux()
{
	cliques.clear();

   MyGraph graph;

   constroiGrafoAux( campusAtualId );

   CliqueComputation cliquesComput;

   cliquesComput.cliqueList = & cliques;
   
   bron_kerbosch_all_cliques( graph,cliquesComput );
      
}

void SolverMIP::imprimeCliques( int campusId, int prioridade, int cjtAlunosId )
{
	ofstream cliquesFile;
	std::string fileCliqueName;
	fileCliqueName.append( this->getCliquesFileName( campusId, prioridade, cjtAlunosId ) );

	cliquesFile.open( fileCliqueName, ios::out );
	if (!cliquesFile)
	{
		cerr << "Can't open cliquesFile " << fileCliqueName << endl;
		return;
	}
	cliquesFile << "Cliques" <<endl;

	// POR CLIQUE:
   cliquesFile<<"\n\nPOR CLIQUE:\n\n";
   std::map< int, std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > >::iterator itL1;
   std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > >::iterator itL2;

   for (itL1 = cliques.begin(); itL1 != cliques.end(); itL1++)
   {
	  int cN = itL1->first;
      cliquesFile << cN << ": ";
      
	  for (itL2 = itL1->second.begin(); itL2 != itL1->second.end(); itL2++)
      {
		  cliquesFile << "(cp" << itL2->first << ",i" << itL2->second << ",d" << itL2->third->getId() << ") ";
      }
      cliquesFile << "\n";
   }

   // POR TRIO:
   cliquesFile<<"\n\nPOR TRIO:\n";

   std::map< Trio< int /*campusId*/, int /*turma*/, Disciplina* >, GGroup<int/*cliqueId*/> >::iterator itL3;
   
   for (itL3 = cliquesPorTrio.begin(); itL3 != cliquesPorTrio.end(); itL3++)
   {
	  Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio = itL3->first;
	  cliquesFile << "\n(cp" << trio.first<< " i" << trio.second << " d" << trio.third->getId() << "): ";
      
	  ITERA_GGROUP_N_PT( itL4, itL3->second, int )
      {
		  int cN = *itL4;
		  cliquesFile << cN <<"; ";
      }
      cliquesFile << "\n";
   }


   cliquesFile.close();
}


// pode deletar se não for usar mais a função de callback
bool SolverMIP::solucaoValidaCliquesAux( double *xSol )
{
	(this->nroPreSolAvaliadas)++;
	std::cout<<"\n\nValidando solucao " << this->nroPreSolAvaliadas <<"...";

	preencheAuxMapCampusTurmaDisc_AlunosDemanda( xSol );

    encontraCliquesAux();

   for ( int dia = 2; dia <= 7; dia++ )
   {	
	   std::map< int, std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > >::iterator 
		   itCliques = this->cliques.begin();

	   for ( ; itCliques != this->cliques.end(); itCliques++ )
	   {
		    int cliqueId = (*itCliques).first;
			
			// -----------------------------------------------------------------------------
			// Restrição-teste: calcula o tempo total alocado no dia (somaTempoAlocado) e o máximo possível
			double somaTempoAlocado = 0.0;
			double rhs = 0.0;

		    std::set<Trio< int, int, Disciplina* > > vertices = (*itCliques).second;
			std::set<Trio< int, int, Disciplina* > >::iterator itVertices = vertices.begin();
			for ( ; itVertices != vertices.end(); itVertices++ )
			{
				int campusId = itVertices->first;
				int turma = itVertices->second;
				Disciplina *disciplina = itVertices->third;

				double tempo1Cred = disciplina->getTempoCredSemanaLetiva();
				double nCreds = this->retornaNCredsAlocados( turma, disciplina, dia, campusId );
				
				somaTempoAlocado += tempo1Cred * nCreds;								

				// Máximo de tempo permitido (right hand side)
				if ( disciplina->getCalendario()->getTempoTotal( dia ) - rhs > 1e-5 )
					rhs = disciplina->getCalendario()->getTempoTotal( dia );

			}
			// -----------------------------------------------------------------------------

			// Se o tempo total alocado no dia for maior do que o máximo permitido, retorna solução invalida.
			if ( somaTempoAlocado - rhs > 1e-5 )
			{
				std::cout<<" Solucao inviavel\n";
				std::cout<<"Clique inviavel com somaTempoAlocado="<<somaTempoAlocado<<" e rhs="<<rhs<<":\n";
				std::set<Trio< int, int, Disciplina* > >::iterator itVertices = vertices.begin();
				for ( ; itVertices != vertices.end(); itVertices++ )
				{
					int campusId = itVertices->first;
					int turma = itVertices->second;
					Disciplina *disciplina = itVertices->third;
					std::cout<<"(i,d,cp = "<<turma<<","<<disciplina->getId()<<","<<campusId<<") ; ";
				}
				return false;
			}						
	   }

   }
   std::cout<<" Solucao viavel\n";
   return true;

}

// Acha o grafo e os cliques atuais, e verifica se a soluçao é válida para passar para o tático
// devido a alteração da composição do "trio" nos "dias"
bool SolverMIP::solucaoValidaCliques( bool zerarGrafo, GGroup<int> dias_a_validar, Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio )
{
	(this->nroPreSolAvaliadas)++;
	std::cout<<"\nValidando solucao " << this->nroPreSolAvaliadas <<"..."; fflush(NULL);
		
    encontraCliques( zerarGrafo );

	std::cout<<"\nEncontrou cliques";fflush(NULL);

	ITERA_GGROUP_N_PT( itDia, dias_a_validar, int )
    {
		int dia = *itDia;
		std::cout<<"\n\nDia "<<dia<<endl; fflush(NULL);

		GGroup<int /*cliqueId*/ > cliques_a_validar;

	    std::map< Trio< int, int, Disciplina* >, GGroup<int> >::iterator itCliquesPorTrio = this->cliquesPorTrio.find( trio );

	    if ( itCliquesPorTrio != this->cliquesPorTrio.end() )
		    cliques_a_validar = itCliquesPorTrio->second;

		ITERA_GGROUP_N_PT( itCliques, cliques_a_validar, int )
		{ 
			int cliqueId = *itCliques;
			std::cout<<" Clique " << cliqueId; fflush(NULL);

			std::set<Trio< int /*campusId*/, int /*turma*/, Disciplina* > > vertices = this->cliques[cliqueId];
			
			// -----------------------------------------------------------------------------
			// Restrição-teste: calcula o tempo total alocado no dia (somaTempoAlocado) e o máximo possível
			double somaTempoAlocado = 0.0;
			double rhs = 0.0;

			std::set<Trio< int, int, Disciplina* > >::iterator itVertices = vertices.begin();
			for ( ; itVertices != vertices.end(); itVertices++ )
			{
				int campusId = itVertices->first;
				int turma = itVertices->second;
				Disciplina *disciplina = itVertices->third;

				double tempo1Cred = disciplina->getTempoCredSemanaLetiva();
				double nCreds = this->retornaNCredsAlocados( turma, disciplina, dia, campusId );
				
				somaTempoAlocado += tempo1Cred * nCreds;								

				// Máximo de tempo permitido (right hand side)
				if ( disciplina->getCalendario()->getTempoTotal( dia ) - rhs > 1e-5 )
					rhs = disciplina->getCalendario()->getTempoTotal( dia );

			}
			// -----------------------------------------------------------------------------

			// Se o tempo total alocado no dia for maior do que o máximo permitido, retorna solução invalida.
			if ( somaTempoAlocado - rhs > 1e-5 )
			{
				std::cout<<" Solucao inviavel\n";
				std::cout<<"Clique inviavel com somaTempoAlocado="<<somaTempoAlocado<<" e rhs="<<rhs<<":\n";
				std::set<Trio< int, int, Disciplina* > >::iterator itVertices = vertices.begin();
				for ( ; itVertices != vertices.end(); itVertices++ )
				{
					int campusId = itVertices->first;
					int turma = itVertices->second;
					Disciplina *disciplina = itVertices->third;
					std::cout<<"(i,d,cp = "<<turma<<","<<disciplina->getId()<<","<<campusId<<") ; ";fflush(NULL);
				}
				fflush(NULL);
				return false;
			}
			std::cout<<": Ok "; fflush(NULL);
	   }

   }
   std::cout<<" Solucao viavel\n";fflush(NULL);
   return true;

}

// Usada somente para soluções intermediárias dos pre-modelos,
// em prioridade maior que 2
// pode deletar se não for usar mais a função de callback
bool SolverMIP::aux_possuiAlunosEmComum( int turma1, Disciplina* disc1, int cp1, int turma2, Disciplina* disc2, int cp2 )
{
	Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio1;
	trio1.set( cp1, turma1, disc1 );
	Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio2;
	trio2.set( cp2, turma2, disc2 );

	// Acha os alunoDemanda da primeira turma
	GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunos1;

	std::map< Trio< int, int, Disciplina* >, GGroup< AlunoDemanda* , LessPtr< AlunoDemanda >> >::iterator 
		itMap1 = auxMapCampusTurmaDisc_AlunosDemanda.find( trio1 );
	if ( itMap1 != auxMapCampusTurmaDisc_AlunosDemanda.end() )
		alunos1 = itMap1->second;

	// Acha os alunoDemanda da segunda turma
	GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > alunos2;

	std::map< Trio< int, int, Disciplina* >, GGroup< AlunoDemanda*, LessPtr< AlunoDemanda > > >::iterator 
		itMap2 = auxMapCampusTurmaDisc_AlunosDemanda.find( trio2 );
	if ( itMap2 != auxMapCampusTurmaDisc_AlunosDemanda.end() )
		alunos2 = itMap2->second;

	// Acha os alunos em comum
	ITERA_GGROUP_LESSPTR( itAlDem1, alunos1, AlunoDemanda )
	{
		int aluno1Id = (*itAlDem1)->getAlunoId();

		ITERA_GGROUP_LESSPTR( itAlDem2, alunos2, AlunoDemanda )
		{
			int aluno2Id = (*itAlDem2)->getAlunoId();

			if ( aluno1Id == aluno2Id )
			{
				return true;
			}
		}			
	}

	return false;
}

// pode deletar se não for usar mais a função de callback
void SolverMIP::preencheAuxMapCampusTurmaDisc_AlunosDemanda( double *xSol )
{
	auxMapCampusTurmaDisc_AlunosDemanda.clear();

	std::string fileName("auxMap");
	stringstream ss;
	ss << this->nroPreSolAvaliadas;
	fileName += ss.str();
	fileName += ".txt";

	ofstream auxMapFile;

	auxMapFile.open(fileName, ios::out);
	if (!auxMapFile)
	{
		cerr << "\nError: Can't open output file " << auxMapFile << endl;
		return;
	}

	VariablePreHash::iterator vit = vHashPre.begin();
    while ( vit != vHashPre.end() )
    {
		VariablePre * v = new VariablePre( vit->first );
		int col = vit->second;
		v->setValue( xSol[ col ] );

		if ( v->getValue() > 0.00001 )
		{
			if ( v->getType() == VariablePre::V_PRE_ALOCA_ALUNO_TURMA_DISC )
			{
				Aluno *aluno = v->getAluno();
				int turma = v->getTurma();
				Disciplina *disciplina = v->getDisciplina();
				Campus *cp = v->getCampus();

				auxMapFile<<"\nAluno " << aluno->getAlunoId() <<" turma " << turma <<" disc " << disciplina->getId()<<" Cp " << cp->getId();

				Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
				trio.set( cp->getId(), turma, disciplina );
				
				AlunoDemanda *alunoDemanda = aluno->getAlunoDemanda( disciplina->getId() );

				auxMapCampusTurmaDisc_AlunosDemanda[ trio ].add( alunoDemanda );
			}
		}
		
		delete v;

		vit++;
	}

	auxMapFile.close();
}

void SolverMIP::heuristicaAlocaAlunos( int campusId, int prioridade, int grupoAlunosAtualId )
{
	std::cout<<"\nHeuristica";

	stringstream ssCp; 	stringstream ssP; 	stringstream ssCjt;
	ssCp << campusId; 	ssP << prioridade;	ssCjt << grupoAlunosAtualId;
	std::string heurFilename( "HeuristAlunoDemanda_Cp" );    
	heurFilename += ssCp.str();
	heurFilename += "_P"; 
	heurFilename += ssP.str();
	heurFilename += "_Cjt"; 
	heurFilename += ssCjt.str();
    heurFilename += ".txt";

	ofstream heurisFile;
	heurisFile.open(heurFilename, ios::out);
	if (!heurisFile)
	{
		cerr << "Can't open output file " << heurFilename << endl;
	}
	else heurisFile.close();

	Campus *cp = problemData->refCampus[campusId];

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para o conjunto de alunos com id igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;
		if ( grupoAlunosId != grupoAlunosAtualId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			std::cout<<"\nAluno "<<aluno->getAlunoId();	fflush(NULL);

			int campus1Id = aluno->getOferta()->getCampusId();
			
			// Calcula a carga horária máxima que deve ser atendida de P2

			double tempoNaoAtendidoP1 = problemData->cargaHorariaNaoAtendidaPorPrioridade( prioridade-1, aluno->getAlunoId() );		
			double tempoP2 = problemData->cargaHorariaAtualRequeridaPorPrioridade( prioridade, aluno );
			if ( tempoNaoAtendidoP1 == 0 || tempoP2 == 0 )
				continue;

			double maxTempoP2 = tempoNaoAtendidoP1;
			if (maxTempoP2 > tempoP2)
				maxTempoP2 = tempoP2;
			
			std::cout<<"\nCalcula rhs";	fflush(NULL);

			// TODO: o alunoDiaRhs pode ser melhorado.
			std::vector<double> alunoDiaRhs(7, 9999.9); // sete dias da semana, iniciados com 9999.9
			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				Disciplina *disciplina = (*itAlDemanda)->demanda->disciplina;
				if ( (*itAlDemanda)->getPrioridade() != prioridade )
				{
					continue;
				}
				ITERA_GGROUP_N_PT( itDia, cp->diasLetivos, int )
				{
					int dia = *itDia;
					double maxTempoDia = disciplina->getCalendario()->getTempoTotal( dia );
					if ( alunoDiaRhs[dia-2] - maxTempoDia > 1e-5 )
					{
						alunoDiaRhs[dia-2] = maxTempoDia;
					}
				}
			}

			std::cout<<"\nItera alunoDemandas";	fflush(NULL);

			double tempoAddP2 = 0.0;

			GGroup< AlunoDemanda*, LessPtr< AlunoDemanda> > alunosDemandaPT;

			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				AlunoDemanda *alDem = *itAlDemanda;

				// Demandas da Prioridade Atual
				if ( alDem->getPrioridade() != prioridade )
				{
					continue;
				}				

				Disciplina *disciplina = alDem->demanda->disciplina;
				Calendario *sl = disciplina->getCalendario();
				
				std::cout<<"\nAlunoDemanda disc"<<disciplina->getId();	fflush(NULL);

				// Se existir a disciplina teorica/pratica correspondente
				int discId = - disciplina->getId();
				if ( problemData->refDisciplinas.find( discId ) != 
					 problemData->refDisciplinas.end() )
				{
					alunosDemandaPT.add( alDem );					
					continue; // pula o caso de disc teorica+pratica
				}

				if ( problemData->retornaTurmaDiscAluno( aluno, disciplina ) != -1 )
				{
					std::cout<<"\nError: aluno ja esta alocado. Como? Nao deveria!!!";	fflush(NULL);
					continue;
				}

				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
					std::cout<<"\nTurma"<<turma;	fflush(NULL);

					if ( heuristicaTentaInsercaoNaTurma( alDem, turma, alunoDiaRhs, heurFilename ) )
					{
						std::cout<<"... inseriu";	fflush(NULL);

						tempoAddP2 += disciplina->getTempoCredSemanaLetiva() * disciplina->getTotalCreditos();
						break;
					}
				}

				if ( tempoAddP2 - maxTempoP2 > -1e-5 )
					break;
			}

			if ( tempoAddP2 - maxTempoP2 > -1e-5 )
				continue;

			std::cout<<"\nIterando as praticas-teoricas";	fflush(NULL);

			// Trata caso de disciplina pratica+teorica
			ITERA_GGROUP_LESSPTR( itAlDem, alunosDemandaPT, AlunoDemanda )
			{
				// ---------------------------------------------
				// Primeira disciplina
				AlunoDemanda *alDem1 = (*itAlDem);

				Disciplina *disciplina1 = alDem1->demanda->disciplina;
				Calendario *sl1 = disciplina1->getCalendario();

				// Selecionando a segunda disciplina
				AlunoDemanda *alDem2 = NULL;
				ITERA_GGROUP_INIC_LESSPTR( it2AlDem, itAlDem, alunosDemandaPT, AlunoDemanda )
				{
					int discId = (*it2AlDem)->demanda->getDisciplinaId();
					if ( discId == - disciplina1->getId() )
					{
						alDem2 = (*it2AlDem); break;
					}
				}
				if ( alDem2 == NULL )
					continue; // se alDem2 == NULL é pq essa par de disciplinas já foi avaliado

				std::cout<<"\nAlDem1 disc"<<disciplina1->getId();	fflush(NULL);

				if ( problemData->retornaTurmaDiscAluno( aluno, disciplina1 ) != -1 )
				{
					if ( alDem1->getPrioridade() == prioridade )
						std::cout<<"\nError: aluno ja esta alocado. Como? Nao deveria!!!";	fflush(NULL);
					continue;
				}

				for ( int turma1 = 0; turma1 < disciplina1->getNumTurmas(); turma1++ )
				{
					std::cout<<"\nTurma"<<turma1;	fflush(NULL);

					if ( heuristicaTentaInsercaoNaTurma( alDem1, turma1, alunoDiaRhs, heurFilename ) )
					{		
						std::cout<<"... inseriu";	fflush(NULL);

						// ---------------------------------------------
						// Segunda disciplina

						Disciplina *disciplina2 = alDem2->demanda->disciplina;
						Calendario *sl2 = disciplina2->getCalendario();

						if ( problemData->retornaTurmaDiscAluno( aluno, disciplina2 ) != -1 )
						{
							if ( alDem2->getPrioridade() == prioridade )
								std::cout<<"\nError: aluno ja esta alocado. Como? Nao deveria!!!";	fflush(NULL);
							continue;
						}
						
						bool SUCESSO2 = false;

						std::cout<<"\nAlDem2 disc"<<disciplina2->getId();	fflush(NULL);
						
						for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
						{
							std::cout<<"\nTurma"<<turma2;	fflush(NULL);

							if ( heuristicaTentaInsercaoNaTurma( alDem2, turma2, alunoDiaRhs, heurFilename ) )
							{
								std::cout<<"... inseriu";	fflush(NULL);
								tempoAddP2 += disciplina1->getTempoCredSemanaLetiva() * disciplina1->getTotalCreditos();
								tempoAddP2 += disciplina2->getTempoCredSemanaLetiva() * disciplina2->getTotalCreditos();
								SUCESSO2 = true;
								break;
							}
						}
						if ( !SUCESSO2 )
						{
							std::cout<<"\nRemovendo disc 1";	fflush(NULL);

							// Retira a inserção feita da PRIMEIRA disciplina
							Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
							trio.set( campus1Id, turma1, disciplina1 );
								
							std::cout<<"\nAtualiza grafo";	fflush(NULL);
							// Remove possíveis arestas do grafo
							atualizaGrafoRemocao( aluno, trio );

							std::cout<<"\nCalcula diasNCreds";	fflush(NULL);
							std::pair<ConjuntoSala*, GGroup<int> > atend =
								this->retornaSalaEDiasDeAtendimentoTaticoAnterior( turma1, disciplina1, cp );
							std::map<int/*dia*/, double> diasNCreds;
							GGroup<int> dias = atend.second;
							ITERA_GGROUP_N_PT( itDia, dias, int )
							{
								int dia = *itDia;
								double nCredsTurmaDia = this->retornaNCredsAlocados( turma1, disciplina1, dia, campus1Id );
								if ( nCredsTurmaDia > 1e-5 )
								{
									diasNCreds[dia] = nCredsTurmaDia;
								}
							}

							std::cout<<"\nRemovendo aluno de turma";	fflush(NULL);
							// Remove aluno da turma e atualiza o nro de creditos por dia alocados pro aluno
							problemData->removeAlunoDeTurma( aluno, trio, diasNCreds );

							alunoDemandaAtendsHeuristica.remove( alDem1 );
							ofstream heurisFile;
							heurisFile.open(heurFilename, ios::app);
							if ( heurisFile )
							{
								heurisFile << "\nRemovido: AlunoDemandaId" << alDem1->getId() 
										<< " Aluno" << alDem1->getAlunoId() 
										<< " Demanda" << alDem1->getDemandaId() 
										<< " Disc" << alDem1->demanda->getDisciplinaId()
										<< " Turma" << turma1
										<< " Prior" << alDem1->getPrioridade() << endl;
								heurisFile.close();
							}
							std::cout<<"\nFim da remocao";	fflush(NULL);
						}
						else
						{
							break;
						}
						// ---------------------------------------------
					}
				}

				if ( tempoAddP2 - maxTempoP2 > -1e-5 )
					break;
			}
			std::cout<<"\nFim aluno";	fflush(NULL);
	
		}
	}

}

bool SolverMIP::heuristicaTentaInsercaoNaTurma( AlunoDemanda *alunoDemanda, int turma, std::vector<double> alunoDiaRhs, std::string heurFilename )
{
	std::cout<<"\nheuristicaTentaInsercaoNaTurma";

	fflush(NULL);

	ofstream heurisFile;
	heurisFile.open(heurFilename, ios::app);
	if (!heurisFile)
	{
		std::cout << "Error: Can't open output file " << heurFilename << endl;
	
		fflush(NULL);
		return false;
	}
	
	Disciplina* disciplina = alunoDemanda->demanda->disciplina;
	Aluno *aluno = problemData->retornaAluno( alunoDemanda->getAlunoId() );
	int campusId = aluno->getOferta()->getCampusId();
	Campus *cp = problemData->refCampus[campusId];
	Calendario* sl = disciplina->getCalendario();

	bool viola = false;

	if ( !problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId ) )
	{
		if (heurisFile)
			heurisFile.close();
		std::cout<<"\nNao existe a turma";	fflush(NULL);
			
		fflush(NULL);
		return false;
	}

	Trio< int /*campusId*/, int /*turma*/, Disciplina* > trio;
	trio.set( campusId, turma, disciplina );

	std::pair<ConjuntoSala*, GGroup<int> > atend =
		this->retornaSalaEDiasDeAtendimentoTaticoAnterior( turma, disciplina, cp );
					
	// ----------------------------------------------
	// Capacidade máxima da sala
	if ( atend.first == NULL ){
		std::cout<<"\n\nERROR: atend null\n\n";	fflush(NULL);
		if (heurisFile)
			heurisFile.close();
		return false;
	}
	int capSala = atend.first->getCapacidadeRepr();
	int lotacao = problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size();
	if ( lotacao >= capSala )
	{
		viola = true;
		if (heurisFile)
			heurisFile.close();
	
		fflush(NULL);
		return false;		
	}
	
	std::cout<<"\nTestei capacidade da sala";	fflush(NULL);
	// ----------------------------------------------
	// Limite superior de créditos diário do aluno
					
	std::map<int/*dia*/, double> diasNCreds;

	GGroup<int> dias_a_validar = atend.second;
	ITERA_GGROUP_N_PT( itDia, dias_a_validar, int )
	{
		int dia = *itDia;
		double nCredsTurmaDia = this->retornaNCredsAlocados( turma, disciplina, dia, campusId );
		if ( nCredsTurmaDia > 1e-5 )
		{
			int k = retornaCombinacaoSLAlunoTaticoAnterior( aluno, dia );
			if ( k != -1 )
			{
				double maxCreds = aluno->getNroMaxCredCombinaSL(k, sl, dia);
				double jaAlocados = aluno->getNroCreditosJaAlocados( sl, dia );
				if ( jaAlocados + nCredsTurmaDia > maxCreds + 1e-5 )
				{
					viola = true;	
					if (heurisFile)
						heurisFile.close();
						
					fflush(NULL);
					return false;					
				}
			}
			else
			{
				double tempoJaAlocado = 0.0; //aluno->getTempoJaAlocado( dia ); //é zero, já que k==-1
				double tempoTurmaDia = nCredsTurmaDia*disciplina->getTempoCredSemanaLetiva();
				if ( tempoJaAlocado + tempoTurmaDia > alunoDiaRhs[dia-2] + 1e-5 )
				{
					viola = true;
					if (heurisFile)
						heurisFile.close();
					
					fflush(NULL);
					return false;
				}
			}

			diasNCreds[dia] = nCredsTurmaDia;
		}
	}
	// ----------------------------------------------
	std::cout<<"\nTestei max creds do dia";	fflush(NULL);

	if ( ! viola )
	{					
		std::cout<<"\nNao violou max de cred nem cap da sala";	fflush(NULL);

		// Insere aluno na turma e atualiza o nro de creditos por dia alocados pro aluno
		problemData->insereAlunoEmTurma( aluno, trio, diasNCreds );
					
		std::cout<<"\nAtualizando grafo...";	fflush(NULL);
		// Insere possíveis novas arestas no grafo
		atualizaGrafoInsercao( aluno, trio );

		std::cout<<"\nValidando solucao...";	fflush(NULL);
		
		// valida solucao
		if ( solucaoValidaCliques( false, dias_a_validar, trio ) )
		{
			std::cout<<"\nSolucao valida!!!";	fflush(NULL);

			alunoDemandaAtendsHeuristica.add( alunoDemanda );

			heurisFile << "AlunoDemandaId" << alunoDemanda->getId() 
						<< " Aluno" << alunoDemanda->getAlunoId() 
						<< " Demanda" <<  alunoDemanda->getDemandaId() 
						<< " Disc" <<  alunoDemanda->demanda->getDisciplinaId()
						<< " Turma" <<  turma
						<< " Prior" <<  alunoDemanda->getPrioridade() << endl;

			if (heurisFile)
				heurisFile.close();

			fflush(NULL);
			return true; // ok
		}
		else
		{
			std::cout<<"\nSolucao INvalida!!!";	fflush(NULL);
		    // Remove possíveis arestas do grafo
			atualizaGrafoRemocao( aluno, trio );

			std::cout<<"\nRemovendo aluno de turma...";	fflush(NULL);
			// Remove aluno da turma e atualiza o nro de creditos por dia alocados pro aluno
			problemData->removeAlunoDeTurma( aluno, trio, diasNCreds );
		}

	}

	if (heurisFile)
		heurisFile.close();

	fflush(NULL);
	return false;
}

void SolverMIP::imprimeAlocacaoFinalHeuristica( int campusId, int prioridade, int grupoAlunosAtualId )
{
	stringstream ssCp; 	stringstream ssP; 	stringstream ssCjt;
	ssCp << campusId; 	ssP << prioridade;	ssCjt << grupoAlunosAtualId;
	std::string heurFilename( "HeuristicaFinalAlunoDemanda_Cp" );    
	heurFilename += ssCp.str();
	heurFilename += "_P"; 
	heurFilename += ssP.str();
	heurFilename += "_Cjt"; 
	heurFilename += ssCjt.str();
    heurFilename += ".txt";

	ofstream heurisFile;
	heurisFile.open(heurFilename, ios::out);
	if (!heurisFile)
	{
		std::cout << "Error: Can't open output file " << heurFilename << endl;fflush(NULL);
		return;
	}
	
	ITERA_GGROUP_LESSPTR( itAlDem, this->alunoDemandaAtendsHeuristica, AlunoDemanda )
	{
		heurisFile << "AlunoDemandaId" << itAlDem->getId() 
					<< " Aluno" << itAlDem->getAlunoId() 
					<< " Demanda" <<  itAlDem->getDemandaId() 
					<< " Disc" <<  itAlDem->demanda->getDisciplinaId()
					<< " Prior" <<  itAlDem->getPrioridade() << endl;
	}
	heurisFile.close();
}

void SolverMIP::escreveSolucaoBinHeuristica( int campusId, int prioridade, int grupoAlunosAtualId )
{
	// WRITES SOLUTION
	char solName[1024];
	strcpy( solName, getSolHeuristBinFileName( campusId, prioridade, grupoAlunosAtualId ).c_str() );

	FILE * fout = fopen( solName, "wb" );
	if ( fout == NULL )
	{
		std::cout << "\nErro em SolverMIP::gravaSolucaoBinHeuristica( int campusId, int prioridade, int cjtAlunosId ):"
				<< "\nArquivo nao pode ser aberto.\n";
	}
	else
	{		 
		 fwrite( &problemData->totalTurmas_AlDem, sizeof( int ), 1, fout );

		 ITERA_GGROUP_LESSPTR( itAlDem, problemData->alunosDemanda, AlunoDemanda )
		 {
			 Aluno* aluno = problemData->retornaAluno( (*itAlDem)->getAlunoId() );
			 Disciplina *disciplina = (*itAlDem)->demanda->disciplina;

			 int turmaAloc = problemData->retornaTurmaDiscAluno( aluno, disciplina );

			 for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			 {
				 if ( turma == turmaAloc )
				 {
					double value = 1.0;
					fwrite( &value, sizeof( double ), 1, fout );
				 }
				 else
				 {
					 double value = -1.0;
					 fwrite( &value, sizeof( double ), 1, fout );
				 }
			 }
		 }
		 fclose( fout ); 
	}

}

bool SolverMIP::leSolucaoHeuritica( int campusId, int prioridade, int grupoAlunosAtualId )
{
	char solHeuristName[1024];
	strcpy( solHeuristName, getSolHeuristBinFileName( campusId, prioridade, grupoAlunosAtualId ).c_str() );
	FILE* finh = fopen( solHeuristName,"rb");
	if ( finh == NULL )
	{
		std::cout << "\nA partir de " << solHeuristName << " , nao foram lidas mais solucoes.\n";
		return false;
	}
	else
	{
		cout<<"\n====================> carregando pre " <<solHeuristName <<endl;

		// lê Solucao Heuristica   	
		int nCols = 0;
		fread(&nCols,sizeof(int),1,finh);
		
		double * xSol = new double[ nCols ];

		for (int i=0; i < nCols; i++)
		{
			double auxDbl;
			fread(&auxDbl,sizeof(double),1,finh);
			xSol[i] = auxDbl;
		}	
		fclose(finh);
		
		if ( nCols != problemData->totalTurmas_AlDem )
		{
			std::cout<<"\nError em leSolucaoHeuritica: O TOTAL DE TURMAS NAO BATE!\n";
			std::cout<<"\nnCols="<<nCols<<"   total de turma="<<problemData->totalTurmas_AlDem<<endl;
			return false;
		}

		int at = 0;
		ITERA_GGROUP_LESSPTR( itAlDem, problemData->alunosDemanda, AlunoDemanda )
		{
			Aluno* aluno = problemData->retornaAluno( (*itAlDem)->getAlunoId() );
			Disciplina *disciplina = (*itAlDem)->demanda->disciplina;
			int campusId = aluno->getOferta()->getCampusId();

			for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
			{
				if ( xSol[at] == 1.0 )
				{					
					Trio< int, int, Disciplina* > trio;
					trio.set( campusId, turma, disciplina);
					std::map<int/*dia*/, double> diasNCreds;

					// enviando diasNCreds vazio. Nao dará problema,
					// pois por enquanto isso só é usado na execução da heuristica.
					problemData->insereAlunoEmTurma( aluno, trio, diasNCreds );
				}
				else if ( xSol[at] != -1.0 )
				{
					std::cout<<"\nError!!!!!!!!!\nSo deveria ter 1.0 e -1.0\n";
				}
				at++;
			}
		}

		cout<<"<==================== Solucao carregada com sucesso"<<endl<<endl;
		return true;
	}
}


/* ======================================================================================================
							NOVA HEURISTICA - MODELO TATICO COM HORARIOS
*/

void SolverMIP::heuristica2AlocaAlunos( int campusId, int prioridade, int grupoAlunosAtualId )
{
	std::cout<<"\n======================================================";
	std::cout<<"\nHeuristica\n";

	stringstream ssCp; 	stringstream ssP; 	stringstream ssCjt;
	ssCp << campusId; 	ssP << prioridade;	ssCjt << grupoAlunosAtualId;
	std::string heurFilename( "HeuristAlunoDemanda_Cp" );    
	heurFilename += ssCp.str();
	heurFilename += "_P"; 
	heurFilename += ssP.str();
	heurFilename += "_Cjt"; 
	heurFilename += ssCjt.str();
    heurFilename += ".txt";

	ofstream heurisFile;
	heurisFile.open(heurFilename, ios::out);
	if (!heurisFile)
	{
		cerr << "Can't open output file " << heurFilename << endl;
	}
	else heurisFile.close();

	Campus *cp = problemData->refCampus[campusId];

	map< int /* cjtAlunosId */, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para o conjunto de alunos com id igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;
		if ( grupoAlunosId != grupoAlunosAtualId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			std::cout<<"\n--------------------------\nAluno "<<aluno->getAlunoId();	fflush(NULL);

			Campus *campus1 = aluno->getOferta()->campus;
			int campus1Id = campus1->getId();
			
			// Calcula a carga horária máxima que deve ser atendida de P2
			double tempoNaoAtendidoP1 = problemData->cargaHorariaNaoAtendidaPorPrioridade( prioridade-1, aluno->getAlunoId() );		
			double tempoP2 = problemData->cargaHorariaAtualRequeridaPorPrioridade( prioridade, aluno );
			if ( tempoNaoAtendidoP1 == 0 || tempoP2 == 0 )
				continue;

			double maxTempoP2 = tempoNaoAtendidoP1;
			if (maxTempoP2 > tempoP2)
				maxTempoP2 = tempoP2;
			
			std::cout<<"\nItera alunoDemandas";	fflush(NULL);

			double tempoAddP2 = 0.0;		
			
			GGroup<AlunoDemanda*, LessPtr<AlunoDemanda>> alDemList = aluno->demandas;
			
			std::list< std::pair< AlunoDemanda*, int > > 
				alunosDemandaP2Ordenados = ordenaAlunosDemandaP2ParaHeurist( alDemList, aluno, prioridade ); 

			while (1)
			{
				bool sucesso=false; 

				GGroup<AlunoDemanda*> alDemPTnaoConsiderar;

				std::list< std::pair< AlunoDemanda*, int > >::iterator 
					itList = alunosDemandaP2Ordenados.begin();
				for ( ; itList!=alunosDemandaP2Ordenados.end(); itList++ )
				{
					// Máximo de 2 créditos de excesso em P2
					if ( (*itList).second > 2 )
						continue;

					// ---------------------------------------------
					// Primeira disciplina
					AlunoDemanda *alDem1 = (*itList).first;

					Disciplina *disciplina1 = alDem1->demanda->disciplina;
					Calendario *sl1 = disciplina1->getCalendario();
				
					std::cout<<"\nAlDem1 disc"<<disciplina1->getId();	fflush(NULL);

					// Se existir a disciplina teorica/pratica correspondente
					bool TEOR_PRAT=false;
					Disciplina *disciplina2 = problemData->getDisciplinaTeorPrat( disciplina1 );
					if ( disciplina2 != NULL ) TEOR_PRAT = true;
								
					if ( TEOR_PRAT )
					{	
						if ( problemData->retornaTurmaDiscAluno( aluno, disciplina1 ) != -1 && 
							 problemData->retornaTurmaDiscAluno( aluno, disciplina2 ) != -1 )
							continue; // alocações já efetivadas

						AlunoDemanda *alDem2=NULL;				

						std::list< std::pair< AlunoDemanda*, int > >::iterator 
							itListAux = alunosDemandaP2Ordenados.begin();
						for ( ; itListAux!=alunosDemandaP2Ordenados.end(); itListAux++ )
						{
							if ( itListAux->first->demanda->getDisciplinaId() == disciplina2->getId() ){
								alDem2 = itListAux->first;
								break;
							}
						}					
						if ( alDem2 == NULL )
						{
							std::cout<<"\nError: nao existe o par da disciplina teorica/pratica "
							<<disciplina2->getId()<<" nas demandas do aluno "<<aluno->getAlunoId();
							continue;
						}
						if ( ( problemData->retornaTurmaDiscAluno( aluno, disciplina1 ) != -1 && 
							   problemData->retornaTurmaDiscAluno( aluno, disciplina2 ) == -1 ) ||
							 ( problemData->retornaTurmaDiscAluno( aluno, disciplina1 ) == -1 && 
							   problemData->retornaTurmaDiscAluno( aluno, disciplina2 ) != -1 ) )
						{
							std::cout<<"\nAtencao/Erro1: aluno alocado somente em 1 das disciplinas de par teorico/pratico "<<disciplina1->getId();
							fflush(NULL);
							continue;
						}
					
						for ( int turma1 = 0; turma1 < disciplina1->getNumTurmas(); turma1++ )
						{
							std::cout<<"\nTurma"<<turma1;	fflush(NULL);

							if ( heuristica2TentaInsercaoNaTurma( alDem1, turma1, heurFilename ) )
							{		
								std::cout<<"... inseriu";	fflush(NULL);

								// ---------------------------------------------
								// Segunda disciplina

								Calendario *sl2 = disciplina2->getCalendario();
						
								bool SUCESSO2 = false;

								std::cout<<"\nAlDem2 disc"<<disciplina2->getId();	fflush(NULL);
						
								for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
								{
									std::cout<<"\nTurma"<<turma2;	fflush(NULL);

									if ( heuristica2TentaInsercaoNaTurma( alDem2, turma2, heurFilename ) )
									{
										std::cout<<"... inseriu";	fflush(NULL);
										tempoAddP2 += disciplina1->getTempoCredSemanaLetiva() * disciplina1->getTotalCreditos();
										tempoAddP2 += disciplina2->getTempoCredSemanaLetiva() * disciplina2->getTotalCreditos();										
										SUCESSO2 = true;
										break;
									}
								}
								if ( !SUCESSO2 )
								{									
									std::cout<<"\nRemovendo disc 1";	fflush(NULL);

									// Retira a inserção feita da PRIMEIRA disciplina

									Trio< int, int, Disciplina* > trio1;
									trio1.set( campus1Id, turma1, disciplina1 );
															
									// Recupera os HorarioDia da turma
									GGroup<HorarioDia*> horariosDias1;
									GGroup< VariableTatico*, LessPtr<VariableTatico> > varsTaticoX =
										this->retornaVariableTaticoCreditosAnterior( turma1, disciplina1, campus1 );
									ITERA_GGROUP_LESSPTR( itVarX, varsTaticoX, VariableTatico )
									{
										int dia = (*itVarX)->getDia();
										HorarioAula* hi = (*itVarX)->getHorarioAulaInicial();
										HorarioAula* hf = (*itVarX)->getHorarioAulaFinal();
		
										int nCreds = sl1->retornaNroCreditosEntreHorarios( hi, hf );
										HorarioAula *ha = hi;
										for ( int i = 1; i <= nCreds; i++ )
										{
											HorarioDia *hd = problemData->getHorarioDiaCorrespondente( ha, dia );
											horariosDias1.add( hd );
											ha = sl1->getProximoHorario( ha );				
										}
									}

									std::cout<<"\nRemovendo aluno de turma";	fflush(NULL);							
									problemData->removeAlunoDeTurma( alDem1, trio1, horariosDias1 );

									alunoDemandaAtendsHeuristica.remove( alDem1 );
									ofstream heurisFile;
									heurisFile.open(heurFilename, ios::app);
									if ( heurisFile )
									{
										heurisFile << "\nRemovido: AlunoDemandaId" << alDem1->getId() 
												<< " Aluno" << alDem1->getAlunoId() 
												<< " Demanda" << alDem1->getDemandaId() 
												<< " Disc" << alDem1->demanda->getDisciplinaId()
												<< " Turma" << turma1
												<< " Prior" << alDem1->getPrioridade() << endl;
										heurisFile.close();
									}
									std::cout<<"\nFim da remocao";	fflush(NULL);
								}
								else
								{
									sucesso=true;
									break; // SUCESSO!
								}
								// ---------------------------------------------
							}
						}
						if (!sucesso)
						{
							// Não conseguiu inserir a disciplina 1,
							// não considerar a disciplina-par que está ADIANTE
							// na list alunosDemandaP2Ordenados (ou seja, alDem2).
							alDemPTnaoConsiderar.add( alDem2 );
						}
					}
					else
					{
						for ( int turma = 0; turma < disciplina1->getNumTurmas(); turma++ )
						{
							std::cout<<"\nTurma"<<turma;	fflush(NULL);

							if ( heuristica2TentaInsercaoNaTurma( alDem1, turma, heurFilename ) )
							{
								std::cout<<"... inseriu";	fflush(NULL);

								tempoAddP2 += disciplina1->getTempoCredSemanaLetiva() * disciplina1->getTotalCreditos();
								sucesso=true;
								break;
							}
						}
					}

					if ( sucesso ) break;
				
				} // FIM DE INSERÇÃO BEM SUCEDIDA
								
				if ( tempoAddP2 - maxTempoP2 > -1e-5 )
					break;

				// Reconstroi a lista de AlunoDemanda contendo somente os alunoDemanda não testados ainda.
				alDemList.clear();
				if ( sucesso )
				{
					alunosDemandaP2Ordenados.reverse();
					std::list< std::pair< AlunoDemanda*, int > >::iterator 
						itListAux = alunosDemandaP2Ordenados.begin();
					for ( ; itListAux!=itList; itListAux++ )
					{
						if ( alDemPTnaoConsiderar.find( itListAux->first ) != alDemPTnaoConsiderar.end() ) 
							continue;	

						alDemList.add( itListAux->first );
					}
				}

				alunosDemandaP2Ordenados = ordenaAlunosDemandaP2ParaHeurist( alDemList, aluno, prioridade );
   
				if ( alunosDemandaP2Ordenados.size() == 0 )
					break;
			}

			std::cout<<"\n-------------------------Fim aluno\n";	fflush(NULL);	
			
			/*
			
			GGroup< AlunoDemanda*, LessPtr< AlunoDemanda> > alunosDemandaPT;
			// ----------------------------------------------------------------

			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				AlunoDemanda *alDem = *itAlDemanda;

				// Demandas da Prioridade Atual
				if ( alDem->getPrioridade() != prioridade )
				{
					continue;
				}				

				Disciplina *disciplina = alDem->demanda->disciplina;
				Calendario *sl = disciplina->getCalendario();
				
				std::cout<<"\nAlunoDemanda disc"<<disciplina->getId();	fflush(NULL);

				// Se existir a disciplina teorica/pratica correspondente
				int discId = - disciplina->getId();
				if ( problemData->refDisciplinas.find( discId ) != 
					 problemData->refDisciplinas.end() )
				{
					alunosDemandaPT.add( alDem );					
					continue; // pula o caso de disc teorica+pratica
				}

				if ( problemData->retornaTurmaDiscAluno( aluno, disciplina ) != -1 )
				{	bool repetido=false;
					ITERA_GGROUP_LESSPTR( it, aluno->demandas, AlunoDemanda )
					{						
						if ( (*it) != alDem &&
							 (*it)->demanda->getDisciplinaId() == disciplina->getId() )
						{
							std::cout<<"\nAtencao1: aluno ja esta alocado. AlunoDemanda repetido!"
									 <<" Provavelmente devido a equivalencia";	fflush(NULL);
							repetido=true;
							 break;
						}
					}
					if (!repetido) std::cout<<"\nError: aluno ja esta alocado. Como? Nao deveria!!!";	
					fflush(NULL);
					continue;
				}

				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
					std::cout<<"\nTurma"<<turma;	fflush(NULL);

					if ( heuristica2TentaInsercaoNaTurma( alDem, turma, heurFilename ) )
					{
						std::cout<<"... inseriu";	fflush(NULL);

						tempoAddP2 += disciplina->getTempoCredSemanaLetiva() * disciplina->getTotalCreditos();
						break;
					}
				}

				if ( tempoAddP2 - maxTempoP2 > -1e-5 )
					break;
			}

			if ( tempoAddP2 - maxTempoP2 > -1e-5 )
				continue;

			std::cout<<"\n\nIterando as praticas-teoricas";	fflush(NULL);
			
			// Trata caso de disciplina pratica+teorica
			ITERA_GGROUP_LESSPTR( itAlDem, alunosDemandaPT, AlunoDemanda )
			{
				// ---------------------------------------------
				// Primeira disciplina
				AlunoDemanda *alDem1 = (*itAlDem);

				Disciplina *disciplina1 = alDem1->demanda->disciplina;
				Calendario *sl1 = disciplina1->getCalendario();

				// Selecionando a segunda disciplina
				AlunoDemanda *alDem2 = NULL;
				ITERA_GGROUP_INIC_LESSPTR( it2AlDem, itAlDem, alunosDemandaPT, AlunoDemanda )
				{
					int discId = (*it2AlDem)->demanda->getDisciplinaId();
					if ( discId == - disciplina1->getId() )
					{
						alDem2 = (*it2AlDem); break;
					}
				}
				if ( alDem2 == NULL )
					continue; // se alDem2 == NULL é pq essa par de disciplinas já foi avaliado

				std::cout<<"\nAlDem1 disc"<<disciplina1->getId();	fflush(NULL);

				if ( problemData->retornaTurmaDiscAluno( aluno, disciplina1 ) != -1 )
				{	bool repetido=false;
					ITERA_GGROUP_LESSPTR( it, aluno->demandas, AlunoDemanda )
					{						
						if ( (*it) != alDem2 &&
							 (*it)->demanda->getDisciplinaId() == disciplina1->getId() )
						{
							std::cout<<"\nAtencao2: aluno ja esta alocado. AlunoDemanda repetido!"
									 <<" Provavelmente devido a equivalencia";	fflush(NULL);
							repetido=true;
							 break;
						}
					}
					if (!repetido) std::cout<<"\nError: aluno ja esta alocado. Como? Nao deveria!!!";	
					fflush(NULL);
					continue;
				}

				for ( int turma1 = 0; turma1 < disciplina1->getNumTurmas(); turma1++ )
				{
					std::cout<<"\nTurma"<<turma1;	fflush(NULL);

					if ( heuristica2TentaInsercaoNaTurma( alDem1, turma1, heurFilename ) )
					{		
						std::cout<<"... inseriu";	fflush(NULL);

						// ---------------------------------------------
						// Segunda disciplina

						Disciplina *disciplina2 = alDem2->demanda->disciplina;
						Calendario *sl2 = disciplina2->getCalendario();

						if ( problemData->retornaTurmaDiscAluno( aluno, disciplina2 ) != -1 )
						{	bool repetido=false;
							ITERA_GGROUP_LESSPTR( it, aluno->demandas, AlunoDemanda )
							{						
								if ( (*it) != alDem2 &&
									 (*it)->demanda->getDisciplinaId() == disciplina2->getId() )
								{
									std::cout<<"\nAtencao3: aluno ja esta alocado. AlunoDemanda repetido!"
											 <<" Provavelmente devido a equivalencia";	fflush(NULL);
									repetido=true;
									 break;
								}
							}
							if (!repetido) std::cout<<"\nError: aluno ja esta alocado. Como? Nao deveria!!!";	
							fflush(NULL);
							continue;
						}
						
						bool SUCESSO2 = false;

						std::cout<<"\nAlDem2 disc"<<disciplina2->getId();	fflush(NULL);
						
						for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
						{
							std::cout<<"\nTurma"<<turma2;	fflush(NULL);

							if ( heuristica2TentaInsercaoNaTurma( alDem2, turma2, heurFilename ) )
							{
								std::cout<<"... inseriu";	fflush(NULL);
								tempoAddP2 += disciplina1->getTempoCredSemanaLetiva() * disciplina1->getTotalCreditos();
								tempoAddP2 += disciplina2->getTempoCredSemanaLetiva() * disciplina2->getTotalCreditos();
								SUCESSO2 = true;
								break;
							}
						}
						if ( !SUCESSO2 )
						{
							std::cout<<"\nRemovendo disc 1";	fflush(NULL);

							// Retira a inserção feita da PRIMEIRA disciplina

							Trio< int, int, Disciplina* > trio1;
							trio1.set( campus1Id, turma1, disciplina1 );
															
							// Recupera os HorarioDia da turma
							GGroup<HorarioDia*> horariosDias1;
							GGroup< VariableTatico*, LessPtr<VariableTatico> > varsTaticoX =
								this->retornaVariableTaticoCreditosAnterior( turma1, disciplina1, campus1 );
							ITERA_GGROUP_LESSPTR( itVarX, varsTaticoX, VariableTatico )
							{
								int dia = (*itVarX)->getDia();
								HorarioAula* hi = (*itVarX)->getHorarioAulaInicial();
								HorarioAula* hf = (*itVarX)->getHorarioAulaFinal();
		
								int nCreds = sl1->retornaNroCreditosEntreHorarios( hi, hf );
								HorarioAula *ha = hi;
								for ( int i = 1; i <= nCreds; i++ )
								{
									HorarioDia *hd = problemData->getHorarioDiaCorrespondente( ha, dia );
									horariosDias1.add( hd );
									ha = sl1->getProximoHorario( ha );				
								}
							}

							std::cout<<"\nRemovendo aluno de turma";	fflush(NULL);							
							problemData->removeAlunoDeTurma( aluno, trio1, horariosDias1 );

							alunoDemandaAtendsHeuristica.remove( alDem1 );
							ofstream heurisFile;
							heurisFile.open(heurFilename, ios::app);
							if ( heurisFile )
							{
								heurisFile << "\nRemovido: AlunoDemandaId" << alDem1->getId() 
										<< " Aluno" << alDem1->getAlunoId() 
										<< " Demanda" << alDem1->getDemandaId() 
										<< " Disc" << alDem1->demanda->getDisciplinaId()
										<< " Turma" << turma1
										<< " Prior" << alDem1->getPrioridade() << endl;
								heurisFile.close();
							}
							std::cout<<"\nFim da remocao";	fflush(NULL);
						}
						else
						{
							break;
						}
						// ---------------------------------------------
					}
				}

				if ( tempoAddP2 - maxTempoP2 > -1e-5 )
					break;
			}
			std::cout<<"\n-------------------------Fim aluno\n";	fflush(NULL);
	
			*/
		}
	}
	
	std::cout<<"\nFim da Heuristica!";
	std::cout<<"\n======================================================\n\n";
}


bool SolverMIP::heuristica2TentaInsercaoNaTurma( AlunoDemanda *alunoDemanda, int turma, std::string heurFilename )
{
	std::cout<<"\n====>heuristicaTentaInsercaoNaTurma";

	fflush(NULL);

	ofstream heurisFile;
	heurisFile.open(heurFilename, ios::app);
	if (!heurisFile)
	{
		std::cout << "\nError: Can't open output file " << heurFilename << endl;
	
		fflush(NULL);
		return false;
	}
	
	Disciplina* disciplina = alunoDemanda->demanda->disciplina;
	Aluno *aluno = problemData->retornaAluno( alunoDemanda->getAlunoId() );
	int campusId = aluno->getOferta()->getCampusId();
	Campus *cp = problemData->refCampus[campusId];
	Calendario* sl = disciplina->getCalendario();

	bool viola = false;

	if ( !problemData->existeTurmaDiscCampus( turma, disciplina->getId(), campusId ) )
	{
		if (heurisFile)
			heurisFile.close();
		std::cout<<"\nNao existe a turma";	fflush(NULL);
			
		fflush(NULL);
		return false;
	}
		
	GGroup< VariableTatico*, LessPtr<VariableTatico> > varsTaticoX =
			this->retornaVariableTaticoCreditosAnterior( turma, disciplina, cp );			
	
	if ( varsTaticoX.size() == 0 ){
		std::cout<<"\n\nERROR: varsTaticoX null\n\n";	fflush(NULL);
		if (heurisFile)
			heurisFile.close();
		return false;
	}

	Trio< int, int, Disciplina* > trio;
	trio.set( campusId, turma, disciplina );
	int lotacao = problemData->mapCampusTurmaDisc_AlunosDemanda[trio].size();			

	// ----------------------------------------------
	// Capacidade máxima da sala
	ITERA_GGROUP_LESSPTR( itVarX, varsTaticoX, VariableTatico )
	{
		Sala* s = (*itVarX)->getSala();
		int capSala = s->getCapacidade();
		
		if ( lotacao >= capSala )
		{
			viola = true;
			break;	
		}
	}
	
	std::cout<<"\nTestei capacidade da sala";	fflush(NULL);
	
	GGroup<HorarioDia*> horariosDias;

	// ----------------------------------------------
	// Horarios do aluno nos dias	
	if ( ! viola )
	{
		ITERA_GGROUP_LESSPTR( itVarX, varsTaticoX, VariableTatico )
		{
			int dia = (*itVarX)->getDia();
			HorarioAula* hi = (*itVarX)->getHorarioAulaInicial();
			HorarioAula* hf = (*itVarX)->getHorarioAulaFinal();
		
			int nCreds = sl->retornaNroCreditosEntreHorarios( hi, hf );
			HorarioAula *ha = hi;
			for ( int i = 1; i <= nCreds; i++ )
			{
				HorarioDia *hd = problemData->getHorarioDiaCorrespondente( ha, dia );
				horariosDias.add( hd );
				if ( aluno->sobrepoeHorarioDiaOcupado( hd ) )
				{
					viola = true; break;
				}
				ha = sl->getProximoHorario( ha );				
			}
			if ( viola ) break;
		}
		std::cout<<"\nTestei horarios do aluno no dia";	fflush(NULL);
	}
	// ----------------------------------------------
	
	if ( ! viola )
	{					
		std::cout<<"\nSolucao valida!!!";	fflush(NULL);

		// Insere aluno na turma e atualiza o nro de creditos por dia alocados pro aluno
		problemData->insereAlunoEmTurma( alunoDemanda, trio, horariosDias );	
		
		alunoDemandaAtendsHeuristica.add( alunoDemanda );

		heurisFile << "AlunoDemandaId" << alunoDemanda->getId() 
					<< " Aluno" << alunoDemanda->getAlunoId() 
					<< " Demanda" <<  alunoDemanda->getDemandaId() 
					<< " Disc" <<  alunoDemanda->demanda->getDisciplinaId()
					<< " Turma" <<  turma
					<< " Prior" <<  alunoDemanda->getPrioridade() << endl;

		if (heurisFile)
			heurisFile.close();

		fflush(NULL);
		return true; // ok
	}
	else
	{
		std::cout<<"\nSolucao INvalida!!!";	fflush(NULL);		    
	}

	if (heurisFile)
		heurisFile.close();

	fflush(NULL);
	return false;
}

/*
	Retorna list de pares <AlunoDemanda,int> ordenada em ordem crescente do módulo segundo termo do par,
	que indica a diferença entre o número de créditos da disciplina em AlunoDemanda e o 
	número de créditos que falta para que o aluno complete a carga horária requerida em P1.
	O segundo termo do par NÃO é o módulo, somente a ordenação da lista leva o módulo em consideração.
*/
std::list< std::pair< AlunoDemanda*, int > > SolverMIP::ordenaAlunosDemandaP2ParaHeurist( 
	GGroup<AlunoDemanda*, LessPtr<AlunoDemanda>> alDemList, Aluno *aluno, int prioridade )
{
	std::list< std::pair< AlunoDemanda*, int > > alunosDemandaP2Ordenados;

	double tempoRequeridoP1 = problemData->cargaHorariaOriginalRequeridaPorPrioridade( 1, aluno );	
	double totalJaAtendido = problemData->cargaHorariaJaAtendida( aluno );

	double tempoNaoAtendido = tempoRequeridoP1 - totalJaAtendido;
	if ( tempoNaoAtendido<=0 )
		return alunosDemandaP2Ordenados;

	// ----------------------------------------------------------------
	// Ordena as demandas de P2 para tentativas de inserção em ordem apropriada.
			
	ITERA_GGROUP_LESSPTR( itAlDemanda, alDemList, AlunoDemanda )
	{
		AlunoDemanda *alDem = *itAlDemanda;
		Disciplina *disciplina = alDem->demanda->disciplina;
		
		if ( alDem->getPrioridade() != prioridade )
			continue;
		if ( problemData->retornaTurmaDiscAluno( aluno, disciplina ) != -1 )
			continue;

		double tempoDisc = disciplina->getTempoCredSemanaLetiva() * disciplina->getTotalCreditos();
		int discId = disciplina->getId();

		// se for pratica/teorica, adiciona a tempoDisc a duração da disciplina-par
		std::map< int, Disciplina* >::iterator itMapDisc = problemData->refDisciplinas.find(-discId );
		if ( itMapDisc != problemData->refDisciplinas.end() )
		{  
			tempoDisc += (*itMapDisc).second->getTempoCredSemanaLetiva() *
							(*itMapDisc).second->getTotalCreditos();
		}

		int dif = tempoDisc-tempoNaoAtendido;
		std::pair< AlunoDemanda*, int > alDem_dif( alDem, dif );

		alunosDemandaP2Ordenados.push_back( alDem_dif );
	}

	alunosDemandaP2Ordenados.sort( compare_dif_func );

	// ----------------------------------------------------------------

	return alunosDemandaP2Ordenados;
}


// TODO
/*

void SolverMIP::heuristicaP1AlocaAlunos( int campusId, int prioridade, int grupoAlunosAtualId )
{
	std::cout<<"\nHeuristica P1";

	stringstream ssCp; 	stringstream ssP; 	stringstream ssCjt;
	ssCp << campusId; 	ssP << prioridade;	ssCjt << grupoAlunosAtualId;
	std::string heurFilename( "HeuristAlunoDemanda_Cp" );    
	heurFilename += ssCp.str();
	heurFilename += "_P"; 
	heurFilename += ssP.str();
	heurFilename += "_Cjt"; 
	heurFilename += ssCjt.str();
    heurFilename += ".txt";

	ofstream heurisFile;
	heurisFile.open(heurFilename, ios::out);
	if (!heurisFile)
	{
		cerr << "Can't open output file " << heurFilename << endl;
	}
	else heurisFile.close();

	Campus *cp = problemData->refCampus[campusId];

	map< int, GGroup< Aluno *, LessPtr< Aluno > > >::iterator
		itMapCjtAlunos = problemData->cjtAlunos.begin();
	
	// Para o conjunto de alunos com id igual ao atual
	for ( ; itMapCjtAlunos != problemData->cjtAlunos.end(); itMapCjtAlunos++ )
	{
		int grupoAlunosId = itMapCjtAlunos->first;
		if ( grupoAlunosId != grupoAlunosAtualId )
		{
			break;
		}

		// Para cada aluno do conjunto
		GGroup< Aluno *, LessPtr< Aluno > > cjtAlunos = problemData->cjtAlunos[ grupoAlunosId ];	
		ITERA_GGROUP_LESSPTR( itAluno, cjtAlunos, Aluno )
		{
			Aluno *aluno = *itAluno;

			if ( aluno->getOferta()->getCampusId() != campusId )
			{
				continue;
			}

			std::cout<<"\n--------------------------\nAluno "<<aluno->getAlunoId();	fflush(NULL);

			Campus *campus1 = aluno->getOferta()->campus;
			int campus1Id = campus1->getId();

			std::cout<<"\nItera alunoDemandas";	fflush(NULL);

			GGroup< AlunoDemanda*, LessPtr< AlunoDemanda> > alunosDemandaPT;

			ITERA_GGROUP_LESSPTR( itAlDemanda, aluno->demandas, AlunoDemanda )
			{
				AlunoDemanda *alDem = *itAlDemanda;

				// Demandas da Prioridade Atual
				if ( alDem->getPrioridade() != prioridade )
				{
					continue;
				}				

				Disciplina *disciplina = alDem->demanda->disciplina;
				Calendario *sl = disciplina->getCalendario();
				
				std::cout<<"\nAlunoDemanda disc"<<disciplina->getId();	fflush(NULL);

				if ( problemData->retornaTurmaDiscAluno( aluno, disciplina ) != -1 )
				{
					continue; // já alocado
				}

				// Se existir a disciplina teorica/pratica correspondente
				int discId = - disciplina->getId();
				if ( problemData->refDisciplinas.find( discId ) != 
					 problemData->refDisciplinas.end() )
				{
					alunosDemandaPT.add( alDem );					
					continue; // pula o caso de disc teorica+pratica
				}

				bool inseriu=false;
				for ( int turma = 0; turma < disciplina->getNumTurmas(); turma++ )
				{
					std::cout<<"\nTurma"<<turma;	fflush(NULL);

					if ( heuristica2TentaInsercaoNaTurma( alDem, turma, heurFilename ) )
					{
						std::cout<<"... inseriu";	fflush(NULL);
						inseriu=true;
						break;
					}
				}

				// ---------------------------------------------------------------
				// Tenta uma disciplina equivalente
				if ( !inseriu && problemData->parametros->considerar_equivalencia )
				{
					std::pair< Curso *, Curriculo * > curso_curr( aluno->getOferta()->curso, aluno->getOferta()->curriculo );
					Disciplina *discEquiv = problemData->ehSubstitutaDe( disciplina, curso_curr );
					
					if ( discEquiv == NULL )
					{
						continue; // não há equivalente
					}
					if ( aluno->demandaDisciplina( discEquiv->getId() ) )
					{
						continue; // discEquiv já está nas demandas do aluno
					}

					// Se existir a disciplina teorica/pratica correspondente
					int discId = - discEquiv->getId();
					if ( problemData->refDisciplinas.find( discId ) != 
						 problemData->refDisciplinas.end() )
					{						
						continue; // pula o caso de disc teorica+pratica
					}

					bool inseriu=false;
					for ( int turma = 0; turma < discEquiv->getNumTurmas(); turma++ )
					{
						std::cout<<"\nTurma"<<turma;	fflush(NULL);
						if ( heuristica2TentaInsercaoNaTurma( discEquiv ?, turma, heurFilename ) )
						{
							std::cout<<"... inseriu";	fflush(NULL);
							inseriu=true;
							break;
						}
					}
				}
				// ---------------------------------------------------------------
			}

			std::cout<<"\n\nIterando as praticas-teoricas";	fflush(NULL);
			
			// Trata caso de disciplina pratica+teorica
			ITERA_GGROUP_LESSPTR( itAlDem, alunosDemandaPT, AlunoDemanda )
			{
				// ---------------------------------------------
				// Primeira disciplina
				AlunoDemanda *alDem1 = (*itAlDem);

				Disciplina *disciplina1 = alDem1->demanda->disciplina;
				Calendario *sl1 = disciplina1->getCalendario();

				// Selecionando a segunda disciplina
				AlunoDemanda *alDem2 = NULL;
				ITERA_GGROUP_INIC_LESSPTR( it2AlDem, itAlDem, alunosDemandaPT, AlunoDemanda )
				{
					int discId = (*it2AlDem)->demanda->getDisciplinaId();
					if ( discId == - disciplina1->getId() )
					{
						alDem2 = (*it2AlDem); break;
					}
				}
				if ( alDem2 == NULL )
					continue; // se alDem2 == NULL é pq essa par de disciplinas já foi avaliado

				std::cout<<"\nAlDem1 disc"<<disciplina1->getId();	fflush(NULL);

				for ( int turma1 = 0; turma1 < disciplina1->getNumTurmas(); turma1++ )
				{
					std::cout<<"\nTurma"<<turma1;	fflush(NULL);

					if ( heuristica2TentaInsercaoNaTurma( alDem1, turma1, heurFilename ) )
					{		
						std::cout<<"... inseriu";	fflush(NULL);

						// ---------------------------------------------
						// Segunda disciplina

						Disciplina *disciplina2 = alDem2->demanda->disciplina;
						Calendario *sl2 = disciplina2->getCalendario();
						
						bool SUCESSO2 = false;

						std::cout<<"\nAlDem2 disc"<<disciplina2->getId();	fflush(NULL);
						
						for ( int turma2 = 0; turma2 < disciplina2->getNumTurmas(); turma2++ )
						{
							std::cout<<"\nTurma"<<turma2;	fflush(NULL);

							if ( heuristica2TentaInsercaoNaTurma( alDem2, turma2, heurFilename ) )
							{
								std::cout<<"... inseriu";	fflush(NULL);
								SUCESSO2 = true;
								break;
							}
						}
						if ( !SUCESSO2 )
						{
							std::cout<<"\nRemovendo disc 1";	fflush(NULL);

							// Retira a inserção feita da PRIMEIRA disciplina

							Trio< int, int, Disciplina* > trio1;
							trio1.set( campus1Id, turma1, disciplina1 );
															
							// Recupera os HorarioDia da turma
							GGroup<HorarioDia*> horariosDias1;
							GGroup< VariableTatico*, LessPtr<VariableTatico> > varsTaticoX =
								this->retornaVariableTaticoCreditosAnterior( turma1, disciplina1, campus1 );
							ITERA_GGROUP_LESSPTR( itVarX, varsTaticoX, VariableTatico )
							{
								int dia = (*itVarX)->getDia();
								HorarioAula* hi = (*itVarX)->getHorarioAulaInicial();
								HorarioAula* hf = (*itVarX)->getHorarioAulaFinal();
		
								int nCreds = sl1->retornaNroCreditosEntreHorarios( hi, hf );
								HorarioAula *ha = hi;
								for ( int i = 1; i <= nCreds; i++ )
								{
									HorarioDia *hd = problemData->getHorarioDiaCorrespondente( ha, dia );
									horariosDias1.add( hd );
									ha = sl1->getProximoHorario( ha );				
								}
							}

							std::cout<<"\nRemovendo aluno de turma";	fflush(NULL);							
							problemData->removeAlunoDeTurma( aluno, trio1, horariosDias1 );

							alunoDemandaAtendsHeuristica.remove( alDem1 );
							ofstream heurisFile;
							heurisFile.open(heurFilename, ios::app);
							if ( heurisFile )
							{
								heurisFile << "\nRemovido: AlunoDemandaId" << alDem1->getId() 
										<< " Aluno" << alDem1->getAlunoId() 
										<< " Demanda" << alDem1->getDemandaId() 
										<< " Disc" << alDem1->demanda->getDisciplinaId()
										<< " Turma" << turma1
										<< " Prior" << alDem1->getPrioridade() << endl;
								heurisFile.close();
							}
							std::cout<<"\nFim da remocao";	fflush(NULL);
						}
						else
						{
							break;
						}
						// ---------------------------------------------
					}
				}
			}
			std::cout<<"\n-------------------------Fim aluno\n";	fflush(NULL);			
		}
	}

}

*/